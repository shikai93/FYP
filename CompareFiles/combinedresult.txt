Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

restore state. Must correspond to the save in __decc_include_prologue.h

www.openssl.org/source/license.html

License

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

restore state. Must correspond to the save in __decc_include_prologue.h

www.openssl.org/source/license.html

License

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

restore state. Must correspond to the save in __decc_include_prologue.h

www.openssl.org/source/license.html

License


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

save state

have the compiler shorten symbols larger than 31 chars to 23 chars followed by a 8 hex char CRC

www.openssl.org/source/license.html

License

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

save state

have the compiler shorten symbols larger than 31 chars to 23 chars followed by a 8 hex char CRC

www.openssl.org/source/license.html

License

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file is only used by HP C on VMS, and is included automatically after each header file from this directory

save state

have the compiler shorten symbols larger than 31 chars to 23 chars followed by a 8 hex char CRC

www.openssl.org/source/license.html

License


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

should not happen

We do this to preserve the settings. If we modify the settings, via the _set_bit function, we will recalculate on output

clear

set

using one because of the bits left byte

These next 2 functions from Goetz Babin-Ebell <babinebell@trustcenter.de>

clear, set on write

Don't need to set

Checks if the given bit string contains only bits specified by the flags vector. Returns 0 if there is at least one bit set in 'a' which is not specified in 'flags', 1 otherwise. 'len' is the length of 'flags'.

Check if there is one bit set at all.

Check each byte of the internal representation of the bit string.

We are done if there is an unneeded bit set.

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_locl.h

t need to set */ c = OPENSSL_clear_realloc(a->data, a->length, w + 1); if (c == NULL) { ASN1err(ASN1_F_ASN1_BIT_STRING_SET_BIT, ERR_R_MALLOC_FAILURE); return 0; } if (w + 1 - a->length > 0) memset(c + a->length, 0, w + 1 - a->length); a->data = c; a->length = w + 1; } a->data[w] = ((a->data[w]) & iv) | v; while ((a->length > 0) && (a->data[a->length - 1] == 0)) a->length--; return (1); } int ASN1_BIT_STRING_get_bit(const ASN1_BIT_STRING *a, int n) { int w, v; w = n / 8; v = 1 << (7 - (n & 0x07)); if ((a == NULL) || (a->length < (w + 1)) || (a->data == NULL)) return (0); return ((a->data[w] & v) != 0); } /* * Checks if the given bit string contains only bits specified by * the flags vector. Returns 0 if there is at least one bit set in

* which is not specified in

, 1 otherwise. *

is the length of

0x07;

0x01)

0x02)

0x04)

0x08)

0x10)

0x20)

0x40)

0x80)

0xff

0x07);

0xff

0x07));

0x07);

0x07));

0xff;


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

else data already loaded

clear error

header length

end of data

no data body so go round again

eos value, so go back and read another header

suck in slen bytes of data

BIO_read takes an int length

Read content in chunks of increasing size so we can return an error for EOF without having to allocate the entire content length in one go.

This can't overflow because |len+want| didn't overflow.

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/numbers.h

internal/asn1_int.h

t overflow because |len+want| didn

0x80)


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1_ITEM version of dup: this follows the model above except we don't need to allocate the buffer. At some point this could be rewritten to directly dup the underlying structure instead of doing and encode and decode.

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

GENERALIZEDTIME implementation. Based on UTCTIME

This is the primary function used to parse ASN1_GENERALIZEDTIME

wrapper around asn1_time_to_tm

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_locl.h


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Compare signs

This converts a big endian buffer and sign into its content encoding. This is used for INTEGER and ENUMERATED types. The internal representation is an ASN1_STRING whose data is a big endian representation of the value, ignoring the sign. The sign is determined by the type: if type & V_ASN1_NEG is true it is negative, otherwise positive. Positive integers are no problem: they are almost the same as the DER encoding, except if the first byte is >= 0x80 we need to add a zero pad. Negative integers are a bit trickier... The DER representation of negative integers is in 2s complement form. The internal form is converted by complementing each octet and finally adding one to the result. This can be done less messily with a little trick. If the internal form has trailing zeroes then they will become FF by the complement and 0 by the add one (due to carry) so just copy as many trailing zeros to the destination as there are in the source. The carry will add one to the last none zero octet: so complement this octet and add one and finally complement any left over until you get to the start of the string. Padding is a little trickier too. If the first bytes is > 0x80 then we pad with 0xff. However if the first byte is 0x80 and one of the following bytes is non-zero we pad with 0xff. The reason for this distinction is that 0x80 followed by optional zeros isn't padded.

If |pad| is zero, the operation is effectively reduced to memcpy, and if |pad| is 0xff, then it performs two's complement, ~dst + 1. Note that in latter case sequence of zeros yields itself, and so does 0x80 followed by any number of zeros. These properties are used elsewhere below...

Begin at the end of the encoding

two's complement value: ~value + 1

Special case [of minimal negative for given length]: if any other bytes non zero we pad, otherwise we don't.

reduce '(b == NULL || blen == 0)' to '(blen == 0)'

This magically handles all corner cases, such as '(b == NULL || blen == 0)', non-negative value, "negative" zero, 0x80 followed by any number of zeros...

yes, p[0] can be written twice, but it's little price to pay for eliminated branches

convert content octets into a big endian buffer. Returns the length of buffer or 0 on error: for malformed INTEGER. If output buffer is NULL just return length.

Zero content length is illegal

Handle common case where length is 1 octet separately

Special case [of "one less minimal negative" for given length]: if any other bytes non zero it was padded, otherwise not.

reject illegal padding: first two octets MSB can't match

skip over pad

Convert big endian buffer into uint64_t, return 0 on error

Write uint64_t to big endian buffer and return offset to first written octet. In other words it returns offset in range from 0 to 7, with 0 denoting 8 written octets and 7 - one.

Absolute value of INT64_MIN: we can't just use -INT64_MIN as gcc produces overflow warnings.

signed version of asn1_get_uint64

Most significant bit is guaranteed to be clear, negation is guaranteed to be meaningful in platform-neutral sense.

This never happens if INT64_MAX == ABS_INT64_MIN, e.g. on ones'-complement system.

Convert ASN1 INTEGER content octets to ASN1_INTEGER structure

Most obvious '-r' triggers undefined behaviour for most common INT64_MIN. Even though below '0 - (uint64_t)r' can appear two's-complement centric, it does produce correct/ expected result even on one's-complement. This is because cast to unsigned has to change bit pattern...

This is a version of d2i_ASN1_INTEGER that ignores the sign bit of ASN1 integers: some broken software can encode a positive INTEGER with its MSB set as negative (it doesn't add a padding zero).

We must OPENSSL_malloc stuff, even for 0 bytes otherwise it signifies a missing NULL parameter.

Correct zero case

Internal functions used by x_int64.c

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/numbers.h

asn1_locl.h

t padded. */ /* * If |pad| is zero, the operation is effectively reduced to memcpy, * and if |pad| is 0xff, then it performs two

s complement value: ~value + 1 */ while (len-- != 0) { *(--dst) = (unsigned char)(carry += *(--src) ^ pad); carry >>= 8; } } static size_t i2c_ibuf(const unsigned char *b, size_t blen, int neg, unsigned char **pp) { unsigned int pad = 0; size_t ret, i; unsigned char *p, pb = 0; if (b != NULL && blen) { ret = blen; i = b[0]; if (!neg && (i > 127)) { pad = 1; pb = 0; } else if (neg) { pb = 0xFF; if (i > 128) { pad = 1; } else if (i == 128) { /* * Special case [of minimal negative for given length]: * if any other bytes non zero we pad, otherwise we don

(b == NULL || blen == 0)

(blen == 0)

(b == NULL || * blen == 0)

negative

s little * price to pay for eliminated branches */ twos_complement(p, b, blen, pb); *pp += ret; return ret; } /* * convert content octets into a big endian buffer. Returns the length * of buffer or 0 on error: for malformed INTEGER. If output buffer is * NULL just return length. */ static size_t c2i_ibuf(unsigned char *b, int *pneg, const unsigned char *p, size_t plen) { int neg, pad; /* Zero content length is illegal */ if (plen == 0) { ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_ZERO_CONTENT); return 0; } neg = p[0] & 0x80; if (pneg) *pneg = neg; /* Handle common case where length is 1 octet separately */ if (plen == 1) { if (b != NULL) { if (neg) b[0] = (p[0] ^ 0xFF) + 1; else b[0] = p[0]; } return 1; } pad = 0; if (p[0] == 0) { pad = 1; } else if (p[0] == 0xFF) { size_t i; /* * Special case [of "one less minimal negative" for given length]: * if any other bytes non zero it was padded, otherwise not. */ for (pad = 0, i = 1; i < plen; i++) pad |= p[i]; pad = pad != 0 ? 1 : 0; } /* reject illegal padding: first two octets MSB can

t just use -INT64_MIN as gcc produces * overflow warnings. */ #define ABS_INT64_MIN ((uint64_t)INT64_MAX + (-(INT64_MIN + INT64_MAX))) /* signed version of asn1_get_uint64 */ static int asn1_get_int64(int64_t *pr, const unsigned char *b, size_t blen, int neg) { uint64_t r; if (asn1_get_uint64(&r, b, blen) == 0) return 0; if (neg) { if (r <= INT64_MAX) { /* Most significant bit is guaranteed to be clear, negation * is guaranteed to be meaningful in platform-neutral sense. */ *pr = -(int64_t)r; } else if (r == ABS_INT64_MIN) { /* This never happens if INT64_MAX == ABS_INT64_MIN, e.g. * on ones

-r

0 - (uint64_t)r

s-complement centric, it does produce correct/ * expected result even on one

0x80

0x80

0xff.

0x80

0xff.

0x80

0xff,

0x80

0xFF;

0xffU

0x80

0x80;

0xFF)

0xFF)

0x80)))

0xffU

0x80)

0xffffffffL;


Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

These functions take a string in UTF8, ASCII or multibyte form and a mask of permissible ASN1 string types. It then works out the minimal type (using the order Numeric < Printable < IA5 < T61 < BMP < Universal < UTF8) and creates a string of the correct type with the supplied data. Yes this is horrible: it has to be :-( The 'ncopy' form checks minimum and maximum size limits too.

First do a string check and work out the number of characters

This counts the characters and does utf8 syntax checking

Now work out minimal type (if any)

Now work out output format and string type

If both the same type just copy across

Work out how much space the destination will need

This function traverses a string and passes the value of each character to an optional function along with a void argument.

Various utility functions for traverse_string

Just count number of characters

Determine size of output as a UTF8 String

Determine the "type" of a string: check each character against a supplied "mask".

Copy one byte per character ASCII like strings

Copy two byte per character BMPStrings

Copy four byte per character UniversalStrings

Copy to a UTF8String

We already know there is enough room so pass 0xff as the length

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

ncopy

%ld

minsize=

%ld

maxsize=

type

mask



0xff))

0xffff))

0xff);

0xff);

0xff);

0xff);

0xff);

0xff);

0xff

0xff,


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Sanity check OID encoding. Need at least one content octet. MSB must be clear in the last octet. can't have leading 0x80 in subidentifiers, see: X.690 8.19.2

Now 0 < len <= INT_MAX, so the cast is safe.

Try to lookup OID in table: these are all valid encodings so if we get a match we know the OID is valid.

Return shared registered OID object: this improves efficiency because we don't have to return a dynamically allocated OID and NID lookups can use the cached value.

only the ASN1_OBJECTs from the 'table' will have values for ->sn or ->ln

detach data from object

once detached we can change it

reattach data to object, after which it remains const

ret->flags=ASN1_OBJECT_FLAG_DYNAMIC; we know it is dynamic

disable purely for compile-time strict const checking. Doing this on a "real" compile will cause memory leaks

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

internal/asn1_int.h

asn1_locl.h

0

2

0

.





.

0

0

NULL

<INVALID>

t have leading 0x80 in subidentifiers, * see: X.690 8.19.2 */ if (len <= 0 || len > INT_MAX || pp == NULL || (p = *pp) == NULL || p[len - 1] & 0x80) { ASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING); return NULL; } /* Now 0 < len <= INT_MAX, so the cast is safe. */ length = (int)len; /* * Try to lookup OID in table: these are all valid encodings so if we get * a match we know the OID is valid. */ tobj.nid = NID_undef; tobj.data = p; tobj.length = length; tobj.flags = 0; i = OBJ_obj2nid(&tobj); if (i != NID_undef) { /* * Return shared registered OID object: this improves efficiency * because we don

table

real

0x80L);

0x7f;

0x80;

0x80)

0x80

0x80)

0x80

0x80)))


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

\0

\0

\0

\0

~



\n

\r

.


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

special case: RFC 2459 tells us to omit 'parameters' with id-dsa-with-sha1

In the interests of compatibility, I'll make sure that the bit string has a 'not-used bits' value of 0

Return value meanings: <=0: error. 1: method does everything. 2: carry on as normal. 3: ASN1 method sets algorithm identifiers: just sign.

In the interests of compatibility, I'll make sure that the bit string has a 'not-used bits' value of 0

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/asn1_int.h

internal/evp_int.h

parameters

ll make sure that the bit string * has a

value of 0 */ signature->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07); signature->flags |= ASN1_STRING_FLAG_BITS_LEFT; err: EVP_MD_CTX_free(ctx); OPENSSL_clear_free((char *)buf_in, (unsigned int)inl); OPENSSL_clear_free((char *)buf_out, outll); return (outl); } #endif int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey, const EVP_MD *type) { int rv; EVP_MD_CTX *ctx = EVP_MD_CTX_new(); if (ctx == NULL) { ASN1err(ASN1_F_ASN1_ITEM_SIGN, ERR_R_MALLOC_FAILURE); return 0; } if (!EVP_DigestSignInit(ctx, NULL, type, NULL, pkey)) { EVP_MD_CTX_free(ctx); return 0; } rv = ASN1_item_sign_ctx(it, algor1, algor2, signature, asn, ctx); EVP_MD_CTX_free(ctx); return rv; } int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *asn, EVP_MD_CTX *ctx) { const EVP_MD *type; EVP_PKEY *pkey; unsigned char *buf_in = NULL, *buf_out = NULL; size_t inl = 0, outl = 0, outll = 0; int signid, paramtype; int rv; type = EVP_MD_CTX_md(ctx); pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx)); if (pkey == NULL) { ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED); goto err; } if (pkey->ameth == NULL) { ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED); goto err; } if (pkey->ameth->item_sign) { rv = pkey->ameth->item_sign(ctx, it, asn, algor1, algor2, signature); if (rv == 1) outl = signature->length; /*- * Return value meanings: * <=0: error. * 1: method does everything. * 2: carry on as normal. * 3: ASN1 method sets algorithm identifiers: just sign. */ if (rv <= 0) ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB); if (rv <= 1) goto err; } else { rv = 2; } if (rv == 2) { if (type == NULL) { ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED); goto err; } if (!OBJ_find_sigid_by_algs(&signid, EVP_MD_nid(type), pkey->ameth->pkey_id)) { ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED); goto err; } if (pkey->ameth->pkey_flags & ASN1_PKEY_SIGPARAM_NULL) paramtype = V_ASN1_NULL; else paramtype = V_ASN1_UNDEF; if (algor1) X509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL); if (algor2) X509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL); } inl = ASN1_item_i2d(asn, &buf_in, it); outll = outl = EVP_PKEY_size(pkey); buf_out = OPENSSL_malloc((unsigned int)outl); if ((buf_in == NULL) || (buf_out == NULL)) { outl = 0; ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_MALLOC_FAILURE); goto err; } if (!EVP_DigestSign(ctx, buf_out, &outl, buf_in, inl)) { outl = 0; ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB); goto err; } OPENSSL_free(signature->data); signature->data = buf_out; buf_out = NULL; signature->length = outl; /* * In the interests of compatibility, I

not-used bits

0x07);

0x07);


Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1_STRING_print_ex() and X509_NAME_print_ex(). Enhanced string and name printing routines handling multibyte characters, RFC2253 and a host of other options.

Three IO functions for sending data to memory, a BIO and and a FILE pointer.

This function handles display of strings, one character at a time. It is passed an unsigned long for each character because it could come from 2 or even 4 byte forms.

If we don't escape with quotes, signal we need quotes

If we get this far and do any escaping at all must escape the escape character itself: backslash.

This function sends each character in a buffer to do_esc_char(). It interprets the content formats and converts to or from UTF8 as appropriate.

Invalid UTF8String

invalid width

We don't need to worry about setting orflags correctly because if utflen==1 its value will be correct anyway otherwise each character will be > 0x7f and so the character will never be escaped on first and last.

This function hex dumps a buffer of characters

"dump" a string. This is done when the type is unknown, or the flags request it. We can either dump the content octets or the entire DER encoding. This uses the RFC2253 #01234 format.

Placing the ASN1_STRING in a temp ASN1_TYPE allows the DER encoding to readily obtained

If we don't dump DER encoding just dump content octets

Lookup table to convert tags to character widths, 0 = UTF8 encoded, -1 is used for non string types otherwise it is the number of bytes per character

0-4

5-9

10-13

15-17

18-20

21-24

25-27

28-30

This is the main function, print out an ASN1_STRING taking note of various escape and display options. Returns number of characters written or -1 if an error occurred.

Keep a copy of escape flags

Decide what to do with type, either dump content or display it

Dump everything

Ignore the string type

Else determine width based on type

Note: if string is UTF8 and we want to convert to UTF8 then we just interpret it as 1 byte per character to avoid converting twice.

Used for line indenting: print 'indent' spaces

XXX: what should this be?

XXX: what should this be?

If the field name is unknown then fix up the DER dump flag. We might want to limit this further so it will DER dump on anything other than a few 'standard' fields.

Wrappers round the main functions

Utility function: convert any string type to UTF8, returns number of bytes in output string or a negative error code

Return 1 if host is a valid hostname and 0 otherwise

Treat UTF8String as width 1 as any MSB set is invalid

Value must be <= 0x7F: check upper bytes are all zeroes

Nothing else allowed at start or end of string

Otherwise invalid if not dot or hyphen

If previous is dot or hyphen then illegal unless both are hyphens: as .- -. .. are all illegal

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/asn1_int.h

charmap.h

\\W%08lX

\\U%04lX

t escape with quotes, signal we need quotes */ if (chflgs & ASN1_STRFLGS_ESC_QUOTE) { if (do_quotes) *do_quotes = 1; if (!io_ch(arg, &chtmp, 1)) return -1; return 1; } if (!io_ch(arg, "\\", 1)) return -1; if (!io_ch(arg, &chtmp, 1)) return -1; return 2; } if (chflgs & (ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_ESC_2254)) { BIO_snprintf(tmphex, 11, "\\%02X", chtmp); if (!io_ch(arg, tmphex, 3)) return -1; return 3; } /* * If we get this far and do any escaping at all must escape the escape * character itself: backslash. */ if (chtmp ==

&& flags & ESC_FLAGS) { if (!io_ch(arg, "\\\\", 2)) return -1; return 2; } if (!io_ch(arg, &chtmp, 1)) return -1; return 1; } #define BUF_TYPE_WIDTH_MASK 0x7 #define BUF_TYPE_CONVUTF8 0x8 /* * This function sends each character in a buffer to do_esc_char(). It * interprets the content formats and converts to or from UTF8 as * appropriate. */ static int do_buf(unsigned char *buf, int buflen, int type, unsigned short flags, char *quotes, char_io *io_ch, void *arg) { int i, outlen, len; unsigned short orflags; unsigned char *p, *q; unsigned long c; p = buf; q = buf + buflen; outlen = 0; while (p != q) { if (p == buf && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_FIRST_ESC_2253; else orflags = 0; switch (type & BUF_TYPE_WIDTH_MASK) { case 4: c = ((unsigned long)*p++) << 24; c |= ((unsigned long)*p++) << 16; c |= ((unsigned long)*p++) << 8; c |= *p++; break; case 2: c = ((unsigned long)*p++) << 8; c |= *p++; break; case 1: c = *p++; break; case 0: i = UTF8_getc(p, buflen, &c); if (i < 0) return -1; /* Invalid UTF8String */ p += i; break; default: return -1; /* invalid width */ } if (p == q && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_LAST_ESC_2253; if (type & BUF_TYPE_CONVUTF8) { unsigned char utfbuf[6]; int utflen; utflen = UTF8_putc(utfbuf, sizeof utfbuf, c); for (i = 0; i < utflen; i++) { /* * We don

0123456789ABCDEF

dump

#

t dump DER encoding just dump content octets */ if (!(lflags & ASN1_STRFLGS_DUMP_DER)) { outlen = do_hex_dump(io_ch, arg, str->data, str->length); if (outlen < 0) return -1; return outlen + 1; } t.type = str->type; t.value.ptr = (char *)str; der_len = i2d_ASN1_TYPE(&t, NULL); der_buf = OPENSSL_malloc(der_len); if (der_buf == NULL) return -1; p = der_buf; i2d_ASN1_TYPE(&t, &p); outlen = do_hex_dump(io_ch, arg, der_buf, der_len); OPENSSL_free(der_buf); if (outlen < 0) return -1; return outlen + 1; } /* * Lookup table to convert tags to character widths, 0 = UTF8 encoded, -1 is * used for non string types otherwise it is the number of bytes per * character */ static const signed char tag2nbyte[] = { -1, -1, -1, -1, -1, /* 0-4 */ -1, -1, -1, -1, -1, /* 5-9 */ -1, -1, 0, -1, /* 10-13 */ -1, -1, -1, -1, /* 15-17 */ 1, 1, 1, /* 18-20 */ -1, 1, 1, 1, /* 21-24 */ -1, 1, -1, /* 25-27 */ 4, -1, 2 /* 28-30 */ }; /* * This is the main function, print out an ASN1_STRING taking note of various * escape and display options. Returns number of characters written or -1 if * an error occurred. */ static int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags, const ASN1_STRING *str) { int outlen, len; int type; char quotes; unsigned short flags; quotes = 0; /* Keep a copy of escape flags */ flags = (unsigned short)(lflags & ESC_FLAGS); type = str->type; outlen = 0; if (lflags & ASN1_STRFLGS_SHOW_TYPE) { const char *tagname; tagname = ASN1_tag2str(type); outlen += strlen(tagname); if (!io_ch(arg, tagname, outlen) || !io_ch(arg, ":", 1)) return -1; outlen++; } /* Decide what to do with type, either dump content or display it */ /* Dump everything */ if (lflags & ASN1_STRFLGS_DUMP_ALL) type = -1; /* Ignore the string type */ else if (lflags & ASN1_STRFLGS_IGNORE_TYPE) type = 1; else { /* Else determine width based on type */ if ((type > 0) && (type < 31)) type = tag2nbyte[type]; else type = -1; if ((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN)) type = 1; } if (type == -1) { len = do_dump(lflags, io_ch, arg, str); if (len < 0) return -1; outlen += len; return outlen; } if (lflags & ASN1_STRFLGS_UTF8_CONVERT) { /* * Note: if string is UTF8 and we want to convert to UTF8 then we * just interpret it as 1 byte per character to avoid converting * twice. */ if (!type) type = 1; else type |= BUF_TYPE_CONVUTF8; } len = do_buf(str->data, str->length, type, flags, &quotes, io_ch, NULL); if (len < 0) return -1; outlen += len; if (quotes) outlen += 2; if (!arg) return outlen; if (quotes && !io_ch(arg, "\"", 1)) return -1; if (do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0) return -1; if (quotes && !io_ch(arg, "\"", 1)) return -1; return outlen; } /* Used for line indenting: print

spaces */ static int do_indent(char_io *io_ch, void *arg, int indent) { int i; for (i = 0; i < indent; i++) if (!io_ch(arg, " ", 1)) return 0; return 1; } #define FN_WIDTH_LN 25 #define FN_WIDTH_SN 10 static int do_name_ex(char_io *io_ch, void *arg, const X509_NAME *n, int indent, unsigned long flags) { int i, prev = -1, orflags, cnt; int fn_opt, fn_nid; ASN1_OBJECT *fn; const ASN1_STRING *val; const X509_NAME_ENTRY *ent; char objtmp[80]; const char *objbuf; int outlen, len; char *sep_dn, *sep_mv, *sep_eq; int sep_dn_len, sep_mv_len, sep_eq_len; if (indent < 0) indent = 0; outlen = indent; if (!do_indent(io_ch, arg, indent)) return -1; switch (flags & XN_FLAG_SEP_MASK) { case XN_FLAG_SEP_MULTILINE: sep_dn = "\n"; sep_dn_len = 1; sep_mv = " + "; sep_mv_len = 3; break; case XN_FLAG_SEP_COMMA_PLUS: sep_dn = ","; sep_dn_len = 1; sep_mv = "+"; sep_mv_len = 1; indent = 0; break; case XN_FLAG_SEP_CPLUS_SPC: sep_dn = ", "; sep_dn_len = 2; sep_mv = " + "; sep_mv_len = 3; indent = 0; break; case XN_FLAG_SEP_SPLUS_SPC: sep_dn = "; "; sep_dn_len = 2; sep_mv = " + "; sep_mv_len = 3; indent = 0; break; default: return -1; } if (flags & XN_FLAG_SPC_EQ) { sep_eq = " = "; sep_eq_len = 3; } else { sep_eq = "="; sep_eq_len = 1; } fn_opt = flags & XN_FLAG_FN_MASK; cnt = X509_NAME_entry_count(n); for (i = 0; i < cnt; i++) { if (flags & XN_FLAG_DN_REV) ent = X509_NAME_get_entry(n, cnt - i - 1); else ent = X509_NAME_get_entry(n, i); if (prev != -1) { if (prev == X509_NAME_ENTRY_set(ent)) { if (!io_ch(arg, sep_mv, sep_mv_len)) return -1; outlen += sep_mv_len; } else { if (!io_ch(arg, sep_dn, sep_dn_len)) return -1; outlen += sep_dn_len; if (!do_indent(io_ch, arg, indent)) return -1; outlen += indent; } } prev = X509_NAME_ENTRY_set(ent); fn = X509_NAME_ENTRY_get_object(ent); val = X509_NAME_ENTRY_get_data(ent); fn_nid = OBJ_obj2nid(fn); if (fn_opt != XN_FLAG_FN_NONE) { int objlen, fld_len; if ((fn_opt == XN_FLAG_FN_OID) || (fn_nid == NID_undef)) { OBJ_obj2txt(objtmp, sizeof objtmp, fn, 1); fld_len = 0; /* XXX: what should this be? */ objbuf = objtmp; } else { if (fn_opt == XN_FLAG_FN_SN) { fld_len = FN_WIDTH_SN; objbuf = OBJ_nid2sn(fn_nid); } else if (fn_opt == XN_FLAG_FN_LN) { fld_len = FN_WIDTH_LN; objbuf = OBJ_nid2ln(fn_nid); } else { fld_len = 0; /* XXX: what should this be? */ objbuf = ""; } } objlen = strlen(objbuf); if (!io_ch(arg, objbuf, objlen)) return -1; if ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) { if (!do_indent(io_ch, arg, fld_len - objlen)) return -1; outlen += fld_len - objlen; } if (!io_ch(arg, sep_eq, sep_eq_len)) return -1; outlen += objlen + sep_eq_len; } /* * If the field name is unknown then fix up the DER dump flag. We * might want to limit this further so it will DER dump on anything * other than a few

0xffffffffL)

0xffff)

0xff)

0x7f)

0x7

0x8

0x7f

0xf];

0x7F:

0x7f)


Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This is the global mask for the mbstring functions: this is use to mask out certain types (such as BMPString and UTF8String) because certain software (e.g. Netscape) has problems with them.

This function sets the default to various "flavours" of configuration. based on an ASCII string. Currently this is: MASK:XXXX : a numerical mask value. nobmp : Don't use BMPStrings (just Printable, T61). pkix : PKIX recommendation in RFC2459. utf8only : only use UTF8Strings (RFC2459 recommendation for 2004). default: the default value, Printable, T61, BMP.

The following function generates an ASN1_STRING based on limits in a table. Frequently the types and length of an ASN1_STRING are restricted by a corresponding OID. For example certificates and certificate requests.

Now the tables and helper functions for the string table:

Return a string table pointer which can be modified: either directly from table or a copy of an internal value added to the table.

Always need a string table so allocate one if NULL

www.openssl.org/source/license.html

License

internal/cryptlib.h

flavours

MASK:

nombstr

pkix

utf8only

default

tbl_standard.h

0xFFFFFFFFL;


Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This is an implementation of the ASN1 Time structure which is: Time ::= CHOICE { utcTime UTCTime, generalTime GeneralizedTime }

Compute the day of the week and the day of the year from the year, month and day. The day of the year is straightforward, the day of the week uses a form of Zeller's congruence. For this months start with March and are numbered 4 through 15.

March and onwards can be one day further into the year

Treat January and February as part of the previous year

Zeller's congruance

ASN1_STRING_FLAG_X509_TIME is used to enforce RFC 5280 time string format, in which: 1. "seconds" is a 'MUST' 2. "Zulu" timezone is a 'MUST' 3. "+|-" is not allowed to indicate a time zone

GENERALIZEDTIME is similar to UTCTIME except the year is represented as YYYY. This stuff treats everything as a two digit field so make first two fields 00 to 99

incomplete 2-digital number

no more bytes to read, but we haven't seen time-zone yet

UTC will never be here

check if tm_mday is valid in tm_mon

it's February

Optional fractional seconds: decimal point followed by one or more digits.

RFC 5280 forbids fractional seconds

Must have at least one digit after decimal point

no more bytes to read, but we haven't seen time-zone yet

'o' will never point to '\0' at this point, the only chance 'o' can point to '\0' is either the subsequent if or the first else if is true.

if not equal, no need to do subsequent checks since the following for-loop will add 'o' by 4 and the final return statement will check if 'l' and 'o' are equal.

if tm is NULL, no need to adjust

not Z, or not +/- in non-strict mode

success, check if tm should be filled

Convert an ASN1_TIME structure to GeneralizedTime

Try UTC, if that fails, try GENERALIZED

Per RFC 5280 (section 4.1.2.5.), the valid input time strings should be encoded with the following rules: 1. UTC: YYMMDDHHMMSSZ, if YY < 50 (20YY) --> UTC: YYMMDDHHMMSSZ 2. UTC: YYMMDDHHMMSSZ, if YY >= 50 (19YY) --> UTC: YYMMDDHHMMSSZ 3. G'd: YYYYMMDDHHMMSSZ, if YYYY >= 2050 --> G'd: YYYYMMDDHHMMSSZ 4. G'd: YYYYMMDDHHMMSSZ, if YYYY < 2050 --> UTC: YYMMDDHHMMSSZ Only strings of the 4th rule should be reformatted, but since a UTC can only present [1950, 2050), so if the given time string is less than 1950 (e.g. 19230419000000Z), we do nothing...

it's OK to let original t.data go since that's assigned to a piece of memory allocated outside of this function. new t.data would be freed after ASN1_STRING_copy is done.

asn1_time_to_tm will check the time type

Try to parse fractional seconds. '14' is the place of 'fraction point' in a GeneralizedTime string.

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

asn1_locl.h

s congruence. For this months start with March and are * numbered 4 through 15. */ static void determine_days(struct tm *tm) { static const int ydays[12] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 }; int y = tm->tm_year + 1900; int m = tm->tm_mon; int d = tm->tm_mday; int c; tm->tm_yday = ydays[m] + d - 1; if (m >= 2) { /* March and onwards can be one day further into the year */ tm->tm_yday += leap_year(y); m += 2; } else { /* Treat January and February as part of the previous year */ m += 14; y--; } c = y / 100; y %= 100; /* Zeller

seconds

MUST

Zulu

MUST

+|-

Z

+

-

0

0

t seen time-zone yet */ if (++o == l) goto err; i2 = (d->type == V_ASN1_UTCTIME) ? i + 1 : i; if ((n < min[i2]) || (n > max[i2])) goto err; switch (i2) { case 0: /* UTC will never be here */ tmp.tm_year = n * 100 - 1900; break; case 1: if (d->type == V_ASN1_UTCTIME) tmp.tm_year = n < 50 ? n + 100 : n; else tmp.tm_year += n; break; case 2: tmp.tm_mon = n - 1; break; case 3: /* check if tm_mday is valid in tm_mon */ if (tmp.tm_mon == 1) { /* it

.

t seen time-zone yet */ if (o == l) goto err; } /* *

will never point to

at this point, the only chance *

can point to

is either the subsequent if or the first * else if is true. */ if (a[o] ==

) { o++; } else if (!strict && ((a[o] ==

) || (a[o] ==

))) { int offsign = a[o] ==

? 1 : -1; int offset = 0; o++; /* * if not equal, no need to do subsequent checks * since the following for-loop will add

by 4 * and the final return statement will check if

* and

are equal. */ if (o + 4 != l) goto err; for (i = end; i < end + 2; i++) { if (!ossl_isdigit(a[o])) goto err; n = a[o] -

; o++; if (!ossl_isdigit(a[o])) goto err; n = (n * 10) + a[o] -

; i2 = (d->type == V_ASN1_UTCTIME) ? i + 1 : i; if ((n < min[i2]) || (n > max[i2])) goto err; /* if tm is NULL, no need to adjust */ if (tm != NULL) { if (i == end) offset = n * 3600; else if (i == end + 1) offset += n * 60; } o++; } if (offset && !OPENSSL_gmtime_adj(&tmp, 0, offset * offsign)) goto err; } else { /* not Z, or not +/- in non-strict mode */ goto err; } if (o == l) { /* success, check if tm should be filled */ if (tm != NULL) *tm = tmp; return 1; } err: return 0; } ASN1_TIME *asn1_time_from_tm(ASN1_TIME *s, struct tm *ts, int type) { char* p; ASN1_TIME *tmps = NULL; const size_t len = 20; if (type == V_ASN1_UNDEF) { if (is_utc(ts->tm_year)) type = V_ASN1_UTCTIME; else type = V_ASN1_GENERALIZEDTIME; } else if (type == V_ASN1_UTCTIME) { if (!is_utc(ts->tm_year)) goto err; } else if (type != V_ASN1_GENERALIZEDTIME) { goto err; } if (s == NULL) tmps = ASN1_STRING_new(); else tmps = s; if (tmps == NULL) return NULL; if (!ASN1_STRING_set(tmps, NULL, len)) goto err; tmps->type = type; p = (char*)tmps->data; if (type == V_ASN1_GENERALIZEDTIME) tmps->length = BIO_snprintf(p, len, "%04d%02d%02d%02d%02d%02dZ", ts->tm_year + 1900, ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min, ts->tm_sec); else tmps->length = BIO_snprintf(p, len, "%02d%02d%02d%02d%02d%02dZ", ts->tm_year % 100, ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min, ts->tm_sec); #ifdef CHARSET_EBCDIC_not ebcdic2ascii(tmps->data, tmps->data, tmps->length); #endif return tmps; err: if (tmps != s) ASN1_STRING_free(tmps); return NULL; } ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t) { return ASN1_TIME_adj(s, t, 0, 0); } ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t, int offset_day, long offset_sec) { struct tm *ts; struct tm data; ts = OPENSSL_gmtime(&t, &data); if (ts == NULL) { ASN1err(ASN1_F_ASN1_TIME_ADJ, ASN1_R_ERROR_GETTING_TIME); return NULL; } if (offset_day || offset_sec) { if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec)) return NULL; } return asn1_time_from_tm(s, ts, V_ASN1_UNDEF); } int ASN1_TIME_check(const ASN1_TIME *t) { if (t->type == V_ASN1_GENERALIZEDTIME) return ASN1_GENERALIZEDTIME_check(t); else if (t->type == V_ASN1_UTCTIME) return ASN1_UTCTIME_check(t); return 0; } /* Convert an ASN1_TIME structure to GeneralizedTime */ ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *t, ASN1_GENERALIZEDTIME **out) { ASN1_GENERALIZEDTIME *ret = NULL; struct tm tm; if (!ASN1_TIME_to_tm(t, &tm)) return NULL; if (out != NULL) ret = *out; ret = asn1_time_from_tm(ret, &tm, V_ASN1_GENERALIZEDTIME); if (out != NULL && ret != NULL) *out = ret; return ret; } int ASN1_TIME_set_string(ASN1_TIME *s, const char *str) { /* Try UTC, if that fails, try GENERALIZED */ if (ASN1_UTCTIME_set_string(s, str)) return 1; return ASN1_GENERALIZEDTIME_set_string(s, str); } int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str) { ASN1_TIME t; struct tm tm; int rv = 0; t.length = strlen(str); t.data = (unsigned char *)str; t.flags = ASN1_STRING_FLAG_X509_TIME; t.type = V_ASN1_UTCTIME; if (!ASN1_TIME_check(&t)) { t.type = V_ASN1_GENERALIZEDTIME; if (!ASN1_TIME_check(&t)) goto out; } /* * Per RFC 5280 (section 4.1.2.5.), the valid input time * strings should be encoded with the following rules: * * 1. UTC: YYMMDDHHMMSSZ, if YY < 50 (20YY) --> UTC: YYMMDDHHMMSSZ * 2. UTC: YYMMDDHHMMSSZ, if YY >= 50 (19YY) --> UTC: YYMMDDHHMMSSZ * 3. G

d: YYYYMMDDHHMMSSZ * 4. G

s OK to let original t.data go since that

Jan

Feb

Mar

Apr

May

Jun

Jul

Aug

Sep

Oct

Nov

Dec

Z

14

fraction point

.

%s %2d %02d:%02d:%02d%.*s %d%s

GMT



%s %2d %02d:%02d:%02d %d%s

GMT



Bad time value


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Returns 0 if they are equal, != 0 otherwise.

They do not have content.

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_locl.h

0xff


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This is the primary function used to parse ASN1_UTCTIME

wrapper around ans1_time_to_tm

Sets the string via simple copy without cleaning it up

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_locl.h


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

UTF8 utilities

This parses a UTF8 string one character at a time. It is passed a pointer to the string and the length of the string. It sets 'value' to the value of the current character. It returns the number of characters read or a negative error code: -1 = string too short -2 = illegal character -3 = subsequent characters not of the form 10xxxxxx -4 = character encoded incorrectly (not minimal length).

Check syntax and work out the encoded value (if correct)

This takes a character 'value' and writes the UTF8 encoded value in 'str' where 'str' is a buffer containing 'len' characters. Returns the number of characters written or -1 if 'len' is too small. 'str' can be set to NULL in which case it just returns the number of characters. It will need at most 6 characters.

Maximum we will need

www.openssl.org/source/license.html

License

internal/cryptlib.h

value

value

str

str

len

len

str

0xxxxxx

0x80)

0x7f;

0xe0)

0xc0)

0xc0)

0x80)

0x1f)

0x3f;

0x80)

0xf0)

0xe0)

0xc0)

0x80)

0xc0)

0x80))

0xf)

0x3f)

0x3f;

0x800)

0xf8)

0xf0)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80))

0x7))

0x3f)

0x3f)

0x3f;

0x10000)

0xfc)

0xf8)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80))

0x3))

0x3f))

0x3f))

0x3f)

0x3f;

0x200000)

0xfe)

0xfc)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80))

0x1))

0x3f))

0x3f))

0x3f))

0x3f)

0x3f;

0x4000000)

0x80)

0x800)

0x1f)

0xc0);

0x3f)

0x80);

0x10000)

0xf)

0xe0);

0x3f)

0x80);

0x3f)

0x80);

0x200000)

0x7)

0xf0);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);

0x4000000)

0x3)

0xf8);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);

0x1)

0xfc);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);

0x3f)

0x80);


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Convert signature OID into digest and public key OIDs

Return value of 2 means carry on, anything else means we exit straight away: either a fatal error of the underlying verification routine handles all verification.

Check public key OID matches public key type

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/asn1_int.h

internal/evp_int.h

0x7)

0x7)


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

Voluntary abort


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Because array size can't be a const in C, the following two are macros. Both sizes are in bytes.

This should be a hidden type, but EVP requires that the size be known

NB: the IV is _two_ blocks long

NB: the IV is _four_ blocks long

www.openssl.org/source/license.html

License

C


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The input and output encrypted as though 128bit cfb mode is being used. The extra state information to record how much of the 128bit block we have used is contained in num;

N.B. This expects the input to be packed, MS bit first

www.openssl.org/source/license.html

License


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

rijndael-alg-fst.c @version 3.0 (December 2000) Optimised ANSI C code for the Rijndael cipher (now AES) @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be> @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be> @author Paulo Barreto <paulo.barreto@terra.com.br> This code is hereby placed in the public domain. THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Note: rewritten a little bit to provide error control and an OpenSSL- compatible API

Te0[x] = S [x].[02, 01, 01, 03]; Te1[x] = S [x].[03, 02, 01, 01]; Te2[x] = S [x].[01, 03, 02, 01]; Te3[x] = S [x].[01, 01, 03, 02]; Td0[x] = Si[x].[0e, 09, 0d, 0b]; Td1[x] = Si[x].[0b, 0e, 09, 0d]; Td2[x] = Si[x].[0d, 0b, 0e, 09]; Td3[x] = Si[x].[09, 0d, 0b, 0e]; Td4[x] = Si[x].[01];

for 128-bit blocks, Rijndael never uses more than 10 rcon values

Expand the cipher key into the encryption key schedule.

Expand the cipher key into the decryption key schedule.

first, start with an encryption schedule

invert the order of the round keys:

apply the inverse MixColumn transform to all round keys but the first and the last:

Encrypt a single block in and out can overlap

?FULL_UNROLL

map byte array block to cipher state and add initial round key:

round 1:

round 2:

round 3:

round 4:

round 5:

round 6:

round 7:

round 8:

round 9:

round 10:

round 11:

round 12:

round 13:

!FULL_UNROLL

Nr - 1 full rounds:

?FULL_UNROLL

apply last round and map cipher state to byte array block:

Decrypt a single block in and out can overlap

?FULL_UNROLL

map byte array block to cipher state and add initial round key:

round 1:

round 2:

round 3:

round 4:

round 5:

round 6:

round 7:

round 8:

round 9:

round 10:

round 11:

round 12:

round 13:

!FULL_UNROLL

Nr - 1 full rounds:

?FULL_UNROLL

apply last round and map cipher state to byte array block:

AES_ASM

for 128-bit blocks, Rijndael never uses more than 10 rcon values

Expand the cipher key into the encryption key schedule.

Expand the cipher key into the decryption key schedule.

first, start with an encryption schedule

invert the order of the round keys:

apply the inverse MixColumn transform to all round keys but the first and the last:

AES_ASM

www.openssl.org/source/license.html

License





aes_locl.h

0xc66363a5U,

0xf87c7c84U,

0xee777799U,

0xf67b7b8dU,

0xfff2f20dU,

0xd66b6bbdU,

0xde6f6fb1U,

0x91c5c554U,

0x60303050U,

0x02010103U,

0xce6767a9U,

0x562b2b7dU,

0xe7fefe19U,

0xb5d7d762U,

0x4dababe6U,

0xec76769aU,

0x8fcaca45U,

0x1f82829dU,

0x89c9c940U,

0xfa7d7d87U,

0xeffafa15U,

0xb25959ebU,

0x8e4747c9U,

0xfbf0f00bU,

0x41adadecU,

0xb3d4d467U,

0x5fa2a2fdU,

0x45afafeaU,

0x239c9cbfU,

0x53a4a4f7U,

0xe4727296U,

0x9bc0c05bU,

0x75b7b7c2U,

0xe1fdfd1cU,

0x3d9393aeU,

0x4c26266aU,

0x6c36365aU,

0x7e3f3f41U,

0xf5f7f702U,

0x83cccc4fU,

0x6834345cU,

0x51a5a5f4U,

0xd1e5e534U,

0xf9f1f108U,

0xe2717193U,

0xabd8d873U,

0x62313153U,

0x2a15153fU,

0x0804040cU,

0x95c7c752U,

0x46232365U,

0x9dc3c35eU,

0x30181828U,

0x379696a1U,

0x0a05050fU,

0x2f9a9ab5U,

0x0e070709U,

0x24121236U,

0x1b80809bU,

0xdfe2e23dU,

0xcdebeb26U,

0x4e272769U,

0x7fb2b2cdU,

0xea75759fU,

0x1209091bU,

0x1d83839eU,

0x582c2c74U,

0x341a1a2eU,

0x361b1b2dU,

0xdc6e6eb2U,

0xb45a5aeeU,

0x5ba0a0fbU,

0xa45252f6U,

0x763b3b4dU,

0xb7d6d661U,

0x7db3b3ceU,

0x5229297bU,

0xdde3e33eU,

0x5e2f2f71U,

0x13848497U,

0xa65353f5U,

0xb9d1d168U,

0x00000000U,

0xc1eded2cU,

0x40202060U,

0xe3fcfc1fU,

0x79b1b1c8U,

0xb65b5bedU,

0xd46a6abeU,

0x8dcbcb46U,

0x67bebed9U,

0x7239394bU,

0x944a4adeU,

0x984c4cd4U,

0xb05858e8U,

0x85cfcf4aU,

0xbbd0d06bU,

0xc5efef2aU,

0x4faaaae5U,

0xedfbfb16U,

0x864343c5U,

0x9a4d4dd7U,

0x66333355U,

0x11858594U,

0x8a4545cfU,

0xe9f9f910U,

0x04020206U,

0xfe7f7f81U,

0xa05050f0U,

0x783c3c44U,

0x259f9fbaU,

0x4ba8a8e3U,

0xa25151f3U,

0x5da3a3feU,

0x804040c0U,

0x058f8f8aU,

0x3f9292adU,

0x219d9dbcU,

0x70383848U,

0xf1f5f504U,

0x63bcbcdfU,

0x77b6b6c1U,

0xafdada75U,

0x42212163U,

0x20101030U,

0xe5ffff1aU,

0xfdf3f30eU,

0xbfd2d26dU,

0x81cdcd4cU,

0x180c0c14U,

0x26131335U,

0xc3ecec2fU,

0xbe5f5fe1U,

0x359797a2U,

0x884444ccU,

0x2e171739U,

0x93c4c457U,

0x55a7a7f2U,

0xfc7e7e82U,

0x7a3d3d47U,

0xc86464acU,

0xba5d5de7U,

0x3219192bU,

0xe6737395U,

0xc06060a0U,

0x19818198U,

0x9e4f4fd1U,

0xa3dcdc7fU,

0x44222266U,

0x542a2a7eU,

0x3b9090abU,

0x0b888883U,

0x8c4646caU,

0xc7eeee29U,

0x6bb8b8d3U,

0x2814143cU,

0xa7dede79U,

0xbc5e5ee2U,

0x160b0b1dU,

0xaddbdb76U,

0xdbe0e03bU,

0x64323256U,

0x743a3a4eU,

0x140a0a1eU,

0x924949dbU,

0x0c06060aU,

0x4824246cU,

0xb85c5ce4U,

0x9fc2c25dU,

0xbdd3d36eU,

0x43acacefU,

0xc46262a6U,

0x399191a8U,

0x319595a4U,

0xd3e4e437U,

0xf279798bU,

0xd5e7e732U,

0x8bc8c843U,

0x6e373759U,

0xda6d6db7U,

0x018d8d8cU,

0xb1d5d564U,

0x9c4e4ed2U,

0x49a9a9e0U,

0xd86c6cb4U,

0xac5656faU,

0xf3f4f407U,

0xcfeaea25U,

0xca6565afU,

0xf47a7a8eU,

0x47aeaee9U,

0x10080818U,

0x6fbabad5U,

0xf0787888U,

0x4a25256fU,

0x5c2e2e72U,

0x381c1c24U,

0x57a6a6f1U,

0x73b4b4c7U,

0x97c6c651U,

0xcbe8e823U,

0xa1dddd7cU,

0xe874749cU,

0x3e1f1f21U,

0x964b4bddU,

0x61bdbddcU,

0x0d8b8b86U,

0x0f8a8a85U,

0xe0707090U,

0x7c3e3e42U,

0x71b5b5c4U,

0xcc6666aaU,

0x904848d8U,

0x06030305U,

0xf7f6f601U,

0x1c0e0e12U,

0xc26161a3U,

0x6a35355fU,

0xae5757f9U,

0x69b9b9d0U,

0x17868691U,

0x99c1c158U,

0x3a1d1d27U,

0x279e9eb9U,

0xd9e1e138U,

0xebf8f813U,

0x2b9898b3U,

0x22111133U,

0xd26969bbU,

0xa9d9d970U,

0x078e8e89U,

0x339494a7U,

0x2d9b9bb6U,

0x3c1e1e22U,

0x15878792U,

0xc9e9e920U,

0x87cece49U,

0xaa5555ffU,

0x50282878U,

0xa5dfdf7aU,

0x038c8c8fU,

0x59a1a1f8U,

0x09898980U,

0x1a0d0d17U,

0x65bfbfdaU,

0xd7e6e631U,

0x844242c6U,

0xd06868b8U,

0x824141c3U,

0x299999b0U,

0x5a2d2d77U,

0x1e0f0f11U,

0x7bb0b0cbU,

0xa85454fcU,

0x6dbbbbd6U,

0x2c16163aU,

0xa5c66363U,

0x84f87c7cU,

0x99ee7777U,

0x8df67b7bU,

0x0dfff2f2U,

0xbdd66b6bU,

0xb1de6f6fU,

0x5491c5c5U,

0x50603030U,

0x03020101U,

0xa9ce6767U,

0x7d562b2bU,

0x19e7fefeU,

0x62b5d7d7U,

0xe64dababU,

0x9aec7676U,

0x458fcacaU,

0x9d1f8282U,

0x4089c9c9U,

0x87fa7d7dU,

0x15effafaU,

0xebb25959U,

0xc98e4747U,

0x0bfbf0f0U,

0xec41adadU,

0x67b3d4d4U,

0xfd5fa2a2U,

0xea45afafU,

0xbf239c9cU,

0xf753a4a4U,

0x96e47272U,

0x5b9bc0c0U,

0xc275b7b7U,

0x1ce1fdfdU,

0xae3d9393U,

0x6a4c2626U,

0x5a6c3636U,

0x417e3f3fU,

0x02f5f7f7U,

0x4f83ccccU,

0x5c683434U,

0xf451a5a5U,

0x34d1e5e5U,

0x08f9f1f1U,

0x93e27171U,

0x73abd8d8U,

0x53623131U,

0x3f2a1515U,

0x0c080404U,

0x5295c7c7U,

0x65462323U,

0x5e9dc3c3U,

0x28301818U,

0xa1379696U,

0x0f0a0505U,

0xb52f9a9aU,

0x090e0707U,

0x36241212U,

0x9b1b8080U,

0x3ddfe2e2U,

0x26cdebebU,

0x694e2727U,

0xcd7fb2b2U,

0x9fea7575U,

0x1b120909U,

0x9e1d8383U,

0x74582c2cU,

0x2e341a1aU,

0x2d361b1bU,

0xb2dc6e6eU,

0xeeb45a5aU,

0xfb5ba0a0U,

0xf6a45252U,

0x4d763b3bU,

0x61b7d6d6U,

0xce7db3b3U,

0x7b522929U,

0x3edde3e3U,

0x715e2f2fU,

0x97138484U,

0xf5a65353U,

0x68b9d1d1U,

0x00000000U,

0x2cc1ededU,

0x60402020U,

0x1fe3fcfcU,

0xc879b1b1U,

0xedb65b5bU,

0xbed46a6aU,

0x468dcbcbU,

0xd967bebeU,

0x4b723939U,

0xde944a4aU,

0xd4984c4cU,

0xe8b05858U,

0x4a85cfcfU,

0x6bbbd0d0U,

0x2ac5efefU,

0xe54faaaaU,

0x16edfbfbU,

0xc5864343U,

0xd79a4d4dU,

0x55663333U,

0x94118585U,

0xcf8a4545U,

0x10e9f9f9U,

0x06040202U,

0x81fe7f7fU,

0xf0a05050U,

0x44783c3cU,

0xba259f9fU,

0xe34ba8a8U,

0xf3a25151U,

0xfe5da3a3U,

0xc0804040U,

0x8a058f8fU,

0xad3f9292U,

0xbc219d9dU,

0x48703838U,

0x04f1f5f5U,

0xdf63bcbcU,

0xc177b6b6U,

0x75afdadaU,

0x63422121U,

0x30201010U,

0x1ae5ffffU,

0x0efdf3f3U,

0x6dbfd2d2U,

0x4c81cdcdU,

0x14180c0cU,

0x35261313U,

0x2fc3ececU,

0xe1be5f5fU,

0xa2359797U,

0xcc884444U,

0x392e1717U,

0x5793c4c4U,

0xf255a7a7U,

0x82fc7e7eU,

0x477a3d3dU,

0xacc86464U,

0xe7ba5d5dU,

0x2b321919U,

0x95e67373U,

0xa0c06060U,

0x98198181U,

0xd19e4f4fU,

0x7fa3dcdcU,

0x66442222U,

0x7e542a2aU,

0xab3b9090U,

0x830b8888U,

0xca8c4646U,

0x29c7eeeeU,

0xd36bb8b8U,

0x3c281414U,

0x79a7dedeU,

0xe2bc5e5eU,

0x1d160b0bU,

0x76addbdbU,

0x3bdbe0e0U,

0x56643232U,

0x4e743a3aU,

0x1e140a0aU,

0xdb924949U,

0x0a0c0606U,

0x6c482424U,

0xe4b85c5cU,

0x5d9fc2c2U,

0x6ebdd3d3U,

0xef43acacU,

0xa6c46262U,

0xa8399191U,

0xa4319595U,

0x37d3e4e4U,

0x8bf27979U,

0x32d5e7e7U,

0x438bc8c8U,

0x596e3737U,

0xb7da6d6dU,

0x8c018d8dU,

0x64b1d5d5U,

0xd29c4e4eU,

0xe049a9a9U,

0xb4d86c6cU,

0xfaac5656U,

0x07f3f4f4U,

0x25cfeaeaU,

0xafca6565U,

0x8ef47a7aU,

0xe947aeaeU,

0x18100808U,

0xd56fbabaU,

0x88f07878U,

0x6f4a2525U,

0x725c2e2eU,

0x24381c1cU,

0xf157a6a6U,

0xc773b4b4U,

0x5197c6c6U,

0x23cbe8e8U,

0x7ca1ddddU,

0x9ce87474U,

0x213e1f1fU,

0xdd964b4bU,

0xdc61bdbdU,

0x860d8b8bU,

0x850f8a8aU,

0x90e07070U,

0x427c3e3eU,

0xc471b5b5U,

0xaacc6666U,

0xd8904848U,

0x05060303U,

0x01f7f6f6U,

0x121c0e0eU,

0xa3c26161U,

0x5f6a3535U,

0xf9ae5757U,

0xd069b9b9U,

0x91178686U,

0x5899c1c1U,

0x273a1d1dU,

0xb9279e9eU,

0x38d9e1e1U,

0x13ebf8f8U,

0xb32b9898U,

0x33221111U,

0xbbd26969U,

0x70a9d9d9U,

0x89078e8eU,

0xa7339494U,

0xb62d9b9bU,

0x223c1e1eU,

0x92158787U,

0x20c9e9e9U,

0x4987ceceU,

0xffaa5555U,

0x78502828U,

0x7aa5dfdfU,

0x8f038c8cU,

0xf859a1a1U,

0x80098989U,

0x171a0d0dU,

0xda65bfbfU,

0x31d7e6e6U,

0xc6844242U,

0xb8d06868U,

0xc3824141U,

0xb0299999U,

0x775a2d2dU,

0x111e0f0fU,

0xcb7bb0b0U,

0xfca85454U,

0xd66dbbbbU,

0x3a2c1616U,

0x63a5c663U,

0x7c84f87cU,

0x7799ee77U,

0x7b8df67bU,

0xf20dfff2U,

0x6bbdd66bU,

0x6fb1de6fU,

0xc55491c5U,

0x30506030U,

0x01030201U,

0x67a9ce67U,

0x2b7d562bU,

0xfe19e7feU,

0xd762b5d7U,

0xabe64dabU,

0x769aec76U,

0xca458fcaU,

0x829d1f82U,

0xc94089c9U,

0x7d87fa7dU,

0xfa15effaU,

0x59ebb259U,

0x47c98e47U,

0xf00bfbf0U,

0xadec41adU,

0xd467b3d4U,

0xa2fd5fa2U,

0xafea45afU,

0x9cbf239cU,

0xa4f753a4U,

0x7296e472U,

0xc05b9bc0U,

0xb7c275b7U,

0xfd1ce1fdU,

0x93ae3d93U,

0x266a4c26U,

0x365a6c36U,

0x3f417e3fU,

0xf702f5f7U,

0xcc4f83ccU,

0x345c6834U,

0xa5f451a5U,

0xe534d1e5U,

0xf108f9f1U,

0x7193e271U,

0xd873abd8U,

0x31536231U,

0x153f2a15U,

0x040c0804U,

0xc75295c7U,

0x23654623U,

0xc35e9dc3U,

0x18283018U,

0x96a13796U,

0x050f0a05U,

0x9ab52f9aU,

0x07090e07U,

0x12362412U,

0x809b1b80U,

0xe23ddfe2U,

0xeb26cdebU,

0x27694e27U,

0xb2cd7fb2U,

0x759fea75U,

0x091b1209U,

0x839e1d83U,

0x2c74582cU,

0x1a2e341aU,

0x1b2d361bU,

0x6eb2dc6eU,

0x5aeeb45aU,

0xa0fb5ba0U,

0x52f6a452U,

0x3b4d763bU,

0xd661b7d6U,

0xb3ce7db3U,

0x297b5229U,

0xe33edde3U,

0x2f715e2fU,

0x84971384U,

0x53f5a653U,

0xd168b9d1U,

0x00000000U,

0xed2cc1edU,

0x20604020U,

0xfc1fe3fcU,

0xb1c879b1U,

0x5bedb65bU,

0x6abed46aU,

0xcb468dcbU,

0xbed967beU,

0x394b7239U,

0x4ade944aU,

0x4cd4984cU,

0x58e8b058U,

0xcf4a85cfU,

0xd06bbbd0U,

0xef2ac5efU,

0xaae54faaU,

0xfb16edfbU,

0x43c58643U,

0x4dd79a4dU,

0x33556633U,

0x85941185U,

0x45cf8a45U,

0xf910e9f9U,

0x02060402U,

0x7f81fe7fU,

0x50f0a050U,

0x3c44783cU,

0x9fba259fU,

0xa8e34ba8U,

0x51f3a251U,

0xa3fe5da3U,

0x40c08040U,

0x8f8a058fU,

0x92ad3f92U,

0x9dbc219dU,

0x38487038U,

0xf504f1f5U,

0xbcdf63bcU,

0xb6c177b6U,

0xda75afdaU,

0x21634221U,

0x10302010U,

0xff1ae5ffU,

0xf30efdf3U,

0xd26dbfd2U,

0xcd4c81cdU,

0x0c14180cU,

0x13352613U,

0xec2fc3ecU,

0x5fe1be5fU,

0x97a23597U,

0x44cc8844U,

0x17392e17U,

0xc45793c4U,

0xa7f255a7U,

0x7e82fc7eU,

0x3d477a3dU,

0x64acc864U,

0x5de7ba5dU,

0x192b3219U,

0x7395e673U,

0x60a0c060U,

0x81981981U,

0x4fd19e4fU,

0xdc7fa3dcU,

0x22664422U,

0x2a7e542aU,

0x90ab3b90U,

0x88830b88U,

0x46ca8c46U,

0xee29c7eeU,

0xb8d36bb8U,

0x143c2814U,

0xde79a7deU,

0x5ee2bc5eU,

0x0b1d160bU,

0xdb76addbU,

0xe03bdbe0U,

0x32566432U,

0x3a4e743aU,

0x0a1e140aU,

0x49db9249U,

0x060a0c06U,

0x246c4824U,

0x5ce4b85cU,

0xc25d9fc2U,

0xd36ebdd3U,

0xacef43acU,

0x62a6c462U,

0x91a83991U,

0x95a43195U,

0xe437d3e4U,

0x798bf279U,

0xe732d5e7U,

0xc8438bc8U,

0x37596e37U,

0x6db7da6dU,

0x8d8c018dU,

0xd564b1d5U,

0x4ed29c4eU,

0xa9e049a9U,

0x6cb4d86cU,

0x56faac56U,

0xf407f3f4U,

0xea25cfeaU,

0x65afca65U,

0x7a8ef47aU,

0xaee947aeU,

0x08181008U,

0xbad56fbaU,

0x7888f078U,

0x256f4a25U,

0x2e725c2eU,

0x1c24381cU,

0xa6f157a6U,

0xb4c773b4U,

0xc65197c6U,

0xe823cbe8U,

0xdd7ca1ddU,

0x749ce874U,

0x1f213e1fU,

0x4bdd964bU,

0xbddc61bdU,

0x8b860d8bU,

0x8a850f8aU,

0x7090e070U,

0x3e427c3eU,

0xb5c471b5U,

0x66aacc66U,

0x48d89048U,

0x03050603U,

0xf601f7f6U,

0x0e121c0eU,

0x61a3c261U,

0x355f6a35U,

0x57f9ae57U,

0xb9d069b9U,

0x86911786U,

0xc15899c1U,

0x1d273a1dU,

0x9eb9279eU,

0xe138d9e1U,

0xf813ebf8U,

0x98b32b98U,

0x11332211U,

0x69bbd269U,

0xd970a9d9U,

0x8e89078eU,

0x94a73394U,

0x9bb62d9bU,

0x1e223c1eU,

0x87921587U,

0xe920c9e9U,

0xce4987ceU,

0x55ffaa55U,

0x28785028U,

0xdf7aa5dfU,

0x8c8f038cU,

0xa1f859a1U,

0x89800989U,

0x0d171a0dU,

0xbfda65bfU,

0xe631d7e6U,

0x42c68442U,

0x68b8d068U,

0x41c38241U,

0x99b02999U,

0x2d775a2dU,

0x0f111e0fU,

0xb0cb7bb0U,

0x54fca854U,

0xbbd66dbbU,

0x163a2c16U,

0x6363a5c6U,

0x7c7c84f8U,

0x777799eeU,

0x7b7b8df6U,

0xf2f20dffU,

0x6b6bbdd6U,

0x6f6fb1deU,

0xc5c55491U,

0x30305060U,

0x01010302U,

0x6767a9ceU,

0x2b2b7d56U,

0xfefe19e7U,

0xd7d762b5U,

0xababe64dU,

0x76769aecU,

0xcaca458fU,

0x82829d1fU,

0xc9c94089U,

0x7d7d87faU,

0xfafa15efU,

0x5959ebb2U,

0x4747c98eU,

0xf0f00bfbU,

0xadadec41U,

0xd4d467b3U,

0xa2a2fd5fU,

0xafafea45U,

0x9c9cbf23U,

0xa4a4f753U,

0x727296e4U,

0xc0c05b9bU,

0xb7b7c275U,

0xfdfd1ce1U,

0x9393ae3dU,

0x26266a4cU,

0x36365a6cU,

0x3f3f417eU,

0xf7f702f5U,

0xcccc4f83U,

0x34345c68U,

0xa5a5f451U,

0xe5e534d1U,

0xf1f108f9U,

0x717193e2U,

0xd8d873abU,

0x31315362U,

0x15153f2aU,

0x04040c08U,

0xc7c75295U,

0x23236546U,

0xc3c35e9dU,

0x18182830U,

0x9696a137U,

0x05050f0aU,

0x9a9ab52fU,

0x0707090eU,

0x12123624U,

0x80809b1bU,

0xe2e23ddfU,

0xebeb26cdU,

0x2727694eU,

0xb2b2cd7fU,

0x75759feaU,

0x09091b12U,

0x83839e1dU,

0x2c2c7458U,

0x1a1a2e34U,

0x1b1b2d36U,

0x6e6eb2dcU,

0x5a5aeeb4U,

0xa0a0fb5bU,

0x5252f6a4U,

0x3b3b4d76U,

0xd6d661b7U,

0xb3b3ce7dU,

0x29297b52U,

0xe3e33eddU,

0x2f2f715eU,

0x84849713U,

0x5353f5a6U,

0xd1d168b9U,

0x00000000U,

0xeded2cc1U,

0x20206040U,

0xfcfc1fe3U,

0xb1b1c879U,

0x5b5bedb6U,

0x6a6abed4U,

0xcbcb468dU,

0xbebed967U,

0x39394b72U,

0x4a4ade94U,

0x4c4cd498U,

0x5858e8b0U,

0xcfcf4a85U,

0xd0d06bbbU,

0xefef2ac5U,

0xaaaae54fU,

0xfbfb16edU,

0x4343c586U,

0x4d4dd79aU,

0x33335566U,

0x85859411U,

0x4545cf8aU,

0xf9f910e9U,

0x02020604U,

0x7f7f81feU,

0x5050f0a0U,

0x3c3c4478U,

0x9f9fba25U,

0xa8a8e34bU,

0x5151f3a2U,

0xa3a3fe5dU,

0x4040c080U,

0x8f8f8a05U,

0x9292ad3fU,

0x9d9dbc21U,

0x38384870U,

0xf5f504f1U,

0xbcbcdf63U,

0xb6b6c177U,

0xdada75afU,

0x21216342U,

0x10103020U,

0xffff1ae5U,

0xf3f30efdU,

0xd2d26dbfU,

0xcdcd4c81U,

0x0c0c1418U,

0x13133526U,

0xecec2fc3U,

0x5f5fe1beU,

0x9797a235U,

0x4444cc88U,

0x1717392eU,

0xc4c45793U,

0xa7a7f255U,

0x7e7e82fcU,

0x3d3d477aU,

0x6464acc8U,

0x5d5de7baU,

0x19192b32U,

0x737395e6U,

0x6060a0c0U,

0x81819819U,

0x4f4fd19eU,

0xdcdc7fa3U,

0x22226644U,

0x2a2a7e54U,

0x9090ab3bU,

0x8888830bU,

0x4646ca8cU,

0xeeee29c7U,

0xb8b8d36bU,

0x14143c28U,

0xdede79a7U,

0x5e5ee2bcU,

0x0b0b1d16U,

0xdbdb76adU,

0xe0e03bdbU,

0x32325664U,

0x3a3a4e74U,

0x0a0a1e14U,

0x4949db92U,

0x06060a0cU,

0x24246c48U,

0x5c5ce4b8U,

0xc2c25d9fU,

0xd3d36ebdU,

0xacacef43U,

0x6262a6c4U,

0x9191a839U,

0x9595a431U,

0xe4e437d3U,

0x79798bf2U,

0xe7e732d5U,

0xc8c8438bU,

0x3737596eU,

0x6d6db7daU,

0x8d8d8c01U,

0xd5d564b1U,

0x4e4ed29cU,

0xa9a9e049U,

0x6c6cb4d8U,

0x5656faacU,

0xf4f407f3U,

0xeaea25cfU,

0x6565afcaU,

0x7a7a8ef4U,

0xaeaee947U,

0x08081810U,

0xbabad56fU,

0x787888f0U,

0x25256f4aU,

0x2e2e725cU,

0x1c1c2438U,

0xa6a6f157U,

0xb4b4c773U,

0xc6c65197U,

0xe8e823cbU,

0xdddd7ca1U,

0x74749ce8U,

0x1f1f213eU,

0x4b4bdd96U,

0xbdbddc61U,

0x8b8b860dU,

0x8a8a850fU,

0x707090e0U,

0x3e3e427cU,

0xb5b5c471U,

0x6666aaccU,

0x4848d890U,

0x03030506U,

0xf6f601f7U,

0x0e0e121cU,

0x6161a3c2U,

0x35355f6aU,

0x5757f9aeU,

0xb9b9d069U,

0x86869117U,

0xc1c15899U,

0x1d1d273aU,

0x9e9eb927U,

0xe1e138d9U,

0xf8f813ebU,

0x9898b32bU,

0x11113322U,

0x6969bbd2U,

0xd9d970a9U,

0x8e8e8907U,

0x9494a733U,

0x9b9bb62dU,

0x1e1e223cU,

0x87879215U,

0xe9e920c9U,

0xcece4987U,

0x5555ffaaU,

0x28287850U,

0xdfdf7aa5U,

0x8c8c8f03U,

0xa1a1f859U,

0x89898009U,

0x0d0d171aU,

0xbfbfda65U,

0xe6e631d7U,

0x4242c684U,

0x6868b8d0U,

0x4141c382U,

0x9999b029U,

0x2d2d775aU,

0x0f0f111eU,

0xb0b0cb7bU,

0x5454fca8U,

0xbbbbd66dU,

0x16163a2cU,

0x51f4a750U,

0x7e416553U,

0x1a17a4c3U,

0x3a275e96U,

0x3bab6bcbU,

0x1f9d45f1U,

0xacfa58abU,

0x4be30393U,

0x2030fa55U,

0xad766df6U,

0x88cc7691U,

0xf5024c25U,

0x4fe5d7fcU,

0xc52acbd7U,

0x26354480U,

0xb562a38fU,

0xdeb15a49U,

0x25ba1b67U,

0x45ea0e98U,

0x5dfec0e1U,

0xc32f7502U,

0x814cf012U,

0x8d4697a3U,

0x6bd3f9c6U,

0x038f5fe7U,

0x15929c95U,

0xbf6d7aebU,

0x955259daU,

0xd4be832dU,

0x587421d3U,

0x49e06929U,

0x8ec9c844U,

0x75c2896aU,

0xf48e7978U,

0x99583e6bU,

0x27b971ddU,

0xbee14fb6U,

0xf088ad17U,

0xc920ac66U,

0x7dce3ab4U,

0x63df4a18U,

0xe51a3182U,

0x97513360U,

0x62537f45U,

0xb16477e0U,

0xbb6bae84U,

0xfe81a01cU,

0xf9082b94U,

0x70486858U,

0x8f45fd19U,

0x94de6c87U,

0x527bf8b7U,

0xab73d323U,

0x724b02e2U,

0xe31f8f57U,

0x6655ab2aU,

0xb2eb2807U,

0x2fb5c203U,

0x86c57b9aU,

0xd33708a5U,

0x302887f2U,

0x23bfa5b2U,

0x02036abaU,

0xed16825cU,

0x8acf1c2bU,

0xa779b492U,

0xf307f2f0U,

0x4e69e2a1U,

0x65daf4cdU,

0x0605bed5U,

0xd134621fU,

0xc4a6fe8aU,

0x342e539dU,

0xa2f355a0U,

0x058ae132U,

0xa4f6eb75U,

0x0b83ec39U,

0x4060efaaU,

0x5e719f06U,

0xbd6e1051U,

0x3e218af9U,

0x96dd063dU,

0xdd3e05aeU,

0x4de6bd46U,

0x91548db5U,

0x71c45d05U,

0x0406d46fU,

0x605015ffU,

0x1998fb24U,

0xd6bde997U,

0x894043ccU,

0x67d99e77U,

0xb0e842bdU,

0x07898b88U,

0xe7195b38U,

0x79c8eedbU,

0xa17c0a47U,

0x7c420fe9U,

0xf8841ec9U,

0x00000000U,

0x09808683U,

0x322bed48U,

0x1e1170acU,

0x6c5a724eU,

0xfd0efffbU,

0x0f853856U,

0x3daed51eU,

0x362d3927U,

0x0a0fd964U,

0x685ca621U,

0x9b5b54d1U,

0x24362e3aU,

0x0c0a67b1U,

0x9357e70fU,

0xb4ee96d2U,

0x1b9b919eU,

0x80c0c54fU,

0x61dc20a2U,

0x5a774b69U,

0x1c121a16U,

0xe293ba0aU,

0xc0a02ae5U,

0x3c22e043U,

0x121b171dU,

0x0e090d0bU,

0xf28bc7adU,

0x2db6a8b9U,

0x141ea9c8U,

0x57f11985U,

0xaf75074cU,

0xee99ddbbU,

0xa37f60fdU,

0xf701269fU,

0x5c72f5bcU,

0x44663bc5U,

0x5bfb7e34U,

0x8b432976U,

0xcb23c6dcU,

0xb6edfc68U,

0xb8e4f163U,

0xd731dccaU,

0x42638510U,

0x13972240U,

0x84c61120U,

0x854a247dU,

0xd2bb3df8U,

0xaef93211U,

0xc729a16dU,

0x1d9e2f4bU,

0xdcb230f3U,

0x0d8652ecU,

0x77c1e3d0U,

0x2bb3166cU,

0xa970b999U,

0x119448faU,

0x47e96422U,

0xa8fc8cc4U,

0xa0f03f1aU,

0x567d2cd8U,

0x223390efU,

0x87494ec7U,

0xd938d1c1U,

0x8ccaa2feU,

0x98d40b36U,

0xa6f581cfU,

0xa57ade28U,

0xdab78e26U,

0x3fadbfa4U,

0x2c3a9de4U,

0x5078920dU,

0x6a5fcc9bU,

0x547e4662U,

0xf68d13c2U,

0x90d8b8e8U,

0x2e39f75eU,

0x82c3aff5U,

0x9f5d80beU,

0x69d0937cU,

0x6fd52da9U,

0xcf2512b3U,

0xc8ac993bU,

0x10187da7U,

0xe89c636eU,

0xdb3bbb7bU,

0xcd267809U,

0x6e5918f4U,

0xec9ab701U,

0x834f9aa8U,

0xe6956e65U,

0xaaffe67eU,

0x21bccf08U,

0xef15e8e6U,

0xbae79bd9U,

0x4a6f36ceU,

0xea9f09d4U,

0x29b07cd6U,

0x31a4b2afU,

0x2a3f2331U,

0xc6a59430U,

0x35a266c0U,

0x744ebc37U,

0xfc82caa6U,

0xe090d0b0U,

0x33a7d815U,

0xf104984aU,

0x41ecdaf7U,

0x7fcd500eU,

0x1791f62fU,

0x764dd68dU,

0x43efb04dU,

0xccaa4d54U,

0xe49604dfU,

0x9ed1b5e3U,

0x4c6a881bU,

0xc12c1fb8U,

0x4665517fU,

0x9d5eea04U,

0x018c355dU,

0xfa877473U,

0xfb0b412eU,

0xb3671d5aU,

0x92dbd252U,

0xe9105633U,

0x6dd64713U,

0x9ad7618cU,

0x37a10c7aU,

0x59f8148eU,

0xeb133c89U,

0xcea927eeU,

0xb761c935U,

0xe11ce5edU,

0x7a47b13cU,

0x9cd2df59U,

0x55f2733fU,

0x1814ce79U,

0x73c737bfU,

0x53f7cdeaU,

0x5ffdaa5bU,

0xdf3d6f14U,

0x7844db86U,

0xcaaff381U,

0xb968c43eU,

0x3824342cU,

0xc2a3405fU,

0x161dc372U,

0xbce2250cU,

0x283c498bU,

0xff0d9541U,

0x39a80171U,

0x080cb3deU,

0xd8b4e49cU,

0x6456c190U,

0x7bcb8461U,

0xd532b670U,

0x486c5c74U,

0xd0b85742U,

0x5051f4a7U,

0x537e4165U,

0xc31a17a4U,

0x963a275eU,

0xcb3bab6bU,

0xf11f9d45U,

0xabacfa58U,

0x934be303U,

0x552030faU,

0xf6ad766dU,

0x9188cc76U,

0x25f5024cU,

0xfc4fe5d7U,

0xd7c52acbU,

0x80263544U,

0x8fb562a3U,

0x49deb15aU,

0x6725ba1bU,

0x9845ea0eU,

0xe15dfec0U,

0x02c32f75U,

0x12814cf0U,

0xa38d4697U,

0xc66bd3f9U,

0xe7038f5fU,

0x9515929cU,

0xebbf6d7aU,

0xda955259U,

0x2dd4be83U,

0xd3587421U,

0x2949e069U,

0x448ec9c8U,

0x6a75c289U,

0x78f48e79U,

0x6b99583eU,

0xdd27b971U,

0xb6bee14fU,

0x17f088adU,

0x66c920acU,

0xb47dce3aU,

0x1863df4aU,

0x82e51a31U,

0x60975133U,

0x4562537fU,

0xe0b16477U,

0x84bb6baeU,

0x1cfe81a0U,

0x94f9082bU,

0x58704868U,

0x198f45fdU,

0x8794de6cU,

0xb7527bf8U,

0x23ab73d3U,

0xe2724b02U,

0x57e31f8fU,

0x2a6655abU,

0x07b2eb28U,

0x032fb5c2U,

0x9a86c57bU,

0xa5d33708U,

0xf2302887U,

0xb223bfa5U,

0xba02036aU,

0x5ced1682U,

0x2b8acf1cU,

0x92a779b4U,

0xf0f307f2U,

0xa14e69e2U,

0xcd65daf4U,

0xd50605beU,

0x1fd13462U,

0x8ac4a6feU,

0x9d342e53U,

0xa0a2f355U,

0x32058ae1U,

0x75a4f6ebU,

0x390b83ecU,

0xaa4060efU,

0x065e719fU,

0x51bd6e10U,

0xf93e218aU,

0x3d96dd06U,

0xaedd3e05U,

0x464de6bdU,

0xb591548dU,

0x0571c45dU,

0x6f0406d4U,

0xff605015U,

0x241998fbU,

0x97d6bde9U,

0xcc894043U,

0x7767d99eU,

0xbdb0e842U,

0x8807898bU,

0x38e7195bU,

0xdb79c8eeU,

0x47a17c0aU,

0xe97c420fU,

0xc9f8841eU,

0x00000000U,

0x83098086U,

0x48322bedU,

0xac1e1170U,

0x4e6c5a72U,

0xfbfd0effU,

0x560f8538U,

0x1e3daed5U,

0x27362d39U,

0x640a0fd9U,

0x21685ca6U,

0xd19b5b54U,

0x3a24362eU,

0xb10c0a67U,

0x0f9357e7U,

0xd2b4ee96U,

0x9e1b9b91U,

0x4f80c0c5U,

0xa261dc20U,

0x695a774bU,

0x161c121aU,

0x0ae293baU,

0xe5c0a02aU,

0x433c22e0U,

0x1d121b17U,

0x0b0e090dU,

0xadf28bc7U,

0xb92db6a8U,

0xc8141ea9U,

0x8557f119U,

0x4caf7507U,

0xbbee99ddU,

0xfda37f60U,

0x9ff70126U,

0xbc5c72f5U,

0xc544663bU,

0x345bfb7eU,

0x768b4329U,

0xdccb23c6U,

0x68b6edfcU,

0x63b8e4f1U,

0xcad731dcU,

0x10426385U,

0x40139722U,

0x2084c611U,

0x7d854a24U,

0xf8d2bb3dU,

0x11aef932U,

0x6dc729a1U,

0x4b1d9e2fU,

0xf3dcb230U,

0xec0d8652U,

0xd077c1e3U,

0x6c2bb316U,

0x99a970b9U,

0xfa119448U,

0x2247e964U,

0xc4a8fc8cU,

0x1aa0f03fU,

0xd8567d2cU,

0xef223390U,

0xc787494eU,

0xc1d938d1U,

0xfe8ccaa2U,

0x3698d40bU,

0xcfa6f581U,

0x28a57adeU,

0x26dab78eU,

0xa43fadbfU,

0xe42c3a9dU,

0x0d507892U,

0x9b6a5fccU,

0x62547e46U,

0xc2f68d13U,

0xe890d8b8U,

0x5e2e39f7U,

0xf582c3afU,

0xbe9f5d80U,

0x7c69d093U,

0xa96fd52dU,

0xb3cf2512U,

0x3bc8ac99U,

0xa710187dU,

0x6ee89c63U,

0x7bdb3bbbU,

0x09cd2678U,

0xf46e5918U,

0x01ec9ab7U,

0xa8834f9aU,

0x65e6956eU,

0x7eaaffe6U,

0x0821bccfU,

0xe6ef15e8U,

0xd9bae79bU,

0xce4a6f36U,

0xd4ea9f09U,

0xd629b07cU,

0xaf31a4b2U,

0x312a3f23U,

0x30c6a594U,

0xc035a266U,

0x37744ebcU,

0xa6fc82caU,

0xb0e090d0U,

0x1533a7d8U,

0x4af10498U,

0xf741ecdaU,

0x0e7fcd50U,

0x2f1791f6U,

0x8d764dd6U,

0x4d43efb0U,

0x54ccaa4dU,

0xdfe49604U,

0xe39ed1b5U,

0x1b4c6a88U,

0xb8c12c1fU,

0x7f466551U,

0x049d5eeaU,

0x5d018c35U,

0x73fa8774U,

0x2efb0b41U,

0x5ab3671dU,

0x5292dbd2U,

0x33e91056U,

0x136dd647U,

0x8c9ad761U,

0x7a37a10cU,

0x8e59f814U,

0x89eb133cU,

0xeecea927U,

0x35b761c9U,

0xede11ce5U,

0x3c7a47b1U,

0x599cd2dfU,

0x3f55f273U,

0x791814ceU,

0xbf73c737U,

0xea53f7cdU,

0x5b5ffdaaU,

0x14df3d6fU,

0x867844dbU,

0x81caaff3U,

0x3eb968c4U,

0x2c382434U,

0x5fc2a340U,

0x72161dc3U,

0x0cbce225U,

0x8b283c49U,

0x41ff0d95U,

0x7139a801U,

0xde080cb3U,

0x9cd8b4e4U,

0x906456c1U,

0x617bcb84U,

0x70d532b6U,

0x74486c5cU,

0x42d0b857U,

0xa75051f4U,

0x65537e41U,

0xa4c31a17U,

0x5e963a27U,

0x6bcb3babU,

0x45f11f9dU,

0x58abacfaU,

0x03934be3U,

0xfa552030U,

0x6df6ad76U,

0x769188ccU,

0x4c25f502U,

0xd7fc4fe5U,

0xcbd7c52aU,

0x44802635U,

0xa38fb562U,

0x5a49deb1U,

0x1b6725baU,

0x0e9845eaU,

0xc0e15dfeU,

0x7502c32fU,

0xf012814cU,

0x97a38d46U,

0xf9c66bd3U,

0x5fe7038fU,

0x9c951592U,

0x7aebbf6dU,

0x59da9552U,

0x832dd4beU,

0x21d35874U,

0x692949e0U,

0xc8448ec9U,

0x896a75c2U,

0x7978f48eU,

0x3e6b9958U,

0x71dd27b9U,

0x4fb6bee1U,

0xad17f088U,

0xac66c920U,

0x3ab47dceU,

0x4a1863dfU,

0x3182e51aU,

0x33609751U,

0x7f456253U,

0x77e0b164U,

0xae84bb6bU,

0xa01cfe81U,

0x2b94f908U,

0x68587048U,

0xfd198f45U,

0x6c8794deU,

0xf8b7527bU,

0xd323ab73U,

0x02e2724bU,

0x8f57e31fU,

0xab2a6655U,

0x2807b2ebU,

0xc2032fb5U,

0x7b9a86c5U,

0x08a5d337U,

0x87f23028U,

0xa5b223bfU,

0x6aba0203U,

0x825ced16U,

0x1c2b8acfU,

0xb492a779U,

0xf2f0f307U,

0xe2a14e69U,

0xf4cd65daU,

0xbed50605U,

0x621fd134U,

0xfe8ac4a6U,

0x539d342eU,

0x55a0a2f3U,

0xe132058aU,

0xeb75a4f6U,

0xec390b83U,

0xefaa4060U,

0x9f065e71U,

0x1051bd6eU,

0x8af93e21U,

0x063d96ddU,

0x05aedd3eU,

0xbd464de6U,

0x8db59154U,

0x5d0571c4U,

0xd46f0406U,

0x15ff6050U,

0xfb241998U,

0xe997d6bdU,

0x43cc8940U,

0x9e7767d9U,

0x42bdb0e8U,

0x8b880789U,

0x5b38e719U,

0xeedb79c8U,

0x0a47a17cU,

0x0fe97c42U,

0x1ec9f884U,

0x00000000U,

0x86830980U,

0xed48322bU,

0x70ac1e11U,

0x724e6c5aU,

0xfffbfd0eU,

0x38560f85U,

0xd51e3daeU,

0x3927362dU,

0xd9640a0fU,

0xa621685cU,

0x54d19b5bU,

0x2e3a2436U,

0x67b10c0aU,

0xe70f9357U,

0x96d2b4eeU,

0x919e1b9bU,

0xc54f80c0U,

0x20a261dcU,

0x4b695a77U,

0x1a161c12U,

0xba0ae293U,

0x2ae5c0a0U,

0xe0433c22U,

0x171d121bU,

0x0d0b0e09U,

0xc7adf28bU,

0xa8b92db6U,

0xa9c8141eU,

0x198557f1U,

0x074caf75U,

0xddbbee99U,

0x60fda37fU,

0x269ff701U,

0xf5bc5c72U,

0x3bc54466U,

0x7e345bfbU,

0x29768b43U,

0xc6dccb23U,

0xfc68b6edU,

0xf163b8e4U,

0xdccad731U,

0x85104263U,

0x22401397U,

0x112084c6U,

0x247d854aU,

0x3df8d2bbU,

0x3211aef9U,

0xa16dc729U,

0x2f4b1d9eU,

0x30f3dcb2U,

0x52ec0d86U,

0xe3d077c1U,

0x166c2bb3U,

0xb999a970U,

0x48fa1194U,

0x642247e9U,

0x8cc4a8fcU,

0x3f1aa0f0U,

0x2cd8567dU,

0x90ef2233U,

0x4ec78749U,

0xd1c1d938U,

0xa2fe8ccaU,

0x0b3698d4U,

0x81cfa6f5U,

0xde28a57aU,

0x8e26dab7U,

0xbfa43fadU,

0x9de42c3aU,

0x920d5078U,

0xcc9b6a5fU,

0x4662547eU,

0x13c2f68dU,

0xb8e890d8U,

0xf75e2e39U,

0xaff582c3U,

0x80be9f5dU,

0x937c69d0U,

0x2da96fd5U,

0x12b3cf25U,

0x993bc8acU,

0x7da71018U,

0x636ee89cU,

0xbb7bdb3bU,

0x7809cd26U,

0x18f46e59U,

0xb701ec9aU,

0x9aa8834fU,

0x6e65e695U,

0xe67eaaffU,

0xcf0821bcU,

0xe8e6ef15U,

0x9bd9bae7U,

0x36ce4a6fU,

0x09d4ea9fU,

0x7cd629b0U,

0xb2af31a4U,

0x23312a3fU,

0x9430c6a5U,

0x66c035a2U,

0xbc37744eU,

0xcaa6fc82U,

0xd0b0e090U,

0xd81533a7U,

0x984af104U,

0xdaf741ecU,

0x500e7fcdU,

0xf62f1791U,

0xd68d764dU,

0xb04d43efU,

0x4d54ccaaU,

0x04dfe496U,

0xb5e39ed1U,

0x881b4c6aU,

0x1fb8c12cU,

0x517f4665U,

0xea049d5eU,

0x355d018cU,

0x7473fa87U,

0x412efb0bU,

0x1d5ab367U,

0xd25292dbU,

0x5633e910U,

0x47136dd6U,

0x618c9ad7U,

0x0c7a37a1U,

0x148e59f8U,

0x3c89eb13U,

0x27eecea9U,

0xc935b761U,

0xe5ede11cU,

0xb13c7a47U,

0xdf599cd2U,

0x733f55f2U,

0xce791814U,

0x37bf73c7U,

0xcdea53f7U,

0xaa5b5ffdU,

0x6f14df3dU,

0xdb867844U,

0xf381caafU,

0xc43eb968U,

0x342c3824U,

0x405fc2a3U,

0xc372161dU,

0x250cbce2U,

0x498b283cU,

0x9541ff0dU,

0x017139a8U,

0xb3de080cU,

0xe49cd8b4U,

0xc1906456U,

0x84617bcbU,

0xb670d532U,

0x5c74486cU,

0x5742d0b8U,

0xf4a75051U,

0x4165537eU,

0x17a4c31aU,

0x275e963aU,

0xab6bcb3bU,

0x9d45f11fU,

0xfa58abacU,

0xe303934bU,

0x30fa5520U,

0x766df6adU,

0xcc769188U,

0x024c25f5U,

0xe5d7fc4fU,

0x2acbd7c5U,

0x35448026U,

0x62a38fb5U,

0xb15a49deU,

0xba1b6725U,

0xea0e9845U,

0xfec0e15dU,

0x2f7502c3U,

0x4cf01281U,

0x4697a38dU,

0xd3f9c66bU,

0x8f5fe703U,

0x929c9515U,

0x6d7aebbfU,

0x5259da95U,

0xbe832dd4U,

0x7421d358U,

0xe0692949U,

0xc9c8448eU,

0xc2896a75U,

0x8e7978f4U,

0x583e6b99U,

0xb971dd27U,

0xe14fb6beU,

0x88ad17f0U,

0x20ac66c9U,

0xce3ab47dU,

0xdf4a1863U,

0x1a3182e5U,

0x51336097U,

0x537f4562U,

0x6477e0b1U,

0x6bae84bbU,

0x81a01cfeU,

0x082b94f9U,

0x48685870U,

0x45fd198fU,

0xde6c8794U,

0x7bf8b752U,

0x73d323abU,

0x4b02e272U,

0x1f8f57e3U,

0x55ab2a66U,

0xeb2807b2U,

0xb5c2032fU,

0xc57b9a86U,

0x3708a5d3U,

0x2887f230U,

0xbfa5b223U,

0x036aba02U,

0x16825cedU,

0xcf1c2b8aU,

0x79b492a7U,

0x07f2f0f3U,

0x69e2a14eU,

0xdaf4cd65U,

0x05bed506U,

0x34621fd1U,

0xa6fe8ac4U,

0x2e539d34U,

0xf355a0a2U,

0x8ae13205U,

0xf6eb75a4U,

0x83ec390bU,

0x60efaa40U,

0x719f065eU,

0x6e1051bdU,

0x218af93eU,

0xdd063d96U,

0x3e05aeddU,

0xe6bd464dU,

0x548db591U,

0xc45d0571U,

0x06d46f04U,

0x5015ff60U,

0x98fb2419U,

0xbde997d6U,

0x4043cc89U,

0xd99e7767U,

0xe842bdb0U,

0x898b8807U,

0x195b38e7U,

0xc8eedb79U,

0x7c0a47a1U,

0x420fe97cU,

0x841ec9f8U,

0x00000000U,

0x80868309U,

0x2bed4832U,

0x1170ac1eU,

0x5a724e6cU,

0x0efffbfdU,

0x8538560fU,

0xaed51e3dU,

0x2d392736U,

0x0fd9640aU,

0x5ca62168U,

0x5b54d19bU,

0x362e3a24U,

0x0a67b10cU,

0x57e70f93U,

0xee96d2b4U,

0x9b919e1bU,

0xc0c54f80U,

0xdc20a261U,

0x774b695aU,

0x121a161cU,

0x93ba0ae2U,

0xa02ae5c0U,

0x22e0433cU,

0x1b171d12U,

0x090d0b0eU,

0x8bc7adf2U,

0xb6a8b92dU,

0x1ea9c814U,

0xf1198557U,

0x75074cafU,

0x99ddbbeeU,

0x7f60fda3U,

0x01269ff7U,

0x72f5bc5cU,

0x663bc544U,

0xfb7e345bU,

0x4329768bU,

0x23c6dccbU,

0xedfc68b6U,

0xe4f163b8U,

0x31dccad7U,

0x63851042U,

0x97224013U,

0xc6112084U,

0x4a247d85U,

0xbb3df8d2U,

0xf93211aeU,

0x29a16dc7U,

0x9e2f4b1dU,

0xb230f3dcU,

0x8652ec0dU,

0xc1e3d077U,

0xb3166c2bU,

0x70b999a9U,

0x9448fa11U,

0xe9642247U,

0xfc8cc4a8U,

0xf03f1aa0U,

0x7d2cd856U,

0x3390ef22U,

0x494ec787U,

0x38d1c1d9U,

0xcaa2fe8cU,

0xd40b3698U,

0xf581cfa6U,

0x7ade28a5U,

0xb78e26daU,

0xadbfa43fU,

0x3a9de42cU,

0x78920d50U,

0x5fcc9b6aU,

0x7e466254U,

0x8d13c2f6U,

0xd8b8e890U,

0x39f75e2eU,

0xc3aff582U,

0x5d80be9fU,

0xd0937c69U,

0xd52da96fU,

0x2512b3cfU,

0xac993bc8U,

0x187da710U,

0x9c636ee8U,

0x3bbb7bdbU,

0x267809cdU,

0x5918f46eU,

0x9ab701ecU,

0x4f9aa883U,

0x956e65e6U,

0xffe67eaaU,

0xbccf0821U,

0x15e8e6efU,

0xe79bd9baU,

0x6f36ce4aU,

0x9f09d4eaU,

0xb07cd629U,

0xa4b2af31U,

0x3f23312aU,

0xa59430c6U,

0xa266c035U,

0x4ebc3774U,

0x82caa6fcU,

0x90d0b0e0U,

0xa7d81533U,

0x04984af1U,

0xecdaf741U,

0xcd500e7fU,

0x91f62f17U,

0x4dd68d76U,

0xefb04d43U,

0xaa4d54ccU,

0x9604dfe4U,

0xd1b5e39eU,

0x6a881b4cU,

0x2c1fb8c1U,

0x65517f46U,

0x5eea049dU,

0x8c355d01U,

0x877473faU,

0x0b412efbU,

0x671d5ab3U,

0xdbd25292U,

0x105633e9U,

0xd647136dU,

0xd7618c9aU,

0xa10c7a37U,

0xf8148e59U,

0x133c89ebU,

0xa927eeceU,

0x61c935b7U,

0x1ce5ede1U,

0x47b13c7aU,

0xd2df599cU,

0xf2733f55U,

0x14ce7918U,

0xc737bf73U,

0xf7cdea53U,

0xfdaa5b5fU,

0x3d6f14dfU,

0x44db8678U,

0xaff381caU,

0x68c43eb9U,

0x24342c38U,

0xa3405fc2U,

0x1dc37216U,

0xe2250cbcU,

0x3c498b28U,

0x0d9541ffU,

0xa8017139U,

0x0cb3de08U,

0xb4e49cd8U,

0x56c19064U,

0xcb84617bU,

0x32b670d5U,

0x6c5c7448U,

0xb85742d0U,

0x52U,

0x09U,

0x6aU,

0xd5U,

0x30U,

0x36U,

0xa5U,

0x38U,

0xbfU,

0x40U,

0xa3U,

0x9eU,

0x81U,

0xf3U,

0xd7U,

0xfbU,

0x7cU,

0xe3U,

0x39U,

0x82U,

0x9bU,

0x2fU,

0xffU,

0x87U,

0x34U,

0x8eU,

0x43U,

0x44U,

0xc4U,

0xdeU,

0xe9U,

0xcbU,

0x54U,

0x7bU,

0x94U,

0x32U,

0xa6U,

0xc2U,

0x23U,

0x3dU,

0xeeU,

0x4cU,

0x95U,

0x0bU,

0x42U,

0xfaU,

0xc3U,

0x4eU,

0x08U,

0x2eU,

0xa1U,

0x66U,

0x28U,

0xd9U,

0x24U,

0xb2U,

0x76U,

0x5bU,

0xa2U,

0x49U,

0x6dU,

0x8bU,

0xd1U,

0x25U,

0x72U,

0xf8U,

0xf6U,

0x64U,

0x86U,

0x68U,

0x98U,

0x16U,

0xd4U,

0xa4U,

0x5cU,

0xccU,

0x5dU,

0x65U,

0xb6U,

0x92U,

0x6cU,

0x70U,

0x48U,

0x50U,

0xfdU,

0xedU,

0xb9U,

0xdaU,

0x5eU,

0x15U,

0x46U,

0x57U,

0xa7U,

0x8dU,

0x9dU,

0x84U,

0x90U,

0xd8U,

0xabU,

0x00U,

0x8cU,

0xbcU,

0xd3U,

0x0aU,

0xf7U,

0xe4U,

0x58U,

0x05U,

0xb8U,

0xb3U,

0x45U,

0x06U,

0xd0U,

0x2cU,

0x1eU,

0x8fU,

0xcaU,

0x3fU,

0x0fU,

0x02U,

0xc1U,

0xafU,

0xbdU,

0x03U,

0x01U,

0x13U,

0x8aU,

0x6bU,

0x3aU,

0x91U,

0x11U,

0x41U,

0x4fU,

0x67U,

0xdcU,

0xeaU,

0x97U,

0xf2U,

0xcfU,

0xceU,

0xf0U,

0xb4U,

0xe6U,

0x73U,

0x96U,

0xacU,

0x74U,

0x22U,

0xe7U,

0xadU,

0x35U,

0x85U,

0xe2U,

0xf9U,

0x37U,

0xe8U,

0x1cU,

0x75U,

0xdfU,

0x6eU,

0x47U,

0xf1U,

0x1aU,

0x71U,

0x1dU,

0x29U,

0xc5U,

0x89U,

0x6fU,

0xb7U,

0x62U,

0x0eU,

0xaaU,

0x18U,

0xbeU,

0x1bU,

0xfcU,

0x56U,

0x3eU,

0x4bU,

0xc6U,

0xd2U,

0x79U,

0x20U,

0x9aU,

0xdbU,

0xc0U,

0xfeU,

0x78U,

0xcdU,

0x5aU,

0xf4U,

0x1fU,

0xddU,

0xa8U,

0x33U,

0x88U,

0x07U,

0xc7U,

0x31U,

0xb1U,

0x12U,

0x10U,

0x59U,

0x27U,

0x80U,

0xecU,

0x5fU,

0x60U,

0x51U,

0x7fU,

0xa9U,

0x19U,

0xb5U,

0x4aU,

0x0dU,

0x2dU,

0xe5U,

0x7aU,

0x9fU,

0x93U,

0xc9U,

0x9cU,

0xefU,

0xa0U,

0xe0U,

0x3bU,

0x4dU,

0xaeU,

0x2aU,

0xf5U,

0xb0U,

0xc8U,

0xebU,

0xbbU,

0x3cU,

0x83U,

0x53U,

0x99U,

0x61U,

0x17U,

0x2bU,

0x04U,

0x7eU,

0xbaU,

0x77U,

0xd6U,

0x26U,

0xe1U,

0x69U,

0x14U,

0x63U,

0x55U,

0x21U,

0x0cU,

0x7dU,

0x01000000,

0x02000000,

0x04000000,

0x08000000,

0x10000000,

0x20000000,

0x40000000,

0x80000000,

0x1B000000,

0x36000000,

0xff]

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0x000000ff)

0xff]

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0x000000ff)

0xff]

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0x000000ff)

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0xff]

0x000000ff);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0xff]

0x000000ff)

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0xff]

0x000000ff)

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0xff]

0x000000ff)

0xff000000)

0xff]

0x00ff0000)

0xff]

0x0000ff00)

0xff]

0x000000ff)

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0x63U,

0x7cU,

0x77U,

0x7bU,

0xf2U,

0x6bU,

0x6fU,

0xc5U,

0x30U,

0x01U,

0x67U,

0x2bU,

0xfeU,

0xd7U,

0xabU,

0x76U,

0xcaU,

0x82U,

0xc9U,

0x7dU,

0xfaU,

0x59U,

0x47U,

0xf0U,

0xadU,

0xd4U,

0xa2U,

0xafU,

0x9cU,

0xa4U,

0x72U,

0xc0U,

0xb7U,

0xfdU,

0x93U,

0x26U,

0x36U,

0x3fU,

0xf7U,

0xccU,

0x34U,

0xa5U,

0xe5U,

0xf1U,

0x71U,

0xd8U,

0x31U,

0x15U,

0x04U,

0xc7U,

0x23U,

0xc3U,

0x18U,

0x96U,

0x05U,

0x9aU,

0x07U,

0x12U,

0x80U,

0xe2U,

0xebU,

0x27U,

0xb2U,

0x75U,

0x09U,

0x83U,

0x2cU,

0x1aU,

0x1bU,

0x6eU,

0x5aU,

0xa0U,

0x52U,

0x3bU,

0xd6U,

0xb3U,

0x29U,

0xe3U,

0x2fU,

0x84U,

0x53U,

0xd1U,

0x00U,

0xedU,

0x20U,

0xfcU,

0xb1U,

0x5bU,

0x6aU,

0xcbU,

0xbeU,

0x39U,

0x4aU,

0x4cU,

0x58U,

0xcfU,

0xd0U,

0xefU,

0xaaU,

0xfbU,

0x43U,

0x4dU,

0x33U,

0x85U,

0x45U,

0xf9U,

0x02U,

0x7fU,

0x50U,

0x3cU,

0x9fU,

0xa8U,

0x51U,

0xa3U,

0x40U,

0x8fU,

0x92U,

0x9dU,

0x38U,

0xf5U,

0xbcU,

0xb6U,

0xdaU,

0x21U,

0x10U,

0xffU,

0xf3U,

0xd2U,

0xcdU,

0x0cU,

0x13U,

0xecU,

0x5fU,

0x97U,

0x44U,

0x17U,

0xc4U,

0xa7U,

0x7eU,

0x3dU,

0x64U,

0x5dU,

0x19U,

0x73U,

0x60U,

0x81U,

0x4fU,

0xdcU,

0x22U,

0x2aU,

0x90U,

0x88U,

0x46U,

0xeeU,

0xb8U,

0x14U,

0xdeU,

0x5eU,

0x0bU,

0xdbU,

0xe0U,

0x32U,

0x3aU,

0x0aU,

0x49U,

0x06U,

0x24U,

0x5cU,

0xc2U,

0xd3U,

0xacU,

0x62U,

0x91U,

0x95U,

0xe4U,

0x79U,

0xe7U,

0xc8U,

0x37U,

0x6dU,

0x8dU,

0xd5U,

0x4eU,

0xa9U,

0x6cU,

0x56U,

0xf4U,

0xeaU,

0x65U,

0x7aU,

0xaeU,

0x08U,

0xbaU,

0x78U,

0x25U,

0x2eU,

0x1cU,

0xa6U,

0xb4U,

0xc6U,

0xe8U,

0xddU,

0x74U,

0x1fU,

0x4bU,

0xbdU,

0x8bU,

0x8aU,

0x70U,

0x3eU,

0xb5U,

0x66U,

0x48U,

0x03U,

0xf6U,

0x0eU,

0x61U,

0x35U,

0x57U,

0xb9U,

0x86U,

0xc1U,

0x1dU,

0x9eU,

0xe1U,

0xf8U,

0x98U,

0x11U,

0x69U,

0xd9U,

0x8eU,

0x94U,

0x9bU,

0x1eU,

0x87U,

0xe9U,

0xceU,

0x55U,

0x28U,

0xdfU,

0x8cU,

0xa1U,

0x89U,

0x0dU,

0xbfU,

0xe6U,

0x42U,

0x68U,

0x41U,

0x99U,

0x2dU,

0x0fU,

0xb0U,

0x54U,

0xbbU,

0x16U

0x01000000,

0x02000000,

0x04000000,

0x08000000,

0x10000000,

0x20000000,

0x40000000,

0x80000000,

0x1B000000,

0x36000000,

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

aes_locl.h


Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

XXX: probably some better way to do this

N.B. The IV for this mode is _twice_ the block size

Note that its effectively impossible to do biIGE in anything other than a single pass, so no provision is made for chaining.

N.B. The IV for this mode is _four times_ the block size

XXX: Do a separate case for when in != out (strictly should check for overlap, too)

First the forward pass

And now backwards

XXX: reduce copies by alternating between buffers

hexdump(stdout, "out ^ iv", out, AES_BLOCK_SIZE);

hexdump(stdout,"enc", out, AES_BLOCK_SIZE);

hexdump(stdout,"iv2", iv2, AES_BLOCK_SIZE);

hexdump(stdout,"out", out, AES_BLOCK_SIZE);

First backwards

And now forwards

www.openssl.org/source/license.html

License

internal/cryptlib.h

aes_locl.h

out ^ iv

enc

iv2

out


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This controls loop-unrolling in aes_core.c

!HEADER_AES_LOCL_H

www.openssl.org/source/license.html

License

0x00ff00ff

0xff00ff00)


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

aes_locl.h

aes(full)

aes(partial)


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License


Copyright 2008-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This is experimental x86[_64] derivative. It assumes little-endian byte order and expects CPU to sustain unaligned memory references. It is used as playground for cache-time attack mitigations and serves as reference C implementation for x86[_64] as well as some other assembly modules.

rijndael-alg-fst.c @version 3.0 (December 2000) Optimised ANSI C code for the Rijndael cipher (now AES) @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be> @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be> @author Paulo Barreto <paulo.barreto@terra.com.br> This code is hereby placed in the public domain. THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

These two parameters control which table, 256-byte or 2KB, is referenced in outer and respectively inner rounds.

AES_COMPACT_IN_OUTER_ROUNDS costs ~30% in performance, while adding AES_COMPACT_IN_INNER_ROUNDS reduces benchmark further by factor of ~2.

32 is common least cache-line size

Te [x] = S [x].[02, 01, 01, 03, 02, 01, 01, 03]; Te0[x] = S [x].[02, 01, 01, 03]; Te1[x] = S [x].[03, 02, 01, 01]; Te2[x] = S [x].[01, 03, 02, 01]; Te3[x] = S [x].[01, 01, 03, 02];

Td [x] = Si[x].[0e, 09, 0d, 0b, 0e, 09, 0d, 0b]; Td0[x] = Si[x].[0e, 09, 0d, 0b]; Td1[x] = Si[x].[0b, 0e, 09, 0d]; Td2[x] = Si[x].[0d, 0b, 0e, 09]; Td3[x] = Si[x].[09, 0d, 0b, 0e]; Td4[x] = Si[x].[01];

for 128-bit blocks, Rijndael never uses more than 10 rcon values

Expand the cipher key into the encryption key schedule.

Expand the cipher key into the decryption key schedule.

first, start with an encryption schedule

invert the order of the round keys:

apply the inverse MixColumn transform to all round keys but the first and the last:

Encrypt a single block in and out can overlap

map byte array block to cipher state and add initial round key:

now do the linear transform using words

Nr - 2 full rounds:

now do the linear transform using words

apply last round and map cipher state to byte array block:

Decrypt a single block in and out can overlap

map byte array block to cipher state and add initial round key:

now do the linear transform using words

Nr - 2 full rounds:

now do the linear transform using words

apply last round and map cipher state to byte array block:

www.openssl.org/source/license.html

License





aes_locl.h

roll %1,%0

=r

I

0

cc

0xa56363c6a56363c6),

0x847c7cf8847c7cf8),

0x997777ee997777ee),

0x8d7b7bf68d7b7bf6),

0x0df2f2ff0df2f2ff),

0xbd6b6bd6bd6b6bd6),

0xb16f6fdeb16f6fde),

0x54c5c59154c5c591),

0x5030306050303060),

0x0301010203010102),

0xa96767cea96767ce),

0x7d2b2b567d2b2b56),

0x19fefee719fefee7),

0x62d7d7b562d7d7b5),

0xe6abab4de6abab4d),

0x9a7676ec9a7676ec),

0x45caca8f45caca8f),

0x9d82821f9d82821f),

0x40c9c98940c9c989),

0x877d7dfa877d7dfa),

0x15fafaef15fafaef),

0xeb5959b2eb5959b2),

0xc947478ec947478e),

0x0bf0f0fb0bf0f0fb),

0xecadad41ecadad41),

0x67d4d4b367d4d4b3),

0xfda2a25ffda2a25f),

0xeaafaf45eaafaf45),

0xbf9c9c23bf9c9c23),

0xf7a4a453f7a4a453),

0x967272e4967272e4),

0x5bc0c09b5bc0c09b),

0xc2b7b775c2b7b775),

0x1cfdfde11cfdfde1),

0xae93933dae93933d),

0x6a26264c6a26264c),

0x5a36366c5a36366c),

0x413f3f7e413f3f7e),

0x02f7f7f502f7f7f5),

0x4fcccc834fcccc83),

0x5c3434685c343468),

0xf4a5a551f4a5a551),

0x34e5e5d134e5e5d1),

0x08f1f1f908f1f1f9),

0x937171e2937171e2),

0x73d8d8ab73d8d8ab),

0x5331316253313162),

0x3f15152a3f15152a),

0x0c0404080c040408),

0x52c7c79552c7c795),

0x6523234665232346),

0x5ec3c39d5ec3c39d),

0x2818183028181830),

0xa1969637a1969637),

0x0f05050a0f05050a),

0xb59a9a2fb59a9a2f),

0x0907070e0907070e),

0x3612122436121224),

0x9b80801b9b80801b),

0x3de2e2df3de2e2df),

0x26ebebcd26ebebcd),

0x6927274e6927274e),

0xcdb2b27fcdb2b27f),

0x9f7575ea9f7575ea),

0x1b0909121b090912),

0x9e83831d9e83831d),

0x742c2c58742c2c58),

0x2e1a1a342e1a1a34),

0x2d1b1b362d1b1b36),

0xb26e6edcb26e6edc),

0xee5a5ab4ee5a5ab4),

0xfba0a05bfba0a05b),

0xf65252a4f65252a4),

0x4d3b3b764d3b3b76),

0x61d6d6b761d6d6b7),

0xceb3b37dceb3b37d),

0x7b2929527b292952),

0x3ee3e3dd3ee3e3dd),

0x712f2f5e712f2f5e),

0x9784841397848413),

0xf55353a6f55353a6),

0x68d1d1b968d1d1b9),

0x0000000000000000),

0x2cededc12cededc1),

0x6020204060202040),

0x1ffcfce31ffcfce3),

0xc8b1b179c8b1b179),

0xed5b5bb6ed5b5bb6),

0xbe6a6ad4be6a6ad4),

0x46cbcb8d46cbcb8d),

0xd9bebe67d9bebe67),

0x4b3939724b393972),

0xde4a4a94de4a4a94),

0xd44c4c98d44c4c98),

0xe85858b0e85858b0),

0x4acfcf854acfcf85),

0x6bd0d0bb6bd0d0bb),

0x2aefefc52aefefc5),

0xe5aaaa4fe5aaaa4f),

0x16fbfbed16fbfbed),

0xc5434386c5434386),

0xd74d4d9ad74d4d9a),

0x5533336655333366),

0x9485851194858511),

0xcf45458acf45458a),

0x10f9f9e910f9f9e9),

0x0602020406020204),

0x817f7ffe817f7ffe),

0xf05050a0f05050a0),

0x443c3c78443c3c78),

0xba9f9f25ba9f9f25),

0xe3a8a84be3a8a84b),

0xf35151a2f35151a2),

0xfea3a35dfea3a35d),

0xc0404080c0404080),

0x8a8f8f058a8f8f05),

0xad92923fad92923f),

0xbc9d9d21bc9d9d21),

0x4838387048383870),

0x04f5f5f104f5f5f1),

0xdfbcbc63dfbcbc63),

0xc1b6b677c1b6b677),

0x75dadaaf75dadaaf),

0x6321214263212142),

0x3010102030101020),

0x1affffe51affffe5),

0x0ef3f3fd0ef3f3fd),

0x6dd2d2bf6dd2d2bf),

0x4ccdcd814ccdcd81),

0x140c0c18140c0c18),

0x3513132635131326),

0x2fececc32fececc3),

0xe15f5fbee15f5fbe),

0xa2979735a2979735),

0xcc444488cc444488),

0x3917172e3917172e),

0x57c4c49357c4c493),

0xf2a7a755f2a7a755),

0x827e7efc827e7efc),

0x473d3d7a473d3d7a),

0xac6464c8ac6464c8),

0xe75d5dbae75d5dba),

0x2b1919322b191932),

0x957373e6957373e6),

0xa06060c0a06060c0),

0x9881811998818119),

0xd14f4f9ed14f4f9e),

0x7fdcdca37fdcdca3),

0x6622224466222244),

0x7e2a2a547e2a2a54),

0xab90903bab90903b),

0x8388880b8388880b),

0xca46468cca46468c),

0x29eeeec729eeeec7),

0xd3b8b86bd3b8b86b),

0x3c1414283c141428),

0x79dedea779dedea7),

0xe25e5ebce25e5ebc),

0x1d0b0b161d0b0b16),

0x76dbdbad76dbdbad),

0x3be0e0db3be0e0db),

0x5632326456323264),

0x4e3a3a744e3a3a74),

0x1e0a0a141e0a0a14),

0xdb494992db494992),

0x0a06060c0a06060c),

0x6c2424486c242448),

0xe45c5cb8e45c5cb8),

0x5dc2c29f5dc2c29f),

0x6ed3d3bd6ed3d3bd),

0xefacac43efacac43),

0xa66262c4a66262c4),

0xa8919139a8919139),

0xa4959531a4959531),

0x37e4e4d337e4e4d3),

0x8b7979f28b7979f2),

0x32e7e7d532e7e7d5),

0x43c8c88b43c8c88b),

0x5937376e5937376e),

0xb76d6ddab76d6dda),

0x8c8d8d018c8d8d01),

0x64d5d5b164d5d5b1),

0xd24e4e9cd24e4e9c),

0xe0a9a949e0a9a949),

0xb46c6cd8b46c6cd8),

0xfa5656acfa5656ac),

0x07f4f4f307f4f4f3),

0x25eaeacf25eaeacf),

0xaf6565caaf6565ca),

0x8e7a7af48e7a7af4),

0xe9aeae47e9aeae47),

0x1808081018080810),

0xd5baba6fd5baba6f),

0x887878f0887878f0),

0x6f25254a6f25254a),

0x722e2e5c722e2e5c),

0x241c1c38241c1c38),

0xf1a6a657f1a6a657),

0xc7b4b473c7b4b473),

0x51c6c69751c6c697),

0x23e8e8cb23e8e8cb),

0x7cdddda17cdddda1),

0x9c7474e89c7474e8),

0x211f1f3e211f1f3e),

0xdd4b4b96dd4b4b96),

0xdcbdbd61dcbdbd61),

0x868b8b0d868b8b0d),

0x858a8a0f858a8a0f),

0x907070e0907070e0),

0x423e3e7c423e3e7c),

0xc4b5b571c4b5b571),

0xaa6666ccaa6666cc),

0xd8484890d8484890),

0x0503030605030306),

0x01f6f6f701f6f6f7),

0x120e0e1c120e0e1c),

0xa36161c2a36161c2),

0x5f35356a5f35356a),

0xf95757aef95757ae),

0xd0b9b969d0b9b969),

0x9186861791868617),

0x58c1c19958c1c199),

0x271d1d3a271d1d3a),

0xb99e9e27b99e9e27),

0x38e1e1d938e1e1d9),

0x13f8f8eb13f8f8eb),

0xb398982bb398982b),

0x3311112233111122),

0xbb6969d2bb6969d2),

0x70d9d9a970d9d9a9),

0x898e8e07898e8e07),

0xa7949433a7949433),

0xb69b9b2db69b9b2d),

0x221e1e3c221e1e3c),

0x9287871592878715),

0x20e9e9c920e9e9c9),

0x49cece8749cece87),

0xff5555aaff5555aa),

0x7828285078282850),

0x7adfdfa57adfdfa5),

0x8f8c8c038f8c8c03),

0xf8a1a159f8a1a159),

0x8089890980898909),

0x170d0d1a170d0d1a),

0xdabfbf65dabfbf65),

0x31e6e6d731e6e6d7),

0xc6424284c6424284),

0xb86868d0b86868d0),

0xc3414182c3414182),

0xb0999929b0999929),

0x772d2d5a772d2d5a),

0x110f0f1e110f0f1e),

0xcbb0b07bcbb0b07b),

0xfc5454a8fc5454a8),

0xd6bbbb6dd6bbbb6d),

0x3a16162c3a16162c)

0x63U,

0x7cU,

0x77U,

0x7bU,

0xf2U,

0x6bU,

0x6fU,

0xc5U,

0x30U,

0x01U,

0x67U,

0x2bU,

0xfeU,

0xd7U,

0xabU,

0x76U,

0xcaU,

0x82U,

0xc9U,

0x7dU,

0xfaU,

0x59U,

0x47U,

0xf0U,

0xadU,

0xd4U,

0xa2U,

0xafU,

0x9cU,

0xa4U,

0x72U,

0xc0U,

0xb7U,

0xfdU,

0x93U,

0x26U,

0x36U,

0x3fU,

0xf7U,

0xccU,

0x34U,

0xa5U,

0xe5U,

0xf1U,

0x71U,

0xd8U,

0x31U,

0x15U,

0x04U,

0xc7U,

0x23U,

0xc3U,

0x18U,

0x96U,

0x05U,

0x9aU,

0x07U,

0x12U,

0x80U,

0xe2U,

0xebU,

0x27U,

0xb2U,

0x75U,

0x09U,

0x83U,

0x2cU,

0x1aU,

0x1bU,

0x6eU,

0x5aU,

0xa0U,

0x52U,

0x3bU,

0xd6U,

0xb3U,

0x29U,

0xe3U,

0x2fU,

0x84U,

0x53U,

0xd1U,

0x00U,

0xedU,

0x20U,

0xfcU,

0xb1U,

0x5bU,

0x6aU,

0xcbU,

0xbeU,

0x39U,

0x4aU,

0x4cU,

0x58U,

0xcfU,

0xd0U,

0xefU,

0xaaU,

0xfbU,

0x43U,

0x4dU,

0x33U,

0x85U,

0x45U,

0xf9U,

0x02U,

0x7fU,

0x50U,

0x3cU,

0x9fU,

0xa8U,

0x51U,

0xa3U,

0x40U,

0x8fU,

0x92U,

0x9dU,

0x38U,

0xf5U,

0xbcU,

0xb6U,

0xdaU,

0x21U,

0x10U,

0xffU,

0xf3U,

0xd2U,

0xcdU,

0x0cU,

0x13U,

0xecU,

0x5fU,

0x97U,

0x44U,

0x17U,

0xc4U,

0xa7U,

0x7eU,

0x3dU,

0x64U,

0x5dU,

0x19U,

0x73U,

0x60U,

0x81U,

0x4fU,

0xdcU,

0x22U,

0x2aU,

0x90U,

0x88U,

0x46U,

0xeeU,

0xb8U,

0x14U,

0xdeU,

0x5eU,

0x0bU,

0xdbU,

0xe0U,

0x32U,

0x3aU,

0x0aU,

0x49U,

0x06U,

0x24U,

0x5cU,

0xc2U,

0xd3U,

0xacU,

0x62U,

0x91U,

0x95U,

0xe4U,

0x79U,

0xe7U,

0xc8U,

0x37U,

0x6dU,

0x8dU,

0xd5U,

0x4eU,

0xa9U,

0x6cU,

0x56U,

0xf4U,

0xeaU,

0x65U,

0x7aU,

0xaeU,

0x08U,

0xbaU,

0x78U,

0x25U,

0x2eU,

0x1cU,

0xa6U,

0xb4U,

0xc6U,

0xe8U,

0xddU,

0x74U,

0x1fU,

0x4bU,

0xbdU,

0x8bU,

0x8aU,

0x70U,

0x3eU,

0xb5U,

0x66U,

0x48U,

0x03U,

0xf6U,

0x0eU,

0x61U,

0x35U,

0x57U,

0xb9U,

0x86U,

0xc1U,

0x1dU,

0x9eU,

0xe1U,

0xf8U,

0x98U,

0x11U,

0x69U,

0xd9U,

0x8eU,

0x94U,

0x9bU,

0x1eU,

0x87U,

0xe9U,

0xceU,

0x55U,

0x28U,

0xdfU,

0x8cU,

0xa1U,

0x89U,

0x0dU,

0xbfU,

0xe6U,

0x42U,

0x68U,

0x41U,

0x99U,

0x2dU,

0x0fU,

0xb0U,

0x54U,

0xbbU,

0x16U

0x50a7f45150a7f451),

0x5365417e5365417e),

0xc3a4171ac3a4171a),

0x965e273a965e273a),

0xcb6bab3bcb6bab3b),

0xf1459d1ff1459d1f),

0xab58faacab58faac),

0x9303e34b9303e34b),

0x55fa302055fa3020),

0xf66d76adf66d76ad),

0x9176cc889176cc88),

0x254c02f5254c02f5),

0xfcd7e54ffcd7e54f),

0xd7cb2ac5d7cb2ac5),

0x8044352680443526),

0x8fa362b58fa362b5),

0x495ab1de495ab1de),

0x671bba25671bba25),

0x980eea45980eea45),

0xe1c0fe5de1c0fe5d),

0x02752fc302752fc3),

0x12f04c8112f04c81),

0xa397468da397468d),

0xc6f9d36bc6f9d36b),

0xe75f8f03e75f8f03),

0x959c9215959c9215),

0xeb7a6dbfeb7a6dbf),

0xda595295da595295),

0x2d83bed42d83bed4),

0xd3217458d3217458),

0x2969e0492969e049),

0x44c8c98e44c8c98e),

0x6a89c2756a89c275),

0x78798ef478798ef4),

0x6b3e58996b3e5899),

0xdd71b927dd71b927),

0xb64fe1beb64fe1be),

0x17ad88f017ad88f0),

0x66ac20c966ac20c9),

0xb43ace7db43ace7d),

0x184adf63184adf63),

0x82311ae582311ae5),

0x6033519760335197),

0x457f5362457f5362),

0xe07764b1e07764b1),

0x84ae6bbb84ae6bbb),

0x1ca081fe1ca081fe),

0x942b08f9942b08f9),

0x5868487058684870),

0x19fd458f19fd458f),

0x876cde94876cde94),

0xb7f87b52b7f87b52),

0x23d373ab23d373ab),

0xe2024b72e2024b72),

0x578f1fe3578f1fe3),

0x2aab55662aab5566),

0x0728ebb20728ebb2),

0x03c2b52f03c2b52f),

0x9a7bc5869a7bc586),

0xa50837d3a50837d3),

0xf2872830f2872830),

0xb2a5bf23b2a5bf23),

0xba6a0302ba6a0302),

0x5c8216ed5c8216ed),

0x2b1ccf8a2b1ccf8a),

0x92b479a792b479a7),

0xf0f207f3f0f207f3),

0xa1e2694ea1e2694e),

0xcdf4da65cdf4da65),

0xd5be0506d5be0506),

0x1f6234d11f6234d1),

0x8afea6c48afea6c4),

0x9d532e349d532e34),

0xa055f3a2a055f3a2),

0x32e18a0532e18a05),

0x75ebf6a475ebf6a4),

0x39ec830b39ec830b),

0xaaef6040aaef6040),

0x069f715e069f715e),

0x51106ebd51106ebd),

0xf98a213ef98a213e),

0x3d06dd963d06dd96),

0xae053eddae053edd),

0x46bde64d46bde64d),

0xb58d5491b58d5491),

0x055dc471055dc471),

0x6fd406046fd40604),

0xff155060ff155060),

0x24fb981924fb9819),

0x97e9bdd697e9bdd6),

0xcc434089cc434089),

0x779ed967779ed967),

0xbd42e8b0bd42e8b0),

0x888b8907888b8907),

0x385b19e7385b19e7),

0xdbeec879dbeec879),

0x470a7ca1470a7ca1),

0xe90f427ce90f427c),

0xc91e84f8c91e84f8),

0x0000000000000000),

0x8386800983868009),

0x48ed2b3248ed2b32),

0xac70111eac70111e),

0x4e725a6c4e725a6c),

0xfbff0efdfbff0efd),

0x5638850f5638850f),

0x1ed5ae3d1ed5ae3d),

0x27392d3627392d36),

0x64d90f0a64d90f0a),

0x21a65c6821a65c68),

0xd1545b9bd1545b9b),

0x3a2e36243a2e3624),

0xb1670a0cb1670a0c),

0x0fe757930fe75793),

0xd296eeb4d296eeb4),

0x9e919b1b9e919b1b),

0x4fc5c0804fc5c080),

0xa220dc61a220dc61),

0x694b775a694b775a),

0x161a121c161a121c),

0x0aba93e20aba93e2),

0xe52aa0c0e52aa0c0),

0x43e0223c43e0223c),

0x1d171b121d171b12),

0x0b0d090e0b0d090e),

0xadc78bf2adc78bf2),

0xb9a8b62db9a8b62d),

0xc8a91e14c8a91e14),

0x8519f1578519f157),

0x4c0775af4c0775af),

0xbbdd99eebbdd99ee),

0xfd607fa3fd607fa3),

0x9f2601f79f2601f7),

0xbcf5725cbcf5725c),

0xc53b6644c53b6644),

0x347efb5b347efb5b),

0x7629438b7629438b),

0xdcc623cbdcc623cb),

0x68fcedb668fcedb6),

0x63f1e4b863f1e4b8),

0xcadc31d7cadc31d7),

0x1085634210856342),

0x4022971340229713),

0x2011c6842011c684),

0x7d244a857d244a85),

0xf83dbbd2f83dbbd2),

0x1132f9ae1132f9ae),

0x6da129c76da129c7),

0x4b2f9e1d4b2f9e1d),

0xf330b2dcf330b2dc),

0xec52860dec52860d),

0xd0e3c177d0e3c177),

0x6c16b32b6c16b32b),

0x99b970a999b970a9),

0xfa489411fa489411),

0x2264e9472264e947),

0xc48cfca8c48cfca8),

0x1a3ff0a01a3ff0a0),

0xd82c7d56d82c7d56),

0xef903322ef903322),

0xc74e4987c74e4987),

0xc1d138d9c1d138d9),

0xfea2ca8cfea2ca8c),

0x360bd498360bd498),

0xcf81f5a6cf81f5a6),

0x28de7aa528de7aa5),

0x268eb7da268eb7da),

0xa4bfad3fa4bfad3f),

0xe49d3a2ce49d3a2c),

0x0d9278500d927850),

0x9bcc5f6a9bcc5f6a),

0x62467e5462467e54),

0xc2138df6c2138df6),

0xe8b8d890e8b8d890),

0x5ef7392e5ef7392e),

0xf5afc382f5afc382),

0xbe805d9fbe805d9f),

0x7c93d0697c93d069),

0xa92dd56fa92dd56f),

0xb31225cfb31225cf),

0x3b99acc83b99acc8),

0xa77d1810a77d1810),

0x6e639ce86e639ce8),

0x7bbb3bdb7bbb3bdb),

0x097826cd097826cd),

0xf418596ef418596e),

0x01b79aec01b79aec),

0xa89a4f83a89a4f83),

0x656e95e6656e95e6),

0x7ee6ffaa7ee6ffaa),

0x08cfbc2108cfbc21),

0xe6e815efe6e815ef),

0xd99be7bad99be7ba),

0xce366f4ace366f4a),

0xd4099fead4099fea),

0xd67cb029d67cb029),

0xafb2a431afb2a431),

0x31233f2a31233f2a),

0x3094a5c63094a5c6),

0xc066a235c066a235),

0x37bc4e7437bc4e74),

0xa6ca82fca6ca82fc),

0xb0d090e0b0d090e0),

0x15d8a73315d8a733),

0x4a9804f14a9804f1),

0xf7daec41f7daec41),

0x0e50cd7f0e50cd7f),

0x2ff691172ff69117),

0x8dd64d768dd64d76),

0x4db0ef434db0ef43),

0x544daacc544daacc),

0xdf0496e4df0496e4),

0xe3b5d19ee3b5d19e),

0x1b886a4c1b886a4c),

0xb81f2cc1b81f2cc1),

0x7f5165467f516546),

0x04ea5e9d04ea5e9d),

0x5d358c015d358c01),

0x737487fa737487fa),

0x2e410bfb2e410bfb),

0x5a1d67b35a1d67b3),

0x52d2db9252d2db92),

0x335610e9335610e9),

0x1347d66d1347d66d),

0x8c61d79a8c61d79a),

0x7a0ca1377a0ca137),

0x8e14f8598e14f859),

0x893c13eb893c13eb),

0xee27a9ceee27a9ce),

0x35c961b735c961b7),

0xede51ce1ede51ce1),

0x3cb1477a3cb1477a),

0x59dfd29c59dfd29c),

0x3f73f2553f73f255),

0x79ce141879ce1418),

0xbf37c773bf37c773),

0xeacdf753eacdf753),

0x5baafd5f5baafd5f),

0x146f3ddf146f3ddf),

0x86db447886db4478),

0x81f3afca81f3afca),

0x3ec468b93ec468b9),

0x2c3424382c342438),

0x5f40a3c25f40a3c2),

0x72c31d1672c31d16),

0x0c25e2bc0c25e2bc),

0x8b493c288b493c28),

0x41950dff41950dff),

0x7101a8397101a839),

0xdeb30c08deb30c08),

0x9ce4b4d89ce4b4d8),

0x90c1566490c15664),

0x6184cb7b6184cb7b),

0x70b632d570b632d5),

0x745c6c48745c6c48),

0x4257b8d04257b8d0)

0x52U,

0x09U,

0x6aU,

0xd5U,

0x30U,

0x36U,

0xa5U,

0x38U,

0xbfU,

0x40U,

0xa3U,

0x9eU,

0x81U,

0xf3U,

0xd7U,

0xfbU,

0x7cU,

0xe3U,

0x39U,

0x82U,

0x9bU,

0x2fU,

0xffU,

0x87U,

0x34U,

0x8eU,

0x43U,

0x44U,

0xc4U,

0xdeU,

0xe9U,

0xcbU,

0x54U,

0x7bU,

0x94U,

0x32U,

0xa6U,

0xc2U,

0x23U,

0x3dU,

0xeeU,

0x4cU,

0x95U,

0x0bU,

0x42U,

0xfaU,

0xc3U,

0x4eU,

0x08U,

0x2eU,

0xa1U,

0x66U,

0x28U,

0xd9U,

0x24U,

0xb2U,

0x76U,

0x5bU,

0xa2U,

0x49U,

0x6dU,

0x8bU,

0xd1U,

0x25U,

0x72U,

0xf8U,

0xf6U,

0x64U,

0x86U,

0x68U,

0x98U,

0x16U,

0xd4U,

0xa4U,

0x5cU,

0xccU,

0x5dU,

0x65U,

0xb6U,

0x92U,

0x6cU,

0x70U,

0x48U,

0x50U,

0xfdU,

0xedU,

0xb9U,

0xdaU,

0x5eU,

0x15U,

0x46U,

0x57U,

0xa7U,

0x8dU,

0x9dU,

0x84U,

0x90U,

0xd8U,

0xabU,

0x00U,

0x8cU,

0xbcU,

0xd3U,

0x0aU,

0xf7U,

0xe4U,

0x58U,

0x05U,

0xb8U,

0xb3U,

0x45U,

0x06U,

0xd0U,

0x2cU,

0x1eU,

0x8fU,

0xcaU,

0x3fU,

0x0fU,

0x02U,

0xc1U,

0xafU,

0xbdU,

0x03U,

0x01U,

0x13U,

0x8aU,

0x6bU,

0x3aU,

0x91U,

0x11U,

0x41U,

0x4fU,

0x67U,

0xdcU,

0xeaU,

0x97U,

0xf2U,

0xcfU,

0xceU,

0xf0U,

0xb4U,

0xe6U,

0x73U,

0x96U,

0xacU,

0x74U,

0x22U,

0xe7U,

0xadU,

0x35U,

0x85U,

0xe2U,

0xf9U,

0x37U,

0xe8U,

0x1cU,

0x75U,

0xdfU,

0x6eU,

0x47U,

0xf1U,

0x1aU,

0x71U,

0x1dU,

0x29U,

0xc5U,

0x89U,

0x6fU,

0xb7U,

0x62U,

0x0eU,

0xaaU,

0x18U,

0xbeU,

0x1bU,

0xfcU,

0x56U,

0x3eU,

0x4bU,

0xc6U,

0xd2U,

0x79U,

0x20U,

0x9aU,

0xdbU,

0xc0U,

0xfeU,

0x78U,

0xcdU,

0x5aU,

0xf4U,

0x1fU,

0xddU,

0xa8U,

0x33U,

0x88U,

0x07U,

0xc7U,

0x31U,

0xb1U,

0x12U,

0x10U,

0x59U,

0x27U,

0x80U,

0xecU,

0x5fU,

0x60U,

0x51U,

0x7fU,

0xa9U,

0x19U,

0xb5U,

0x4aU,

0x0dU,

0x2dU,

0xe5U,

0x7aU,

0x9fU,

0x93U,

0xc9U,

0x9cU,

0xefU,

0xa0U,

0xe0U,

0x3bU,

0x4dU,

0xaeU,

0x2aU,

0xf5U,

0xb0U,

0xc8U,

0xebU,

0xbbU,

0x3cU,

0x83U,

0x53U,

0x99U,

0x61U,

0x17U,

0x2bU,

0x04U,

0x7eU,

0xbaU,

0x77U,

0xd6U,

0x26U,

0xe1U,

0x69U,

0x14U,

0x63U,

0x55U,

0x21U,

0x0cU,

0x7dU

0x00000001U,

0x00000002U,

0x00000004U,

0x00000008U,

0x00000010U,

0x00000020U,

0x00000040U,

0x00000080U,

0x0000001bU,

0x00000036U,

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff];

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x000000ffU)

0xff]

0x0000ff00U)

0xff]

0x00ff0000U)

0xff000000U)

0xff]

0x000000ffU)

0xff]

0x0000ff00U)

0xff]

0x00ff0000U)

0xff000000U)

0xff]

0x000000ffU)

0xff]

0x0000ff00U)

0xff]

0x00ff0000U)

0xff000000U)

0xff]

0x000000ffU)

0xff]

0x0000ff00U)

0xff]

0x00ff0000U)

0xff000000U)

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0x80808080;

0x7f7f7f7f)

0x1b1b1b1b);

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0xff]

0xff]

0xff])

0xff]

0xff]


Copyright 2013-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Simple AES CCM test program, uses the same NIST data used for the FIPS self test but uses the application level EVP APIs.

AES-CCM test data from NIST public test vectors

Set cipher type and mode

Set nonce length if default 96 bits is not appropriate

Set tag length

Initialise key and IV

Set plaintext length: only needed if AAD is used

Zero or one call to specify any AAD

Encrypt plaintext: can only be called once

Output encrypted block

Finalise: note get no output for CCM

Get tag

Output tag

Select cipher

Set nonce length, omit for 96 bits

Set expected tag value

Specify key and IV

Set ciphertext length: only needed if we have AAD

Zero or one call to specify any AAD

Decrypt plaintext, verify tag: can only be called once

Output decrypted block: if tag verify failed we get nothing

www.openssl.org/source/license.html

License

AES CCM Encrypt:\n

Plaintext:\n

Ciphertext:\n

Tag:\n

AES CCM Derypt:\n

Ciphertext:\n

Plaintext:\n

Plaintext not available: tag verify failed.\n

0xce,

0xb0,

0x09,

0xae,

0xa4,

0x45,

0x44,

0x51,

0xfe,

0xad,

0xf0,

0xe6,

0xb3,

0x6f,

0x45,

0x55,

0x5d,

0xd0,

0x47,

0x23,

0xba,

0xa4,

0x48,

0xe8

0x76,

0x40,

0x43,

0xc4,

0x94,

0x60,

0xb7

0x6e,

0x80,

0xdd,

0x7f,

0x1b,

0xad,

0xf3,

0xa1,

0xc9,

0xab,

0x25,

0xc7,

0x5f,

0x10,

0xbd,

0xe7,

0x8c,

0x23,

0xfa,

0x0e,

0xb8,

0xf9,

0xaa,

0xa5,

0x3a,

0xde,

0xfb,

0xf4,

0xcb,

0xf7,

0x8f,

0xe4

0xc8,

0xd2,

0x75,

0xf9,

0x19,

0xe1,

0x7d,

0x7f,

0xe6,

0x9c,

0x2a,

0x1f,

0x58,

0x93,

0x9d,

0xfe,

0x4d,

0x40,

0x37,

0x91,

0xb5,

0xdf,

0x13,

0x10

0x8a,

0x0f,

0x3d,

0x82,

0x29,

0xe4,

0x8e,

0x74,

0x87,

0xfd,

0x95,

0xa2,

0x8a,

0xd3,

0x92,

0xc8,

0x0b,

0x36,

0x81,

0xd4,

0xfb,

0xc7,

0xbb,

0xfd

0x2d,

0xd6,

0xef,

0x1c,

0x45,

0xd4,

0xcc,

0xb7,

0x23,

0xdc,

0x07,

0x44,

0x14,

0xdb,

0x50,

0x6d


Copyright 2012-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Simple AES GCM test program, uses the same NIST data used for the FIPS self test but uses the application level EVP APIs.

AES-GCM test data from NIST public test vectors

Set cipher type and mode

Set IV length if default 96 bits is not appropriate

Initialise key and IV

Zero or more calls to specify any AAD

Encrypt plaintext

Output encrypted block

Finalise: note get no output for GCM

Get tag

Output tag

Select cipher

Set IV length, omit for 96 bits

Specify key and IV

Zero or more calls to specify any AAD

Decrypt plaintext

Output decrypted block

Set expected tag value.

Finalise: note get no output for GCM

Print out return value. If this is not successful authentication failed and plaintext is not trustworthy.

www.openssl.org/source/license.html

License

AES GCM Encrypt:\n

Plaintext:\n

Ciphertext:\n

Tag:\n

AES GCM Derypt:\n

Ciphertext:\n

Plaintext:\n

Tag Verify %s\n

Successful!

Failed!

0xee,

0xbc,

0x1f,

0x57,

0x48,

0x7f,

0x51,

0x92,

0x1c,

0x04,

0x65,

0x66,

0x5f,

0x8a,

0xe6,

0xd1,

0x65,

0x8b,

0xb2,

0x6d,

0xe6,

0xf8,

0xa0,

0x69,

0xa3,

0x52,

0x02,

0x93,

0xa5,

0x72,

0x07,

0x8f

0x99,

0xaa,

0x3e,

0x68,

0xed,

0x81,

0x73,

0xa0,

0xee,

0xd0,

0x66,

0x84

0xf5,

0x6e,

0x87,

0x05,

0x5b,

0xc3,

0x2d,

0x0e,

0xeb,

0x31,

0xb2,

0xea,

0xcc,

0x2b,

0xf2,

0xa5

0x4d,

0x23,

0xc3,

0xce,

0xc3,

0x34,

0xb4,

0x9b,

0xdb,

0x37,

0x0c,

0x43,

0x7f,

0xec,

0x78,

0xde

0xf7,

0x26,

0x44,

0x13,

0xa8,

0x4c,

0x0e,

0x7c,

0xd5,

0x36,

0x86,

0x7e,

0xb9,

0xf2,

0x17,

0x36

0x67,

0xba,

0x05,

0x10,

0x26,

0x2a,

0xe4,

0x87,

0xd7,

0x37,

0xee,

0x62,

0x98,

0xf7,

0x7e,

0x0c


Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Use a buffer size which is not aligned to block size

If we get here then it looks like there is a mismatch between the linux headers and the actual kernel version, so we have tried to compile with afalg support, but then skipped it in e_afalg.c. As far as this test is concerned we behave as if we had been configured without support

Probably a platform env issue, not a test failure.

www.openssl.org/source/license.html

License

testutil.h

\x5F\x4D\xCC\x3B\x5A\xA7\x65\xD6\ \x1D\x83\x27\xDE\xB8\x82\xCF\x99

\x2B\x95\x99\x0A\x91\x51\x37\x4A\ \xBD\x8F\xF8\xC5\xA7\xA0\xFE\x08

afalg

Can't load AFALG engine


Copyright 2006-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

for strncasecmp

Find an implementation of an ASN1 algorithm. If 'pe' is not NULL also search through engines and set pe to a functional reference to the engine implementing 'type' or NULL if no engine implements it.

type will contain the final unaliased type

Convert structural into functional reference

www.openssl.org/source/license.html

License

e_os.h

internal/cryptlib.h

internal/asn1_int.h

internal/evp_int.h

standard_methods.h

pe

type


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

See comments in opt_verify for explanation of this.

www.openssl.org/source/license.html

License

apps.h

RANDFILE

Can't load %s into RNG\n

\0

\0

\0

Can't load %s into RNG\n

\0

Cannot write random bytes:\n


Copyright 2004-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

should not be used

solely for completeness

to be used with below

formally can't be used, as flags can vary

always same as last macro

__stdcall appears to be the only way to get the name decoration right with Borland C. Otherwise it works purely incidentally, as we pass no parameters.

www.openssl.org/source/license.html

License

t be used, as flags can vary */ #define APPLINK_READ 19 #define APPLINK_WRITE 20 #define APPLINK_LSEEK 21 #define APPLINK_CLOSE 22 #define APPLINK_MAX 22 /* always same as last macro */ #ifndef APPMACROS_ONLY # include <stdio.h> # include <io.h> # include <fcntl.h> static void *app_stdin(void) { return stdin; } static void *app_stdout(void) { return stdout; } static void *app_stderr(void) { return stderr; } static int app_feof(FILE *fp) { return feof(fp); } static int app_ferror(FILE *fp) { return ferror(fp); } static void app_clearerr(FILE *fp) { clearerr(fp); } static int app_fileno(FILE *fp) { return _fileno(fp); } static int app_fsetmod(FILE *fp, char mod) { return _setmode(_fileno(fp), mod ==

C


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

On VMS, you need to define this to get the declaration of fileno(). The value 2 is to make sure no function defined in POSIX-2 is left undefined.

Skip whitespace.

The start of something good :-)

now look for the end of this

We know that there is no previous user data to return to us

Under _WIN32, which covers even Win64 and CE, file descriptors referenced by BIO_s_fd are not inherited by child process and therefore below is not an option. It could have been an option if bss_fd.c was operating on real Windows descriptors, such as those obtained with CreateFile.

Can't do BIO_gets on an fd BIO so add a buffering BIO

See if an empty password will do

Initialize or extend, if certs != NULL, a certificate stack.

Initialize or extend, if crls != NULL, a certificate stack.

Return error for unknown extensions

Print error for unknown extensions

ASN1 parse unknown extensions

BIO_dump unknown extensions

Does extension exist?

If normal copy don't override existing extension

Delete all extensions of same type

Try to load an engine in a shareable library

Free our "structural" reference.

false

FALSE

no

NO

0

true

TRUE

yes

YES

1

name is expected to be in the format /type0=value0/type1=value1/type2=... where characters may be escaped by \

Collect the type

Collect the value.

If not at EOS (must be + or /), move forward.

Parse

Read whole contents of a BIO into an allocated memory buffer and return it.

next_protos_parse parses a comma separated list of strings into a string in a format suitable for passing to SSL_CTX_set_next_protos_advertised. outlen: (output) set to the length of the resulting buffer on success. err: (maybe NULL) on failure, an error message line is written to this BIO. in: a NUL terminated string like "abc,def,ghi" returns: a malloc'd buffer or NULL on failure.

Get first http URL from a DIST_POINT structure

Look through a CRLDP structure and attempt to find an http URL to downloads a CRL from.

Example of downloading CRLs from CRLDP: not usable for real world as it always downloads, doesn't support non-blocking I/O and doesn't cache anything.

Try to download delta CRL

Platform-specific sections

UNICODE path

we could map more codes...

app_tminterval section

sum of user and kernel times

by means of unistd.h

app_isdir section

raw_read|write section

Centralized handling if input and output files with format specification The format is meant to show what the input and output is supposed to be, and is therefore a show of intent more than anything else. However, it does impact behavior on some platform, such as differentiating between text and binary input/output on non-Unix platforms

On VMS, setbuf() will only take 32-bit pointers, and a compilation with /POINTER_SIZE=64 will give off a MAYLOSEDATA2 warning here. However, we trust that the C RTL will never give us a FILE pointer above the first 4 GB of memory, so we simply turn off the warning temporarily.

The assert above should make sure we never reach this point

Open a file for writing, owner-read-only.

VMS doesn't have O_BINARY, it just doesn't make sense. But, it still needs to know that we're going binary, or fdopen() will fail with "invalid argument"... so we tell VMS what the context is.

If we have fp, then fdopen took over fd, so don't close both.

On Windows select only works for sockets, so we simply don't wait

if OPENSSL_SYS_WINDOWS is defined then so is OPENSSL_SYS_MSDOS

Probably redirected input? _kbhit() does not work in this case

Corrupt a signature by modifying final byte

www.openssl.org/source/license.html

", 7) == 0)

License

s_apps.h

apps.h

\0

argv space

\'

"

\0

\0

subject=

\n

issuer=

\n

\0

\0

OpenSSL application user interface

pass phrase

Out of memory\n

password buffer

User interface error\n

aborted!\n

pass:

env:

Can't read environment variable %s\n

file:

r

Can't open file %s\n

fd:

Can't access file descriptor %s\n

t do BIO_gets on an fd BIO so add a buffering BIO */ btmp = BIO_new(BIO_f_buffer()); pwdbio = BIO_push(btmp, pwdbio); #endif } else if (strcmp(arg, "stdin") == 0) { pwdbio = dup_bio_in(FORMAT_TEXT); if (!pwdbio) { BIO_printf(bio_err, "Can

); return NULL; } } else { BIO_printf(bio_err,

%s\"\n

Error reading password from BIO\n

\n

%s: Can't load config file \"%s\"\n

%s: Error on line %ld of config file \"%s\"\n

r

r

Error configuring OpenSSL modules\n

oid_section

problem loading oid section %s\n

problem creating object %s=%s\n

Error loading PKCS12 file for %s\n





Passphrase callback error for %s\n

Mac verify error (wrong password?) in PKCS12 file for %s\n

https not supported\n

GET

Host

Error loading %s from %s\n

certificate

CRL

r

bad input format specified for %s\n

unable to load certificate\n

r

bad input format specified for input crl\n

unable to load CRL\n

no keyfile specified\n

no engine specified\n

cannot load %s from engine\n

engines not supported\n

r

bad input format specified for key file\n

unable to load %s\n

no keyfile specified\n

no engine specified\n

cannot load %s from engine\n

engines not supported\n

r

RSA keys not supported\n

RSA keys not supported\n

unable to load %s\n

bad input format specified for %s\n

r

unable to load %s\n

certificates

CRLs

%s: Could not allocate %d bytes for %s\n

compatible

ca_default

no_header

no_version

no_serial

no_signame

no_validity

no_subject

no_issuer

no_pubkey

no_extensions

no_sigdump

no_aux

no_attributes

ext_default

ext_error

ext_parse

ext_dump

esc_2253

esc_2254

esc_ctrl

esc_msb

use_quote

utf8

ignore_type

show_type

dump_all

dump_nostr

dump_der

compat

sep_comma_plus

sep_comma_plus_space

sep_semi_plus_space

sep_multiline

dn_rev

nofname

sname

lname

align

oid

space_eq

dump_unknown

RFC2253

oneline

multiline

ca_default

none

copy

copyall

t override existing extension */ if (copy_type == EXT_COPY_ADD) continue; /* Delete all extensions of same type */ do { tmpext = X509_get_ext(x, idx); X509_delete_ext(x, idx); X509_EXTENSION_free(tmpext); idx = X509_get_ext_by_OBJ(x, obj, -1); } while (idx != -1); } if (!X509_add_ext(x, ext, -1)) goto end; } ret = 1; end: sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free); return ret; } static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl) { STACK_OF(CONF_VALUE) *vals; CONF_VALUE *val; int i, ret = 1; if (!arg) return 0; vals = X509V3_parse_list(arg); for (i = 0; i < sk_CONF_VALUE_num(vals); i++) { val = sk_CONF_VALUE_value(vals, i); if (!set_table_opts(flags, val->name, in_tbl)) ret = 0; } sk_CONF_VALUE_pop_free(vals, X509V3_conf_free); return ret; } static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl) { char c; const NAME_EX_TBL *ptbl; c = arg[0]; if (c ==

) { c = 0; arg++; } else if (c ==

) { c = 1; arg++; } else { c = 1; } for (ptbl = in_tbl; ptbl->name; ptbl++) { if (strcasecmp(arg, ptbl->name) == 0) { *flags &= ~ptbl->mask; if (c) *flags |= ptbl->flag; else *flags &= ~ptbl->flag; return 1; } } return 0; } void print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags) { char *buf; char mline = 0; int indent = 0; if (title) BIO_puts(out, title); if ((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) { mline = 1; indent = 4; } if (lflags == XN_FLAG_COMPAT) { buf = X509_NAME_oneline(nm, 0, 0); BIO_puts(out, buf); BIO_puts(out, "\n"); OPENSSL_free(buf); } else { if (mline) BIO_puts(out, "\n"); X509_NAME_print_ex(out, nm, indent, lflags); BIO_puts(out, "\n"); } } void print_bignum_var(BIO *out, const BIGNUM *in, const char *var, int len, unsigned char *buffer) { BIO_printf(out, " static unsigned char %s_%d[] = {", var, len); if (BN_is_zero(in)) { BIO_printf(out, "\n\t0x00"); } else { int i, l; l = BN_bn2bin(in, buffer); for (i = 0; i < l; i++) { if ((i % 10) == 0) BIO_printf(out, "\n\t"); if (i < l - 1) BIO_printf(out, "0x%02X, ", buffer[i]); else BIO_printf(out, "0x%02X", buffer[i]); } } BIO_printf(out, "\n };\n"); } void print_array(BIO *out, const char* title, int len, const unsigned char* d) { int i; BIO_printf(out, "unsigned char %s[%d] = {", title, len); for (i = 0; i < len; i++) { if ((i % 10) == 0) BIO_printf(out, "\n "); if (i < len - 1) BIO_printf(out, "0x%02X, ", d[i]); else BIO_printf(out, "0x%02X", d[i]); } BIO_printf(out, "\n};\n"); } X509_STORE *setup_verify(const char *CAfile, const char *CApath, int noCAfile, int noCApath) { X509_STORE *store = X509_STORE_new(); X509_LOOKUP *lookup; if (store == NULL) goto end; if (CAfile != NULL || !noCAfile) { lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file()); if (lookup == NULL) goto end; if (CAfile) { if (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM)) { BIO_printf(bio_err, "Error loading file %s\n", CAfile); goto end; } } else { X509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT); } } if (CApath != NULL || !noCApath) { lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir()); if (lookup == NULL) goto end; if (CApath) { if (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM)) { BIO_printf(bio_err, "Error loading directory %s\n", CApath); goto end; } } else { X509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT); } } ERR_clear_error(); return store; end: X509_STORE_free(store); return NULL; } #ifndef OPENSSL_NO_ENGINE /* Try to load an engine in a shareable library */ static ENGINE *try_load_engine(const char *engine) { ENGINE *e = ENGINE_by_id("dynamic"); if (e) { if (!ENGINE_ctrl_cmd_string(e, "SO_PATH", engine, 0) || !ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0)) { ENGINE_free(e); e = NULL; } } return e; } #endif ENGINE *setup_engine(const char *engine, int debug) { ENGINE *e = NULL; #ifndef OPENSSL_NO_ENGINE if (engine != NULL) { if (strcmp(engine, "auto") == 0) { BIO_printf(bio_err, "enabling auto ENGINE support\n"); ENGINE_register_all_complete(); return NULL; } if ((e = ENGINE_by_id(engine)) == NULL && (e = try_load_engine(engine)) == NULL) { BIO_printf(bio_err, "invalid engine \"%s\"\n", engine); ERR_print_errors(bio_err); return NULL; } if (debug) { ENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM, 0, bio_err, 0); } ENGINE_ctrl_cmd(e, "SET_USER_INTERFACE", 0, ui_method, 0, 1); if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) { BIO_printf(bio_err, "can

); ERR_print_errors(bio_err); ENGINE_free(e); return NULL; } BIO_printf(bio_err,

%s\" set.\n

structural

0

0

0

V

r

Out of memory\n

unable to load number from %s\n

error converting number from bin to BIGNUM\n

file name too long\n

%s.%s

%s-%s

w

error converting serial to ASN.1 format\n

\n

file name too long\n

%s.%s

%s.%s

%s-%s

%s-%s

unable to rename %s to %s\n

reason

unable to rename %s to %s\n

reason

r

%s.attr

%s-attr

new DB

unique_subject

error creating serial number index:(%ld,%ld,%ld)\n

error creating name index:(%ld,%ld,%ld)\n

file name too long\n

%s.attr

%s.attr.%s

%s.%s

%s-attr

%s-attr-%s

%s-%s

w

unable to open '%s'\n

w

unable to open '%s'\n

unique_subject = %s\n

yes

no

file name too long\n

%s.attr

%s.attr.%s

%s.attr.%s

%s.%s

%s.%s

%s-attr

%s-attr-%s

%s-attr-%s

%s-%s

%s-%s

unable to rename %s to %s\n

reason

unable to rename %s to %s\n

reason

unable to rename %s to %s\n

reason

unable to rename %s to %s\n

reason

f

F

n

N

0

t

T

y

Y

1

/

=

\0

%s: Hit end of string before finding the equals.\n

\0

/

+

\\

\0

%s: escape character at end of string\n

\0

%s: Skipping unknown attribute \"%s\"\n

:

%s Policies:

\n

<empty>\n

Require explicit Policy: %s\n

True

False

Authority

User

abc,def,ghi

d buffer or NULL on failure. */ unsigned char *next_protos_parse(size_t *outlen, const char *in) { size_t len; unsigned char *out; size_t i, start = 0; len = strlen(in); if (len >= 65535) return NULL; out = app_malloc(strlen(in) + 1, "NPN buffer"); for (i = 0; i <= len; ++i) { if (i == len || in[i] ==

) { if (i - start > 255) { OPENSSL_free(out); return NULL; } out[start] = i - start; start = i + 1; } else { out[i + 1] = in[i]; } } *outlen = len + 1; return out; } void print_cert_checks(BIO *bio, X509 *x, const char *checkhost, const char *checkemail, const char *checkip) { if (x == NULL) return; if (checkhost) { BIO_printf(bio, "Hostname %s does%s match certificate\n", checkhost, X509_check_host(x, checkhost, 0, 0, NULL) == 1 ? "" : " NOT"); } if (checkemail) { BIO_printf(bio, "Email %s does%s match certificate\n", checkemail, X509_check_email(x, checkemail, 0, 0) ? "" : " NOT"); } if (checkip) { BIO_printf(bio, "IP %s does%s match certificate\n", checkip, X509_check_ip_asc(x, checkip, 0) ? "" : " NOT"); } } /* Get first http URL from a DIST_POINT structure */ static const char *get_dp_url(DIST_POINT *dp) { GENERAL_NAMES *gens; GENERAL_NAME *gen; int i, gtype; ASN1_STRING *uri; if (!dp->distpoint || dp->distpoint->type != 0) return NULL; gens = dp->distpoint->name.fullname; for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) { gen = sk_GENERAL_NAME_value(gens, i); uri = GENERAL_NAME_get0_value(gen, &gtype); if (gtype == GEN_URI && ASN1_STRING_length(uri) > 6) { const char *uptr = (const char *)ASN1_STRING_get0_data(uri); if (strncmp(uptr, "http://", 7) == 0) return uptr; } } return NULL; } /* * Look through a CRLDP structure and attempt to find an http URL to * downloads a CRL from. */ static X509_CRL *load_crl_crldp(STACK_OF(DIST_POINT) *crldp) { int i; const char *urlptr = NULL; for (i = 0; i < sk_DIST_POINT_num(crldp); i++) { DIST_POINT *dp = sk_DIST_POINT_value(crldp, i); urlptr = get_dp_url(dp); if (urlptr) return load_crl(urlptr, FORMAT_HTTP); } return NULL; } /* * Example of downloading CRLs from CRLDP: not usable for real world as it * always downloads, doesn

t cache * anything. */ static STACK_OF(X509_CRL) *crls_http_cb(X509_STORE_CTX *ctx, X509_NAME *nm) { X509 *x; STACK_OF(X509_CRL) *crls = NULL; X509_CRL *crl; STACK_OF(DIST_POINT) *crldp; crls = sk_X509_CRL_new_null(); if (!crls) return NULL; x = X509_STORE_CTX_get_current_cert(ctx); crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL); crl = load_crl_crldp(crldp); sk_DIST_POINT_pop_free(crldp, DIST_POINT_free); if (!crl) { sk_X509_CRL_free(crls); return NULL; } sk_X509_CRL_push(crls, crl); /* Try to download delta CRL */ crldp = X509_get_ext_d2i(x, NID_freshest_crl, NULL, NULL); crl = load_crl_crldp(crldp); sk_DIST_POINT_pop_free(crldp, DIST_POINT_free); if (crl) sk_X509_CRL_push(crls, crl); return crls; } void store_setup_crl_download(X509_STORE *st) { X509_STORE_set_lookup_crls_cb(st, crls_http_cb); } /* * Platform-specific sections */ #if defined(_WIN32) # ifdef fileno # undef fileno # define fileno(a) (int)_fileno(a) # endif # include <windows.h> # include <tchar.h> static int WIN32_rename(const char *from, const char *to) { TCHAR *tfrom = NULL, *tto; DWORD err; int ret = 0; if (sizeof(TCHAR) == 1) { tfrom = (TCHAR *)from; tto = (TCHAR *)to; } else { /* UNICODE path */ size_t i, flen = strlen(from) + 1, tlen = strlen(to) + 1; tfrom = malloc(sizeof(*tfrom) * (flen + tlen)); if (tfrom == NULL) goto err; tto = tfrom + flen; # if !defined(_WIN32_WCE) || _WIN32_WCE>=101 if (!MultiByteToWideChar(CP_ACP, 0, from, flen, (WCHAR *)tfrom, flen)) # endif for (i = 0; i < flen; i++) tfrom[i] = (TCHAR)from[i]; # if !defined(_WIN32_WCE) || _WIN32_WCE>=101 if (!MultiByteToWideChar(CP_ACP, 0, to, tlen, (WCHAR *)tto, tlen)) # endif for (i = 0; i < tlen; i++) tto[i] = (TCHAR)to[i]; } if (MoveFile(tfrom, tto)) goto ok; err = GetLastError(); if (err == ERROR_ALREADY_EXISTS || err == ERROR_FILE_EXISTS) { if (DeleteFile(tto) && MoveFile(tfrom, tto)) goto ok; err = GetLastError(); } if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) errno = ENOENT; else if (err == ERROR_ACCESS_DENIED) errno = EACCES; else errno = EINVAL; /* we could map more codes... */ err: ret = -1; ok: if (tfrom != NULL && tfrom != (TCHAR *)from) free(tfrom); return ret; } #endif /* app_tminterval section */ #if defined(_WIN32) double app_tminterval(int stop, int usertime) { FILETIME now; double ret = 0; static ULARGE_INTEGER tmstart; static int warning = 1; # ifdef _WIN32_WINNT static HANDLE proc = NULL; if (proc == NULL) { if (check_winnt()) proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId()); if (proc == NULL) proc = (HANDLE) - 1; } if (usertime && proc != (HANDLE) - 1) { FILETIME junk; GetProcessTimes(proc, &junk, &junk, &junk, &now); } else # endif { SYSTEMTIME systime; if (usertime && warning) { BIO_printf(bio_err, "To get meaningful results, run " "this program on idle system.\n"); warning = 0; } GetSystemTime(&systime); SystemTimeToFileTime(&systime, &now); } if (stop == TM_START) { tmstart.u.LowPart = now.dwLowDateTime; tmstart.u.HighPart = now.dwHighDateTime; } else { ULARGE_INTEGER tmstop; tmstop.u.LowPart = now.dwLowDateTime; tmstop.u.HighPart = now.dwHighDateTime; ret = (__int64)(tmstop.QuadPart - tmstart.QuadPart) * 1e-7; } return (ret); } #elif defined(OPENSSL_SYSTEM_VXWORKS) # include <time.h> double app_tminterval(int stop, int usertime) { double ret = 0; # ifdef CLOCK_REALTIME static struct timespec tmstart; struct timespec now; # else static unsigned long tmstart; unsigned long now; # endif static int warning = 1; if (usertime && warning) { BIO_printf(bio_err, "To get meaningful results, run " "this program on idle system.\n"); warning = 0; } # ifdef CLOCK_REALTIME clock_gettime(CLOCK_REALTIME, &now); if (stop == TM_START) tmstart = now; else ret = ((now.tv_sec + now.tv_nsec * 1e-9) - (tmstart.tv_sec + tmstart.tv_nsec * 1e-9)); # else now = tickGet(); if (stop == TM_START) tmstart = now; else ret = (now - tmstart) / (double)sysClkRateGet(); # endif return (ret); } #elif defined(OPENSSL_SYSTEM_VMS) # include <time.h> # include <times.h> double app_tminterval(int stop, int usertime) { static clock_t tmstart; double ret = 0; clock_t now; # ifdef __TMS struct tms rus; now = times(&rus); if (usertime) now = rus.tms_utime; # else if (usertime) now = clock(); /* sum of user and kernel times */ else { struct timeval tv; gettimeofday(&tv, NULL); now = (clock_t)((unsigned long long)tv.tv_sec * CLK_TCK + (unsigned long long)tv.tv_usec * (1000000 / CLK_TCK) ); } # endif if (stop == TM_START) tmstart = now; else ret = (now - tmstart) / (double)(CLK_TCK); return (ret); } #elif defined(_SC_CLK_TCK) /* by means of unistd.h */ # include <sys/times.h> double app_tminterval(int stop, int usertime) { double ret = 0; struct tms rus; clock_t now = times(&rus); static clock_t tmstart; if (usertime) now = rus.tms_utime; if (stop == TM_START) { tmstart = now; } else { long int tck = sysconf(_SC_CLK_TCK); ret = (now - tmstart) / (double)tck; } return (ret); } #else # include <sys/time.h> # include <sys/resource.h> double app_tminterval(int stop, int usertime) { double ret = 0; struct rusage rus; struct timeval now; static struct timeval tmstart; if (usertime) getrusage(RUSAGE_SELF, &rus), now = rus.ru_utime; else gettimeofday(&now, NULL); if (stop == TM_START) tmstart = now; else ret = ((now.tv_sec + now.tv_usec * 1e-6) - (tmstart.tv_sec + tmstart.tv_usec * 1e-6)); return ret; } #endif int app_access(const char* name, int flag) { #ifdef _WIN32 return _access(name, flag); #else return access(name, flag); #endif } /* app_isdir section */ #ifdef _WIN32 int app_isdir(const char *name) { DWORD attr; # if defined(UNICODE) || defined(_UNICODE) size_t i, len_0 = strlen(name) + 1; WCHAR tempname[MAX_PATH]; if (len_0 > MAX_PATH) return -1; # if !defined(_WIN32_WCE) || _WIN32_WCE>=101 if (!MultiByteToWideChar(CP_ACP, 0, name, len_0, tempname, MAX_PATH)) # endif for (i = 0; i < len_0; i++) tempname[i] = (WCHAR)name[i]; attr = GetFileAttributes(tempname); # else attr = GetFileAttributes(name); # endif if (attr == INVALID_FILE_ATTRIBUTES) return -1; return ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0); } #else # include <sys/stat.h> # ifndef S_ISDIR # if defined(_S_IFMT) && defined(_S_IFDIR) # define S_ISDIR(a) (((a) & _S_IFMT) == _S_IFDIR) # else # define S_ISDIR(a) (((a) & S_IFMT) == S_IFDIR) # endif # endif int app_isdir(const char *name) { # if defined(S_ISDIR) struct stat st; if (stat(name, &st) == 0) return S_ISDIR(st.st_mode); else return -1; # else return -1; # endif } #endif /* raw_read|write section */ #if defined(__VMS) # include "vms_term_sock.h" static int stdin_sock = -1; static void close_stdin_sock(void) { TerminalSocket (TERM_SOCK_DELETE, &stdin_sock); } int fileno_stdin(void) { if (stdin_sock == -1) { TerminalSocket(TERM_SOCK_CREATE, &stdin_sock); atexit(close_stdin_sock); } return stdin_sock; } #else int fileno_stdin(void) { return fileno(stdin); } #endif int fileno_stdout(void) { return fileno(stdout); } #if defined(_WIN32) && defined(STD_INPUT_HANDLE) int raw_read_stdin(void *buf, int siz) { DWORD n; if (ReadFile(GetStdHandle(STD_INPUT_HANDLE), buf, siz, &n, NULL)) return (n); else return (-1); } #elif defined(__VMS) # include <sys/socket.h> int raw_read_stdin(void *buf, int siz) { return recv(fileno_stdin(), buf, siz, 0); } #else int raw_read_stdin(void *buf, int siz) { return read(fileno_stdin(), buf, siz); } #endif #if defined(_WIN32) && defined(STD_OUTPUT_HANDLE) int raw_write_stdout(const void *buf, int siz) { DWORD n; if (WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), buf, siz, &n, NULL)) return (n); else return (-1); } #else int raw_write_stdout(const void *buf, int siz) { return write(fileno_stdout(), buf, siz); } #endif /* * Centralized handling if input and output files with format specification * The format is meant to show what the input and output is supposed to be, * and is therefore a show of intent more than anything else. However, it * does impact behavior on some platform, such as differentiating between * text and binary input/output on non-Unix platforms */ static int istext(int format) { return (format & B_FORMAT_TEXT) == B_FORMAT_TEXT; } BIO *dup_bio_in(int format) { return BIO_new_fp(stdin, BIO_NOCLOSE | (istext(format) ? BIO_FP_TEXT : 0)); } BIO *dup_bio_out(int format) { BIO *b = BIO_new_fp(stdout, BIO_NOCLOSE | (istext(format) ? BIO_FP_TEXT : 0)); #ifdef OPENSSL_SYS_VMS if (istext(format)) b = BIO_push(BIO_new(BIO_f_linebuffer()), b); #endif return b; } BIO *dup_bio_err(int format) { BIO *b = BIO_new_fp(stderr, BIO_NOCLOSE | (istext(format) ? BIO_FP_TEXT : 0)); #ifdef OPENSSL_SYS_VMS if (istext(format)) b = BIO_push(BIO_new(BIO_f_linebuffer()), b); #endif return b; } void unbuffer(FILE *fp) { /* * On VMS, setbuf() will only take 32-bit pointers, and a compilation * with /POINTER_SIZE=64 will give off a MAYLOSEDATA2 warning here. * However, we trust that the C RTL will never give us a FILE pointer * above the first 4 GB of memory, so we simply turn off the warning * temporarily. */ #if defined(OPENSSL_SYS_VMS) && defined(__DECC) # pragma environment save # pragma message disable maylosedata2 #endif setbuf(fp, NULL); #if defined(OPENSSL_SYS_VMS) && defined(__DECC) # pragma environment restore #endif } static const char *modestr(char mode, int format) { OPENSSL_assert(mode ==

|| mode ==

|| mode ==

); switch (mode) { case

: return istext(format) ? "a" : "ab"; case

: return istext(format) ? "r" : "rb"; case

: return istext(format) ? "w" : "wb"; } /* The assert above should make sure we never reach this point */ return NULL; } static const char *modeverb(char mode) { switch (mode) { case

: return "appending"; case

: return "reading"; case

: return "writing"; } return "(doing something)"; } /* * Open a file for writing, owner-read-only. */ BIO *bio_open_owner(const char *filename, int format, int private) { FILE *fp = NULL; BIO *b = NULL; int fd = -1, bflags, mode, textmode; if (!private || filename == NULL || strcmp(filename, "-") == 0) return bio_open_default(filename,

, format); mode = O_WRONLY; #ifdef O_CREAT mode |= O_CREAT; #endif #ifdef O_TRUNC mode |= O_TRUNC; #endif textmode = istext(format); if (!textmode) { #ifdef O_BINARY mode |= O_BINARY; #elif defined(_O_BINARY) mode |= _O_BINARY; #endif } #ifdef OPENSSL_SYS_VMS /* VMS doesn

t make sense. But, * it still needs to know that we

invalid argument

ctx=bin

w

%s: Can't open \"%s\" for writing, %s\n

t close both. */ if (fp) fclose(fp); else if (fd >= 0) close(fd); return NULL; } static BIO *bio_open_default_(const char *filename, char mode, int format, int quiet) { BIO *ret; if (filename == NULL || strcmp(filename, "-") == 0) { ret = mode ==

? dup_bio_in(format) : dup_bio_out(format); if (quiet) { ERR_clear_error(); return ret; } if (ret != NULL) return ret; BIO_printf(bio_err, "Can

, mode == 'r' ?

:

, strerror(errno)); } else { ret = BIO_new_file(filename, modestr(mode, format)); if (quiet) { ERR_clear_error(); return ret; } if (ret != NULL) return ret; BIO_printf(bio_err,

t open %s for %s, %s\n", filename, modeverb(mode), strerror(errno)); } ERR_print_errors(bio_err); return NULL; } BIO *bio_open_default(const char *filename, char mode, int format) { return bio_open_default_(filename, mode, format, 0); } BIO *bio_open_default_quiet(const char *filename, char mode, int format) { return bio_open_default_(filename, mode, format, 1); } void wait_for_async(SSL *s) { /* On Windows select only works for sockets, so we simply don

allocate async fds

today

\0

0xfL

0xffffffffl},

0xffffffffl},

0xffffffffL},

0xffffffffL},

0xffffffffL},

0xffffffffL},

0xffffffffL},

0x00");

0x%02X,

0x%02X",

0x%02X,

0x%02X",

0x1;

Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

struct timeval for DTLS

quick macro when you need to pass an unsigned char instead of a char. this is true for some implementations of the is() functions, for example.

Common verification options.

Common "extended validation" options.

Common SSL options. Any changes here must be coordinated with ../ssl/ssl_conf.c

Random state options.

Option parsing.

value type: - no value (also the value zero), n number, p positive number, u unsigned, l long, s string, < input file, > output file, f any format, F der/pem format, E der/pem/engine format identifier. l, n and u include zero; p does not.

A string/int pairing; widely use for option value lookup, hence the name OPT_PAIR. But that name is misleading in s_cb.c, so we also use the "generic" name STRINT_PAIR.

Flags to pass into opt_format; see FORMAT_xxx, below.

VMS C only for now, implemented in vms_decc_init.c If other C compilers forget to terminate argv with NULL, this function can be re-used.

Win32-specific argv initialization that splits OS-supplied UNICODE command line string to array of UTF8-encoded strings.

Sets the file to load the Certificate Transparency log list from. If path is NULL, loads from the default file path. Returns 1 on success, 0 otherwise.

Functions defined in ca.c and also used in ocsp.c

index - unique

index - unique when active and not disabled

Revoked

Expired

Valid ; inserted with: ca ... -valid

Suspended

See OPT_FMT_xxx, above.

On some platforms, it's important to distinguish between text and binary files. On some, there might even be specific file formats for different contents. The FORMAT_xxx macros are meant to express an intent with the file being read or created.

Generic text

Generic binary

Base64

ASN.1/DER

Not really a file format

PEM RSAPubicKey format

DER RSAPubicKey format

MS Key blob format

MS PVK file format

Download using HTTP

NSS keylog format

IETF RFC 5280 says serial number must be <= 20 bytes. Use 159 bits so that the first bit will never be one, so that the DER encoding rules won't force a leading octet.

www.openssl.org/source/license.html

License

e_os.h

internal/nelem.h

policy

s

adds policy to the acceptable policy set

purpose

s

certificate chain purpose

verify_name

s

verification policy name

verify_depth

n

chain depth limit

auth_level

n

chain authentication security level

attime

M

verification epoch time

verify_hostname

s

expected peer hostname

verify_email

s

expected peer email

verify_ip

s

expected peer IP address

ignore_critical

-

permit unhandled critical extensions

issuer_checks

-

(deprecated)

crl_check

-

check leaf certificate revocation

crl_check_all

-

check full chain revocation

policy_check

-

perform rfc5280 policy checks

explicit_policy

-

set policy variable require-explicit-policy

inhibit_any

-

set policy variable inhibit-any-policy

inhibit_map

-

set policy variable inhibit-policy-mapping

x509_strict

-

disable certificate compatibility work-arounds

extended_crl

-

enable extended CRL features

use_deltas

-

use delta CRLs

policy_print

-

print policy processing diagnostics

check_ss_sig

-

check root CA self-signatures

trusted_first

-

search trust store first (default)

suiteB_128_only

-

Suite B 128-bit-only mode

suiteB_128

-

Suite B 128-bit mode allowing 192-bit algorithms

suiteB_192

-

Suite B 192-bit-only mode

partial_chain

-

accept chains anchored by intermediate trust-store CAs

no_alt_chains

-

(deprecated)

no_check_time

-

ignore certificate validity time

allow_proxy_certs

-

allow the use of proxy certificates

extended validation

xkey

<

key for Extended certificates

xcert

<

cert for Extended certificates

xchain

<

chain for Extended certificates

xchain_build

-

build certificate chain for the extended certificates

xcertform

F

format of Extended certificate (PEM or DER) PEM default

xkeyform

F

format of Extended certificate's key (PEM or DER) PEM default

no_ssl3

-

Just disable SSLv3

no_tls1

-

Just disable TLSv1

no_tls1_1

-

Just disable TLSv1.1

no_tls1_2

-

Just disable TLSv1.2

no_tls1_3

-

Just disable TLSv1.3

bugs

-

Turn on SSL bug compatibility

no_comp

-

Disable SSL/TLS compression (default)

comp

-

Use SSL/TLS-level compression

no_ticket

-

Disable use of TLS session tickets

serverpref

-

Use server's cipher preferences

legacy_renegotiation

-

Enable use of legacy renegotiation (dangerous)

no_renegotiation

-

Disable all renegotiation.

legacy_server_connect

-

Allow initial connection to servers that don't support RI

no_resumption_on_reneg

-

Disallow session resumption on renegotiation

no_legacy_server_connect

-

Disallow initial connection to servers that don't support RI

allow_no_dhe_kex

-

In TLSv1.3 allow non-(ec)dhe based key exchange on resumption

strict

-

Enforce strict certificate checks as per TLS standard

sigalgs

s

Signature algorithms to support (colon-separated list)

client_sigalgs

s

Signature algorithms to support for client certificate

authentication (colon-separated list)

groups

s

Groups to advertise (colon-separated list)

curves

s

Groups to advertise (colon-separated list)

named_curve

s

Elliptic curve used for ECDHE (server-side only)

cipher

s

Specify cipher list to be used

dhparam

<

DH parameter file to use, in cert file if not specified

record_padding

s

Block size to pad TLS 1.3 records to.

debug_broken_protocol

-

Perform all sorts of protocol violations for testing purposes

rand

s

Load the file(s) into the random number generator

writerand

>

Write random data to the specified file

generic

R

E

V

S

s important to distinguish between text and binary * files. On some, there might even be specific file formats for different * contents. The FORMAT_xxx macros are meant to express an intent with the * file being read or created. */ # define B_FORMAT_TEXT 0x8000 # define FORMAT_UNDEF 0 # define FORMAT_TEXT (1 | B_FORMAT_TEXT) /* Generic text */ # define FORMAT_BINARY 2 /* Generic binary */ # define FORMAT_BASE64 (3 | B_FORMAT_TEXT) /* Base64 */ # define FORMAT_ASN1 4 /* ASN.1/DER */ # define FORMAT_PEM (5 | B_FORMAT_TEXT) # define FORMAT_PKCS12 6 # define FORMAT_SMIME (7 | B_FORMAT_TEXT) # define FORMAT_ENGINE 8 /* Not really a file format */ # define FORMAT_PEMRSA (9 | B_FORMAT_TEXT) /* PEM RSAPubicKey format */ # define FORMAT_ASN1RSA 10 /* DER RSAPubicKey format */ # define FORMAT_MSBLOB 11 /* MS Key blob format */ # define FORMAT_PVK 12 /* MS PVK file format */ # define FORMAT_HTTP 13 /* Download using HTTP */ # define FORMAT_NSS 14 /* NSS keylog format */ # define EXT_COPY_NONE 0 # define EXT_COPY_ADD 1 # define EXT_COPY_ALL 2 # define NETSCAPE_CERT_HDR "certificate" # define APP_PASS_LEN 1024 /* * IETF RFC 5280 says serial number must be <= 20 bytes. Use 159 bits * so that the first bit will never be one, so that the DER encoding * rules won

progs.h

0x8000


Copyright 2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Copyright (C) 2017 National Security Research Institute. All Rights Reserved. Information for ARIA http://210.104.33.10/ARIA/index-e.html (English) http://seed.kisa.or.kr/ (Korean) Public domain version is distributed above.

Begin macro

rotation

End Macr

Key Constant 128bit : 0, 1, 2 192bit : 1, 2, 3(0) 256bit : 2, 3(0), 4(1)

32bit expanded s-box

Key XOR Layer

S-Box Layer 1 + M

S-Box Layer 2 + M

Word-level diffusion

Byte-level diffusion

Odd round Substitution & Diffusion

Even round Substitution & Diffusion

Q, R Macro expanded ARIA GSRK

Exclusive or two 128 bit values into the result. It is safe for the result to be the same as the either input.

Generalised circular rotate right and exclusive or function. It is safe for the output to overlap either input.

Circular rotate 19 bits right and xor. It is safe for the output to overlap either input.

Circular rotate 31 bits right and xor. It is safe for the output to overlap either input.

Circular rotate 61 bits left and xor. It is safe for the output to overlap either input.

Circular rotate 31 bits left and xor. It is safe for the output to overlap either input.

Circular rotate 19 bits left and xor. It is safe for the output to overlap either input.

First substitution and xor layer, used for odd steps. It is safe for the input and output to be the same.

Second substitution and xor layer, used for even steps. It is safe for the input and output to be the same.

Diffusion layer step It is NOT safe for the input and output to overlap.

Odd round function Apply the first substitution layer and then a diffusion step. It is safe for the input and output to overlap.

Even round function Apply the second substitution layer and then a diffusion step. It is safe for the input and output to overlap.

Encrypt or decrypt a single block in and out can overlap

Encrypt a single block in and out can overlap

Expand the cipher key into the encryption key schedule. We short circuit execution of the last two or four rotations based on the key size.

Expand the cipher key into the decryption key schedule.

www.openssl.org/source/license.html

210.104.33.10/ARIA/index-e.html (English)

seed.kisa.or.kr/ (Korean)

License

internal/aria.h

0x0000ff00)

0x00ff0000)

0x517cc1b7,

0x27220a94,

0xfe13abe8,

0xfa9a6ee0

0x6db14acc,

0x9e21c820,

0xff28b1d5,

0xef5de2b0

0xdb92371d,

0x2126e970,

0x03249775,

0x04e8c90e

0x517cc1b7,

0x27220a94,

0xfe13abe8,

0xfa9a6ee0

0x6db14acc,

0x9e21c820,

0xff28b1d5,

0xef5de2b0

0x00636363,

0x007c7c7c,

0x00777777,

0x007b7b7b,

0x00f2f2f2,

0x006b6b6b,

0x006f6f6f,

0x00c5c5c5,

0x00303030,

0x00010101,

0x00676767,

0x002b2b2b,

0x00fefefe,

0x00d7d7d7,

0x00ababab,

0x00767676,

0x00cacaca,

0x00828282,

0x00c9c9c9,

0x007d7d7d,

0x00fafafa,

0x00595959,

0x00474747,

0x00f0f0f0,

0x00adadad,

0x00d4d4d4,

0x00a2a2a2,

0x00afafaf,

0x009c9c9c,

0x00a4a4a4,

0x00727272,

0x00c0c0c0,

0x00b7b7b7,

0x00fdfdfd,

0x00939393,

0x00262626,

0x00363636,

0x003f3f3f,

0x00f7f7f7,

0x00cccccc,

0x00343434,

0x00a5a5a5,

0x00e5e5e5,

0x00f1f1f1,

0x00717171,

0x00d8d8d8,

0x00313131,

0x00151515,

0x00040404,

0x00c7c7c7,

0x00232323,

0x00c3c3c3,

0x00181818,

0x00969696,

0x00050505,

0x009a9a9a,

0x00070707,

0x00121212,

0x00808080,

0x00e2e2e2,

0x00ebebeb,

0x00272727,

0x00b2b2b2,

0x00757575,

0x00090909,

0x00838383,

0x002c2c2c,

0x001a1a1a,

0x001b1b1b,

0x006e6e6e,

0x005a5a5a,

0x00a0a0a0,

0x00525252,

0x003b3b3b,

0x00d6d6d6,

0x00b3b3b3,

0x00292929,

0x00e3e3e3,

0x002f2f2f,

0x00848484,

0x00535353,

0x00d1d1d1,

0x00000000,

0x00ededed,

0x00202020,

0x00fcfcfc,

0x00b1b1b1,

0x005b5b5b,

0x006a6a6a,

0x00cbcbcb,

0x00bebebe,

0x00393939,

0x004a4a4a,

0x004c4c4c,

0x00585858,

0x00cfcfcf,

0x00d0d0d0,

0x00efefef,

0x00aaaaaa,

0x00fbfbfb,

0x00434343,

0x004d4d4d,

0x00333333,

0x00858585,

0x00454545,

0x00f9f9f9,

0x00020202,

0x007f7f7f,

0x00505050,

0x003c3c3c,

0x009f9f9f,

0x00a8a8a8,

0x00515151,

0x00a3a3a3,

0x00404040,

0x008f8f8f,

0x00929292,

0x009d9d9d,

0x00383838,

0x00f5f5f5,

0x00bcbcbc,

0x00b6b6b6,

0x00dadada,

0x00212121,

0x00101010,

0x00ffffff,

0x00f3f3f3,

0x00d2d2d2,

0x00cdcdcd,

0x000c0c0c,

0x00131313,

0x00ececec,

0x005f5f5f,

0x00979797,

0x00444444,

0x00171717,

0x00c4c4c4,

0x00a7a7a7,

0x007e7e7e,

0x003d3d3d,

0x00646464,

0x005d5d5d,

0x00191919,

0x00737373,

0x00606060,

0x00818181,

0x004f4f4f,

0x00dcdcdc,

0x00222222,

0x002a2a2a,

0x00909090,

0x00888888,

0x00464646,

0x00eeeeee,

0x00b8b8b8,

0x00141414,

0x00dedede,

0x005e5e5e,

0x000b0b0b,

0x00dbdbdb,

0x00e0e0e0,

0x00323232,

0x003a3a3a,

0x000a0a0a,

0x00494949,

0x00060606,

0x00242424,

0x005c5c5c,

0x00c2c2c2,

0x00d3d3d3,

0x00acacac,

0x00626262,

0x00919191,

0x00959595,

0x00e4e4e4,

0x00797979,

0x00e7e7e7,

0x00c8c8c8,

0x00373737,

0x006d6d6d,

0x008d8d8d,

0x00d5d5d5,

0x004e4e4e,

0x00a9a9a9,

0x006c6c6c,

0x00565656,

0x00f4f4f4,

0x00eaeaea,

0x00656565,

0x007a7a7a,

0x00aeaeae,

0x00080808,

0x00bababa,

0x00787878,

0x00252525,

0x002e2e2e,

0x001c1c1c,

0x00a6a6a6,

0x00b4b4b4,

0x00c6c6c6,

0x00e8e8e8,

0x00dddddd,

0x00747474,

0x001f1f1f,

0x004b4b4b,

0x00bdbdbd,

0x008b8b8b,

0x008a8a8a,

0x00707070,

0x003e3e3e,

0x00b5b5b5,

0x00666666,

0x00484848,

0x00030303,

0x00f6f6f6,

0x000e0e0e,

0x00616161,

0x00353535,

0x00575757,

0x00b9b9b9,

0x00868686,

0x00c1c1c1,

0x001d1d1d,

0x009e9e9e,

0x00e1e1e1,

0x00f8f8f8,

0x00989898,

0x00111111,

0x00696969,

0x00d9d9d9,

0x008e8e8e,

0x00949494,

0x009b9b9b,

0x001e1e1e,

0x00878787,

0x00e9e9e9,

0x00cecece,

0x00555555,

0x00282828,

0x00dfdfdf,

0x008c8c8c,

0x00a1a1a1,

0x00898989,

0x000d0d0d,

0x00bfbfbf,

0x00e6e6e6,

0x00424242,

0x00686868,

0x00414141,

0x00999999,

0x002d2d2d,

0x000f0f0f,

0x00b0b0b0,

0x00545454,

0x00bbbbbb,

0x00161616

0xe200e2e2,

0x4e004e4e,

0x54005454,

0xfc00fcfc,

0x94009494,

0xc200c2c2,

0x4a004a4a,

0xcc00cccc,

0x62006262,

0x0d000d0d,

0x6a006a6a,

0x46004646,

0x3c003c3c,

0x4d004d4d,

0x8b008b8b,

0xd100d1d1,

0x5e005e5e,

0xfa00fafa,

0x64006464,

0xcb00cbcb,

0xb400b4b4,

0x97009797,

0xbe00bebe,

0x2b002b2b,

0xbc00bcbc,

0x77007777,

0x2e002e2e,

0x03000303,

0xd300d3d3,

0x19001919,

0x59005959,

0xc100c1c1,

0x1d001d1d,

0x06000606,

0x41004141,

0x6b006b6b,

0x55005555,

0xf000f0f0,

0x99009999,

0x69006969,

0xea00eaea,

0x9c009c9c,

0x18001818,

0xae00aeae,

0x63006363,

0xdf00dfdf,

0xe700e7e7,

0xbb00bbbb,

0x00000000,

0x73007373,

0x66006666,

0xfb00fbfb,

0x96009696,

0x4c004c4c,

0x85008585,

0xe400e4e4,

0x3a003a3a,

0x09000909,

0x45004545,

0xaa00aaaa,

0x0f000f0f,

0xee00eeee,

0x10001010,

0xeb00ebeb,

0x2d002d2d,

0x7f007f7f,

0xf400f4f4,

0x29002929,

0xac00acac,

0xcf00cfcf,

0xad00adad,

0x91009191,

0x8d008d8d,

0x78007878,

0xc800c8c8,

0x95009595,

0xf900f9f9,

0x2f002f2f,

0xce00cece,

0xcd00cdcd,

0x08000808,

0x7a007a7a,

0x88008888,

0x38003838,

0x5c005c5c,

0x83008383,

0x2a002a2a,

0x28002828,

0x47004747,

0xdb00dbdb,

0xb800b8b8,

0xc700c7c7,

0x93009393,

0xa400a4a4,

0x12001212,

0x53005353,

0xff00ffff,

0x87008787,

0x0e000e0e,

0x31003131,

0x36003636,

0x21002121,

0x58005858,

0x48004848,

0x01000101,

0x8e008e8e,

0x37003737,

0x74007474,

0x32003232,

0xca00caca,

0xe900e9e9,

0xb100b1b1,

0xb700b7b7,

0xab00abab,

0x0c000c0c,

0xd700d7d7,

0xc400c4c4,

0x56005656,

0x42004242,

0x26002626,

0x07000707,

0x98009898,

0x60006060,

0xd900d9d9,

0xb600b6b6,

0xb900b9b9,

0x11001111,

0x40004040,

0xec00ecec,

0x20002020,

0x8c008c8c,

0xbd00bdbd,

0xa000a0a0,

0xc900c9c9,

0x84008484,

0x04000404,

0x49004949,

0x23002323,

0xf100f1f1,

0x4f004f4f,

0x50005050,

0x1f001f1f,

0x13001313,

0xdc00dcdc,

0xd800d8d8,

0xc000c0c0,

0x9e009e9e,

0x57005757,

0xe300e3e3,

0xc300c3c3,

0x7b007b7b,

0x65006565,

0x3b003b3b,

0x02000202,

0x8f008f8f,

0x3e003e3e,

0xe800e8e8,

0x25002525,

0x92009292,

0xe500e5e5,

0x15001515,

0xdd00dddd,

0xfd00fdfd,

0x17001717,

0xa900a9a9,

0xbf00bfbf,

0xd400d4d4,

0x9a009a9a,

0x7e007e7e,

0xc500c5c5,

0x39003939,

0x67006767,

0xfe00fefe,

0x76007676,

0x9d009d9d,

0x43004343,

0xa700a7a7,

0xe100e1e1,

0xd000d0d0,

0xf500f5f5,

0x68006868,

0xf200f2f2,

0x1b001b1b,

0x34003434,

0x70007070,

0x05000505,

0xa300a3a3,

0x8a008a8a,

0xd500d5d5,

0x79007979,

0x86008686,

0xa800a8a8,

0x30003030,

0xc600c6c6,

0x51005151,

0x4b004b4b,

0x1e001e1e,

0xa600a6a6,

0x27002727,

0xf600f6f6,

0x35003535,

0xd200d2d2,

0x6e006e6e,

0x24002424,

0x16001616,

0x82008282,

0x5f005f5f,

0xda00dada,

0xe600e6e6,

0x75007575,

0xa200a2a2,

0xef00efef,

0x2c002c2c,

0xb200b2b2,

0x1c001c1c,

0x9f009f9f,

0x5d005d5d,

0x6f006f6f,

0x80008080,

0x0a000a0a,

0x72007272,

0x44004444,

0x9b009b9b,

0x6c006c6c,

0x90009090,

0x0b000b0b,

0x5b005b5b,

0x33003333,

0x7d007d7d,

0x5a005a5a,

0x52005252,

0xf300f3f3,

0x61006161,

0xa100a1a1,

0xf700f7f7,

0xb000b0b0,

0xd600d6d6,

0x3f003f3f,

0x7c007c7c,

0x6d006d6d,

0xed00eded,

0x14001414,

0xe000e0e0,

0xa500a5a5,

0x3d003d3d,

0x22002222,

0xb300b3b3,

0xf800f8f8,

0x89008989,

0xde00dede,

0x71007171,

0x1a001a1a,

0xaf00afaf,

0xba00baba,

0xb500b5b5,

0x81008181

0x52520052,

0x09090009,

0x6a6a006a,

0xd5d500d5,

0x30300030,

0x36360036,

0xa5a500a5,

0x38380038,

0xbfbf00bf,

0x40400040,

0xa3a300a3,

0x9e9e009e,

0x81810081,

0xf3f300f3,

0xd7d700d7,

0xfbfb00fb,

0x7c7c007c,

0xe3e300e3,

0x39390039,

0x82820082,

0x9b9b009b,

0x2f2f002f,

0xffff00ff,

0x87870087,

0x34340034,

0x8e8e008e,

0x43430043,

0x44440044,

0xc4c400c4,

0xdede00de,

0xe9e900e9,

0xcbcb00cb,

0x54540054,

0x7b7b007b,

0x94940094,

0x32320032,

0xa6a600a6,

0xc2c200c2,

0x23230023,

0x3d3d003d,

0xeeee00ee,

0x4c4c004c,

0x95950095,

0x0b0b000b,

0x42420042,

0xfafa00fa,

0xc3c300c3,

0x4e4e004e,

0x08080008,

0x2e2e002e,

0xa1a100a1,

0x66660066,

0x28280028,

0xd9d900d9,

0x24240024,

0xb2b200b2,

0x76760076,

0x5b5b005b,

0xa2a200a2,

0x49490049,

0x6d6d006d,

0x8b8b008b,

0xd1d100d1,

0x25250025,

0x72720072,

0xf8f800f8,

0xf6f600f6,

0x64640064,

0x86860086,

0x68680068,

0x98980098,

0x16160016,

0xd4d400d4,

0xa4a400a4,

0x5c5c005c,

0xcccc00cc,

0x5d5d005d,

0x65650065,

0xb6b600b6,

0x92920092,

0x6c6c006c,

0x70700070,

0x48480048,

0x50500050,

0xfdfd00fd,

0xeded00ed,

0xb9b900b9,

0xdada00da,

0x5e5e005e,

0x15150015,

0x46460046,

0x57570057,

0xa7a700a7,

0x8d8d008d,

0x9d9d009d,

0x84840084,

0x90900090,

0xd8d800d8,

0xabab00ab,

0x00000000,

0x8c8c008c,

0xbcbc00bc,

0xd3d300d3,

0x0a0a000a,

0xf7f700f7,

0xe4e400e4,

0x58580058,

0x05050005,

0xb8b800b8,

0xb3b300b3,

0x45450045,

0x06060006,

0xd0d000d0,

0x2c2c002c,

0x1e1e001e,

0x8f8f008f,

0xcaca00ca,

0x3f3f003f,

0x0f0f000f,

0x02020002,

0xc1c100c1,

0xafaf00af,

0xbdbd00bd,

0x03030003,

0x01010001,

0x13130013,

0x8a8a008a,

0x6b6b006b,

0x3a3a003a,

0x91910091,

0x11110011,

0x41410041,

0x4f4f004f,

0x67670067,

0xdcdc00dc,

0xeaea00ea,

0x97970097,

0xf2f200f2,

0xcfcf00cf,

0xcece00ce,

0xf0f000f0,

0xb4b400b4,

0xe6e600e6,

0x73730073,

0x96960096,

0xacac00ac,

0x74740074,

0x22220022,

0xe7e700e7,

0xadad00ad,

0x35350035,

0x85850085,

0xe2e200e2,

0xf9f900f9,

0x37370037,

0xe8e800e8,

0x1c1c001c,

0x75750075,

0xdfdf00df,

0x6e6e006e,

0x47470047,

0xf1f100f1,

0x1a1a001a,

0x71710071,

0x1d1d001d,

0x29290029,

0xc5c500c5,

0x89890089,

0x6f6f006f,

0xb7b700b7,

0x62620062,

0x0e0e000e,

0xaaaa00aa,

0x18180018,

0xbebe00be,

0x1b1b001b,

0xfcfc00fc,

0x56560056,

0x3e3e003e,

0x4b4b004b,

0xc6c600c6,

0xd2d200d2,

0x79790079,

0x20200020,

0x9a9a009a,

0xdbdb00db,

0xc0c000c0,

0xfefe00fe,

0x78780078,

0xcdcd00cd,

0x5a5a005a,

0xf4f400f4,

0x1f1f001f,

0xdddd00dd,

0xa8a800a8,

0x33330033,

0x88880088,

0x07070007,

0xc7c700c7,

0x31310031,

0xb1b100b1,

0x12120012,

0x10100010,

0x59590059,

0x27270027,

0x80800080,

0xecec00ec,

0x5f5f005f,

0x60600060,

0x51510051,

0x7f7f007f,

0xa9a900a9,

0x19190019,

0xb5b500b5,

0x4a4a004a,

0x0d0d000d,

0x2d2d002d,

0xe5e500e5,

0x7a7a007a,

0x9f9f009f,

0x93930093,

0xc9c900c9,

0x9c9c009c,

0xefef00ef,

0xa0a000a0,

0xe0e000e0,

0x3b3b003b,

0x4d4d004d,

0xaeae00ae,

0x2a2a002a,

0xf5f500f5,

0xb0b000b0,

0xc8c800c8,

0xebeb00eb,

0xbbbb00bb,

0x3c3c003c,

0x83830083,

0x53530053,

0x99990099,

0x61610061,

0x17170017,

0x2b2b002b,

0x04040004,

0x7e7e007e,

0xbaba00ba,

0x77770077,

0xd6d600d6,

0x26260026,

0xe1e100e1,

0x69690069,

0x14140014,

0x63630063,

0x55550055,

0x21210021,

0x0c0c000c,

0x7d7d007d

0x30303000,

0x68686800,

0x99999900,

0x1b1b1b00,

0x87878700,

0xb9b9b900,

0x21212100,

0x78787800,

0x50505000,

0x39393900,

0xdbdbdb00,

0xe1e1e100,

0x72727200,

0x09090900,

0x62626200,

0x3c3c3c00,

0x3e3e3e00,

0x7e7e7e00,

0x5e5e5e00,

0x8e8e8e00,

0xf1f1f100,

0xa0a0a000,

0xcccccc00,

0xa3a3a300,

0x2a2a2a00,

0x1d1d1d00,

0xfbfbfb00,

0xb6b6b600,

0xd6d6d600,

0x20202000,

0xc4c4c400,

0x8d8d8d00,

0x81818100,

0x65656500,

0xf5f5f500,

0x89898900,

0xcbcbcb00,

0x9d9d9d00,

0x77777700,

0xc6c6c600,

0x57575700,

0x43434300,

0x56565600,

0x17171700,

0xd4d4d400,

0x40404000,

0x1a1a1a00,

0x4d4d4d00,

0xc0c0c000,

0x63636300,

0x6c6c6c00,

0xe3e3e300,

0xb7b7b700,

0xc8c8c800,

0x64646400,

0x6a6a6a00,

0x53535300,

0xaaaaaa00,

0x38383800,

0x98989800,

0x0c0c0c00,

0xf4f4f400,

0x9b9b9b00,

0xededed00,

0x7f7f7f00,

0x22222200,

0x76767600,

0xafafaf00,

0xdddddd00,

0x3a3a3a00,

0x0b0b0b00,

0x58585800,

0x67676700,

0x88888800,

0x06060600,

0xc3c3c300,

0x35353500,

0x0d0d0d00,

0x01010100,

0x8b8b8b00,

0x8c8c8c00,

0xc2c2c200,

0xe6e6e600,

0x5f5f5f00,

0x02020200,

0x24242400,

0x75757500,

0x93939300,

0x66666600,

0x1e1e1e00,

0xe5e5e500,

0xe2e2e200,

0x54545400,

0xd8d8d800,

0x10101000,

0xcecece00,

0x7a7a7a00,

0xe8e8e800,

0x08080800,

0x2c2c2c00,

0x12121200,

0x97979700,

0x32323200,

0xababab00,

0xb4b4b400,

0x27272700,

0x0a0a0a00,

0x23232300,

0xdfdfdf00,

0xefefef00,

0xcacaca00,

0xd9d9d900,

0xb8b8b800,

0xfafafa00,

0xdcdcdc00,

0x31313100,

0x6b6b6b00,

0xd1d1d100,

0xadadad00,

0x19191900,

0x49494900,

0xbdbdbd00,

0x51515100,

0x96969600,

0xeeeeee00,

0xe4e4e400,

0xa8a8a800,

0x41414100,

0xdadada00,

0xffffff00,

0xcdcdcd00,

0x55555500,

0x86868600,

0x36363600,

0xbebebe00,

0x61616100,

0x52525200,

0xf8f8f800,

0xbbbbbb00,

0x0e0e0e00,

0x82828200,

0x48484800,

0x69696900,

0x9a9a9a00,

0xe0e0e000,

0x47474700,

0x9e9e9e00,

0x5c5c5c00,

0x04040400,

0x4b4b4b00,

0x34343400,

0x15151500,

0x79797900,

0x26262600,

0xa7a7a700,

0xdedede00,

0x29292900,

0xaeaeae00,

0x92929200,

0xd7d7d700,

0x84848400,

0xe9e9e900,

0xd2d2d200,

0xbababa00,

0x5d5d5d00,

0xf3f3f300,

0xc5c5c500,

0xb0b0b000,

0xbfbfbf00,

0xa4a4a400,

0x3b3b3b00,

0x71717100,

0x44444400,

0x46464600,

0x2b2b2b00,

0xfcfcfc00,

0xebebeb00,

0x6f6f6f00,

0xd5d5d500,

0xf6f6f600,

0x14141400,

0xfefefe00,

0x7c7c7c00,

0x70707000,

0x5a5a5a00,

0x7d7d7d00,

0xfdfdfd00,

0x2f2f2f00,

0x18181800,

0x83838300,

0x16161600,

0xa5a5a500,

0x91919100,

0x1f1f1f00,

0x05050500,

0x95959500,

0x74747400,

0xa9a9a900,

0xc1c1c100,

0x5b5b5b00,

0x4a4a4a00,

0x85858500,

0x6d6d6d00,

0x13131300,

0x07070700,

0x4f4f4f00,

0x4e4e4e00,

0x45454500,

0xb2b2b200,

0x0f0f0f00,

0xc9c9c900,

0x1c1c1c00,

0xa6a6a600,

0xbcbcbc00,

0xececec00,

0x73737300,

0x90909000,

0x7b7b7b00,

0xcfcfcf00,

0x59595900,

0x8f8f8f00,

0xa1a1a100,

0xf9f9f900,

0x2d2d2d00,

0xf2f2f200,

0xb1b1b100,

0x00000000,

0x94949400,

0x37373700,

0x9f9f9f00,

0xd0d0d000,

0x2e2e2e00,

0x9c9c9c00,

0x6e6e6e00,

0x28282800,

0x3f3f3f00,

0x80808000,

0xf0f0f000,

0x3d3d3d00,

0xd3d3d300,

0x25252500,

0x8a8a8a00,

0xb5b5b500,

0xe7e7e700,

0x42424200,

0xb3b3b300,

0xc7c7c700,

0xeaeaea00,

0xf7f7f700,

0x4c4c4c00,

0x11111100,

0x33333300,

0x03030300,

0xa2a2a200,

0xacacac00,

0x60606000

0xff00ff00)

0x00ff00ff);

0x63,

0x7c,

0x77,

0x7b,

0xf2,

0x6b,

0x6f,

0xc5,

0x30,

0x01,

0x67,

0x2b,

0xfe,

0xd7,

0xab,

0x76,

0xca,

0x82,

0xc9,

0x7d,

0xfa,

0x59,

0x47,

0xf0,

0xad,

0xd4,

0xa2,

0xaf,

0x9c,

0xa4,

0x72,

0xc0,

0xb7,

0xfd,

0x93,

0x26,

0x36,

0x3f,

0xf7,

0xcc,

0x34,

0xa5,

0xe5,

0xf1,

0x71,

0xd8,

0x31,

0x15,

0x04,

0xc7,

0x23,

0xc3,

0x18,

0x96,

0x05,

0x9a,

0x07,

0x12,

0x80,

0xe2,

0xeb,

0x27,

0xb2,

0x75,

0x09,

0x83,

0x2c,

0x1a,

0x1b,

0x6e,

0x5a,

0xa0,

0x52,

0x3b,

0xd6,

0xb3,

0x29,

0xe3,

0x2f,

0x84,

0x53,

0xd1,

0x00,

0xed,

0x20,

0xfc,

0xb1,

0x5b,

0x6a,

0xcb,

0xbe,

0x39,

0x4a,

0x4c,

0x58,

0xcf,

0xd0,

0xef,

0xaa,

0xfb,

0x43,

0x4d,

0x33,

0x85,

0x45,

0xf9,

0x02,

0x7f,

0x50,

0x3c,

0x9f,

0xa8,

0x51,

0xa3,

0x40,

0x8f,

0x92,

0x9d,

0x38,

0xf5,

0xbc,

0xb6,

0xda,

0x21,

0x10,

0xff,

0xf3,

0xd2,

0xcd,

0x0c,

0x13,

0xec,

0x5f,

0x97,

0x44,

0x17,

0xc4,

0xa7,

0x7e,

0x3d,

0x64,

0x5d,

0x19,

0x73,

0x60,

0x81,

0x4f,

0xdc,

0x22,

0x2a,

0x90,

0x88,

0x46,

0xee,

0xb8,

0x14,

0xde,

0x5e,

0x0b,

0xdb,

0xe0,

0x32,

0x3a,

0x0a,

0x49,

0x06,

0x24,

0x5c,

0xc2,

0xd3,

0xac,

0x62,

0x91,

0x95,

0xe4,

0x79,

0xe7,

0xc8,

0x37,

0x6d,

0x8d,

0xd5,

0x4e,

0xa9,

0x6c,

0x56,

0xf4,

0xea,

0x65,

0x7a,

0xae,

0x08,

0xba,

0x78,

0x25,

0x2e,

0x1c,

0xa6,

0xb4,

0xc6,

0xe8,

0xdd,

0x74,

0x1f,

0x4b,

0xbd,

0x8b,

0x8a,

0x70,

0x3e,

0xb5,

0x66,

0x48,

0x03,

0xf6,

0x0e,

0x61,

0x35,

0x57,

0xb9,

0x86,

0xc1,

0x1d,

0x9e,

0xe1,

0xf8,

0x98,

0x11,

0x69,

0xd9,

0x8e,

0x94,

0x9b,

0x1e,

0x87,

0xe9,

0xce,

0x55,

0x28,

0xdf,

0x8c,

0xa1,

0x89,

0x0d,

0xbf,

0xe6,

0x42,

0x68,

0x41,

0x99,

0x2d,

0x0f,

0xb0,

0x54,

0xbb,

0x16

0xe2,

0x4e,

0x54,

0xfc,

0x94,

0xc2,

0x4a,

0xcc,

0x62,

0x0d,

0x6a,

0x46,

0x3c,

0x4d,

0x8b,

0xd1,

0x5e,

0xfa,

0x64,

0xcb,

0xb4,

0x97,

0xbe,

0x2b,

0xbc,

0x77,

0x2e,

0x03,

0xd3,

0x19,

0x59,

0xc1,

0x1d,

0x06,

0x41,

0x6b,

0x55,

0xf0,

0x99,

0x69,

0xea,

0x9c,

0x18,

0xae,

0x63,

0xdf,

0xe7,

0xbb,

0x00,

0x73,

0x66,

0xfb,

0x96,

0x4c,

0x85,

0xe4,

0x3a,

0x09,

0x45,

0xaa,

0x0f,

0xee,

0x10,

0xeb,

0x2d,

0x7f,

0xf4,

0x29,

0xac,

0xcf,

0xad,

0x91,

0x8d,

0x78,

0xc8,

0x95,

0xf9,

0x2f,

0xce,

0xcd,

0x08,

0x7a,

0x88,

0x38,

0x5c,

0x83,

0x2a,

0x28,

0x47,

0xdb,

0xb8,

0xc7,

0x93,

0xa4,

0x12,

0x53,

0xff,

0x87,

0x0e,

0x31,

0x36,

0x21,

0x58,

0x48,

0x01,

0x8e,

0x37,

0x74,

0x32,

0xca,

0xe9,

0xb1,

0xb7,

0xab,

0x0c,

0xd7,

0xc4,

0x56,

0x42,

0x26,

0x07,

0x98,

0x60,

0xd9,

0xb6,

0xb9,

0x11,

0x40,

0xec,

0x20,

0x8c,

0xbd,

0xa0,

0xc9,

0x84,

0x04,

0x49,

0x23,

0xf1,

0x4f,

0x50,

0x1f,

0x13,

0xdc,

0xd8,

0xc0,

0x9e,

0x57,

0xe3,

0xc3,

0x7b,

0x65,

0x3b,

0x02,

0x8f,

0x3e,

0xe8,

0x25,

0x92,

0xe5,

0x15,

0xdd,

0xfd,

0x17,

0xa9,

0xbf,

0xd4,

0x9a,

0x7e,

0xc5,

0x39,

0x67,

0xfe,

0x76,

0x9d,

0x43,

0xa7,

0xe1,

0xd0,

0xf5,

0x68,

0xf2,

0x1b,

0x34,

0x70,

0x05,

0xa3,

0x8a,

0xd5,

0x79,

0x86,

0xa8,

0x30,

0xc6,

0x51,

0x4b,

0x1e,

0xa6,

0x27,

0xf6,

0x35,

0xd2,

0x6e,

0x24,

0x16,

0x82,

0x5f,

0xda,

0xe6,

0x75,

0xa2,

0xef,

0x2c,

0xb2,

0x1c,

0x9f,

0x5d,

0x6f,

0x80,

0x0a,

0x72,

0x44,

0x9b,

0x6c,

0x90,

0x0b,

0x5b,

0x33,

0x7d,

0x5a,

0x52,

0xf3,

0x61,

0xa1,

0xf7,

0xb0,

0xd6,

0x3f,

0x7c,

0x6d,

0xed,

0x14,

0xe0,

0xa5,

0x3d,

0x22,

0xb3,

0xf8,

0x89,

0xde,

0x71,

0x1a,

0xaf,

0xba,

0xb5,

0x81

0x52,

0x09,

0x6a,

0xd5,

0x30,

0x36,

0xa5,

0x38,

0xbf,

0x40,

0xa3,

0x9e,

0x81,

0xf3,

0xd7,

0xfb,

0x7c,

0xe3,

0x39,

0x82,

0x9b,

0x2f,

0xff,

0x87,

0x34,

0x8e,

0x43,

0x44,

0xc4,

0xde,

0xe9,

0xcb,

0x54,

0x7b,

0x94,

0x32,

0xa6,

0xc2,

0x23,

0x3d,

0xee,

0x4c,

0x95,

0x0b,

0x42,

0xfa,

0xc3,

0x4e,

0x08,

0x2e,

0xa1,

0x66,

0x28,

0xd9,

0x24,

0xb2,

0x76,

0x5b,

0xa2,

0x49,

0x6d,

0x8b,

0xd1,

0x25,

0x72,

0xf8,

0xf6,

0x64,

0x86,

0x68,

0x98,

0x16,

0xd4,

0xa4,

0x5c,

0xcc,

0x5d,

0x65,

0xb6,

0x92,

0x6c,

0x70,

0x48,

0x50,

0xfd,

0xed,

0xb9,

0xda,

0x5e,

0x15,

0x46,

0x57,

0xa7,

0x8d,

0x9d,

0x84,

0x90,

0xd8,

0xab,

0x00,

0x8c,

0xbc,

0xd3,

0x0a,

0xf7,

0xe4,

0x58,

0x05,

0xb8,

0xb3,

0x45,

0x06,

0xd0,

0x2c,

0x1e,

0x8f,

0xca,

0x3f,

0x0f,

0x02,

0xc1,

0xaf,

0xbd,

0x03,

0x01,

0x13,

0x8a,

0x6b,

0x3a,

0x91,

0x11,

0x41,

0x4f,

0x67,

0xdc,

0xea,

0x97,

0xf2,

0xcf,

0xce,

0xf0,

0xb4,

0xe6,

0x73,

0x96,

0xac,

0x74,

0x22,

0xe7,

0xad,

0x35,

0x85,

0xe2,

0xf9,

0x37,

0xe8,

0x1c,

0x75,

0xdf,

0x6e,

0x47,

0xf1,

0x1a,

0x71,

0x1d,

0x29,

0xc5,

0x89,

0x6f,

0xb7,

0x62,

0x0e,

0xaa,

0x18,

0xbe,

0x1b,

0xfc,

0x56,

0x3e,

0x4b,

0xc6,

0xd2,

0x79,

0x20,

0x9a,

0xdb,

0xc0,

0xfe,

0x78,

0xcd,

0x5a,

0xf4,

0x1f,

0xdd,

0xa8,

0x33,

0x88,

0x07,

0xc7,

0x31,

0xb1,

0x12,

0x10,

0x59,

0x27,

0x80,

0xec,

0x5f,

0x60,

0x51,

0x7f,

0xa9,

0x19,

0xb5,

0x4a,

0x0d,

0x2d,

0xe5,

0x7a,

0x9f,

0x93,

0xc9,

0x9c,

0xef,

0xa0,

0xe0,

0x3b,

0x4d,

0xae,

0x2a,

0xf5,

0xb0,

0xc8,

0xeb,

0xbb,

0x3c,

0x83,

0x53,

0x99,

0x61,

0x17,

0x2b,

0x04,

0x7e,

0xba,

0x77,

0xd6,

0x26,

0xe1,

0x69,

0x14,

0x63,

0x55,

0x21,

0x0c,

0x7d

0x30,

0x68,

0x99,

0x1b,

0x87,

0xb9,

0x21,

0x78,

0x50,

0x39,

0xdb,

0xe1,

0x72,

0x09,

0x62,

0x3c,

0x3e,

0x7e,

0x5e,

0x8e,

0xf1,

0xa0,

0xcc,

0xa3,

0x2a,

0x1d,

0xfb,

0xb6,

0xd6,

0x20,

0xc4,

0x8d,

0x81,

0x65,

0xf5,

0x89,

0xcb,

0x9d,

0x77,

0xc6,

0x57,

0x43,

0x56,

0x17,

0xd4,

0x40,

0x1a,

0x4d,

0xc0,

0x63,

0x6c,

0xe3,

0xb7,

0xc8,

0x64,

0x6a,

0x53,

0xaa,

0x38,

0x98,

0x0c,

0xf4,

0x9b,

0xed,

0x7f,

0x22,

0x76,

0xaf,

0xdd,

0x3a,

0x0b,

0x58,

0x67,

0x88,

0x06,

0xc3,

0x35,

0x0d,

0x01,

0x8b,

0x8c,

0xc2,

0xe6,

0x5f,

0x02,

0x24,

0x75,

0x93,

0x66,

0x1e,

0xe5,

0xe2,

0x54,

0xd8,

0x10,

0xce,

0x7a,

0xe8,

0x08,

0x2c,

0x12,

0x97,

0x32,

0xab,

0xb4,

0x27,

0x0a,

0x23,

0xdf,

0xef,

0xca,

0xd9,

0xb8,

0xfa,

0xdc,

0x31,

0x6b,

0xd1,

0xad,

0x19,

0x49,

0xbd,

0x51,

0x96,

0xee,

0xe4,

0xa8,

0x41,

0xda,

0xff,

0xcd,

0x55,

0x86,

0x36,

0xbe,

0x61,

0x52,

0xf8,

0xbb,

0x0e,

0x82,

0x48,

0x69,

0x9a,

0xe0,

0x47,

0x9e,

0x5c,

0x04,

0x4b,

0x34,

0x15,

0x79,

0x26,

0xa7,

0xde,

0x29,

0xae,

0x92,

0xd7,

0x84,

0xe9,

0xd2,

0xba,

0x5d,

0xf3,

0xc5,

0xb0,

0xbf,

0xa4,

0x3b,

0x71,

0x44,

0x46,

0x2b,

0xfc,

0xeb,

0x6f,

0xd5,

0xf6,

0x14,

0xfe,

0x7c,

0x70,

0x5a,

0x7d,

0xfd,

0x2f,

0x18,

0x83,

0x16,

0xa5,

0x91,

0x1f,

0x05,

0x95,

0x74,

0xa9,

0xc1,

0x5b,

0x4a,

0x85,

0x6d,

0x13,

0x07,

0x4f,

0x4e,

0x45,

0xb2,

0x0f,

0xc9,

0x1c,

0xa6,

0xbc,

0xec,

0x73,

0x90,

0x7b,

0xcf,

0x59,

0x8f,

0xa1,

0xf9,

0x2d,

0xf2,

0xb1,

0x00,

0x94,

0x37,

0x9f,

0xd0,

0x2e,

0x9c,

0x6e,

0x28,

0x3f,

0x80,

0xf0,

0x3d,

0xd3,

0x25,

0x8a,

0xb5,

0xe7,

0x42,

0xb3,

0xc7,

0xea,

0xf7,

0x4c,

0x11,

0x33,

0x03,

0xa2,

0xac,

0x60

0x51,

0x7c,

0xc1,

0xb7,

0x27,

0x22,

0x0a,

0x94,

0xfe,

0x13,

0xab,

0xe8,

0xfa,

0x9a,

0x6e,

0xe0

0x6d,

0xb1,

0x4a,

0xcc,

0x9e,

0x21,

0xc8,

0x20,

0xff,

0x28,

0xb1,

0xd5,

0xef,

0x5d,

0xe2,

0xb0

0xdb,

0x92,

0x37,

0x1d,

0x21,

0x26,

0xe9,

0x70,

0x03,

0x24,

0x97,

0x75,

0x04,

0xe8,

0xc9,

0x0e

Copyright 2006-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Copyright (c) 2017 National Security Resarch Institute. All rights reserved.

Size of each encryption/decription block

Number of keys needed in the worst case

www.openssl.org/source/license.html

License

C


Copyright 2011-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Why doesn't gcc define __ARM_ARCH__? Instead it defines bunch of below macros. See all_architectires[] table in gcc/config/arm/arm.c. On a side note it defines __ARMEL__/__ARMEB__ for little-/big-endian.

www.openssl.org/source/license.html

License

t gcc define __ARM_ARCH__? Instead it defines * bunch of below macros. See all_architectires[] table in * gcc/config/arm/arm.c. On a side note it defines * __ARMEL__/__ARMEB__ for little-/big-endian. */ # elif defined(__ARM_ARCH) # define __ARM_ARCH__ __ARM_ARCH # elif defined(__ARM_ARCH_8A__) # define __ARM_ARCH__ 8 # elif defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || \ defined(__ARM_ARCH_7R__)|| defined(__ARM_ARCH_7M__) || \ defined(__ARM_ARCH_7EM__) # define __ARM_ARCH__ 7 # elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || \ defined(__ARM_ARCH_6K__)|| defined(__ARM_ARCH_6M__) || \ defined(__ARM_ARCH_6Z__)|| defined(__ARM_ARCH_6ZK__) || \ defined(__ARM_ARCH_6T2__) # define __ARM_ARCH__ 6 # elif defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) || \ defined(__ARM_ARCH_5E__)|| defined(__ARM_ARCH_5TE__) || \ defined(__ARM_ARCH_5TEJ__) # define __ARM_ARCH__ 5 # elif defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__) # define __ARM_ARCH__ 4 # else # error "unsupported ARM architecture" # endif # endif # endif # if !defined(__ARM_MAX_ARCH__) # define __ARM_MAX_ARCH__ __ARM_ARCH__ # endif # if __ARM_MAX_ARCH__<__ARM_ARCH__ # error "__ARM_MAX_ARCH__ can

# elif __ARM_MAX_ARCH__!=__ARM_ARCH__ # if __ARM_ARCH__<7 && __ARM_MAX_ARCH__>=7 && defined(__ARMEB__) # error


Copyright 2011-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Following subroutines could have been inlined, but it's not all ARM compilers support inline assembler...

Use a weak reference to getauxval() so we can use it if it is available but don't break the build if it is not.

ARM puts the feature bits for Crypto Extensions in AT_HWCAP2, whereas AArch64 used AT_HWCAP.

AT_HWCAP

AT_HWCAP2

AT_HWCAP

Capability probing by catching SIGILL appears to be problematic on iOS. But since Apple universe is "monocultural", it's actually possible to simply set pre-defined processor capability mask.

One could do same even for __aarch64__ iOS builds. It's not done exclusively for reasons of keeping code unified across platforms. Unified code works because it never triggers SIGILL on Apple devices...

www.openssl.org/source/license.html

License

arm_arch.h

s not all * ARM compilers support inline assembler... */ void _armv7_neon_probe(void); void _armv8_aes_probe(void); void _armv8_sha1_probe(void); void _armv8_sha256_probe(void); void _armv8_pmull_probe(void); unsigned long _armv7_tick(void); unsigned long OPENSSL_rdtsc(void) { if (OPENSSL_armcap_P & ARMV7_TICK) return _armv7_tick(); else return 0; } # if defined(__GNUC__) && __GNUC__>=2 void OPENSSL_cpuid_setup(void) __attribute__ ((constructor)); # endif /* * Use a weak reference to getauxval() so we can use it if it is available but * don

OPENSSL_armcap

monocultural

s actually * possible to simply set pre-defined processor capability mask. */ if (1) { OPENSSL_armcap_P = ARMV7_NEON; return; } /* * One could do same even for __aarch64__ iOS builds. It


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL licenses, (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.openssl.org/source/license.html or in the file LICENSE in the source distribution.

Fuzz ASN.1 parsing for various data structures. Specify which on the command line: asn1 <data structure>

SN1_ITEM_ref(TS_RESP), want to do this, but type is hidden, however d2i exists...

www.openssl.org/source/license.html

License

fuzzer.h

rand.inc

0x10200000L

0x10200000L

Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ompa

let the recipient choose

used in ASN1_TYPE

used in ASN1 template code

ASN.1 tag values





alias









alias





NB the constants below are used internally by ASN1_INTEGER and ASN1_ENUMERATED to indicate the sign. They are not on the wire tag values.

For use with d2i_ASN1_type_bytes()

For use with ASN1_mbstring_copy()

Set if 0x07 has bits left value

This indicates that the ASN1_STRING is not a real value but just a place holder for the location where indefinite length constructed data should be inserted in the memory buffer

This flag is used by the CMS code to indicate that a string is not complete and is a place holder for content when it had all been accessed. The flag will be reset when content has been written to it.

This flag is used by ASN1 code to indicate an ASN1_STRING is an MSTRING type.

String is embedded and only content should be freed

String should be parsed in RFC 5280's time format

This is the base type that holds just about everything :-)

The value of the following field depends on the type being held. It is mostly being used for BIT_STRING so if the input data has a non-zero 'unused bits' value, it will be handled correctly

ASN1_ENCODING structure: this is used to save the received encoding of an ASN1 type. This is useful to get round problems with invalid encodings which can break signatures.

DER encoding

Length of encoding

set to 1 if 'enc' is invalid

Used with ASN1 LONG type: if a long is set to this it is omitted

A zero passed to ASN1_STRING_TABLE_new_add for the flags is interpreted as "don't change" and STABLE_FLAGS_MALLOC is always set. By setting STABLE_FLAGS_MALLOC only we can clear the existing value. Use the alias STABLE_FLAGS_CLEAR to reflect this.

size limits: this stuff is taken straight from RFC2459

Declarations for template structures: for full definitions see asn1t.h

This is just an opaque pointer

Declare ASN1 functions: the implement macro in in asn1t.h

The following macros and typedefs allow an ASN1_ITEM to be embedded in a structure and referenced. Since the ASN1_ITEM pointers need to be globally accessible (possibly from shared libraries) they may exist in different forms. On platforms that support it the ASN1_ITEM structure itself will be globally exported. Other platforms will export a function that returns an ASN1_ITEM pointer. To handle both cases transparently the macros below should be used instead of hard coding an ASN1_ITEM pointer in a structure. The structure will look like this: typedef struct SOMETHING_st { ... ASN1_ITEM_EXP iptr; ... } SOMETHING; It would be initialised as e.g.: SOMETHING somevar = {...,ASN1_ITEM_ref(X509),...}; and the actual pointer extracted with: const ASN1_ITEM it = ASN1_ITEM_ptr(somevar.iptr); Finally an ASN1_ITEM pointer can be extracted from an appropriate reference with: ASN1_ITEM_rptr(X509). This would be used when a function takes an ASN1_ITEM argument.

ASN1_ITEM pointer exported type

Macro to obtain ASN1_ITEM pointer from exported type

Macro to include ASN1_ITEM pointer from base type

Platforms that can't easily handle shared global variables are declared as functions returning ASN1_ITEM pointers.

ASN1_ITEM pointer exported type

Macro to obtain ASN1_ITEM pointer from exported type

Macro to include ASN1_ITEM pointer from base type

Parameters used by ASN1_STRING_print_ex()

These determine which characters to escape: RFC2253 special characters, control characters and MSB set characters

This flag determines how we do escaping: normally RC2253 backslash only, set this to use backslash and quote.

These three flags are internal use only.

Character is a valid PrintableString character

Character needs escaping if it is the first character

Character needs escaping if it is the last character

NB the internal flags are safely reused below by flags handled at the top level.

If this is set we convert all character strings to UTF8 first

If this is set we don't attempt to interpret content: just assume all strings are 1 byte per character. This will produce some pretty odd looking output!

If this is set we include the string type in the output

This determines which strings to display and which to 'dump' (hex dump of content octets or DER encoding). We can only dump non character strings or everything. If we don't dump 'unknown' they are interpreted as character strings with 1 octet per character and are subject to the usual escaping options.

These determine what 'dumping' does, we can dump the content octets or the DER encoding: both use the RFC2253 #XXXXX notation.

This flag specifies that RC2254 escaping shall be performed.

All the string flags consistent with RFC2253, escaping control characters isn't essential in RFC2253 but it is advisable anyway.

set and sequence are left complete and still contain the set or sequence bytes

This is used to contain a list of bit names

Since this is used to store all sorts of things, via macros, for now, make its data void

General

given a string, return the correct type, max is the maximum length

SPECIALS

Used to implement other functions

ASN1 alloc/free macros for when a type is only used internally

Used to load and write Netscape format cert

ASN1 template functions

Old API compatible functions

ASN1 Print flags

Indicate missing OPTIONAL fields

Mark start and end of SEQUENCE

Mark start and end of SEQUENCE/SET OF

Show the ASN1 type of primitives

Don't show ASN1 type of ANY

Don't show ASN1 type of MSTRINGs

Don't show field names in SEQUENCE

Show structure names of each SEQUENCE field

Don't show structure name even at top level

www.openssl.org/source/license.html

License

C

s time format */ # define ASN1_STRING_FLAG_X509_TIME 0x100 /* This is the base type that holds just about everything :-) */ struct asn1_string_st { int length; int type; unsigned char *data; /* * The value of the following field depends on the type being held. It * is mostly being used for BIT_STRING so if the input data has a * non-zero

value, it will be handled correctly */ long flags; }; /* * ASN1_ENCODING structure: this is used to save the received encoding of an * ASN1 type. This is useful to get round problems with invalid encodings * which can break signatures. */ typedef struct ASN1_ENCODING_st { unsigned char *enc; /* DER encoding */ long len; /* Length of encoding */ int modified; /* set to 1 if

is invalid */ } ASN1_ENCODING; /* Used with ASN1 LONG type: if a long is set to this it is omitted */ # define ASN1_LONG_UNDEF 0x7fffffffL # define STABLE_FLAGS_MALLOC 0x01 /* * A zero passed to ASN1_STRING_TABLE_new_add for the flags is interpreted * as "don

t easily handle shared global variables are declared as * functions returning ASN1_ITEM pointers. */ /* ASN1_ITEM pointer exported type */ typedef const ASN1_ITEM *ASN1_ITEM_EXP (void); /* Macro to obtain ASN1_ITEM pointer from exported type */ # define ASN1_ITEM_ptr(iptr) (iptr()) /* Macro to include ASN1_ITEM pointer from base type */ # define ASN1_ITEM_ref(iptr) (iptr##_it) # define ASN1_ITEM_rptr(ref) (ref##_it()) # define DECLARE_ASN1_ITEM(name) \ const ASN1_ITEM * name##_it(void); # endif /* Parameters used by ASN1_STRING_print_ex() */ /* * These determine which characters to escape: RFC2253 special characters, * control characters and MSB set characters */ # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 /* * This flag determines how we do escaping: normally RC2253 backslash only, * set this to use backslash and quote. */ # define ASN1_STRFLGS_ESC_QUOTE 8 /* These three flags are internal use only. */ /* Character is a valid PrintableString character */ # define CHARTYPE_PRINTABLESTRING 0x10 /* Character needs escaping if it is the first character */ # define CHARTYPE_FIRST_ESC_2253 0x20 /* Character needs escaping if it is the last character */ # define CHARTYPE_LAST_ESC_2253 0x40 /* * NB the internal flags are safely reused below by flags handled at the top * level. */ /* * If this is set we convert all character strings to UTF8 first */ # define ASN1_STRFLGS_UTF8_CONVERT 0x10 /* * If this is set we don

dump

t dump

they are interpreted as character * strings with 1 octet per character and are subject to the usual escaping * options. */ # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 /* * These determine what

does, we can dump the content octets or the * DER encoding: both use the RFC2253 #XXXXX notation. */ # define ASN1_STRFLGS_DUMP_DER 0x200 /* * This flag specifies that RC2254 escaping shall be performed. */ #define ASN1_STRFLGS_ESC_2254 0x400 /* * All the string flags consistent with RFC2253, escaping control characters * isn

t show ASN1 type of ANY */ # define ASN1_PCTX_FLAGS_NO_ANY_TYPE 0x010 /* Don

t show field names in SEQUENCE */ # define ASN1_PCTX_FLAGS_NO_FIELD_NAME 0x040 /* Show structure names of each SEQUENCE field */ # define ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME 0x080 /* Don

0x10100000L

0x00

0x40

0x80

0xc0

0x20

0x1f

0x100

0x0001

0x0002

0x0004

0x0004

0x0008

0x0010

0x0020

0x0040

0x0040

0x0080

0x0100

0x0200

0x0400

0x0800

0x1000

0x2000

0x4000

0x8000

0x10000

0x1000

0x400

0x800

0x1000

0x08/*

0x07

0x010

0x020

0x040

0x080

0x100

0x7fffffffL

0x01

0x02

0x10

0x20

0x40

0x10

0x20

0x40

0x80

0x100

0x200

0x400

0x001

0x002

0x004

0x008

0x010

0x020

0x040

0x080

0x100


Copyright 2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Custom test data

We conduct tests with these arrays for every type we try out. You will find the expected results together with the test structures for each type, further down.

32-bit long

We make the last byte 0xfe to avoid a clash with ASN1_LONG_UNDEF

Type specific test data

First, a few utility things that all type specific data can use, or in some cases, MUST use.

For easy creation of arrays of expected data. These macros correspond to the uses of CUSTOM_DATA above.

A structure to collect all test information in. There MUST be one instance of this for each test

1 if this package should be skipped

An array of structures to compare decoded custom data with

An array of structures that are encoded into a DER blob, which is then decoded, and result gets compared with the original.

The i2d function to use with this type

The d2i function to use with this type

Function to free a decoded structure

To facilitate the creation of an encdec_data array

LONG

If decoding is expected to succeed, set this to 1, otherwise 0

The following should fail on the second because it's the default

t_zero

t_longundef

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1 (too large positive)

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

Check that default numbers fail

The following should fail on the second because it's the default

t_zero

t_longundef

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad (illegal padding)

t_8bytes_4_neg

t_8bytes_5_negpad (illegal padding)

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

Check that default numbers fail

INT32

t_zero

t_zero

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1 (too large positive)

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

UINT32

t_zero

t_zero

t_one

t_one_neg (illegal negative value)

t_minus_256 (illegal negative value)

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg (illegal negative value)

t_4bytes_5_negpad (illegal padding)

INT64

t_zero

t_zero

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1 (too large positive)

t_8bytes_2

t_8bytes_3_pad (illegal padding)

t_8bytes_4_neg

t_8bytes_5_negpad (illegal padding)

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

UINT64

t_zero

t_zero

t_one

t_one_neg (illegal negative value)

t_minus_256 (illegal negative value)

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg (illegal negative value)

t_4bytes_5_negpad (illegal padding)

General testing functions

Template structure to map onto any test data structure

In reality, there's more

do_decode returns a tristate: -1 Couldn't decode 0 decoded structure wasn't what was expected (failure) 1 decoded structure was what was expected (success)

do_encode returns a tristate: -1 Couldn't encode 0 encoded DER wasn't what was expected (failure) 1 encoded DER was what was expected (success)

Do an encode/decode round trip

The first item is just an INTEGER tag, INTEGER length and INTEGER content

The second item is an explicit tag, content length, INTEGER tag, INTEGER length, INTEGER bytes

The whole sequence is the sequence tag, content length, BOOLEAN true (copied from t_true), the first (firstbytes) and second (secondbytes) items

Sequence tag

ASN1_BOOLEAN TRUE

Marks decoding success

First INTEGER item (non-optional)

Second INTEGER item (optional)

Start with the explicit optional tag

Attempt to decode a custom encoding of the test structure

We force the defaults to be explicitly encoded to make sure we test for defaults that shouldn't be present (i.e. we check for failure)

Attempt to encode the test structure and compare it to custom DER

Do decode_custom checks

Do enc_dec checks

www.openssl.org/source/license.html

License

internal/numbers.h

testutil.h

-Wunused-function

-Wformat

-Wunused-function

-Wformat

s the default */ { 0xff, 0, 1 }, { 0, 0, 0 }, /* t_zero */ { 0, 0, 0 }, { 0xff, 1, 0x7fffffff }, /* t_longundef */ CUSTOM_EXPECTED_SUCCESS(1, 1), /* t_one */ CUSTOM_EXPECTED_SUCCESS(-1, -1), /* t_one_neg */ CUSTOM_EXPECTED_SUCCESS(-256, -256), /* t_minus_256 */ CUSTOM_EXPECTED_FAILURE, /* t_9bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_2 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_3_pad */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_4_neg */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_5_negpad */ CUSTOM_EXPECTED_FAILURE, /* t_5bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_1 (too large positive) */ CUSTOM_EXPECTED_SUCCESS(INT32_MAX - 1, INT32_MAX -1), /* t_4bytes_2 */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_3_pad (illegal padding) */ CUSTOM_EXPECTED_SUCCESS(INT32_MIN, INT32_MIN), /* t_4bytes_4_neg */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_5_negpad (illegal padding) */ }; static ASN1_LONG_DATA long_encdec_data_32bit[] = { ENCDEC_ARRAY(LONG_MAX - 1, LONG_MAX, LONG_MIN, LONG_MIN), /* Check that default numbers fail */ { 0, ASN1_LONG_UNDEF, 1 }, { 0, 1, 0 } }; static TEST_PACKAGE long_test_package_32bit = { ASN1_ITEM_ref(ASN1_LONG_DATA), "LONG", sizeof(long) != 4, long_expected_32bit, sizeof(long_expected_32bit), sizeof(long_expected_32bit[0]), long_encdec_data_32bit, sizeof(long_encdec_data_32bit), sizeof(long_encdec_data_32bit[0]), (i2d_fn *)i2d_ASN1_LONG_DATA, (d2i_fn *)d2i_ASN1_LONG_DATA, (ifree_fn *)ASN1_LONG_DATA_free }; static ASN1_LONG_DATA long_expected_64bit[] = { /* The following should fail on the second because it

LONG

INT32

UINT32

INT64

UINT64

s more */ } EXPECTED; /* * do_decode returns a tristate: * * -1 Couldn

t what was expected (failure) * 1 decoded structure was what was expected (success) */ static int do_decode(unsigned char *bytes, long nbytes, const EXPECTED *expected, size_t expected_size, const TEST_PACKAGE *package) { EXPECTED *enctst = NULL; const unsigned char *start; int ret = 0; start = bytes; enctst = package->d2i(NULL, &bytes, nbytes); if (enctst == NULL) { if (expected->success == 0) { ret = 1; ERR_clear_error(); } else { ret = -1; } } else { if (start + nbytes == bytes && memcmp(enctst, expected, expected_size) == 0) ret = 1; else ret = 0; } package->ifree(enctst); return ret; } /* * do_encode returns a tristate: * * -1 Couldn

t what was expected (failure) * 1 encoded DER was what was expected (success) */ static int do_encode(EXPECTED *input, const unsigned char *expected, size_t expected_len, const TEST_PACKAGE *package) { unsigned char *data = NULL; int len; int ret = 0; len = package->i2d(input, &data); if (len < 0) return -1; if ((size_t)len != expected_len || memcmp(data, expected, expected_len) != 0) { if (input->success == 0) { ret = 1; ERR_clear_error(); } else { ret = 0; } } else { ret = 1; } OPENSSL_free(data); return ret; } /* Do an encode/decode round trip */ static int do_enc_dec(EXPECTED *bytes, long nbytes, const TEST_PACKAGE *package) { unsigned char *data = NULL; int len; int ret = 0; void *p = bytes; len = package->i2d(p, &data); if (len < 0) return -1; ret = do_decode(data, len, bytes, nbytes, package); OPENSSL_free(data); return ret; } static size_t der_encode_length(size_t len, unsigned char **pp) { size_t lenbytes; OPENSSL_assert(len < 0x8000); if (len > 255) lenbytes = 3; else if (len > 127) lenbytes = 2; else lenbytes = 1; if (pp != NULL) { if (lenbytes == 1) { *(*pp)++ = len; } else { *(*pp)++ = lenbytes - 1; if (lenbytes == 2) { *(*pp)++ = 0x80 | len; } else { *(*pp)++ = 0x80 | (len >> 8); *(*pp)++ = len & 0xff; } } } return lenbytes; } static size_t make_custom_der(const TEST_CUSTOM_DATA *custom_data, unsigned char **encoding, int explicit_default) { size_t firstbytes, secondbytes = 0, secondbytesinner = 0, seqbytes; const unsigned char t_true[] = { V_ASN1_BOOLEAN, 0x01, 0xff }; unsigned char *p = NULL; size_t i; /* * The first item is just an INTEGER tag, INTEGER length and INTEGER content */ firstbytes = 1 + der_encode_length(custom_data->nbytes1, NULL) + custom_data->nbytes1; for (i = custom_data->nbytes2; i > 0; i--) { if (custom_data->bytes2[i - 1] !=

) break; } if (explicit_default || i > 0) { /* * The second item is an explicit tag, content length, INTEGER tag, * INTEGER length, INTEGER bytes */ secondbytesinner = 1 + der_encode_length(custom_data->nbytes2, NULL) + custom_data->nbytes2; secondbytes = 1 + der_encode_length(secondbytesinner, NULL) + secondbytesinner; } /* * The whole sequence is the sequence tag, content length, BOOLEAN true * (copied from t_true), the first (firstbytes) and second (secondbytes) * items */ seqbytes = 1 + der_encode_length(sizeof(t_true) + firstbytes + secondbytes, NULL) + sizeof(t_true) + firstbytes + secondbytes; *encoding = p = OPENSSL_malloc(seqbytes); if (*encoding == NULL) return 0; /* Sequence tag */ *p++ = 0x30; der_encode_length(sizeof(t_true) + firstbytes + secondbytes, &p); /* ASN1_BOOLEAN TRUE */ memcpy(p, t_true, sizeof(t_true)); /* Marks decoding success */ p += sizeof(t_true); /* First INTEGER item (non-optional) */ *p++ = V_ASN1_INTEGER; der_encode_length(custom_data->nbytes1, &p); memcpy(p, custom_data->bytes1, custom_data->nbytes1); p += custom_data->nbytes1; if (secondbytes > 0) { /* Second INTEGER item (optional) */ /* Start with the explicit optional tag */ *p++ = 0xa0; der_encode_length(secondbytesinner, &p); *p++ = V_ASN1_INTEGER; der_encode_length(custom_data->nbytes2, &p); memcpy(p, custom_data->bytes2, custom_data->nbytes2); p += custom_data->nbytes2; } OPENSSL_assert(seqbytes == (size_t)(p - *encoding)); return seqbytes; } /* Attempt to decode a custom encoding of the test structure */ static int do_decode_custom(const TEST_CUSTOM_DATA *custom_data, const EXPECTED *expected, size_t expected_size, const TEST_PACKAGE *package) { unsigned char *encoding = NULL; /* * We force the defaults to be explicitly encoded to make sure we test * for defaults that shouldn

Failed custom encode round trip %u of %s

Custom encode round trip %u of %s mismatch

do_encode_custom() return unknown value

Failed custom decode round trip %u of %s

Custom decode round trip %u of %s mismatch

do_decode_custom() return unknown value

Failed encode/decode round trip %u of %s

Encode/decode round trip %u of %s mismatch

do_enc_dec() return unknown value

Printing of %s failed

0x00

0x01

0xff

0xff,

0x00

0x7f,

0xff,

0xff,

0xff

0x01,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x00,

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x7f,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x00,

0x7f,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0xff,

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x01,

0xff,

0xff,

0xff,

0xff

0x00,

0x80,

0x00,

0x00,

0x00

0xfe

0x7f,

0xff,

0xff,

0xfe

0x00,

0x7f,

0xff,

0xff,

0xfe

0x80,

0x00,

0x00,

0x00

0xff,

0x80,

0x00,

0x00,

0x00

0xff,

0xff,

0xff,

0xff,

0x10200000L

0xff,

0xff,

0x7fffffff

0xff,

0xff,

0x7fffffff

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x80000000,

0x80000000),

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x8000);

0x80

0x80

0xff;

0x01,

0xff

0x30;

0xa0;

0x10200000L

0x10200000L


Generated by util/mkerr.pl DO NOT EDIT Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

a2d_ASN1_OBJECT

a2i_ASN1_INTEGER

a2i_ASN1_STRING

append_exp

ASN1_BIT_STRING_set_bit

asn1_cb

asn1_check_tlen

asn1_collect

asn1_d2i_ex_primitive

ASN1_d2i_fp

asn1_d2i_read_bio

ASN1_digest

asn1_do_adb

asn1_do_lock

ASN1_dup

asn1_ex_c2i

asn1_find_end

ASN1_GENERALIZEDTIME_adj

ASN1_generate_v3

asn1_get_int64

ASN1_get_object

asn1_get_uint64

ASN1_i2d_bio

ASN1_i2d_fp

ASN1_item_d2i_fp

ASN1_item_dup

asn1_item_embed_d2i

asn1_item_embed_new

ASN1_item_i2d_bio

ASN1_item_i2d_fp

ASN1_item_pack

ASN1_item_sign

ASN1_item_sign_ctx

ASN1_item_unpack

ASN1_item_verify

ASN1_mbstring_ncopy

ASN1_OBJECT_new

asn1_output_data

ASN1_PCTX_new

ASN1_SCTX_new

ASN1_sign

asn1_str2type

asn1_string_get_int64

asn1_string_get_uint64

ASN1_STRING_set

ASN1_STRING_TABLE_add

asn1_string_to_bn

ASN1_STRING_type_new

asn1_template_ex_d2i

asn1_template_new

asn1_template_noexp_d2i

ASN1_TIME_adj

ASN1_TYPE_get_int_octetstring

ASN1_TYPE_get_octetstring

ASN1_UTCTIME_adj

ASN1_verify

b64_read_asn1

B64_write_ASN1

BIO_new_NDEF

bitstr_cb

bn_to_asn1_string

c2i_ASN1_BIT_STRING

c2i_ASN1_INTEGER

c2i_ASN1_OBJECT

c2i_ibuf

c2i_uint64_int

collect_data

d2i_ASN1_OBJECT

d2i_ASN1_UINTEGER

d2i_AutoPrivateKey

d2i_PrivateKey

d2i_PublicKey

do_tcreate

i2d_ASN1_bio_stream

i2d_DSA_PUBKEY

i2d_EC_PUBKEY

i2d_PrivateKey

i2d_PublicKey

i2d_RSA_PUBKEY

long_c2i

oid_module_init

parse_tagging

PKCS5_pbe2_set_iv

PKCS5_pbe2_set_scrypt

PKCS5_pbe_set

PKCS5_pbe_set0_algor

PKCS5_pbkdf2_set

pkcs5_scrypt_set

SMIME_read_ASN1

SMIME_text

stbl_module_init

uint32_c2i

uint64_c2i

X509_CRL_add0_revoked

X509_INFO_new

x509_name_encode

x509_name_ex_d2i

x509_name_ex_new

X509_PKEY_new

adding object

asn1 parse error

asn1 sig parse error

aux error

bad object header

bmpstring is wrong length

bn lib

boolean is wrong length

buffer too small

cipher has no object identifier

context not initialised

data is wrong

decode error

depth exceeded

digest and key type not supported

encode error

error getting time

error loading section

error setting cipher params

expecting an integer

expecting an object

explicit length mismatch

explicit tag not constructed

field missing

first num too large

header too long

illegal bitstring format

illegal boolean

illegal characters

illegal format

illegal hex

illegal implicit tag

illegal integer

illegal negative value

illegal nested tagging

illegal null

illegal null value

illegal object

illegal optional any

illegal options on item template

illegal padding

illegal tagged any

illegal time value

illegal zero content

integer not ascii format

integer too large for long

invalid bit string bits left

invalid bmpstring length

invalid digit

invalid mime type

invalid modifier

invalid number

invalid object encoding

invalid scrypt parameters

invalid separator

invalid string table value

invalid universalstring length

invalid utf8string

invalid value

list error

mime no content type

mime parse error

mime sig parse error

missing eoc

missing second number

missing value

mstring not universal

mstring wrong tag

nested asn1 string

non hex characters

not ascii format

not enough data

no content type

no matching choice type

no multipart body failure

no multipart boundary

no sig content type

null is wrong length

object not ascii format

odd number of chars

second number too large

sequence length mismatch

sequence not constructed

sequence or set needs config

short line

sig invalid mime type

streaming not supported

string too long

string too short

the asn1 object identifier is not known for this md

time not ascii format

too large

too long

too small

type not constructed

type not primitive

unexpected eoc

universalstring is wrong length

unknown format

unknown message digest algorithm

unknown object type

unknown public key type

unknown signature algorithm

unknown tag

unsupported any defined by type

unsupported public key type

unsupported type

wrong integer type

wrong public key type

wrong tag


Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Maximum number of nested sequences

Input formats

ASCII: default

UTF8

Hex

List of bits

If no tagging return base type

Generate the encoding

Set point to start copying for modified encoding

Do we need IMPLICIT tagging?

If IMPLICIT we will replace the underlying tag

Skip existing tag+len

Update copy length

For IMPLICIT tagging the length should match the original length and constructed flag should be consistent.

Indefinite length constructed

Just retain constructed flag

Work out new length with IMPLICIT tag: ignore constructed because it will mess up if indefinite length

Work out length in any EXPLICIT, starting from end

Content length: number of content octets + any padding

Total object length: length including new header

Allocate buffer for new encoding

Generate tagged encoding

Output explicit tags first

If IMPLICIT, output tag

Copy across original encoding

Obtain new ASN1_TYPE structure

Look for the ':' in name value pairs

If this is not a modifier mark end of string and exit

If no value and not end of string, error

Check for illegal multiple IMPLICIT tagging

Check we haven't gone past max length: should be impossible

If we have non numeric characters, parse them

Handle multiple types: SET and SEQUENCE

Now we has a STACK of the components, convert to the correct form

Can only have IMPLICIT if permitted

If IMPLICIT set tag to implicit value then reset implicit tag since it has been used.

Special cases

type modifiers

Explicit tag

Implicit tag

OCTET STRING wrapper

SEQUENCE wrapper

SET wrapper

BIT STRING wrapper

www.openssl.org/source/license.html

License

internal/cryptlib.h

,

:

:

tag=

ASCII

UTF8

HEX

BITLIST

t gone past max length: should be impossible */ if (eptr && *eptr && (eptr > vstart + vlen)) return 0; if (tag_num < 0) { ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER); return 0; } *ptag = tag_num; /* If we have non numeric characters, parse them */ if (eptr) vlen -= eptr - vstart; else vlen = 0; if (vlen) { switch (*eptr) { case

: *pclass = V_ASN1_UNIVERSAL; break; case

: *pclass = V_ASN1_APPLICATION; break; case

: *pclass = V_ASN1_PRIVATE; break; case

: *pclass = V_ASN1_CONTEXT_SPECIFIC; break; default: erch[0] = *eptr; erch[1] = 0; ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER); ERR_add_error_data(2, "Char=", erch); return 0; } } else *pclass = V_ASN1_CONTEXT_SPECIFIC; return 1; } /* Handle multiple types: SET and SEQUENCE */ static ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf, int depth, int *perr) { ASN1_TYPE *ret = NULL; STACK_OF(ASN1_TYPE) *sk = NULL; STACK_OF(CONF_VALUE) *sect = NULL; unsigned char *der = NULL; int derlen; int i; sk = sk_ASN1_TYPE_new_null(); if (!sk) goto bad; if (section) { if (!cnf) goto bad; sect = X509V3_get_section(cnf, (char *)section); if (!sect) goto bad; for (i = 0; i < sk_CONF_VALUE_num(sect); i++) { ASN1_TYPE *typ = generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf, depth + 1, perr); if (!typ) goto bad; if (!sk_ASN1_TYPE_push(sk, typ)) goto bad; } } /* * Now we has a STACK of the components, convert to the correct form */ if (utype == V_ASN1_SET) derlen = i2d_ASN1_SET_ANY(sk, &der); else derlen = i2d_ASN1_SEQUENCE_ANY(sk, &der); if (derlen < 0) goto bad; if ((ret = ASN1_TYPE_new()) == NULL) goto bad; if ((ret->value.asn1_string = ASN1_STRING_type_new(utype)) == NULL) goto bad; ret->type = utype; ret->value.asn1_string->data = der; ret->value.asn1_string->length = derlen; der = NULL; bad: OPENSSL_free(der); sk_ASN1_TYPE_pop_free(sk, ASN1_TYPE_free); X509V3_section_free(cnf, sect); return ret; } static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed, int exp_pad, int imp_ok) { tag_exp_type *exp_tmp; /* Can only have IMPLICIT if permitted */ if ((arg->imp_tag != -1) && !imp_ok) { ASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG); return 0; } if (arg->exp_count == ASN1_FLAG_EXP_MAX) { ASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED); return 0; } exp_tmp = &arg->exp_list[arg->exp_count++]; /* * If IMPLICIT set tag to implicit value then reset implicit tag since it * has been used. */ if (arg->imp_tag != -1) { exp_tmp->exp_tag = arg->imp_tag; exp_tmp->exp_class = arg->imp_class; arg->imp_tag = -1; arg->imp_class = -1; } else { exp_tmp->exp_tag = exp_tag; exp_tmp->exp_class = exp_class; } exp_tmp->exp_constructed = exp_constructed; exp_tmp->exp_pad = exp_pad; return 1; } static int asn1_str2tag(const char *tagstr, int len) { unsigned int i; static const struct tag_name_st *tntmp, tnst[] = { ASN1_GEN_STR("BOOL", V_ASN1_BOOLEAN), ASN1_GEN_STR("BOOLEAN", V_ASN1_BOOLEAN), ASN1_GEN_STR("NULL", V_ASN1_NULL), ASN1_GEN_STR("INT", V_ASN1_INTEGER), ASN1_GEN_STR("INTEGER", V_ASN1_INTEGER), ASN1_GEN_STR("ENUM", V_ASN1_ENUMERATED), ASN1_GEN_STR("ENUMERATED", V_ASN1_ENUMERATED), ASN1_GEN_STR("OID", V_ASN1_OBJECT), ASN1_GEN_STR("OBJECT", V_ASN1_OBJECT), ASN1_GEN_STR("UTCTIME", V_ASN1_UTCTIME), ASN1_GEN_STR("UTC", V_ASN1_UTCTIME), ASN1_GEN_STR("GENERALIZEDTIME", V_ASN1_GENERALIZEDTIME), ASN1_GEN_STR("GENTIME", V_ASN1_GENERALIZEDTIME), ASN1_GEN_STR("OCT", V_ASN1_OCTET_STRING), ASN1_GEN_STR("OCTETSTRING", V_ASN1_OCTET_STRING), ASN1_GEN_STR("BITSTR", V_ASN1_BIT_STRING), ASN1_GEN_STR("BITSTRING", V_ASN1_BIT_STRING), ASN1_GEN_STR("UNIVERSALSTRING", V_ASN1_UNIVERSALSTRING), ASN1_GEN_STR("UNIV", V_ASN1_UNIVERSALSTRING), ASN1_GEN_STR("IA5", V_ASN1_IA5STRING), ASN1_GEN_STR("IA5STRING", V_ASN1_IA5STRING), ASN1_GEN_STR("UTF8", V_ASN1_UTF8STRING), ASN1_GEN_STR("UTF8String", V_ASN1_UTF8STRING), ASN1_GEN_STR("BMP", V_ASN1_BMPSTRING), ASN1_GEN_STR("BMPSTRING", V_ASN1_BMPSTRING), ASN1_GEN_STR("VISIBLESTRING", V_ASN1_VISIBLESTRING), ASN1_GEN_STR("VISIBLE", V_ASN1_VISIBLESTRING), ASN1_GEN_STR("PRINTABLESTRING", V_ASN1_PRINTABLESTRING), ASN1_GEN_STR("PRINTABLE", V_ASN1_PRINTABLESTRING), ASN1_GEN_STR("T61", V_ASN1_T61STRING), ASN1_GEN_STR("T61STRING", V_ASN1_T61STRING), ASN1_GEN_STR("TELETEXSTRING", V_ASN1_T61STRING), ASN1_GEN_STR("GeneralString", V_ASN1_GENERALSTRING), ASN1_GEN_STR("GENSTR", V_ASN1_GENERALSTRING), ASN1_GEN_STR("NUMERIC", V_ASN1_NUMERICSTRING), ASN1_GEN_STR("NUMERICSTRING", V_ASN1_NUMERICSTRING), /* Special cases */ ASN1_GEN_STR("SEQUENCE", V_ASN1_SEQUENCE), ASN1_GEN_STR("SEQ", V_ASN1_SEQUENCE), ASN1_GEN_STR("SET", V_ASN1_SET), /* type modifiers */ /* Explicit tag */ ASN1_GEN_STR("EXP", ASN1_GEN_FLAG_EXP), ASN1_GEN_STR("EXPLICIT", ASN1_GEN_FLAG_EXP), /* Implicit tag */ ASN1_GEN_STR("IMP", ASN1_GEN_FLAG_IMP), ASN1_GEN_STR("IMPLICIT", ASN1_GEN_FLAG_IMP), /* OCTET STRING wrapper */ ASN1_GEN_STR("OCTWRAP", ASN1_GEN_FLAG_OCTWRAP), /* SEQUENCE wrapper */ ASN1_GEN_STR("SEQWRAP", ASN1_GEN_FLAG_SEQWRAP), /* SET wrapper */ ASN1_GEN_STR("SETWRAP", ASN1_GEN_FLAG_SETWRAP), /* BIT STRING wrapper */ ASN1_GEN_STR("BITWRAP", ASN1_GEN_FLAG_BITWRAP), ASN1_GEN_STR("FORM", ASN1_GEN_FLAG_FORMAT), ASN1_GEN_STR("FORMAT", ASN1_GEN_FLAG_FORMAT), }; if (len == -1) len = strlen(tagstr); tntmp = tnst; for (i = 0; i < OSSL_NELEM(tnst); i++, tntmp++) { if ((len == tntmp->len) && (strncmp(tntmp->strnam, tagstr, len) == 0)) return tntmp->tag; } return -1; } static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype) { ASN1_TYPE *atmp = NULL; CONF_VALUE vtmp; unsigned char *rdata; long rdlen; int no_unused = 1; if ((atmp = ASN1_TYPE_new()) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE); return NULL; } if (!str) str = ""; switch (utype) { case V_ASN1_NULL: if (str && *str) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE); goto bad_form; } break; case V_ASN1_BOOLEAN: if (format != ASN1_GEN_FORMAT_ASCII) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT); goto bad_form; } vtmp.name = NULL; vtmp.section = NULL; vtmp.value = (char *)str; if (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean)) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN); goto bad_str; } break; case V_ASN1_INTEGER: case V_ASN1_ENUMERATED: if (format != ASN1_GEN_FORMAT_ASCII) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT); goto bad_form; } if ((atmp->value.integer = s2i_ASN1_INTEGER(NULL, str)) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER); goto bad_str; } break; case V_ASN1_OBJECT: if (format != ASN1_GEN_FORMAT_ASCII) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT); goto bad_form; } if ((atmp->value.object = OBJ_txt2obj(str, 0)) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT); goto bad_str; } break; case V_ASN1_UTCTIME: case V_ASN1_GENERALIZEDTIME: if (format != ASN1_GEN_FORMAT_ASCII) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT); goto bad_form; } if ((atmp->value.asn1_string = ASN1_STRING_new()) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE); goto bad_str; } if (!ASN1_STRING_set(atmp->value.asn1_string, str, -1)) { ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE); goto bad_str; } atmp->value.asn1_string->type = utype; if (!ASN1_TIME_check(atmp->value.asn1_string)) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE); goto bad_str; } break; case V_ASN1_BMPSTRING: case V_ASN1_PRINTABLESTRING: case V_ASN1_IA5STRING: case V_ASN1_T61STRING: case V_ASN1_UTF8STRING: case V_ASN1_VISIBLESTRING: case V_ASN1_UNIVERSALSTRING: case V_ASN1_GENERALSTRING: case V_ASN1_NUMERICSTRING: if (format == ASN1_GEN_FORMAT_ASCII) format = MBSTRING_ASC; else if (format == ASN1_GEN_FORMAT_UTF8) format = MBSTRING_UTF8; else { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT); goto bad_form; } if (ASN1_mbstring_copy(&atmp->value.asn1_string, (unsigned char *)str, -1, format, ASN1_tag2bit(utype)) <= 0) { ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE); goto bad_str; } break; case V_ASN1_BIT_STRING: case V_ASN1_OCTET_STRING: if ((atmp->value.asn1_string = ASN1_STRING_new()) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE); goto bad_form; } if (format == ASN1_GEN_FORMAT_HEX) { if ((rdata = OPENSSL_hexstr2buf(str, &rdlen)) == NULL) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX); goto bad_str; } atmp->value.asn1_string->data = rdata; atmp->value.asn1_string->length = rdlen; atmp->value.asn1_string->type = utype; } else if (format == ASN1_GEN_FORMAT_ASCII) ASN1_STRING_set(atmp->value.asn1_string, str, -1); else if ((format == ASN1_GEN_FORMAT_BITLIST) && (utype == V_ASN1_BIT_STRING)) { if (!CONF_parse_list (str,

, 1, bitstr_cb, atmp->value.bit_string)) { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR); goto bad_str; } no_unused = 0; } else { ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT); goto bad_form; } if ((utype == V_ASN1_BIT_STRING) && no_unused) { atmp->value.asn1_string->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07); atmp->value.asn1_string->flags |= ASN1_STRING_FLAG_BITS_LEFT; } break; default: ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE); goto bad_str; } atmp->type = utype; return atmp; bad_str: ERR_add_error_data(2, "string=", str); bad_form: ASN1_TYPE_free(atmp); return NULL; } static int bitstr_cb(const char *elem, int len, void *bitstr) { long bitnum; char *eptr; if (!elem) return 0; bitnum = strtoul(elem, &eptr, 10); if (eptr && *eptr && (eptr != elem + len)) return 0; if (bitnum < 0) { ASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER); return 0; } if (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1)) { ASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE); return 0; } return 1; } static int mask_cb(const char *elem, int len, void *arg) { unsigned long *pmask = arg, tmpmask; int tag; if (elem == NULL) return 0; if ((len == 3) && (strncmp(elem, "DIR", 3) == 0)) { *pmask |= B_ASN1_DIRECTORYSTRING; return 1; } tag = asn1_str2tag(elem, len); if (!tag || (tag & ASN1_GEN_FLAG)) return 0; tmpmask = ASN1_tag2bit(tag); if (!tmpmask) return 0; *pmask |= tmpmask; return 1; } int ASN1_str2mask(const char *str, unsigned long *pmask) { *pmask = 0; return CONF_parse_list(str,

0x10000

0x80)

0x1)

0x07);


Copyright 2015-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Internal ASN1 structures and functions: not for application use

ASN1 public key method structure

Legacy functions for old PEM

Custom ASN1 signature verification

EVP_PKEY_ASN1_METHOD

These are used internally in the ASN1_OBJECT to keep track of whether the names and data need to be free()ed

internal use

critical x509v3 object id

internal use

internal use

data remains const after init

Should we free this one

ASN1 print context structure

ASN1_PCTX

www.openssl.org/source/license.html

License

0x01/*

0x02/*

0x04/*

0x08/*


Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Internal tests for the asn1 module

Test of a_strnid's tbl_standard

Test of ameth_lib's standard_methods

www.openssl.org/source/license.html

License

testutil.h

internal/nelem.h

s tbl_standard * ***/ #include "../crypto/asn1/tbl_standard.h" static int test_tbl_standard() { const ASN1_STRING_TABLE *tmp; int last_nid = -1; size_t i; for (tmp = tbl_standard, i = 0; i < OSSL_NELEM(tbl_standard); i++, tmp++) { if (tmp->nid < last_nid) { last_nid = 0; break; } last_nid = tmp->nid; } if (TEST_int_ne(last_nid, 0)) { TEST_info("asn1 tbl_standard: Table order OK"); return 1; } TEST_info("asn1 tbl_standard: out of order"); for (tmp = tbl_standard, i = 0; i < OSSL_NELEM(tbl_standard); i++, tmp++) TEST_note("asn1 tbl_standard: Index %zu, NID %d, Name=%s", i, tmp->nid, OBJ_nid2ln(tmp->nid)); return 0; } /********************************************************************** * * Test of ameth_lib

internal/asn1_int.h

../crypto/asn1/standard_methods.h

asn1 standard methods: Table order OK

asn1 standard methods: out of order

asn1 standard methods: Index %zu, pkey ID %d, Name=%s


Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_item_list.h

Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

0x10200000L

0x10200000L


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

If there is 0 or 1 byte left, the length check should pick things up

high-tag

Set this so that even if things are not long enough the values are set correctly

Decode a length field. The short form is a single byte defining a length 0 - 127. The long form is a byte 0 - 127 with the top bit set and this indicates the number of following octets that contain the length. These octets are stored most significant digit first.

Skip leading zeroes

class 0 is constructed constructed == 2 for indefinite length constructed

Copy flags but preserve embed value

an allowance for strings :-)

www.openssl.org/source/license.html

License

internal/cryptlib.h

asn1_locl.h

\0

0x80)

0x7f;

0x7f;

0x80;

0x80;

0x80)

0x7f;

0x80)

0x7f;

0x80;

0x80;

0x80;

0xff;

0x10100000L


Copyright 2005-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Internal ASN1 structures and functions: not for application use

ASN1 scan context structure

The ASN1_ITEM associated with this field

If ASN1_TEMPLATE associated with this field

Various flags associated with field and context

If SEQUENCE OF or SET OF, field index

ASN1 depth of field

Structure and field name

If a primitive type the type of underlying field

The field value itself

Callback to pass information to

Context specific application data

ASN1_SCTX

Internal functions used by x_int64.c

www.openssl.org/source/license.html

License


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

This file is obsolete; please update your software.


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1_BMPSTRING bmp=NULL;

Because we know BIO_dump_indent()

if j == 0x21 it is a constructed indefinite length object

do the BMP thang

testing whether the octet string is printable

printable string

not printable => print octet string as hex dump

print the normal dump

End of sequence

0-4

5-9

10-13

15-17

18-20

21-24

25-27

28-30

www.openssl.org/source/license.html

License

internal/cryptlib.h

%-18s

cons:

prim:

priv [ %d ]

cont [ %d ]

appl [ %d ]

<ASN1 %d>

BAD RECURSION DEPTH\n

Error in encoding\n

%5ld:

d=%-2d hl=%ld l=%4ld

d=%-2d hl=%ld l=inf

\n

length is greater than %ld\n

\n

:

:

:BAD OBJECT

:BAD BOOLEAN

:%u



\n

\r

\t

~

:

[HEX DUMP]:

%02X

\n

:

-

%02X

00

:BAD INTEGER

:

-

%02X

00

:BAD ENUMERATED

\n

:[

%02X

]

\n

EOC

BOOLEAN

INTEGER

BIT STRING

OCTET STRING

NULL

OBJECT

OBJECT DESCRIPTOR

EXTERNAL

REAL

ENUMERATED

<ASN1 11>

UTF8STRING

<ASN1 13>

<ASN1 14>

<ASN1 15>

SEQUENCE

SET

NUMERICSTRING

PRINTABLESTRING

T61STRING

VIDEOTEXSTRING

IA5STRING

UTCTIME

GENERALIZEDTIME

GRAPHICSTRING

VISIBLESTRING

GENERALSTRING

UNIVERSALSTRING

<ASN1 29>

BMPSTRING

(unknown)

0x80)

0x21

0x21)

0x100;


Copyright 2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Tests for the ANS1_STRING_TABLE_ functions

check if all newly added NIDs are cleaned up

www.openssl.org/source/license.html

License

testutil.h

asn1 string table: ASN1_STRING_TABLE_get non-exist nid

asn1 string table: add NID(%d) failed

asn1 string table: add NID(%d) failed

asn1 string table: get NID(%d) failed

asn1 string table: get NID(%d) failed

asn1 string table: get NID(%d) failed

asn1 string table: get NID(%d) failed


Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Time tests for the asn1 module

TIME string value

GENERALIZED OR UTC

expected type after set/set_string_gmt

check result

expected time_

compariston to baseline result

convertion result

Bad time

Epoch begins

ditto

Max 32bit time_t

Just before 2038

Bad UTC time

Match baseline

In various flavors

ASSUMES SIGNED TIME_T

ASSUMES SIGNED TIME_T

A baseline time to compare to

else cannot simply convert GENERALIZEDTIME to UTCTIME

On platforms where |time_t| is an unsigned integer, t will be a positive number. We check if we're on a platform with a signed |time_t| with '!(t > 0)' because some compilers are picky if you do 't < 0', or even 't <= 0' if |t| is unsigned.

On some platforms, |time_t| is signed, but a negative value is an error, and using it with gmtime() or localtime() generates a NULL. If that is the case, we can't perform tests on negative values.

www.openssl.org/source/license.html

License

testutil.h

internal/nelem.h

0

ABCD

0ABCD

1-700101000000Z

`9700101000000Z

19700101000000Z

A00101000000Z

A9700101000000Z

1A700101000000Z

19A00101000000Z

197A0101000000Z

1970A101000000Z

19700A01000000Z

197001A1000000Z

1970010A000000Z

19700101A00000Z

197001010A0000Z

1970010100A000Z

19700101000A00Z

197001010000A0Z

1970010100000AZ

700101000000X

19700101000000X

19700101000000Z

700101000000Z

20380119031407Z

380119031407Z

20371231235959Z

20371231235959Z

371231235959Z

19701006121456Z

701006121456Z

19991231000000Z

199912310000Z

991231000000Z

9912310000Z

9912310000+0000

199912310000+0000

9912310000-0000

199912310000-0000

199912310100+0100

199912302300-0100

199912302300-A000

199912302300-0A00

9912310100+0100

9912302300-0100

19011213204552Z

691006121456Z

19691006121456Z

20380119031408Z

20380119031409Z

380119031408Z

20500101120000Z

19011213204551Z

19000101120000Z

19991231000000Z

ASN1_TIME_check(%s) unexpected result

ASN1_TIME_cmp_time_t(%s vs %ld) compare failed

ASN1_TIME_diff(%s) to self failed

ASN1_TIME_diff(%s) to self not equal

ASN1_TIME_diff(%s) to baseline failed

ASN1_TIME_diff(%s) to baseline bad comparison

ASN1_TIME_cmp_time_t(%s) to baseline bad comparison

ASN1_TIME_set(%ld) failed

ASN1_TIME_set(%ld) compare failed (%s->%s)

ASN1_TIME_set(%ld) unexpected type

ASN1_TIME_set() = %*s

ASN1_TIME_new() failed

ASN1_TIME_set_string_gmt(%s) failed

ASN1_TIME_normalize(%s) failed

ASN1_TIME_set_string_gmt(%s) unexpected type

ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string_gmt() failed

ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string_gnt() to baseline bad comparison

ASN1_TIME_set_string_gmt() = %*s

ASN1_TIME_new() failed

ASN1_TIME_set_string(%s) failed

ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string() failed

ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string() to baseline bad comparison

ASN1_TIME_set_string() = %*s

ASN1_TIME_to_generalizedtime(%s) failed

ASN1_TIME_to_generalizedtime(%s) should have failed

ASN1_TIME_to_generalizedtime(%s->%s) bad result

atime=%s

re on a platform with a signed |time_t| with

* because some compilers are picky if you do

, or even

* if |t| is unsigned. */ time_t t = -1; /* * On some platforms, |time_t| is signed, but a negative value is an * error, and using it with gmtime() or localtime() generates a NULL. * If that is the case, we can

Adding negative-sign time_t tests

Adding 64-bit time_t tests

Adding negative-sign 64-bit time_t tests

0X",

0X",

0x7FFFFFFF,

0x7FFFFFFF,

0x80000000,

0x80000001,

0x80000000,


Generated by util/mkerr.pl DO NOT EDIT Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1 function codes.

ASN1 reason codes.

www.openssl.org/source/license.html

License

C


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

A nice addition from Dr Stephen Henson <steve@openssl.org> to add the -strparse option which parses nested binary structures

Pre-allocate :-)

If any structs to parse go through in sequence

hmm... this is a little evil but it works

www.openssl.org/source/license.html

License

apps.h

help

-

Display this summary

inform

F

input format - one of DER PEM

in

<

input file

out

>

output file (output format is always DER)

i

indents the output

noout

do not produce any output

offset

p

offset into file

length

p

length of section in file

oid

<

file of extra oid definitions

dump

unknown data in hex form

dlimit

p

dump the first arg bytes of unknown data in hex form

strparse

s

offset; a series of these can be used to 'dig'

into multiple ASN1 blob wrappings

genstr

s

string to generate ASN1 structure from

genconf

s

file to generate ASN1 structure from

(-inform will be ignored)

strictpem

do not attempt base64 decode outside PEM markers

item

s

item to parse and print

%s: Memory allocation failure\n

%s: Use -help for summary.\n

Unknown item name %s\n

Supported types:\n

%s\n

r

r

w

Error reading PEM file\n

'%s' is an invalid number\n

Error parsing structure\n

Can't parse %s type\n

Error: offset too large\n

Error writing output\n

Error parsing item %s\n

default

asn1

Can't find 'asn1' in '%s'\n


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL licenses, (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.openssl.org/source/license.html or in the file LICENSE in the source distribution.

Fuzz the parser used for dumping ASN.1 using "openssl asn1parse".

www.openssl.org/source/license.html

License

openssl asn1parse

fuzzer.h

/dev/null

w


Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1 template defines, structures and functions

Macro to obtain ASN1_ADB pointer from a type (only used internally)

Macros for start and end of ASN1_ITEM definition

Macro to obtain ASN1_ADB pointer from a type (only used internally)

Macros for start and end of ASN1_ITEM definition

Macros to aid ASN1 template writing

This is a ASN1 type which just embeds a template

This pair helps declare a SEQUENCE. We can do: ASN1_SEQUENCE(stname) = { ... SEQUENCE components ... } ASN1_SEQUENCE_END(stname) This will produce an ASN1_ITEM called stname_it for a structure called stname. If you want the same structure but a different name then use: ASN1_SEQUENCE(itname) = { ... SEQUENCE components ... } ASN1_SEQUENCE_END_name(stname, itname) This will create an item called itname_it using a structure called stname.

This pair helps declare a CHOICE type. We can do: ASN1_CHOICE(chname) = { ... CHOICE options ... ASN1_CHOICE_END(chname) This will produce an ASN1_ITEM called chname_it for a structure called chname. The structure definition must look like this: typedef struct { int type; union { ASN1_SOMETHING opt1; ASN1_SOMEOTHER opt2; } value; } chname; the name of the selector must be 'type'. to use an alternative selector name use the ASN1_CHOICE_END_selector() version.

This helps with the template wrapper form of ASN1_ITEM

These help with SEQUENCE or CHOICE components

used to declare other types

implicit and explicit helper macros

Any defined by macros: the field used is in the table itself

Plain simple type

Embedded simple type

OPTIONAL simple type

IMPLICIT tagged simple type

IMPLICIT tagged OPTIONAL simple type

Same as above but EXPLICIT

SEQUENCE OF type

OPTIONAL SEQUENCE OF

Same as above but for SET OF

Finally compound types of SEQUENCE, SET, IMPLICIT, EXPLICIT and OPTIONAL

EXPLICIT using indefinite length constructed form

EXPLICIT OPTIONAL using indefinite length constructed form

Macros for the ASN1_ADB structure

This is the ASN1 template structure that defines a wrapper round the actual type. It determines the actual position of the field in the value structure, various flags such as OPTIONAL and the field name.

Various flags

tag, not used if no tagging

Offset of this field in structure

Field name

Relevant ASN1_ITEM or ASN1_ADB

Macro to extract ASN1_ITEM and ASN1_ADB pointer from ASN1_TEMPLATE

Various flags

Offset of selector field

Application callback

Table of possible types

Number of entries in tbl

Type to use if no match

Type to use if selector is NULL

NID for an object or value for an int

item for this value

template flags

Field is optional

Field is a SET OF

Field is a SEQUENCE OF

Special case: this refers to a SET OF that will be sorted into DER order when encoded and the corresponding STACK will be modified to match the new order.

Mask for SET OF or SEQUENCE OF

These flags mean the tag should be taken from the tag field. If EXPLICIT then the underlying type is used for the inner tag.

IMPLICIT tagging

EXPLICIT tagging, inner tag from underlying type

context specific IMPLICIT

context specific EXPLICIT

If tagging is in force these determine the type of tag to use. Otherwise the tag is determined by the underlying type. These values reflect the actual octet format.

Universal tag

Application tag

Context specific tag

Private tag

These are for ANY DEFINED BY type. In this case the 'item' field points to an ASN1_ADB structure which contains a table of values to decode the relevant type

This flag when present in a SEQUENCE OF, SET OF or EXPLICIT causes indefinite length constructed encoding to be used if required.

Field is embedded and not a pointer

This is the actual ASN1 item itself

The item type, primitive, SEQUENCE, CHOICE or extern

underlying type

If SEQUENCE or CHOICE this contains the contents

Number of templates if SEQUENCE or CHOICE

functions that handle this type

Structure size (usually)

Structure name

These are values for the itype field and determine how the type is interpreted. For PRIMITIVE types the underlying type determines the behaviour if items is NULL. Otherwise templates must contain a single template and the type is treated in the same way as the type specified in the template. For SEQUENCE types the templates field points to the members, the size field is the structure size. For CHOICE types the templates field points to each possible member (typically a union) and the 'size' field is the offset of the selector. The 'funcs' field is used for application specific functions. The EXTERN type uses a new style d2i/i2d. The new style should be used where possible because it avoids things like the d2i IMPLICIT hack. MSTRING is a multiple string type, it is used for a CHOICE of character strings where the actual strings all occupy an ASN1_STRING structure. In this case the 'utype' field has a special meaning, it is used as a mask of acceptable types using the B_ASN1 constants. NDEF_SEQUENCE is the same as SEQUENCE except that it will use indefinite length constructed encoding if requested.

Cache for ASN1 tag and length, so we don't keep re-reading it for things like CHOICE

Values below are valid

return value

length

class value

class value

header length

Typedefs for ASN1 function pointers

This is the ASN1_AUX structure: it handles various miscellaneous requirements. For example the use of reference counts and an informational callback. The "informational callback" is called at various points during the ASN1 encoding and decoding. It can be used to provide minor customisation of the structures used. This is most useful where the supplied routines almost do the right thing but need some extra help at a few points. If the callback returns zero then it is assumed a fatal error has occurred and the main operation should be abandoned. If major changes in the default behaviour are required then an external type is more appropriate.

Offset of reference value

Lock type to use

Offset of ASN1_ENCODING structure

For print related callbacks exarg points to this structure

For streaming related callbacks exarg points to this structure

BIO to stream through

BIO with filters appended

Streaming I/O boundary

Flags in ASN1_AUX

Use a reference count

Save the encoding of structure (useful for signatures)

The Sequence length is invalid

operation values for asn1_cb

Macro to implement a primitive type

Macro to implement a multi string type

Macro to implement standard functions in terms of ASN1_ITEM structures

This includes evil casts to remove const: they will go away when full ASN1 constification is done.

external definitions for primitive types

LONG and ZLONG are strongly discouraged for use as stored data, as the underlying C type (long) differs in size depending on the architecture. They are designed with 32-bit longs in mind.

Functions used internally by the ASN1 code

www.openssl.org/source/license.html

License

C

type

item

size

funcs

utype

informational callback

0x1)

0x1

0x2

0x3

0x3

0x1

0x2

0x3

0x0<<6)

0x1<<6)

0x2<<6)

0x3<<6)

0x3<<6)

0x3<<8)

0x1<<8)

0x1<<9)

0x1<<11)

0x1

0x0

0x1

0x2

0x4

0x5

0x6

0x10200000L


Copyright 2008-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Generalised MIME like utilities for streaming ASN1. Although many have a PKCS7/CMS like flavour others are more general purpose.

MIME format structures Note that all are translated to lower case apart from parameter values. Quotes are stripped off

Param name e.g. "micalg"

Param value e.g. "sha1"

Name of line e.g. "content-type"

Value of line e.g. "text/plain"

Zero or more parameters

x

Output an ASN1 structure in BER format streaming if necessary

If streaming create stream BIO and copy all content through it

Free up successive BIOs until we hit the old output BIO

else just write out ASN1 structure which will have all content stored internally

Base 64 read and write of ASN1 structure

prepend the b64 BIO so all data is base64 encoded.

Streaming ASN1 PEM write

Generate the MIME "micalg" parameter from RFC3851, RFC4490

SMIME sender

We want multipart/signed

Generate a random boundary

Now write out the first part

Headers for signature

Determine smime-type header

MIME headers

Handle output of ASN1 data

If data is not detached or resigning then the output BIO is already set up to finalise when it is written through.

Let ASN1 code prepend any needed BIOs

Copy data across, passing through filter BIOs for processing

Finalize structure

Now remove any digests prepended to the BIO

SMIME reader: handle multipart/signed and opaque signing. in multipart case the content is placed in a memory BIO pointed to by "bcont". In opaque this is set to NULL

Handle multipart/signed

Split into two parts

Parse the signature piece

Get content type

Read in ASN1

OK, if not multipart/signed try opaque signature

Copy text from one BIO to another making the output CRLF at EOL

Buffer output so we don't write one line at a time. This is useful when streaming as we don't end up with one OCTET STRING per line.

Not EOF: write out all CRLF

Strip off headers if they are text/plain

Split a multipart/XXX message body into component parts: result is canonical parts in a STACK of bios

Strip CR+LF from linebuf

This is the big one: parse MIME header lines up to message body

If whitespace at line start then continuation line

Go through all characters

State machine to handle MIME headers if this looks horrible that's because it is

Blank line means end of headers

Strip a parameter of whitespace from start of param

Look for first non white space or quote

Next char is start of string if non null

Else null string

As above but strip from end of string : maybe should handle brackets?

Look for first non white space or quote

Parameter values are case sensitive so leave as is

Find a header with a given name (if possible)

Check for a multipart boundary. Returns: 0 : no boundary 1 : part boundary 2 : final boundary

Quickly eliminate if line length too short

Check for part boundary

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

internal/evp_int.h

internal/bio.h

asn1_locl.h

micalg

sha1

content-type

text/plain

-----BEGIN %s-----\n

-----END %s-----\n

micalg

,

sha1

md5

sha-256

sha-384

sha-512

gostr3411-94

unknown

smime.p7m

application/x-pkcs7-

application/pkcs7-

\r\n

\n

0

A

MIME-Version: 1.0%s

Content-Type: multipart/signed;

protocol=\"%ssignature\";

micalg=\"

\"; boundary=\"----%s\"%s%s

This is an S/MIME signed message%s%s

------%s%s

%s------%s%s

Content-Type: %ssignature;

name=\"smime.p7s\"%s

Content-Transfer-Encoding: base64%s

Content-Disposition: attachment;

filename=\"smime.p7s\"%s%s

%s------%s--%s%s

enveloped-data

signed-receipt

signed-data

certs-only

compressed-data

smime.p7z

MIME-Version: 1.0%s

Content-Disposition: attachment;

filename=\"%s\"%s

Content-Type: %smime;

smime-type=%s;

name=\"%s\"%s

Content-Transfer-Encoding: base64%s%s

%s

bcont

content-type

multipart/signed

boundary

content-type

application/x-pkcs7-signature

application/pkcs7-signature

type:

application/x-pkcs7-mime

application/pkcs7-mime

type:

t write one line at a time. This is useful * when streaming as we don

Content-Type: text/plain\r\n\r\n

\r\n

\r\n

\r\n

content-type

text/plain

type:

\r\n

\r

\n

s because it *is* */ switch (state) { case MIME_START: if (c ==

) { state = MIME_TYPE; *p = 0; ntmp = strip_ends(q); q = p + 1; } break; case MIME_TYPE: if (c ==

) { mime_debug("Found End Value\n"); *p = 0; new_hdr = mime_hdr_new(ntmp, strip_ends(q)); if (new_hdr == NULL) goto err; if (!sk_MIME_HEADER_push(headers, new_hdr)) goto err; mhdr = new_hdr; new_hdr = NULL; ntmp = NULL; q = p + 1; state = MIME_NAME; } else if (c ==

) { save_state = state; state = MIME_COMMENT; } break; case MIME_COMMENT: if (c ==

) { state = save_state; } break; case MIME_NAME: if (c ==

) { state = MIME_VALUE; *p = 0; ntmp = strip_ends(q); q = p + 1; } break; case MIME_VALUE: if (c ==

) { state = MIME_NAME; *p = 0; mime_hdr_addparam(mhdr, ntmp, strip_ends(q)); ntmp = NULL; q = p + 1; } else if (c ==

') { mime_debug(

); state = MIME_QUOTE; } else if (c == '(') { save_state = state; state = MIME_COMMENT; } break; case MIME_QUOTE: if (c == '

) { mime_debug("Found Match Quote\n"); state = MIME_VALUE; } break; } } if (state == MIME_TYPE) { new_hdr = mime_hdr_new(ntmp, strip_ends(q)); if (new_hdr == NULL) goto err; if (!sk_MIME_HEADER_push(headers, new_hdr)) goto err; mhdr = new_hdr; new_hdr = NULL; } else if (state == MIME_VALUE) mime_hdr_addparam(mhdr, ntmp, strip_ends(q)); if (p == linebuf) break; /* Blank line means end of headers */ } return headers; err: mime_hdr_free(new_hdr); sk_MIME_HEADER_pop_free(headers, mime_hdr_free); return NULL; } static char *strip_ends(char *name) { return strip_end(strip_start(name)); } /* Strip a parameter of whitespace from start of param */ static char *strip_start(char *name) { char *p, c; /* Look for first non white space or quote */ for (p = name; (c = *p); p++) { if (c ==

') { /* Next char is start of string if non null */ if (p[1]) return p + 1; /* Else null string */ return NULL; } if (!ossl_isspace(c)) return p; } return NULL; } /* As above but strip from end of string : maybe should handle brackets? */ static char *strip_end(char *name) { char *p, c; if (!name) return NULL; /* Look for first non white space or quote */ for (p = name + strlen(name) - 1; p >= name; p--) { c = *p; if (c == '

) { if (p - 1 == name) return NULL; *p = 0; return name; } if (ossl_isspace(c)) *p = 0; else return name; } return NULL; } static MIME_HEADER *mime_hdr_new(const char *name, const char *value) { MIME_HEADER *mhdr = NULL; char *tmpname = NULL, *tmpval = NULL, *p; if (name) { if ((tmpname = OPENSSL_strdup(name)) == NULL) return NULL; for (p = tmpname; *p; p++) *p = ossl_tolower(*p); } if (value) { if ((tmpval = OPENSSL_strdup(value)) == NULL) goto err; for (p = tmpval; *p; p++) *p = ossl_tolower(*p); } mhdr = OPENSSL_malloc(sizeof(*mhdr)); if (mhdr == NULL) goto err; mhdr->name = tmpname; mhdr->value = tmpval; if ((mhdr->params = sk_MIME_PARAM_new(mime_param_cmp)) == NULL) goto err; return mhdr; err: OPENSSL_free(tmpname); OPENSSL_free(tmpval); OPENSSL_free(mhdr); return NULL; } static int mime_hdr_addparam(MIME_HEADER *mhdr, const char *name, const char *value) { char *tmpname = NULL, *tmpval = NULL, *p; MIME_PARAM *mparam = NULL; if (name) { tmpname = OPENSSL_strdup(name); if (!tmpname) goto err; for (p = tmpname; *p; p++) *p = ossl_tolower(*p); } if (value) { tmpval = OPENSSL_strdup(value); if (!tmpval) goto err; } /* Parameter values are case sensitive so leave as is */ mparam = OPENSSL_malloc(sizeof(*mparam)); if (mparam == NULL) goto err; mparam->param_name = tmpname; mparam->param_value = tmpval; if (!sk_MIME_PARAM_push(mhdr->params, mparam)) goto err; return 1; err: OPENSSL_free(tmpname); OPENSSL_free(tmpval); OPENSSL_free(mparam); return 0; } static int mime_hdr_cmp(const MIME_HEADER *const *a, const MIME_HEADER *const *b) { if (!(*a)->name || !(*b)->name) return ! !(*a)->name - ! !(*b)->name; return (strcmp((*a)->name, (*b)->name)); } static int mime_param_cmp(const MIME_PARAM *const *a, const MIME_PARAM *const *b) { if (!(*a)->param_name || !(*b)->param_name) return ! !(*a)->param_name - ! !(*b)->param_name; return (strcmp((*a)->param_name, (*b)->param_name)); } /* Find a header with a given name (if possible) */ static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, const char *name) { MIME_HEADER htmp; int idx; htmp.name = (char *)name; htmp.value = NULL; htmp.params = NULL; idx = sk_MIME_HEADER_find(hdrs, &htmp); if (idx < 0) return NULL; return sk_MIME_HEADER_value(hdrs, idx); } static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, const char *name) { MIME_PARAM param; int idx; param.param_name = (char *)name; param.param_value = NULL; idx = sk_MIME_PARAM_find(hdr->params, &param); if (idx < 0) return NULL; return sk_MIME_PARAM_value(hdr->params, idx); } static void mime_hdr_free(MIME_HEADER *hdr) { if (hdr == NULL) return; OPENSSL_free(hdr->name); OPENSSL_free(hdr->value); if (hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free); OPENSSL_free(hdr); } static void mime_param_free(MIME_PARAM *param) { OPENSSL_free(param->param_name); OPENSSL_free(param->param_value); OPENSSL_free(param); } /*- * Check for a multipart boundary. Returns: * 0 : no boundary * 1 : part boundary * 2 : final boundary */ static int mime_bound_check(char *line, int linelen, const char *bound, int blen) { if (linelen == -1) linelen = strlen(line); if (blen == -1) blen = strlen(bound); /* Quickly eliminate if line length too short */ if (blen + 2 > linelen) return 0; /* Check for part boundary */ if ((strncmp(line, "--", 2) == 0) && strncmp(line + 2, bound, blen) == 0) { if (strncmp(line + blen + 2, "--", 2) == 0) return 2; else return 1; } return 0; } static int strip_eol(char *linebuf, int *plen, int flags) { int len = *plen; char *p, c; int is_eol = 0; p = linebuf + len - 1; for (p = linebuf + len - 1; len > 0; len--, p--) { c = *p; if (c ==

) is_eol = 1; else if (is_eol && flags & SMIME_ASCIICRLF && c < 33) continue; else if (c !=

0xf;


Copyright 2002-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Simple ASN1 OID module: add all objects in a given section

Create an OID based on a name value pair. Accept two formats. shortname = 1.2.3.4 shortname = some long name, 1.2.3.4

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

internal/asn1_int.h

internal/objects.h

oid_section

,


Copyright 2012-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Multi string module: add table entries from a given section

Create an table entry based on a name value pair. format is oid_name = n1:v1, n2:v2,... where name is "min", "max", "mask" or "flags".

www.openssl.org/source/license.html

License

internal/cryptlib.h

stbl_section

min

max

mask

flags

min

max

mask

flags

nomask

none

field=

, value=

name=

, value=


Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1 packing and unpacking functions

Extract an ASN1 object from an ASN1_STRING

www.openssl.org/source/license.html

License

internal/cryptlib.h


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Without this we start getting longjmp crashes because it thinks we're jumping up the stack when in fact we are jumping to an entirely different stack. The cost of this is not having certain buffer overrun/underrun checks etc for this source file :-(

This must be the first #include file

Pool has not been initialised, so init with the defaults, i.e. no max size and no pre-created jobs

Pool is empty

Run the job

Stop the job

Should not happen. Getting here will close the thread...can't do much about it

Resume previous job

Should not happen

Start a new job

Could be we've deliberately not been started within a job so this is counted as success.

Reset counts of added and deleted fds

Pre-create jobs as required

Not actually fatal because we already created the pool, just skip creation of any more jobs

We're not in a job anyway so ignore this

We're not in a job anyway so ignore this

www.openssl.org/source/license.html

License

re jumping * up the stack when in fact we are jumping to an entirely different stack. The * cost of this is not having certain buffer overrun/underrun checks etc for * this source file :-( */ #undef _FORTIFY_SOURCE /* This must be the first #include file */ #include "async_locl.h" #include <openssl/err.h> #include "internal/cryptlib_int.h" #include <string.h> #define ASYNC_JOB_RUNNING 0 #define ASYNC_JOB_PAUSING 1 #define ASYNC_JOB_PAUSED 2 #define ASYNC_JOB_STOPPING 3 static CRYPTO_THREAD_LOCAL ctxkey; static CRYPTO_THREAD_LOCAL poolkey; static void async_free_pool_internal(async_pool *pool); static async_ctx *async_ctx_new(void) { async_ctx *nctx = NULL; nctx = OPENSSL_malloc(sizeof (async_ctx)); if (nctx == NULL) { ASYNCerr(ASYNC_F_ASYNC_CTX_NEW, ERR_R_MALLOC_FAILURE); goto err; } async_fibre_init_dispatcher(&nctx->dispatcher); nctx->currjob = NULL; nctx->blocked = 0; if (!CRYPTO_THREAD_set_local(&ctxkey, nctx)) goto err; return nctx; err: OPENSSL_free(nctx); return NULL; } async_ctx *async_get_ctx(void) { if (!OPENSSL_init_crypto(OPENSSL_INIT_ASYNC, NULL)) return NULL; return (async_ctx *)CRYPTO_THREAD_get_local(&ctxkey); } static int async_ctx_free(void) { async_ctx *ctx; ctx = async_get_ctx(); if (!CRYPTO_THREAD_set_local(&ctxkey, NULL)) return 0; OPENSSL_free(ctx); return 1; } static ASYNC_JOB *async_job_new(void) { ASYNC_JOB *job = NULL; job = OPENSSL_zalloc(sizeof (ASYNC_JOB)); if (job == NULL) { ASYNCerr(ASYNC_F_ASYNC_JOB_NEW, ERR_R_MALLOC_FAILURE); return NULL; } job->status = ASYNC_JOB_RUNNING; return job; } static void async_job_free(ASYNC_JOB *job) { if (job != NULL) { OPENSSL_free(job->funcargs); async_fibre_free(&job->fibrectx); OPENSSL_free(job); } } static ASYNC_JOB *async_get_pool_job(void) { ASYNC_JOB *job; async_pool *pool; pool = (async_pool *)CRYPTO_THREAD_get_local(&poolkey); if (pool == NULL) { /* * Pool has not been initialised, so init with the defaults, i.e. * no max size and no pre-created jobs */ if (ASYNC_init_thread(0, 0) == 0) return NULL; pool = (async_pool *)CRYPTO_THREAD_get_local(&poolkey); } job = sk_ASYNC_JOB_pop(pool->jobs); if (job == NULL) { /* Pool is empty */ if ((pool->max_size != 0) && (pool->curr_size >= pool->max_size)) return NULL; job = async_job_new(); if (job != NULL) { if (! async_fibre_makecontext(&job->fibrectx)) { async_job_free(job); return NULL; } pool->curr_size++; } } return job; } static void async_release_job(ASYNC_JOB *job) { async_pool *pool; pool = (async_pool *)CRYPTO_THREAD_get_local(&poolkey); OPENSSL_free(job->funcargs); job->funcargs = NULL; sk_ASYNC_JOB_push(pool->jobs, job); } void async_start_func(void) { ASYNC_JOB *job; async_ctx *ctx = async_get_ctx(); while (1) { /* Run the job */ job = ctx->currjob; job->ret = job->func(job->funcargs); /* Stop the job */ job->status = ASYNC_JOB_STOPPING; if (!async_fibre_swapcontext(&job->fibrectx, &ctx->dispatcher, 1)) { /* * Should not happen. Getting here will close the thread...can

ve deliberately not been started within a job so this is * counted as success. */ return 1; } job = ctx->currjob; job->status = ASYNC_JOB_PAUSING; if (!async_fibre_swapcontext(&job->fibrectx, &ctx->dispatcher, 1)) { ASYNCerr(ASYNC_F_ASYNC_PAUSE_JOB, ASYNC_R_FAILED_TO_SWAP_CONTEXT); return 0; } /* Reset counts of added and deleted fds */ async_wait_ctx_reset_counts(job->waitctx); return 1; } static void async_empty_pool(async_pool *pool) { ASYNC_JOB *job; if (!pool || !pool->jobs) return; do { job = sk_ASYNC_JOB_pop(pool->jobs); async_job_free(job); } while (job); } int async_init(void) { if (!CRYPTO_THREAD_init_local(&ctxkey, NULL)) return 0; if (!CRYPTO_THREAD_init_local(&poolkey, NULL)) { CRYPTO_THREAD_cleanup_local(&ctxkey); return 0; } return 1; } void async_deinit(void) { CRYPTO_THREAD_cleanup_local(&ctxkey); CRYPTO_THREAD_cleanup_local(&poolkey); } int ASYNC_init_thread(size_t max_size, size_t init_size) { async_pool *pool; size_t curr_size = 0; if (init_size > max_size) { ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_INVALID_POOL_SIZE); return 0; } if (!OPENSSL_init_crypto(OPENSSL_INIT_ASYNC, NULL)) { return 0; } if (!ossl_init_thread_start(OPENSSL_INIT_THREAD_ASYNC)) { return 0; } pool = OPENSSL_zalloc(sizeof *pool); if (pool == NULL) { ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE); return 0; } pool->jobs = sk_ASYNC_JOB_new_null(); if (pool->jobs == NULL) { ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE); OPENSSL_free(pool); return 0; } pool->max_size = max_size; /* Pre-create jobs as required */ while (init_size--) { ASYNC_JOB *job; job = async_job_new(); if (job == NULL || !async_fibre_makecontext(&job->fibrectx)) { /* * Not actually fatal because we already created the pool, just * skip creation of any more jobs */ async_job_free(job); break; } job->funcargs = NULL; sk_ASYNC_JOB_push(pool->jobs, job); curr_size++; } pool->curr_size = curr_size; if (!CRYPTO_THREAD_set_local(&poolkey, pool)) { ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_FAILED_TO_SET_POOL); goto err; } return 1; err: async_free_pool_internal(pool); return 0; } static void async_free_pool_internal(async_pool *pool) { if (pool == NULL) return; async_empty_pool(pool); sk_ASYNC_JOB_free(pool->jobs); OPENSSL_free(pool); CRYPTO_THREAD_set_local(&poolkey, NULL); async_local_cleanup(); async_ctx_free(); } void ASYNC_cleanup_thread(void) { async_free_pool_internal((async_pool *)CRYPTO_THREAD_get_local(&poolkey)); } ASYNC_JOB *ASYNC_get_current_job(void) { async_ctx *ctx; ctx = async_get_ctx(); if (ctx == NULL) return NULL; return ctx->currjob; } ASYNC_WAIT_CTX *ASYNC_get_wait_ctx(ASYNC_JOB *job) { return job->waitctx; } void ASYNC_block_pause(void) { async_ctx *ctx = async_get_ctx(); if (ctx == NULL || ctx->currjob == NULL) { /* * We

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

application has to include <windows.h> to use this

www.openssl.org/source/license.html

License

C


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

namespace

License

async_bio.h

async bio

Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

AsyncBioCreate creates a filter BIO for testing asynchronous state

machines which consume a stream socket. Reads and writes will fail

and return EAGAIN unless explicitly allowed. Each async BIO has a

read quota and a write quota. Initially both are zero. As each is

incremented, bytes are allowed to flow through the BIO.

AsyncBioCreateDatagram creates a filter BIO for testing for

asynchronous state machines which consume datagram sockets. The read

and write quota count in packets rather than bytes.

AsyncBioAllowRead increments |bio|'s read quota by |count|.

AsyncBioAllowWrite increments |bio|'s write quota by |count|.

AsyncBioEnforceWriteQuota configures where |bio| enforces its write quota.

HEADER_ASYNC_BIO

License

s read quota by |count|. void AsyncBioAllowRead(BIO *bio, size_t count); // AsyncBioAllowWrite increments |bio|


Generated by util/mkerr.pl DO NOT EDIT Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

async_ctx_new

ASYNC_init_thread

async_job_new

ASYNC_pause_job

async_start_func

ASYNC_start_job

failed to set pool

failed to swap context

init failed

invalid pool size


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Must do this before including any header files, because on MacOS/X <stlib.h> includes <signal.h> which includes <ucontext.h>

Otherwise incomplete ucontext_t structure

www.openssl.org/source/license.html

License

-Wdeprecated-declarations

internal/async.h

arch/async_win.h

arch/async_posix.h

arch/async_null.h


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This must be the first #include file

www.openssl.org/source/license.html

License

../async_locl.h

Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

If we haven't managed to detect any other async architecture then we default to NULL.

www.openssl.org/source/license.html

License


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This must be the first #include file

Some platforms provide getcontext() but it does not work (notably MacOSX PPC64). Check for a working getcontext();

www.openssl.org/source/license.html

License

../async_locl.h

Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

OPENSSL_ASYNC_ARCH_ASYNC_POSIX_H

www.openssl.org/source/license.html

License


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This must be the first #include file

Only try and cleanup if it hasn't been marked deleted

Always free the fd_lookup_st

This one has been marked deleted so do nothing

This one has been marked deleted so do nothing

We ignore fds that have been marked as both added and deleted

This one has been marked deleted already so do nothing

If fd has just been added, remove it from the list

It is responsibility of the caller to cleanup before calling ASYNC_WAIT_CTX_clear_fd

Mark it as deleted. We don't call cleanup if explicitly asked to clear an fd. We assume the caller is going to do that (if appropriate).

www.openssl.org/source/license.html

License

async_locl.h

t been marked deleted */ if (curr->cleanup != NULL) curr->cleanup(ctx, curr->key, curr->fd, curr->custom_data); } /* Always free the fd_lookup_st */ next = curr->next; OPENSSL_free(curr); curr = next; } OPENSSL_free(ctx); } int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD fd, void *custom_data, void (*cleanup)(ASYNC_WAIT_CTX *, const void *, OSSL_ASYNC_FD, void *)) { struct fd_lookup_st *fdlookup; fdlookup = OPENSSL_zalloc(sizeof *fdlookup); if (fdlookup == NULL) return 0; fdlookup->key = key; fdlookup->fd = fd; fdlookup->custom_data = custom_data; fdlookup->cleanup = cleanup; fdlookup->add = 1; fdlookup->next = ctx->fds; ctx->fds = fdlookup; ctx->numadd++; return 1; } int ASYNC_WAIT_CTX_get_fd(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD *fd, void **custom_data) { struct fd_lookup_st *curr; curr = ctx->fds; while (curr != NULL) { if (curr->del) { /* This one has been marked deleted so do nothing */ curr = curr->next; continue; } if (curr->key == key) { *fd = curr->fd; *custom_data = curr->custom_data; return 1; } curr = curr->next; } return 0; } int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *fd, size_t *numfds) { struct fd_lookup_st *curr; curr = ctx->fds; *numfds = 0; while (curr != NULL) { if (curr->del) { /* This one has been marked deleted so do nothing */ curr = curr->next; continue; } if (fd != NULL) { *fd = curr->fd; fd++; } (*numfds)++; curr = curr->next; } return 1; } int ASYNC_WAIT_CTX_get_changed_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *addfd, size_t *numaddfds, OSSL_ASYNC_FD *delfd, size_t *numdelfds) { struct fd_lookup_st *curr; *numaddfds = ctx->numadd; *numdelfds = ctx->numdel; if (addfd == NULL && delfd == NULL) return 1; curr = ctx->fds; while (curr != NULL) { /* We ignore fds that have been marked as both added and deleted */ if (curr->del && !curr->add && (delfd != NULL)) { *delfd = curr->fd; delfd++; } if (curr->add && !curr->del && (addfd != NULL)) { *addfd = curr->fd; addfd++; } curr = curr->next; } return 1; } int ASYNC_WAIT_CTX_clear_fd(ASYNC_WAIT_CTX *ctx, const void *key) { struct fd_lookup_st *curr, *prev; curr = ctx->fds; prev = NULL; while (curr != NULL) { if (curr->del == 1) { /* This one has been marked deleted already so do nothing */ curr = curr->next; continue; } if (curr->key == key) { /* If fd has just been added, remove it from the list */ if (curr->add == 1) { if (ctx->fds == curr) { ctx->fds = curr->next; } else { prev->next = curr->next; } /* It is responsibility of the caller to cleanup before calling * ASYNC_WAIT_CTX_clear_fd */ OPENSSL_free(curr); ctx->numadd--; return 1; } /* * Mark it as deleted. We don


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This must be the first #include file

www.openssl.org/source/license.html

License

../async_locl.h

internal/cryptlib.h

Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This is the same detection used in cryptlib to set up the thread local storage that we depend on, so just copy that

www.openssl.org/source/license.html

License

internal/cryptlib.h


Generated by util/mkerr.pl DO NOT EDIT Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASYNC function codes.

ASYNC reason codes.

www.openssl.org/source/license.html

License

C


Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL licenses, (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.openssl.org/source/license.html or in the file LICENSE in the source distribution.

Should we fragment records or not? 0 = no, !0 = ye

Choose a sufficiently large type likely to be unused for this custom BIO

Pretend we wrote out the record header

Create a new one byte long record for each byte in the record in the input buffer

Content type

Version hi

Version lo

Length hi

Length lo

Data

We can't fragment anything after the ServerHello (or CCS <= TLS1.2), otherwise we get a bad record MAC TODO(TLS1.3): Change TLS1_3_VERSION_DRAFT to TLS1_3_VERSION before release

Write any data we have left after fragmenting

We don't support this - not needed anyway

We do 2 test runs. The first time around we just do a normal handshake with lots of async io going on. The second time around we also break up all records so that the content is only one byte length (up until the CCS)

BIOs get freed on error

Send and receive some test data. Do the whole thing twice to ensure we hit at least one async event in both reading and writing

Write some test data. It should never take more than 2 attempts (the first one might be a retryable fail).

Now read the test data. It may take more attempts here because it could fail once for each byte read, including all overhead bytes from the record header/padding etc.

Also frees the BIOs

www.openssl.org/source/license.html

License

../ssl/packet_locl.h

ssltestlib.h

testutil.h

Async filter

t fragment anything after the ServerHello (or CCS <= * TLS1.2), otherwise we get a bad record MAC * TODO(TLS1.3): Change TLS1_3_VERSION_DRAFT to TLS1_3_VERSION * before release */ if (contenttype == SSL3_RT_CHANGE_CIPHER_SPEC || (negversion == TLS1_3_VERSION_DRAFT && msgtype == SSL3_MT_SERVER_HELLO)) { fragment = 0; break; } } } /* Write any data we have left after fragmenting */ ret = 0; if ((int)written < inl) { ret = BIO_write(next, in + written, inl - written); } if (ret <= 0 && BIO_should_write(next)) BIO_set_retry_write(bio); else ret += written; } else { ctrs->wctr++; BIO_set_retry_write(bio); } return ret; } static long async_ctrl(BIO *bio, int cmd, long num, void *ptr) { long ret; BIO *next = BIO_next(bio); if (next == NULL) return 0; switch (cmd) { case BIO_CTRL_DUP: ret = 0L; break; default: ret = BIO_ctrl(next, cmd, num, ptr); break; } return ret; } static int async_gets(BIO *bio, char *buf, int size) { /* We don

Test data

0x80


Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

First case: no fd added or removed

Second case: one fd added

Third case: all fd removed

Last case: fd added and immediately removed

On first run we're not expecting any wait fds

On second run we're expecting one added fd

Assign to something else

On third run we expect one deleted fd

On last run we are not expecting any wait fd

www.openssl.org/source/license.html

License

test_ASYNC_init_thread() failed\n

test_ASYNC_start_job() failed\n

test_ASYNC_get_current_job() failed\n

re not expecting any wait fds */ || ASYNC_start_job(&job, waitctx, &funcret, waitfd, NULL, 0) != ASYNC_PAUSE || !ASYNC_WAIT_CTX_get_all_fds(waitctx, NULL, &numfds) || numfds != 0 || !ASYNC_WAIT_CTX_get_changed_fds(waitctx, NULL, &numfds, NULL, &numdelfds) || numfds != 0 || numdelfds != 0 /* On second run we

test_ASYNC_get_wait_fd() failed\n

test_ASYNC_block_pause() failed\n

OpenSSL build is not ASYNC capable - skipping async tests\n

PASS\n


Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Throughout this file and bio_lcl.h, the existence of the macro AI_PASSIVE is used to detect the availability of struct addrinfo, getnameinfo() and getaddrinfo(). If that macro doesn't exist, we use our own implementation instead, using gethostbyname, getservbyname and a few other.

Address structure

BIO_ADDR_make - non-public routine to fill a BIO_ADDR with the contents of a struct sockaddr.

addr_strings - helper function to get host and service names @ap: the BIO_ADDR that has the input info @numeric: 0 if actual names should be returned, 1 if the numeric representation should be returned. @hostname: a pointer to a pointer to a memory area to store the host name or numeric representation. Unused if NULL. @service: a pointer to a pointer to a memory area to store the service name or numeric representation. Unused if NULL. The return value is 0 on failure, with the error code in the error stack, and 1 on success.

VMS getnameinfo() has a bug, it doesn't fill in serv, which leaves it with whatever garbage that happens to be there. However, we initialise serv with the empty string (serv[0] is therefore NUL), so it gets real easy to detect when things didn't go the way one might expect.

port is 16 bits => max 5 decimal digits

BIO_ADDR_sockaddr - non-public routine to return the struct sockaddr for a given BIO_ADDR. In reality, this is simply a type safe cast. The returned struct sockaddr is const, so it can't be tampered with.

BIO_ADDR_sockaddr_noconst - non-public function that does the same as BIO_ADDR_sockaddr, but returns a non-const. USE WITH CARE, as it allows you to tamper with the data (and thereby the contents of the input BIO_ADDR).

BIO_ADDR_sockaddr_size - non-public function that returns the size of the struct sockaddr the BIO_ADDR is using. If the protocol family isn't set or is something other than AF_INET, AF_INET6 or AF_UNIX, the size of the BIO_ADDR type is returned.

Address info database

BIO_ADDRINFO_sockaddr_size - non-public function that returns the size of the struct sockaddr inside the BIO_ADDRINFO.

BIO_ADDRINFO_sockaddr - non-public function that returns bai_addr as the struct sockaddr it is.

Free manually when we know that addrinfo_wrap() was used. See further comment above addrinfo_wrap()

Service functions

The specs in hostserv can take these forms: host:service => host = "host", service = "service" host: => host = "host", service = NULL host: => host = "host", service = NULL :service => host = NULL, service = "service" :service => host = NULL, service = "service" in case no : is present in the string, the result depends on hostserv_prio, as follows: when hostserv_prio == BIO_PARSE_PRIO_HOST host => host = "host", service untouched when hostserv_prio == BIO_PARSE_PRIO_SERV service => host untouched, service = "service"

Check for more than one colon. There are three possible interpretations: 1. IPv6 address with port number, last colon being separator. 2. IPv6 address only. 3. IPv6 address only if hostserv_prio == BIO_PARSE_PRIO_HOST, IPv6 address and port number if hostserv_prio == BIO_PARSE_PRIO_SERV Because of this ambiguity, we currently choose to make it an error.

addrinfo_wrap is used to build our own addrinfo "chain". (it has only one entry, so calling it a chain may be a stretch) It should ONLY be called when getaddrinfo() and friends aren't available, OR when dealing with a non IP protocol family, such as AF_UNIX the return value is 1 on success, or 0 on failure, which only happens if a memory allocation error occurred.

Magic: We know that BIO_ADDR_sockaddr_noconst is really just an advanced cast of BIO_ADDR to struct sockaddr by the power of union, so while it may seem that we're creating a memory leak here, we are not. It will be all right.

BIO_lookup_ex - look up the node and service you want to connect to. @node: the node you want to connect to. @service: the service you want to connect to. @lookup_type: declare intent with the result, client or server. @family: the address family you want to use. Use AF_UNSPEC for any, or AF_INET, AF_INET6 or AF_UNIX. @socktype: The socket type you want to use. Can be SOCK_STREAM, SOCK_DGRAM or 0 for all. @protocol: The protocol to use, e.g. IPPROTO_TCP or IPPROTO_UDP or 0 for all. Note that some platforms may not return IPPROTO_SCTP without explicitly requesting it (i.e. IPPROTO_SCTP may not be returned with 0 for the protocol) @res: Storage place for the resulting list of returned addresses This will do a lookup of the node and service that you want to connect to. It returns a linked list of different addresses you can try to connect to. When no longer needed you should call BIO_ADDRINFO_free() to free the result. The return value is 1 on success or 0 in case of error.

Assume failure

Note that |res| SHOULD be a 'struct addrinfo ' thanks to macro magic in bio_lcl.h

Success

Because struct hostent is defined for 32-bit pointers only with VMS C, we need to make sure that '&he_fallback_address' and '&he_fallback_addresses' are 32-bit pointers

Windows doesn't seem to have in_addr_t

Apparently, on WIN64, s_proto and s_port have traded places...

We forgot to handle a lookup type!

This might be misleading, because h_errno is used as if it was errno. To minimize mixup add 1000. Underlying reason for this is that hstrerror is declared obsolete, not to mention that a) h_errno is not always guaranteed to be meaningless; b) hstrerror can reside in yet another library, linking for sake of hstrerror is an overkill; c) this path is not executed on contemporary systems anyway [above getaddrinfo/gai_strerror is]. We just let system administrator figure this out...

Because struct servent is defined for 32-bit pointers only with VMS C, we need to make sure that 'proto' is a 32-bit pointer.

Because hostent::h_addr_list is an array of 32-bit pointers with VMS C, we must make sure our iterator designates the same element type, hence the pointer size dance.

The easiest way to create a linked list from an array is to start from the back

OPENSSL_NO_SOCK

www.openssl.org/source/license.html

License

bio_lcl.h

internal/thread_once.h

t exist, * we use our own implementation instead, using gethostbyname, * getservbyname and a few other. */ /********************************************************************** * * Address structure * */ BIO_ADDR *BIO_ADDR_new(void) { BIO_ADDR *ret = OPENSSL_zalloc(sizeof(*ret)); if (ret == NULL) { BIOerr(BIO_F_BIO_ADDR_NEW, ERR_R_MALLOC_FAILURE); return NULL; } ret->sa.sa_family = AF_UNSPEC; return ret; } void BIO_ADDR_free(BIO_ADDR *ap) { OPENSSL_free(ap); } void BIO_ADDR_clear(BIO_ADDR *ap) { memset(ap, 0, sizeof(*ap)); ap->sa.sa_family = AF_UNSPEC; } /* * BIO_ADDR_make - non-public routine to fill a BIO_ADDR with the contents * of a struct sockaddr. */ int BIO_ADDR_make(BIO_ADDR *ap, const struct sockaddr *sa) { if (sa->sa_family == AF_INET) { ap->s_in = *(const struct sockaddr_in *)sa; return 1; } #ifdef AF_INET6 if (sa->sa_family == AF_INET6) { ap->s_in6 = *(const struct sockaddr_in6 *)sa; return 1; } #endif #ifdef AF_UNIX if (ap->sa.sa_family == AF_UNIX) { ap->s_un = *(const struct sockaddr_un *)sa; return 1; } #endif return 0; } int BIO_ADDR_rawmake(BIO_ADDR *ap, int family, const void *where, size_t wherelen, unsigned short port) { #ifdef AF_UNIX if (family == AF_UNIX) { if (wherelen + 1 > sizeof(ap->s_un.sun_path)) return 0; memset(&ap->s_un, 0, sizeof(ap->s_un)); ap->s_un.sun_family = family; strncpy(ap->s_un.sun_path, where, sizeof(ap->s_un.sun_path) - 1); return 1; } #endif if (family == AF_INET) { if (wherelen != sizeof(struct in_addr)) return 0; memset(&ap->s_in, 0, sizeof(ap->s_in)); ap->s_in.sin_family = family; ap->s_in.sin_port = port; ap->s_in.sin_addr = *(struct in_addr *)where; return 1; } #ifdef AF_INET6 if (family == AF_INET6) { if (wherelen != sizeof(struct in6_addr)) return 0; memset(&ap->s_in6, 0, sizeof(ap->s_in6)); ap->s_in6.sin6_family = family; ap->s_in6.sin6_port = port; ap->s_in6.sin6_addr = *(struct in6_addr *)where; return 1; } #endif return 0; } int BIO_ADDR_family(const BIO_ADDR *ap) { return ap->sa.sa_family; } int BIO_ADDR_rawaddress(const BIO_ADDR *ap, void *p, size_t *l) { size_t len = 0; const void *addrptr = NULL; if (ap->sa.sa_family == AF_INET) { len = sizeof(ap->s_in.sin_addr); addrptr = &ap->s_in.sin_addr; } #ifdef AF_INET6 else if (ap->sa.sa_family == AF_INET6) { len = sizeof(ap->s_in6.sin6_addr); addrptr = &ap->s_in6.sin6_addr; } #endif #ifdef AF_UNIX else if (ap->sa.sa_family == AF_UNIX) { len = strlen(ap->s_un.sun_path); addrptr = &ap->s_un.sun_path; } #endif if (addrptr == NULL) return 0; if (p != NULL) { memcpy(p, addrptr, len); } if (l != NULL) *l = len; return 1; } unsigned short BIO_ADDR_rawport(const BIO_ADDR *ap) { if (ap->sa.sa_family == AF_INET) return ap->s_in.sin_port; #ifdef AF_INET6 if (ap->sa.sa_family == AF_INET6) return ap->s_in6.sin6_port; #endif return 0; } /*- * addr_strings - helper function to get host and service names * @ap: the BIO_ADDR that has the input info * @numeric: 0 if actual names should be returned, 1 if the numeric * representation should be returned. * @hostname: a pointer to a pointer to a memory area to store the * host name or numeric representation. Unused if NULL. * @service: a pointer to a pointer to a memory area to store the * service name or numeric representation. Unused if NULL. * * The return value is 0 on failure, with the error code in the error * stack, and 1 on success. */ static int addr_strings(const BIO_ADDR *ap, int numeric, char **hostname, char **service) { if (BIO_sock_init() != 1) return 0; if (1) { #ifdef AI_PASSIVE int ret = 0; char host[NI_MAXHOST] = "", serv[NI_MAXSERV] = ""; int flags = 0; if (numeric) flags |= NI_NUMERICHOST | NI_NUMERICSERV; if ((ret = getnameinfo(BIO_ADDR_sockaddr(ap), BIO_ADDR_sockaddr_size(ap), host, sizeof(host), serv, sizeof(serv), flags)) != 0) { # ifdef EAI_SYSTEM if (ret == EAI_SYSTEM) { SYSerr(SYS_F_GETNAMEINFO, get_last_socket_error()); BIOerr(BIO_F_ADDR_STRINGS, ERR_R_SYS_LIB); } else # endif { BIOerr(BIO_F_ADDR_STRINGS, ERR_R_SYS_LIB); ERR_add_error_data(1, gai_strerror(ret)); } return 0; } /* VMS getnameinfo() has a bug, it doesn

t go the way one might expect. */ if (serv[0] ==

) { BIO_snprintf(serv, sizeof(serv), "%d", ntohs(BIO_ADDR_rawport(ap))); } if (hostname != NULL) *hostname = OPENSSL_strdup(host); if (service != NULL) *service = OPENSSL_strdup(serv); } else { #endif if (hostname != NULL) *hostname = OPENSSL_strdup(inet_ntoa(ap->s_in.sin_addr)); if (service != NULL) { char serv[6]; /* port is 16 bits => max 5 decimal digits */ BIO_snprintf(serv, sizeof(serv), "%d", ntohs(ap->s_in.sin_port)); *service = OPENSSL_strdup(serv); } } if ((hostname != NULL && *hostname == NULL) || (service != NULL && *service == NULL)) { if (hostname != NULL) { OPENSSL_free(*hostname); *hostname = NULL; } if (service != NULL) { OPENSSL_free(*service); *service = NULL; } BIOerr(BIO_F_ADDR_STRINGS, ERR_R_MALLOC_FAILURE); return 0; } return 1; } char *BIO_ADDR_hostname_string(const BIO_ADDR *ap, int numeric) { char *hostname = NULL; if (addr_strings(ap, numeric, &hostname, NULL)) return hostname; return NULL; } char *BIO_ADDR_service_string(const BIO_ADDR *ap, int numeric) { char *service = NULL; if (addr_strings(ap, numeric, NULL, &service)) return service; return NULL; } char *BIO_ADDR_path_string(const BIO_ADDR *ap) { #ifdef AF_UNIX if (ap->sa.sa_family == AF_UNIX) return OPENSSL_strdup(ap->s_un.sun_path); #endif return NULL; } /* * BIO_ADDR_sockaddr - non-public routine to return the struct sockaddr * for a given BIO_ADDR. In reality, this is simply a type safe cast. * The returned struct sockaddr is const, so it can

t set or is something other than AF_INET, AF_INET6 or AF_UNIX, * the size of the BIO_ADDR type is returned. */ socklen_t BIO_ADDR_sockaddr_size(const BIO_ADDR *ap) { if (ap->sa.sa_family == AF_INET) return sizeof(ap->s_in); #ifdef AF_INET6 if (ap->sa.sa_family == AF_INET6) return sizeof(ap->s_in6); #endif #ifdef AF_UNIX if (ap->sa.sa_family == AF_UNIX) return sizeof(ap->s_un); #endif return sizeof(*ap); } /********************************************************************** * * Address info database * */ const BIO_ADDRINFO *BIO_ADDRINFO_next(const BIO_ADDRINFO *bai) { if (bai != NULL) return bai->bai_next; return NULL; } int BIO_ADDRINFO_family(const BIO_ADDRINFO *bai) { if (bai != NULL) return bai->bai_family; return 0; } int BIO_ADDRINFO_socktype(const BIO_ADDRINFO *bai) { if (bai != NULL) return bai->bai_socktype; return 0; } int BIO_ADDRINFO_protocol(const BIO_ADDRINFO *bai) { if (bai != NULL) { if (bai->bai_protocol != 0) return bai->bai_protocol; #ifdef AF_UNIX if (bai->bai_family == AF_UNIX) return 0; #endif switch (bai->bai_socktype) { case SOCK_STREAM: return IPPROTO_TCP; case SOCK_DGRAM: return IPPROTO_UDP; default: break; } } return 0; } /* * BIO_ADDRINFO_sockaddr_size - non-public function that returns the size * of the struct sockaddr inside the BIO_ADDRINFO. */ socklen_t BIO_ADDRINFO_sockaddr_size(const BIO_ADDRINFO *bai) { if (bai != NULL) return bai->bai_addrlen; return 0; } /* * BIO_ADDRINFO_sockaddr - non-public function that returns bai_addr * as the struct sockaddr it is. */ const struct sockaddr *BIO_ADDRINFO_sockaddr(const BIO_ADDRINFO *bai) { if (bai != NULL) return bai->bai_addr; return NULL; } const BIO_ADDR *BIO_ADDRINFO_address(const BIO_ADDRINFO *bai) { if (bai != NULL) return (BIO_ADDR *)bai->bai_addr; return NULL; } void BIO_ADDRINFO_free(BIO_ADDRINFO *bai) { if (bai == NULL) return; #ifdef AI_PASSIVE # ifdef AF_UNIX # define _cond bai->bai_family != AF_UNIX # else # define _cond 1 # endif if (_cond) { freeaddrinfo(bai); return; } #endif /* Free manually when we know that addrinfo_wrap() was used. * See further comment above addrinfo_wrap() */ while (bai != NULL) { BIO_ADDRINFO *next = bai->bai_next; OPENSSL_free(bai->bai_addr); OPENSSL_free(bai); bai = next; } } /********************************************************************** * * Service functions * */ /*- * The specs in hostserv can take these forms: * * host:service => *host = "host", *service = "service" * host:* => *host = "host", *service = NULL * host: => *host = "host", *service = NULL * :service => *host = NULL, *service = "service" * *:service => *host = NULL, *service = "service" * * in case no : is present in the string, the result depends on * hostserv_prio, as follows: * * when hostserv_prio == BIO_PARSE_PRIO_HOST * host => *host = "host", *service untouched * * when hostserv_prio == BIO_PARSE_PRIO_SERV * service => *host untouched, *service = "service" * */ int BIO_parse_hostserv(const char *hostserv, char **host, char **service, enum BIO_hostserv_priorities hostserv_prio) { const char *h = NULL; size_t hl = 0; const char *p = NULL; size_t pl = 0; if (*hostserv ==

) { if ((p = strchr(hostserv,

)) == NULL) goto spec_err; h = hostserv + 1; hl = p - h; p++; if (*p ==

) p = NULL; else if (*p !=

) goto spec_err; else { p++; pl = strlen(p); } } else { const char *p2 = strrchr(hostserv,

); p = strchr(hostserv,

); /*- * Check for more than one colon. There are three possible * interpretations: * 1. IPv6 address with port number, last colon being separator. * 2. IPv6 address only. * 3. IPv6 address only if hostserv_prio == BIO_PARSE_PRIO_HOST, * IPv6 address and port number if hostserv_prio == BIO_PARSE_PRIO_SERV * Because of this ambiguity, we currently choose to make it an * error. */ if (p != p2) goto amb_err; if (p != NULL) { h = hostserv; hl = p - h; p++; pl = strlen(p); } else if (hostserv_prio == BIO_PARSE_PRIO_HOST) { h = hostserv; hl = strlen(h); } else { p = hostserv; pl = strlen(p); } } if (p != NULL && strchr(p,

)) goto spec_err; if (h != NULL && host != NULL) { if (hl == 0 || (hl == 1 && h[0] ==

)) { *host = NULL; } else { *host = OPENSSL_strndup(h, hl); if (*host == NULL) goto memerr; } } if (p != NULL && service != NULL) { if (pl == 0 || (pl == 1 && p[0] ==

)) { *service = NULL; } else { *service = OPENSSL_strndup(p, pl); if (*service == NULL) goto memerr; } } return 1; amb_err: BIOerr(BIO_F_BIO_PARSE_HOSTSERV, BIO_R_AMBIGUOUS_HOST_OR_SERVICE); return 0; spec_err: BIOerr(BIO_F_BIO_PARSE_HOSTSERV, BIO_R_MALFORMED_HOST_OR_SERVICE); return 0; memerr: BIOerr(BIO_F_BIO_PARSE_HOSTSERV, ERR_R_MALLOC_FAILURE); return 0; } /* addrinfo_wrap is used to build our own addrinfo "chain". * (it has only one entry, so calling it a chain may be a stretch) * It should ONLY be called when getaddrinfo() and friends * aren

re creating a memory leak here, we are not. It will be all right. */ BIO_ADDR *addr = BIO_ADDR_new(); if (addr != NULL) { BIO_ADDR_rawmake(addr, family, where, wherelen, port); (*bai)->bai_addr = BIO_ADDR_sockaddr_noconst(addr); } } (*bai)->bai_next = NULL; if ((*bai)->bai_addr == NULL) { BIO_ADDRINFO_free(*bai); *bai = NULL; return 0; } return 1; } DEFINE_RUN_ONCE_STATIC(do_bio_lookup_init) { OPENSSL_init_crypto(0, NULL); bio_lookup_lock = CRYPTO_THREAD_lock_new(); return bio_lookup_lock != NULL; } int BIO_lookup(const char *host, const char *service, enum BIO_lookup_type lookup_type, int family, int socktype, BIO_ADDRINFO **res) { return BIO_lookup_ex(host, service, lookup_type, family, socktype, 0, res); } /*- * BIO_lookup_ex - look up the node and service you want to connect to. * @node: the node you want to connect to. * @service: the service you want to connect to. * @lookup_type: declare intent with the result, client or server. * @family: the address family you want to use. Use AF_UNSPEC for any, or * AF_INET, AF_INET6 or AF_UNIX. * @socktype: The socket type you want to use. Can be SOCK_STREAM, SOCK_DGRAM * or 0 for all. * @protocol: The protocol to use, e.g. IPPROTO_TCP or IPPROTO_UDP or 0 for all. * Note that some platforms may not return IPPROTO_SCTP without * explicitly requesting it (i.e. IPPROTO_SCTP may not be returned * with 0 for the protocol) * @res: Storage place for the resulting list of returned addresses * * This will do a lookup of the node and service that you want to connect to. * It returns a linked list of different addresses you can try to connect to. * * When no longer needed you should call BIO_ADDRINFO_free() to free the result. * * The return value is 1 on success or 0 in case of error. */ int BIO_lookup_ex(const char *host, const char *service, int lookup_type, int family, int socktype, int protocol, BIO_ADDRINFO **res) { int ret = 0; /* Assume failure */ switch(family) { case AF_INET: #ifdef AF_INET6 case AF_INET6: #endif #ifdef AF_UNIX case AF_UNIX: #endif #ifdef AF_UNSPEC case AF_UNSPEC: #endif break; default: BIOerr(BIO_F_BIO_LOOKUP_EX, BIO_R_UNSUPPORTED_PROTOCOL_FAMILY); return 0; } #ifdef AF_UNIX if (family == AF_UNIX) { if (addrinfo_wrap(family, socktype, host, strlen(host), 0, res)) return 1; else BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_MALLOC_FAILURE); return 0; } #endif if (BIO_sock_init() != 1) return 0; if (1) { #ifdef AI_PASSIVE int gai_ret = 0; struct addrinfo hints; memset(&hints, 0, sizeof hints); hints.ai_family = family; hints.ai_socktype = socktype; hints.ai_protocol = protocol; if (lookup_type == BIO_LOOKUP_SERVER) hints.ai_flags |= AI_PASSIVE; /* Note that |res| SHOULD be a

thanks to * macro magic in bio_lcl.h */ switch ((gai_ret = getaddrinfo(host, service, &hints, res))) { # ifdef EAI_SYSTEM case EAI_SYSTEM: SYSerr(SYS_F_GETADDRINFO, get_last_socket_error()); BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_SYS_LIB); break; # endif case 0: ret = 1; /* Success */ break; default: BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_SYS_LIB); ERR_add_error_data(1, gai_strerror(gai_ret)); break; } } else { #endif const struct hostent *he; /* * Because struct hostent is defined for 32-bit pointers only with * VMS C, we need to make sure that

and *

are 32-bit pointers */ #if defined(OPENSSL_SYS_VMS) && defined(__DECC) # pragma pointer_size save # pragma pointer_size 32 #endif /* Windows doesn

We forgot to handle a lookup type!

proto

tcp

udp

\0


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Stolen from tjh's ssl/ssl_trc.c stuff.

if this is the last call then update the ddt_dump thing so that we will move the selection point in the debug window

www.openssl.org/source/license.html

License

s ssl/ssl_trc.c stuff. */ #include <stdio.h> #include "bio_lcl.h" #define TRUNCATE #define DUMP_WIDTH 16 #define DUMP_WIDTH_LESS_INDENT(i) (DUMP_WIDTH - ((i - (i > 6 ? 6 : i) + 3) / 4)) #define SPACE(buf, pos, n) (sizeof(buf) - (pos) > (n)) int BIO_dump_cb(int (*cb) (const void *data, size_t len, void *u), void *u, const char *s, int len) { return BIO_dump_indent_cb(cb, u, s, len, 0); } int BIO_dump_indent_cb(int (*cb) (const void *data, size_t len, void *u), void *u, const char *s, int len, int indent) { int ret = 0; char buf[288 + 1]; int i, j, rows, trc, n; unsigned char ch; int dump_width; trc = 0; #ifdef TRUNCATE for (; (len > 0) && ((s[len - 1] ==

) || (s[len - 1] ==

)); len--) trc++; #endif if (indent < 0) indent = 0; else if (indent > 128) indent = 128; dump_width = DUMP_WIDTH_LESS_INDENT(indent); rows = len / dump_width; if ((rows * dump_width) < len) rows++; for (i = 0; i < rows; i++) { n = BIO_snprintf(buf, sizeof(buf), "%*s%04x - ", indent, "", i * dump_width); for (j = 0; j < dump_width; j++) { if (SPACE(buf, n, 3)) { if (((i * dump_width) + j) >= len) { strcpy(buf + n, " "); } else { ch = ((unsigned char)*(s + i * dump_width + j)) & 0xff; BIO_snprintf(buf + n, 4, "%02x%c", ch, j == 7 ?

:

); } n += 3; } } if (SPACE(buf, n, 2)) { strcpy(buf + n, " "); n += 2; } for (j = 0; j < dump_width; j++) { if (((i * dump_width) + j) >= len) break; if (SPACE(buf, n, 1)) { ch = ((unsigned char)*(s + i * dump_width + j)) & 0xff; #ifndef CHARSET_EBCDIC buf[n++] = ((ch >=

) && (ch <=

)) ? ch :

; #else buf[n++] = ((ch >= os_toascii[

]) && (ch <= os_toascii[

])) ? os_toebcdic[ch] :

; #endif buf[n] =

; } } if (SPACE(buf, n, 1)) { buf[n++] =

; buf[n] =

%*s%04x - <SPACES/NULS>\n



%*s



%02X:

\n

%*s



%02X

0xff;

0xff;


Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Copyright Patrick Powell 1995 This code is based on code written by Patrick Powell <papowell@astart.com> It may be used for any purpose as long as this notice remains intact on all source code distributions.

format read states

format flags - Bits

left-aligned padding

print an explicit '+' for a value with positive sign

print an explicit ' ' for a value with positive sign

print 0/0x prefix for octal/hex and decimal point for floating point

print leading zeroes

print HEX in UPPPERcase

treat value as unsigned

conversion flags

Floating point formats

some handy macros

FALLTHROUGH

fall thru

fall thru

not supported yet, treat as next char

unknown, skip

We have to truncate if there is no dynamic buffer and we have filled the static buffer.

Calculate the maximum output including padding. Make sure max doesn't overflow into negativity

spaces

sign

prefix

zeros

digits

left justified spaces

G_FORMAT sometimes prints like E_FORMAT and sometimes like F_FORMAT depending on the number to be printed. Work out which one it is and use that from here on.

Calculate the exponent

In G_FORMAT the "precision" represents significant digits. We always have at least 1 significant digit.

Now convert significant digits to decimal places

Should not happen. If we're in F_FORMAT then exp < max?

In E_FORMAT there is always one significant digit in front of the decimal point, so: significant digits == 1 + decimal places

Number too big

sorry, we only support 9 digits past the decimal because of our conversion method

we "cheat" by converting the fractional part to integer by multiplying by a factor of 10

convert integer part

convert fractional part

We strip trailing zeros in G_FORMAT

convert exponent part

Exponent is huge!! Too big to print

Add a leading 0 for single digit exponents

-1 for decimal point (if we have one, i.e. max > 0), another -1 if we are printing a sign

Take some off for exponent prefix "+e" and exponent

Decimal point. This should probably use locale to find the correct char to print out.

If we haven't at least one buffer, someone has done a big booboo

|currlen| must always be <= |maxlen|



Was previously 10k, which is unreasonable in small-stack environments, like threads or DOS programs.

As snprintf is not available everywhere, we provide our own implementation. This function has nothing to do with BIOs, but it's closely related to BIO_printf, and we need some name prefix ... (XXX the function should be renamed, but to what?)

In case of truncation, return -1 like traditional snprintf. (Current drafts for ISO/IEC 9899 say snprintf should return the number of characters that would have been written, had the buffer been large enough.)

www.openssl.org/source/license.html

License

internal/ctype.h

internal/numbers.h

internal/cryptlib.h

+



0

\0

%

-

+



#

0

*

.

*

h

l

l

q

j

L

z

d

i

X

x

o

u

o

u

f

E

e

G

g

c

s

p

n

%

w

\0

<NULL>

t overflow into negativity */ if (max < INT_MAX - padlen) max += padlen; else max = INT_MAX; } if (flags & DP_F_MINUS) padlen = -padlen; while ((padlen > 0) && (max < 0 || cnt < max)) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen,

)) return 0; --padlen; ++cnt; } while (strln > 0 && (max < 0 || cnt < max)) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen, *value++)) return 0; --strln; ++cnt; } while ((padlen < 0) && (max < 0 || cnt < max)) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen,

)) return 0; ++padlen; ++cnt; } return 1; } static int fmtint(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen, int64_t value, int base, int min, int max, int flags) { int signvalue = 0; const char *prefix = ""; uint64_t uvalue; char convert[DECIMAL_SIZE(value) + 3]; int place = 0; int spadlen = 0; int zpadlen = 0; int caps = 0; if (max < 0) max = 0; uvalue = value; if (!(flags & DP_F_UNSIGNED)) { if (value < 0) { signvalue =

; uvalue = 0 - (uint64_t)value; } else if (flags & DP_F_PLUS) signvalue =

; else if (flags & DP_F_SPACE) signvalue =

; } if (flags & DP_F_NUM) { if (base == 8) prefix = "0"; if (base == 16) prefix = "0x"; } if (flags & DP_F_UP) caps = 1; do { convert[place++] = (caps ? "0123456789ABCDEF" : "0123456789abcdef") [uvalue % (unsigned)base]; uvalue = (uvalue / (unsigned)base); } while (uvalue && (place < (int)sizeof(convert))); if (place == sizeof(convert)) place--; convert[place] = 0; zpadlen = max - place; spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix); if (zpadlen < 0) zpadlen = 0; if (spadlen < 0) spadlen = 0; if (flags & DP_F_ZERO) { zpadlen = OSSL_MAX(zpadlen, spadlen); spadlen = 0; } if (flags & DP_F_MINUS) spadlen = -spadlen; /* spaces */ while (spadlen > 0) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen,

)) return 0; --spadlen; } /* sign */ if (signvalue) if(!doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue)) return 0; /* prefix */ while (*prefix) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen, *prefix)) return 0; prefix++; } /* zeros */ if (zpadlen > 0) { while (zpadlen > 0) { if(!doapr_outch(sbuffer, buffer, currlen, maxlen,

)) return 0; --zpadlen; } } /* digits */ while (place > 0) { if (!doapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place])) return 0; } /* left justified spaces */ while (spadlen < 0) { if (!doapr_outch(sbuffer, buffer, currlen, maxlen,

)) return 0; ++spadlen; } return 1; } static LDOUBLE abs_val(LDOUBLE value) { LDOUBLE result = value; if (value < 0) result = -value; return result; } static LDOUBLE pow_10(int in_exp) { LDOUBLE result = 1; while (in_exp) { result *= 10; in_exp--; } return result; } static long roundv(LDOUBLE value) { long intpart; intpart = (long)value; value = value - intpart; if (value >= 0.5) intpart++; return intpart; } static int fmtfp(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen, LDOUBLE fvalue, int min, int max, int flags, int style) { int signvalue = 0; LDOUBLE ufvalue; LDOUBLE tmpvalue; char iconvert[20]; char fconvert[20]; char econvert[20]; int iplace = 0; int fplace = 0; int eplace = 0; int padlen = 0; int zpadlen = 0; long exp = 0; unsigned long intpart; unsigned long fracpart; unsigned long max10; int realstyle; if (max < 0) max = 6; if (fvalue < 0) signvalue =

; else if (flags & DP_F_PLUS) signvalue =

; else if (flags & DP_F_SPACE) signvalue =

; /* * G_FORMAT sometimes prints like E_FORMAT and sometimes like F_FORMAT * depending on the number to be printed. Work out which one it is and use * that from here on. */ if (style == G_FORMAT) { if (fvalue == 0.0) { realstyle = F_FORMAT; } else if (fvalue < 0.0001) { realstyle = E_FORMAT; } else if ((max == 0 && fvalue >= 10) || (max > 0 && fvalue >= pow_10(max))) { realstyle = E_FORMAT; } else { realstyle = F_FORMAT; } } else { realstyle = style; } if (style != F_FORMAT) { tmpvalue = fvalue; /* Calculate the exponent */ if (fvalue != 0.0) { while (tmpvalue < 1) { tmpvalue *= 10; exp--; } while (tmpvalue > 10) { tmpvalue /= 10; exp++; } } if (style == G_FORMAT) { /* * In G_FORMAT the "precision" represents significant digits. We * always have at least 1 significant digit. */ if (max == 0) max = 1; /* Now convert significant digits to decimal places */ if (realstyle == F_FORMAT) { max -= (exp + 1); if (max < 0) { /* * Should not happen. If we

cheat

0123456789

0123456789

0123456789

0

+e

0



.

0

e

E

-

+



t at least one buffer, someone has done a big booboo */ if (!ossl_assert(*sbuffer != NULL || buffer != NULL)) return 0; /* |currlen| must always be <= |*maxlen| */ if (!ossl_assert(*currlen <= *maxlen)) return 0; if (buffer && *currlen == *maxlen) { if (*maxlen > INT_MAX - BUFFER_INC) return 0; *maxlen += BUFFER_INC; if (*buffer == NULL) { *buffer = OPENSSL_malloc(*maxlen); if (*buffer == NULL) return 0; if (*currlen > 0) { if (!ossl_assert(*sbuffer != NULL)) return 0; memcpy(*buffer, *sbuffer, *currlen); } *sbuffer = NULL; } else { char *tmpbuf; tmpbuf = OPENSSL_realloc(*buffer, *maxlen); if (tmpbuf == NULL) return 0; *buffer = tmpbuf; } } if (*currlen < *maxlen) { if (*sbuffer) (*sbuffer)[(*currlen)++] = (char)c; else (*buffer)[(*currlen)++] = (char)c; } return 1; } /***************************************************************************/ int BIO_printf(BIO *bio, const char *format, ...) { va_list args; int ret; va_start(args, format); ret = BIO_vprintf(bio, format, args); va_end(args); return (ret); } int BIO_vprintf(BIO *bio, const char *format, va_list args) { int ret; size_t retlen; char hugebuf[1024 * 2]; /* Was previously 10k, which is unreasonable * in small-stack environments, like threads * or DOS programs. */ char *hugebufp = hugebuf; size_t hugebufsize = sizeof(hugebuf); char *dynbuf = NULL; int ignored; dynbuf = NULL; if (!_dopr(&hugebufp, &dynbuf, &hugebufsize, &retlen, &ignored, format, args)) { OPENSSL_free(dynbuf); return -1; } if (dynbuf) { ret = BIO_write(bio, dynbuf, (int)retlen); OPENSSL_free(dynbuf); } else { ret = BIO_write(bio, hugebuf, (int)retlen); } return (ret); } /* * As snprintf is not available everywhere, we provide our own * implementation. This function has nothing to do with BIOs, but it

0x

0x";


Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

don't generate another error code here

Because only AF_INET addresses will reach this far, we can assert that l should be 4

don't generate another error code here

Note: under Windows the third parameter is of type (char ) whereas under other systems it is (void ) if you don't have a cast it will choke the compiler: if you do have a cast then you can either go for (char ) or (void ).

Caching gethostbyname() results forever is wrong, so we have to let the true gethostbyname() worry about this

Not making wsa_state available to the rest of the code is formally wrong. But the structures we use are [believed to be] invariable among Winsock DLLs, while API availability is [expected to be] probed at run-time with DSO_global_lookup.

OPENSSL_SYS_WINDOWS

don't make sock_init() call exit()

2011-02-18 SMS. VMS ioctl() can't tolerate a 64-bit "void arg", but we observe that all the consumers pass in an "unsigned long ", so we arrange a local copy with a short pointer, and use that, instead.

__INITIAL_POINTER_SIZE == 64

__INITIAL_POINTER_SIZE == 64 [else]

defined(OPENSSL_SYS_VMS)

defined(OPENSSL_SYS_VMS) [else]

__DJGPP__

make sure this call always pushes an error level; BIO_socket_ioctl() does so, so we do too.

BSD4.x

BSD4.x

make sure this call always pushes an error level; BIO_socket_ioctl() does so, so we do too.

www.openssl.org/source/license.html

License

bio_lcl.h

t generate another error code here */ if (BIO_lookup(str, NULL, BIO_LOOKUP_CLIENT, AF_INET, SOCK_STREAM, &res)) { size_t l; if (BIO_ADDRINFO_family(res) != AF_INET) { BIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET); } else if (BIO_ADDR_rawaddress(BIO_ADDRINFO_address(res), NULL, &l)) { /* * Because only AF_INET addresses will reach this far, we can assert * that l should be 4 */ if (ossl_assert(l == 4)) ret = BIO_ADDR_rawaddress(BIO_ADDRINFO_address(res), ip, &l); } BIO_ADDRINFO_free(res); } else { ERR_add_error_data(2, "host=", str); } return ret; } int BIO_get_port(const char *str, unsigned short *port_ptr) { BIO_ADDRINFO *res = NULL; int ret = 0; if (str == NULL) { BIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_DEFINED); return (0); } if (BIO_sock_init() != 1) return 0; /* don

host=

t have a cast it will * choke the compiler: if you do have a cast then you can either go for * (char *) or (void *). */ i = getsockopt(sock, SOL_SOCKET, SO_ERROR, (void *)&j, &size); if (i < 0) return (get_last_socket_error()); else return (j); } # if OPENSSL_API_COMPAT < 0x10100000L struct hostent *BIO_gethostbyname(const char *name) { /* * Caching gethostbyname() results forever is wrong, so we have to let * the true gethostbyname() worry about this */ # if (defined(NETWARE_BSDSOCK) && !defined(__NOVELL_LIBC__)) return gethostbyname((char *)name); # else return gethostbyname(name); # endif } # endif int BIO_sock_init(void) { # ifdef OPENSSL_SYS_WINDOWS static struct WSAData wsa_state; if (!wsa_init_done) { int err; wsa_init_done = 1; memset(&wsa_state, 0, sizeof(wsa_state)); /* * Not making wsa_state available to the rest of the code is formally * wrong. But the structures we use are [believed to be] invariable * among Winsock DLLs, while API availability is [expected to be] * probed at run-time with DSO_global_lookup. */ if (WSAStartup(0x0202, &wsa_state) != 0) { err = WSAGetLastError(); SYSerr(SYS_F_WSASTARTUP, err); BIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP); return (-1); } } # endif /* OPENSSL_SYS_WINDOWS */ # ifdef WATT32 extern int _watt_do_exit; _watt_do_exit = 0; /* don

void *arg

unsigned long *

:

0x10100000L

0x10100000L

0x0202,

0x10100000L


Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

BIO_socket - create a socket @domain: the socket domain (AF_INET, AF_INET6, AF_UNIX, ...) @socktype: the socket type (SOCK_STEAM, SOCK_DGRAM) @protocol: the protocol to use (IPPROTO_TCP, IPPROTO_UDP) @options: BIO socket options (currently unused) Creates a socket. This should be called before calling any of BIO_connect and BIO_listen. Returns the file descriptor on success or INVALID_SOCKET on failure. On failure errno is set, and a status is added to the OpenSSL error stack.

BIO_connect - connect to an address @sock: the socket to connect with @addr: the address to connect to @options: BIO socket options Connects to the address using the given socket and options. Options can be a combination of the following: - BIO_SOCK_KEEPALIVE: enable regularly sending keep-alive messages. - BIO_SOCK_NONBLOCK: Make the socket non-blocking. - BIO_SOCK_NODELAY: don't delay small messages. options holds BIO socket options that can be used You should call this for every address returned by BIO_lookup until the connection is successful. Returns 1 on success or 0 on failure. On failure errno is set and an error status is added to the OpenSSL error stack.

BIO_listen - Creates a listen socket @sock: the socket to listen with @addr: local address to bind to @options: BIO socket options Binds to the address using the given socket and options, then starts listening for incoming connections. Options can be a combination of the following: - BIO_SOCK_KEEPALIVE: enable regularly sending keep-alive messages. - BIO_SOCK_NONBLOCK: Make the socket non-blocking. - BIO_SOCK_NODELAY: don't delay small messages. - BIO_SOCK_REUSEADDR: Try to reuse the address and port combination for a recently closed port. - BIO_SOCK_V6_ONLY: When creating an IPv6 socket, make it listen only for IPv6 addresses and not IPv4 addresses mapped to IPv6. It's recommended that you set up both an IPv6 and IPv4 listen socket, and then check both for new clients that connect to it. You want to set up the socket as non-blocking in that case since else it could hang. Not all operating systems support IPv4 addresses on an IPv6 socket, and for others it's an option. If you pass the BIO_LISTEN_V6_ONLY it will try to create the IPv6 sockets to only listen for IPv6 connection. It could be that the first BIO_listen() call will listen to all the IPv6 and IPv4 addresses and that then trying to bind to the IPv4 address will fail. We can't tell the difference between already listening ourself to it and someone else listening to it when failing and errno is EADDRINUSE, so it's recommended to not give an error in that case if the first call was successful. When restarting the program it could be that the port is still in use. If you set to BIO_SOCK_REUSEADDR option it will try to reuse the port anyway. It's recommended that you use this.

SO_REUSEADDR has different behavior on Windows than on other operating systems, don't set it there.

BIO_accept_ex - Accept new incoming connections @sock: the listening socket @addr: the BIO_ADDR to store the peer address in @options: BIO socket options, applied on the accepted socket.

BIO_closesocket - Close a socket @sock: the socket to close

www.openssl.org/source/license.html

License

bio_lcl.h

t delay small messages. * * options holds BIO socket options that can be used * You should call this for every address returned by BIO_lookup * until the connection is successful. * * Returns 1 on success or 0 on failure. On failure errno is set * and an error status is added to the OpenSSL error stack. */ int BIO_connect(int sock, const BIO_ADDR *addr, int options) { int on = 1; if (sock == -1) { BIOerr(BIO_F_BIO_CONNECT, BIO_R_INVALID_SOCKET); return 0; } if (!BIO_socket_nbio(sock, (options & BIO_SOCK_NONBLOCK) != 0)) return 0; if (options & BIO_SOCK_KEEPALIVE) { if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) != 0) { SYSerr(SYS_F_SETSOCKOPT, get_last_socket_error()); BIOerr(BIO_F_BIO_CONNECT, BIO_R_UNABLE_TO_KEEPALIVE); return 0; } } if (options & BIO_SOCK_NODELAY) { if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) != 0) { SYSerr(SYS_F_SETSOCKOPT, get_last_socket_error()); BIOerr(BIO_F_BIO_CONNECT, BIO_R_UNABLE_TO_NODELAY); return 0; } } if (connect(sock, BIO_ADDR_sockaddr(addr), BIO_ADDR_sockaddr_size(addr)) == -1) { if (!BIO_sock_should_retry(-1)) { SYSerr(SYS_F_CONNECT, get_last_socket_error()); BIOerr(BIO_F_BIO_CONNECT, BIO_R_CONNECT_ERROR); } return 0; } return 1; } /*- * BIO_listen - Creates a listen socket * @sock: the socket to listen with * @addr: local address to bind to * @options: BIO socket options * * Binds to the address using the given socket and options, then * starts listening for incoming connections. * * Options can be a combination of the following: * - BIO_SOCK_KEEPALIVE: enable regularly sending keep-alive messages. * - BIO_SOCK_NONBLOCK: Make the socket non-blocking. * - BIO_SOCK_NODELAY: don

s recommended that you set up both an IPv6 and IPv4 listen socket, and * then check both for new clients that connect to it. You want to set up * the socket as non-blocking in that case since else it could hang. * * Not all operating systems support IPv4 addresses on an IPv6 socket, and for * others it

t tell the difference between already listening ourself to * it and someone else listening to it when failing and errno is EADDRINUSE, so * it

s recommended that you use this. */ int BIO_listen(int sock, const BIO_ADDR *addr, int options) { int on = 1; int socktype; socklen_t socktype_len = sizeof(socktype); if (sock == -1) { BIOerr(BIO_F_BIO_LISTEN, BIO_R_INVALID_SOCKET); return 0; } if (getsockopt(sock, SOL_SOCKET, SO_TYPE, &socktype, &socktype_len) != 0 || socktype_len != sizeof(socktype)) { SYSerr(SYS_F_GETSOCKOPT, get_last_socket_error()); BIOerr(BIO_F_BIO_LISTEN, BIO_R_GETTING_SOCKTYPE); return 0; } if (!BIO_socket_nbio(sock, (options & BIO_SOCK_NONBLOCK) != 0)) return 0; # ifndef OPENSSL_SYS_WINDOWS /* SO_REUSEADDR has different behavior on Windows than on * other operating systems, don


