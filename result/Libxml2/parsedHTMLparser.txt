HTMLparser.c : an HTML 4.0 non-verifying parser See Copyright for the status of this software. daniel@veillard.com

#define DEBUG

#define DEBUG_PUSH

Some factorized error routines

htmlErrMemory: @ctxt: an HTML parser context @extra: extra informations Handle a redefinition of attribute error

htmlParseErr: @ctxt: an HTML parser context @error: the error number @msg: the error message @str1: string infor @str2: string infor Handle a fatal parser error, i.e. violating Well-Formedness constraints

htmlParseErrInt: @ctxt: an HTML parser context @error: the error number @msg: the error message @val: integer info Handle a fatal parser error, i.e. violating Well-Formedness constraints

Parser stacks related functions and macros

htmlnamePush: @ctxt: an HTML parser context @value: the element name Pushes a new element name on top of the name stack Returns 0 in case of error, the index in the stack otherwise

htmlnamePop: @ctxt: an HTML parser context Pops the top element name from the name stack Returns the name just removed

Macros for accessing the content. Those should be used only by the parser, and not exported. Dirty macros, i.e. one need to make assumption on the context to use them CUR_PTR return the current pointer to the xmlChar to be parsed. CUR returns the current xmlChar value, i.e. a 8 bit value if compiled in ISO-Latin or UTF-8, and the current 16 bit value if compiled in UNICODE mode. This should be used internally by the parser only to compare to ASCII values otherwise it would break when running with UTF-8 encoding. NXT(n) returns the n'th next xmlChar. Same as CUR is should be used only to compare on ASCII based substring. UPP(n) returns the n'th next xmlChar converted to uppercase. Same as CUR it should be used only to compare on ASCII based substring. SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined strings without newlines within the parser. Clean macros, not dependent of an ASCII context, expect UTF-8 encoding CURRENT Returns the current char value, with the full decoding of UTF-8 if we are using this mode. It returns an int. NEXT Skip to the next character, this does the proper decoding in UTF-8 mode. It also pop-up unfinished entities on the fly. NEXTL(l) Skip the current unicode character of l xmlChars long. COPY(to) copy one char to to, increment CUR_PTR and to accordingly

Inported from XML

#define CUR (ctxt->token ? ctxt->token : (int) (ctxt->input->cur))

\ if (ctxt->input->cur == '%') xmlParserHandlePEReference(ctxt);\ if (ctxt->input->cur == '&') xmlParserHandleReference(ctxt);

htmlFindEncoding: @the HTML parser context Ty to find and encoding in the current data available in the input buffer this is needed to try to switch to the proper encoding when one face a character error. That's an heuristic, since it's operating outside of parsing it could try to use a meta which had been commented out, that's the reason it should only be used in case of error, not as a default. Returns an encoding string or NULL if not found, the string need to be freed

we also expect the input buffer to be zero terminated

htmlCurrentChar: @ctxt: the HTML parser context @len: pointer to the length of the char read The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer. Implement the end of line normalization: 2.11 End-of-Line Handling If the encoding is unspecified, in the case we find an ISO-Latin-1 char, then the encoding converter is plugged in automatically. Returns the current char value and its length

We are supposed to handle UTF8, check it's valid From rfc2044: encoding of the Unicode values on UTF-8: UCS-4 range (hex.) UTF-8 octet sequence (binary) 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx Check for the 0x110000 limit too

4-byte code

3-byte code

2-byte code

1-byte code

Assume it's a fixed length encoding (1) with a compatible encoding for the ASCII set, since XML constructs only use < 128 chars

Humm this is bad, do an automatic flow conversion

If we detect an UTF8 error that probably mean that the input encoding didn't get properly advertized in the declaration header. Report the error and switch the encoding to ISO-Latin-1 (if you don't like this policy, just declare the encoding !)

htmlSkipBlankChars: @ctxt: the HTML parser context skip all blanks character found at that point in the input streams. Returns the number of space chars skipped

The list of HTML elements and their properties

Start Tag: 1 means the start tag can be ommited End Tag: 1 means the end tag can be ommited 2 means it's forbidden (empty elements) 3 means the tag is stylistic and should be closed easily Depr: this element is deprecated DTD: 1 means that this element is valid only in the Loose DTD 2 means that this element is valid only in the Frameset DTD Name,Start Tag,End Tag,Save End,Empty,Deprecated,DTD,inline,Description , subElements , impliedsubelt , Attributes, userdata

Definitions and a couple of vars for HTML Elements

placeholders: elts with content but no subelements

... and for HTML Attributes

Other declarations that should go inline ...

start tags that imply the end of current element

The list of HTML elements which are supposed not to have CDATA content and where a p element will be implied TODO: extend that list by reading the HTML SGML DTD on implied paragraph

The list of HTML attributes which are of content %Script; NOTE: when adding ones, check htmlIsScriptAttribute() since it assumes the name starts with 'on'

This table is used by the htmlparser to know what to do with broken html pages. By assigning different priorities to different elements the parser can decide how to handle extra endtags. Endtags are only allowed to close elements with lower or equal priority.

Default priority

functions to handle HTML specific data

htmlInitAutoClose: Initialize the htmlStartCloseIndex for fast lookup of closing tags names. This is not reentrant. Call xmlInitParser() once before processing in case of use in multithreaded programs.

htmlTagLookup: @tag: The tag name in lowercase Lookup the HTML tag in the ElementTable Returns the related htmlElemDescPtr or NULL if not found.

htmlGetEndPriority: @name: The name of the element to look up the priority for. Return value: The "endtag" priority.

htmlCheckAutoClose: @newtag: The new tag name @oldtag: The old tag name Checks whether the new tag is one of the registered valid tags for closing old. Initialize the htmlStartCloseIndex for fast lookup of closing tags names. Returns 0 if no, 1 if yes.

inefficient, but not a big deal

htmlAutoCloseOnClose: @ctxt: an HTML parser context @newtag: The new tag name @force: force the tag closure The HTML DTD allows an ending tag to implicitly close other tags.

A missplaced endtag can only close elements with lower or equal priority, so if we find an element with higher priority before we find an element with matching name, we just ignore this endtag

htmlAutoCloseOnEnd: @ctxt: an HTML parser context Close all remaining tags at the end of the stream

htmlAutoClose: @ctxt: an HTML parser context @newtag: The new tag name or NULL The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function is called when a new tag has been detected and generates the appropriates closes if possible/needed. If newtag is NULL this mean we are at the end of the resource and we should check

htmlAutoCloseTag: @doc: the HTML document @name: The tag name @elem: the HTML element The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if the element or one of it's children would autoclose the given tag. Returns 1 if autoclose, 0 otherwise

htmlIsAutoClosed: @doc: the HTML document @elem: the HTML element The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if a tag is autoclosed by one of it's child Returns 1 if autoclosed, 0 otherwise

htmlCheckImplied: @ctxt: an HTML parser context @newtag: The new tag name The HTML DTD allows a tag to exists only implicitly called when a new tag has been detected and generates the appropriates implicit tags if missing

we already saw or generated an <head> before

dropped OBJECT ... i you put it first BODY will be assumed !

we already saw or generated a <body> before

htmlCheckParagraph @ctxt: an HTML parser context Check whether a p element need to be implied before inserting characters in the current element. Returns 1 if a paragraph has been inserted, 0 if not and -1 in case of error.

htmlIsScriptAttribute: @name: an attribute name Check if an attribute is of content type Script Returns 1 is the attribute is a script 0 otherwise

all script attributes start with 'on'

The list of HTML predefined entities

the 4 absolute ones, plus apostrophe.

A bunch still in the 128-255 range Replacing them depend really on the charset used.

Anything below should really be kept as entities references

Commodity functions to handle entities

Macro used to grow the current buffer.

htmlEntityLookup: @name: the entity name Lookup the given entity in EntitiesTable TODO: the linear scan is really ugly, an hash table is really needed. Returns the associated htmlEntityDescPtr if found, NULL otherwise.

htmlEntityValueLookup: @value: the entity's unicode value Lookup the given entity in EntitiesTable TODO: the linear scan is really ugly, an hash table is really needed. Returns the associated htmlEntityDescPtr if found, NULL otherwise.

UTF8ToHtml: @out: a pointer to an array of bytes to store the result @outlen: the length of @out @in: a pointer to an array of UTF-8 chars @inlen: the length of @in Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out. Returns 0 if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed as the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.

initialization nothing to do

trailing byte in leading position

no chance for this in Ascii

assertion: c is a single UTF-4 value

Try to lookup a predefined HTML entity for it

htmlEncodeEntities: @out: a pointer to an array of bytes to store the result @outlen: the length of @out @in: a pointer to an array of UTF-8 chars @inlen: the length of @in @quoteChar: the quote character to escape (' or ") or zero. Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out. Returns 0 if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed as the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.

trailing byte in leading position

no chance for this in Ascii

assertion: c is a single UTF-4 value

Try to lookup a predefined HTML entity for it

Commodity functions to handle streams

htmlNewInputStream: @ctxt: an HTML parser context Create a new input stream structure Returns the new input stream or NULL

Commodity functions, cleanup needed ?

all tags allowing pc data from the html 4.01 loose dtd NOTE: it might be more apropriate to integrate this information into the html40ElementTable array but I don't want to risk any binary incomptibility

areBlanks: @ctxt: an HTML parser context @str: a xmlChar @len: the size of @str Is this a sequence of blank chars that one can ignore ? Returns 1 if ignorable 0 otherwise.

Only strip CDATA children of the body tag for strict HTML DTDs

keep ws in constructs like ...<b> </b>... for all tags "b" allowing PCDATA

keep ws in constructs like <p><b>xy</b> <i>z</i><p> for all tags "p" allowing PCDATA

htmlNewDocNoDtD: @URI: URI for the dtd, or NULL @ExternalID: the external ID of the DTD, or NULL Creates a new HTML document without a DTD node if @URI and @ExternalID are NULL Returns a new document, do not initialize the DTD if not provided

Allocate a new document and fill the fields.

htmlNewDoc: @URI: URI for the dtd, or NULL @ExternalID: the external ID of the DTD, or NULL Creates a new HTML document Returns a new document

The parser itself Relates to http://www.w3.org/TR/html40

The parser itself

htmlParseHTMLName: @ctxt: an HTML parser context parse an HTML tag or attribute name, note that we convert it to lowercase since HTML names are not case-sensitive. Returns the Tag Name parsed or NULL

htmlParseHTMLName_nonInvasive: @ctxt: an HTML parser context parse an HTML tag or attribute name, note that we convert it to lowercase since HTML names are not case-sensitive, this doesn't consume the data from the stream, it's a look-ahead Returns the Tag Name parsed or NULL

htmlParseName: @ctxt: an HTML parser context parse an HTML name, this routine is case sensitive. Returns the Name parsed or NULL

Accelerator for simple ASCII names

Handler for more complex cases

accelerators

test bigname.xml

htmlParseHTMLAttribute: @ctxt: an HTML parser context @stop: a char stop value parse an HTML attribute value till the stop (quote), if stop is 0 then it stops at the first space Returns the attribute parsed or NULL

allocate a translation buffer.

Ok loop until we reach one of the ending chars

htmlParseEntityRef: @ctxt: an HTML parser context @str: location to store the entity name parse an HTML ENTITY references [68] EntityRef ::= '&' Name ';' Returns the associated htmlEntityDescPtr if found, or NULL otherwise, if non-NULL str will have to be freed by the caller.

Lookup the entity in the table.

OK that's ugly !!!

htmlParseAttValue: @ctxt: an HTML parser context parse a value for an attribute Note: the parser won't do substitution of entities here, this will be handled later in xmlStringGetNodeList, unless it was asked for ctxt->replaceEntities != 0 Returns the AttValue parsed or NULL.

That's an HTMLism, the attribute value may not be quoted

htmlParseSystemLiteral: @ctxt: an HTML parser context parse an HTML Literal [11] SystemLiteral ::= ('"' [^"] '"') | ("'" [^'] "'") Returns the SystemLiteral parsed or NULL

htmlParsePubidLiteral: @ctxt: an HTML parser context parse an HTML public literal [12] PubidLiteral ::= '"' PubidChar '"' | "'" (PubidChar - "'") "'" Returns the PubidLiteral parsed or NULL.

Name ::= (Letter | '_') (NameChar)

htmlParseScript: @ctxt: an HTML parser context parse the content of an HTML SCRIPT or STYLE element http://www.w3.org/TR/html4/sgml/dtd.html#Script http://www.w3.org/TR/html4/sgml/dtd.html#StyleSheet http://www.w3.org/TR/html4/types.html#type-script http://www.w3.org/TR/html4/types.html#h-6.15 http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.2.1 Script data ( %Script; in the DTD) can be the content of the SCRIPT element and the value of intrinsic event attributes. User agents must not evaluate script data as HTML markup but instead must pass it on as data to a script engine. NOTES: - The content is passed like CDATA - the attributes for style and scripting "onXXX" are also described as CDATA but SGML allows entities references in attributes so their processing is identical as other attributes

One should break here, the specification is clear: Authors should therefore escape "</" within the content. Escape mechanisms are specific to each scripting or style sheet language. In recovery mode, only break if end tag match the current tag, effectively ignoring all tags inside the script/style block and treating the entire block as CDATA.

while

while

Insert as CDATA, which is the same as HTML_PRESERVE_NODE

Insert as CDATA, which is the same as HTML_PRESERVE_NODE

htmlParseCharData: @ctxt: an HTML parser context parse a CharData section. if we are within a CDATA section ']]>' marks an end of section. [14] CharData ::= [^<&] - ([^<&] ']]>' [^<&])

Ok the segment is to be consumed as chars.

Ok the segment is to be consumed as chars.

Loop detection

htmlParseExternalID: @ctxt: an HTML parser context @publicID: a xmlChar receiving PubidLiteral Parse an External ID or a Public ID [75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral [83] PublicID ::= 'PUBLIC' S PubidLiteral Returns the function returns SystemLiteral and in the second case publicID receives PubidLiteral, is strict is off it is possible to return NULL and have publicID set.

xmlParsePI: @ctxt: an XML parser context parse an XML Processing Instruction. [16] PI ::= '<?' PITarget (S (Char - (Char '?>' Char)))? '?>'

this is a Processing Instruction.

Parse the target name and check for special support like namespace.

SAX: PI detected.

SAX: PI detected.

htmlParseComment: @ctxt: an HTML parser context Parse an XML (SGML) comment <!-- .... --> [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-'))) '-->'

Check that there is a comment right here.

htmlParseCharRef: @ctxt: an HTML parser context parse Reference declarations [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';' Returns the value parsed (as an int)

Check the value IS_CHAR ...

htmlParseDocTypeDecl: @ctxt: an HTML parser context parse a DOCTYPE declaration [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | PEReference | S) ']' S?)? '>'

We know that '<!DOCTYPE' has been detected.

Parse the DOCTYPE name.

Check that upper(name) == "HTML" !!!!!!!!!!!!!

Check for SystemID and ExternalID

We should be at the end of the DOCTYPE declaration.

We shouldn't try to resynchronize ...

Create or update the document accordingly to the DOCTYPE

Cleanup, since we don't use all those identifiers

htmlParseAttribute: @ctxt: an HTML parser context @value: a xmlChar used to store the value of the attribute parse an attribute [41] Attribute ::= Name Eq AttValue [25] Eq ::= S? '=' S? With namespace: [NS 11] Attribute ::= QName Eq AttValue Also the case QName == xmlns:??? is handled independently as a namespace definition. Returns the attribute name, and the value in value.

read the value

assume a minimized attribute

htmlCheckEncoding: @ctxt: an HTML parser context @attvalue: the attribute value Checks an http-equiv attribute from a Meta tag to detect the encoding If a new encoding is detected the parser is switched to decode it and pass UTF8

do not change encoding

registered set of known encodings

fallback for unknown encodings

convert as much as possible to the parser reading buffer.

htmlCheckMeta: @ctxt: an HTML parser context @atts: the attributes values Checks an attributes from a Meta tag

htmlParseStartTag: @ctxt: an HTML parser context parse a start of tag either for rule element or EmptyElement. In both case we don't parse the tag closing chars. [40] STag ::= '<' Name (S Attribute) S? '>' [44] EmptyElemTag ::= '<' Name (S Attribute) S? '/>' With namespace: [NS 8] STag ::= '<' QName (S Attribute) S? '>' [NS 10] EmptyElement ::= '<' QName (S Attribute) S? '/>' Returns 0 in case of success, -1 in case of error and 1 if discarded

Dump the bogus tag like browsers do

Check for auto-closure of HTML elements.

Check for implied HTML elements.

Avoid html at any level > 0, head at any level != 1 or any attempt to recurse body

Now parse the attributes, it ends up with the ending (S Attribute) S?

Well formedness requires at most one declaration of an attribute

Add the pair to atts

allow for 10 attrs by default

Dump the bogus attribute string up to the next blank or the end of the tag.

Handle specific association to the META tag

SAX: Start of Element !

htmlParseEndTag: @ctxt: an HTML parser context parse an end of tag [42] ETag ::= '</' Name S? '>' With namespace [NS 9] ETag ::= '</' QName S? '>' Returns 1 if the current level should be closed.

We should definitely be at the ending "S? '>'" part

We're not at the ending > !! Error, unless in recover mode where we search forwards until we find a >

if we ignored misplaced tags in htmlParseStartTag don't pop them out now.

If the name read is not one of the element in the parsing stack then return, it's just an error.

Check for auto-closure of HTML elements.

Well formedness constraints, opening and closing must match. With the exception that the autoclose may have popped stuff out of the stack.

SAX: End of Tag

htmlParseReference: @ctxt: an HTML parser context parse and handle entity references in content, this will end-up in a call to character() since this is either a CharRef, or a predefined entity.

ctxt->sax->characters(ctxt->userData, BAD_CAST ";", 1);

htmlParseContent: @ctxt: an HTML parser context Parse a content: comment, sub-element, reference or text.

Our tag or one of it's parent or children is ending.

while

Dump the bogus tag like browsers do

Has this node been popped out during parsing of the next element

Handle SCRIPT/STYLE separately

Sometimes DOCTYPE arrives in the middle of the document

First case : a comment

Second case : a Processing Instruction.

Third case : a sub-element.

Fourth case : a reference. If if has not been resolved, parsing returns it's Name, create the node

Fifth case : end of the resource

Last case, text. Note that References are handled directly.

htmlParseContent: @ctxt: an HTML parser context Parse a content: comment, sub-element, reference or text.

htmlParseElement: @ctxt: an HTML parser context parse an HTML element, this is highly recursive [39] element ::= EmptyElemTag | STag content ETag [41] Attribute ::= Name Eq AttValue

Capture start position

Lookup the info for that element.

Check for an Empty Element labeled the XML/SGML way

end of parsing of this node.

Capture end position and add node

Check for an Empty Element from DTD definition

Parse the content of the element:

Capture end position and add node

htmlParseDocument: @ctxt: an HTML parser context parse an HTML document (and build a tree if using the standard SAX interface). Returns 0, -1 in case of error. the parser context is augmented as a result of the parsing.

SAX: beginning of the document processing.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

Wipe out everything which is before the first '<'

Parse possible comments and PIs before any content

Then possibly doc type declaration(s) and more Misc (doctypedecl Misc)?

Parse possible comments and PIs before any content

Time to start parsing the tree itself

autoclose

SAX: end of the document processing.

Parser contexts handling

htmlInitParserCtxt: @ctxt: an HTML parser context Initialize a parser context Returns 0 in case of success and -1 in case of error

Allocate the Input stack

Allocate the Node stack

Allocate the Name stack

htmlFreeParserCtxt: @ctxt: an HTML parser context Free all the memory used by a parser context. However the parsed document in ctxt->myDoc is not freed.

htmlNewParserCtxt: Allocate and initialize a new parser context. Returns the htmlParserCtxtPtr or NULL in case of allocation error

htmlCreateMemoryParserCtxt: @buffer: a pointer to a char array @size: the size of the array Create a parser context for an HTML in-memory document. Returns the new parser context or NULL

htmlCreateDocParserCtxt: @cur: a pointer to an array of xmlChar @encoding: a free form C string describing the HTML document encoding, or NULL Create a parser context for an HTML document. TODO: check the need to add encoding handling there Returns the new parser context or NULL

registered set of known encodings

fallback for unknown encodings

Progressive parsing interfaces

htmlParseLookupSequence: @ctxt: an HTML parser context @first: the first char to lookup @next: the next char to lookup or zero @third: the next char to lookup or zero @comment: flag to force checking inside comments Try to find if a sequence (first, next, third) or just (first next) or (first) is available in the input stream. This function has a side effect of (possibly) incrementing ctxt->checkIndex to avoid rescanning sequences of bytes, it DOES change the state of the parser, do not use liberally. This is basically similar to xmlParseLookupSequence() Returns the index to the current parsing point if the full sequence is available, -1 otherwise.

take into account the sequence length

do not increment past <! - some people use <!-->

htmlParseLookupChars: @ctxt: an HTML parser context @stop: Array of chars, which stop the lookup. @stopLen: Length of stop-Array Try to find if any char of the stop-Array is available in the input stream. This function has a side effect of (possibly) incrementing ctxt->checkIndex to avoid rescanning sequences of bytes, it DOES change the state of the parser, do not use liberally. Returns the index to the current parsing point if a stopChar is available, -1 otherwise.

do not increment past <! - some people use <!-->

htmlParseTryOrFinish: @ctxt: an HTML parser context @terminate: last chunk indicator Try to progress on parsing Returns zero if no parsing was possible

SAX: end of the document processing.

Document parsing is done !

Very first chars read from the document flow.

Lookup the info for that element.

Check for an Empty Element labeled the XML/SGML way

end of parsing of this node.

Check for an Empty Element from DTD definition

Handle preparsed entities and charRef

Handle SCRIPT/STYLE separately

bad cut of input

Sometimes DOCTYPE arrives in the middle of the document

TODO: check generation of subtrees if noent !!!

check that the text sequence is complete before handing out the data to the parser to avoid problems with erroneous end of data detection.

SAX: end of the document processing.

htmlParseChunk: @ctxt: an HTML parser context @chunk: an char array @size: the size in byte of the chunk @terminate: last chunk indicator Parse a Chunk of memory Returns zero if no error, the xmlParserErrors otherwise.

User entry points

htmlCreatePushParserCtxt: @sax: a SAX handler @user_data: The user data returned on SAX callbacks @chunk: a pointer to an array of chars @size: number of chars in the array @filename: an optional file name or URI @enc: an optional encoding Create a parser context for using the HTML parser in push mode The value of @filename is used for fetching external entities and error/warning reports. Returns the new parser context or NULL

LIBXML_PUSH_ENABLED

htmlSAXParseDoc: @cur: a pointer to an array of xmlChar @encoding: a free form C string describing the HTML document encoding, or NULL @sax: the SAX handler block @userData: if using SAX, this pointer will be provided on callbacks. Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks to handle parse events. If sax is NULL, fallback to the default DOM behavior and return a tree. Returns the resulting document tree unless SAX is NULL or the document is not well formed.

htmlParseDoc: @cur: a pointer to an array of xmlChar @encoding: a free form C string describing the HTML document encoding, or NULL parse an HTML in-memory document and build a tree. Returns the resulting document tree

htmlCreateFileParserCtxt: @filename: the filename @encoding: a free form C string describing the HTML document encoding, or NULL Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the new parser context or NULL

htmlCharEncoding enc;

set encoding

htmlSAXParseFile: @filename: the filename @encoding: a free form C string describing the HTML document encoding, or NULL @sax: the SAX handler block @userData: if using SAX, this pointer will be provided on callbacks. parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. Returns the resulting document tree unless SAX is NULL or the document is not well formed.

htmlParseFile: @filename: the filename @encoding: a free form C string describing the HTML document encoding, or NULL parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the resulting document tree

htmlHandleOmittedElem: @val: int 0 or 1 Set and return the previous value for handling HTML omitted tags. Returns the last value for 0 for no handling, 1 for auto insertion.

htmlElementAllowedHere: @parent: HTML parent element @elt: HTML element Checks whether an HTML element may be a direct child of a parent element. Note - doesn't check for deprecated elements Returns 1 if allowed; 0 otherwise.

htmlElementStatusHere: @parent: HTML parent element @elt: HTML element Checks whether an HTML element may be a direct child of a parent element. and if so whether it is valid or deprecated. Returns one of HTML_VALID, HTML_DEPRECATED, HTML_INVALID

htmlAttrAllowed: @elt: HTML element @attr: HTML attribute @legacy: whether to allow deprecated attributes Checks whether an attribute is valid for an element Has full knowledge of Required and Deprecated attributes Returns one of HTML_REQUIRED, HTML_VALID, HTML_DEPRECATED, HTML_INVALID

htmlNodeStatus: @node: an htmlNodePtr in a tree @legacy: whether to allow deprecated elements (YES is faster here for Element nodes) Checks whether the tree node is valid. Experimental (the author only uses the HTML enhancements in a SAX parser) Return: for Element nodes, a return from htmlElementAllowedHere (if legacy allowed) or htmlElementStatusHere (otherwise). for Attribute nodes, a return from htmlAttrAllowed for other nodes, HTML_NA (no checks performed)

New set (2.6.0) of simpler and more flexible APIs

DICT_FREE: @str: a string Free a string if it is not owned by the "dict" dictionnary in the current scope

htmlCtxtReset: @ctxt: an HTML parser context Reset a parser context

Non consuming

htmlCtxtUseOptions: @ctxt: an HTML parser context @options: a combination of htmlParserOption(s) Applies the options to the parser context Returns 0 in case of success, the set of unknown or unimplemented options in case of error.

htmlDoRead: @ctxt: an HTML parser context @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) @reuse: keep the context for reuse Common front-end for the htmlRead functions Returns the resulting document tree or NULL

htmlReadDoc: @cur: a pointer to a zero terminated string @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML in-memory document and build a tree. Returns the resulting document tree

htmlReadFile: @filename: a file or URL @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML file from the filesystem or the network. Returns the resulting document tree

htmlReadMemory: @buffer: a pointer to a char array @size: the size of the array @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML in-memory document and build a tree. Returns the resulting document tree

htmlReadFd: @fd: an open file descriptor @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML from a file descriptor and build a tree. Returns the resulting document tree

htmlReadIO: @ioread: an I/O read function @ioclose: an I/O close function @ioctx: an I/O handler @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an HTML document from I/O functions and source and build a tree. Returns the resulting document tree

htmlCtxtReadDoc: @ctxt: an HTML parser context @cur: a pointer to a zero terminated string @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

htmlCtxtReadFile: @ctxt: an HTML parser context @filename: a file or URL @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML file from the filesystem or the network. This reuses the existing @ctxt parser context Returns the resulting document tree

htmlCtxtReadMemory: @ctxt: an HTML parser context @buffer: a pointer to a char array @size: the size of the array @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

htmlCtxtReadFd: @ctxt: an HTML parser context @fd: an open file descriptor @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an XML from a file descriptor and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

htmlCtxtReadIO: @ctxt: an HTML parser context @ioread: an I/O read function @ioclose: an I/O close function @ioctx: an I/O handler @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of htmlParserOption(s) parse an HTML document from I/O functions and source and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

LIBXML_HTML_ENABLED

W3C//DTD HTML 4.01//EN") ||

W3C//DTD HTML 4//EN"))

www.w3.org/TR/REC-html40/loose.dtd",

W3C//DTD HTML 4.0 Transitional//EN"));

www.w3.org/TR/html40 *

www.w3.org/TR/html4/sgml/dtd.html#Script

www.w3.org/TR/html4/sgml/dtd.html#StyleSheet

www.w3.org/TR/html4/types.html#type-script

www.w3.org/TR/html4/types.html#h-6.15

www.w3.org/TR/html4/appendix/notes.html#h-B.3.2.1

W3C//DTD HTML 4.0 Transitional//EN",

www.w3.org/TR/REC-html40/loose.dtd");

W3C//DTD HTML 4.0 Transitional//EN",

www.w3.org/TR/REC-html40/loose.dtd");

libxml.h

Memory allocation failed : %s\n

Memory allocation failed\n

head

body

th next xmlChar. Same as CUR is should be used only * to compare on ASCII based substring. * UPP(n) returns the n

\n

%

&

s an heuristic, since it

s the reason it * should only be used in case of error, not as a default. * * Returns an encoding string or NULL if not found, the string need to * be freed */ static xmlChar * htmlFindEncoding(xmlParserCtxtPtr ctxt) { const xmlChar *start, *cur, *end; if ((ctxt == NULL) || (ctxt->input == NULL) || (ctxt->input->encoding != NULL) || (ctxt->input->buf == NULL) || (ctxt->input->buf->encoder != NULL)) return(NULL); if ((ctxt->input->cur == NULL) || (ctxt->input->end == NULL)) return(NULL); start = ctxt->input->cur; end = ctxt->input->end; /* we also expect the input buffer to be zero terminated */ if (*end != 0) return(NULL); cur = xmlStrcasestr(start, BAD_CAST "HTTP-EQUIV"); if (cur == NULL) return(NULL); cur = xmlStrcasestr(cur, BAD_CAST "CONTENT"); if (cur == NULL) return(NULL); cur = xmlStrcasestr(cur, BAD_CAST "CHARSET="); if (cur == NULL) return(NULL); cur += 8; start = cur; while (((*cur >=

) && (*cur <=

)) || ((*cur >=

) && (*cur <=

)) || ((*cur >=

) && (*cur <=

)) || (*cur ==

) || (*cur ==

) || (*cur ==

) || (*cur ==

)) cur++; if (cur == start) return(NULL); return(xmlStrndup(start, cur - start)); } /** * htmlCurrentChar: * @ctxt: the HTML parser context * @len: pointer to the length of the char read * * The current char value, if using UTF-8 this may actually span multiple * bytes in the input buffer. Implement the end of line normalization: * 2.11 End-of-Line Handling * If the encoding is unspecified, in the case we find an ISO-Latin-1 * char, then the encoding converter is plugged in automatically. * * Returns the current char value and its length */ static int htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) { if (ctxt->instate == XML_PARSER_EOF) return(0); if (ctxt->token != 0) { *len = 0; return(ctxt->token); } if (ctxt->charset == XML_CHAR_ENCODING_UTF8) { /* * We are supposed to handle UTF8, check it

Char 0x%X out of allowed range\n

Char 0x%X out of allowed range\n



s a fixed length encoding (1) with * a compatible encoding for the ASCII set, since * XML constructs only use < 128 chars */ *len = 1; if ((int) *ctxt->input->cur < 0x80) return((int) *ctxt->input->cur); /* * Humm this is bad, do an automatic flow conversion */ { xmlChar * guess; xmlCharEncodingHandlerPtr handler; guess = htmlFindEncoding(ctxt); if (guess == NULL) { xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1); } else { if (ctxt->input->encoding != NULL) xmlFree((xmlChar *) ctxt->input->encoding); ctxt->input->encoding = guess; handler = xmlFindCharEncodingHandler((const char *) guess); if (handler != NULL) { xmlSwitchToEncoding(ctxt, handler); } else { htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING, "Unsupported encoding %s", guess, NULL); } } ctxt->charset = XML_CHAR_ENCODING_UTF8; } return(xmlCurrentChar(ctxt, len)); encoding_error: /* * If we detect an UTF8 error that probably mean that the * input encoding didn

t like this policy, just declare the * encoding !) */ { char buffer[150]; if (ctxt->input->end - ctxt->input->cur >= 4) { snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", ctxt->input->cur[0], ctxt->input->cur[1], ctxt->input->cur[2], ctxt->input->cur[3]); } else { snprintf(buffer, 149, "Bytes: 0x%02X\n", ctxt->input->cur[0]); } htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING, "Input is not proper UTF-8, indicate encoding !\n", BAD_CAST buffer, NULL); } ctxt->charset = XML_CHAR_ENCODING_8859_1; *len = 1; return((int) *ctxt->input->cur); } /** * htmlSkipBlankChars: * @ctxt: the HTML parser context * * skip all blanks character found at that point in the input streams. * * Returns the number of space chars skipped */ static int htmlSkipBlankChars(xmlParserCtxtPtr ctxt) { int res = 0; while (IS_BLANK_CH(*(ctxt->input->cur))) { if ((*ctxt->input->cur == 0) && (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) { xmlPopInput(ctxt); } else { if (*(ctxt->input->cur) ==

) { ctxt->input->line++; ctxt->input->col = 1; } else ctxt->input->col++; ctxt->input->cur++; ctxt->nbChars++; if (*ctxt->input->cur == 0) xmlParserInputGrow(ctxt->input, INPUT_CHUNK); } res++; } return(res); } /************************************************************************ * * * The list of HTML elements and their properties * * * ************************************************************************/ /* * Start Tag: 1 means the start tag can be ommited * End Tag: 1 means the end tag can be ommited * 2 means it

tt

i

b

u

s

strike

big

small

em

strong

dfn

code

samp

kbd

var

cite

abbr

acronym

a

img

applet

embed

object

font

basefont

br

script

map

q

sub

sup

span

bdo

iframe

pre

p

dl

div

center

noscript

noframes

blockquote

form

isindex

hr

table

fieldset

address

input

select

textarea

label

button

h1

h2

h3

h4

h5

h6

ul

ol

dir

menu

id

class

style

title

lang

dir

onclick

ondblclick

onmousedown

onmouseup

onmouseover

onmouseout

onkeypress

onkeydown

onkeyup

align

char

charoff

valign

charset

type

name

href

hreflang

rel

rev

accesskey

shape

coords

tabindex

onfocus

onblur

target

rows

cols

alt

src

alt

href

clear

p

param

codebase

archive

alt

name

height

width

align

hspace

vspace

shape

coords

href

nohref

tabindex

accesskey

onfocus

onblur

id

size

color

face

cite

ins

del

onload

onunload

background

bgcolor

text

link

vlink

alink

name

value

type

disabled

tabindex

accesskey

onfocus

onblur

span

width

col

datetime

cite

compact

dt

dd

compact

label

legend

size

color

face

pre

p

div

center

noscript

noframes

blockquote

isindex

hr

table

fieldset

address

method

enctype

accept

name

onsubmit

onreset

accept-charset

longdesc

name

src

frameborder

marginwidth

marginheight

noresize

scrolling

rows

cols

onload

onunload

frameset

frame

noframes

profile

title

isindex

base

script

style

meta

link

object

align

noshade

size

width

version

head

body

frameset

longdesc

name

src

frameborder

marginwidth

marginheight

scrolling

align

height

width

longdesc

name

height

width

usemap

ismap

align

alt

border

code

codebase

frameborder

height

hidden

hspace

name

palette

pluginspace

pluginurl

src

type

units

vspace

width

type

name

value

checked

disabled

readonly

size

maxlength

src

alt

usemap

ismap

tabindex

accesskey

onfocus

onblur

onselect

onchange

accept

prompt

for

accesskey

onfocus

onblur

accesskey

align

charset

href

hreflang

type

rel

rev

media

area

name

action

li

http-equiv

name

scheme

content

type

body

param

declare

classid

codebase

data

type

codetype

archive

standby

height

width

usemap

name

tabindex

align

border

hspace

vspace

type

compact

start

option

disabled

disabled

label

selected

value

id

value

valuetype

type

width

tt

i

b

u

s

strike

a

br

script

map

q

span

bdo

iframe

charset

src

defer

event

for

language

optgroup

option

name

size

multiple

disabled

tabindex

onfocus

onblur

onchange

media

title

summary

width

border

frame

rules

cellspacing

cellpadding

datapagesize

align

bgcolor

caption

col

colgroup

thead

tfoot

tbody

tr

tr

nowrap

bgcolor

width

height

abbr

axis

headers

scope

rowspan

colspan

name

disabled

readonly

tabindex

accesskey

onfocus

onblur

onselect

onchange

th

td

bgcolor

li

type

compact

dir

a

anchor

abbr

abbreviated form

acronym



address

information on author

applet

java applet

area

client-side image map area

b

bold text style

base

document base uri

basefont

base font size

bdo

i18n bidi over-ride

big

large text style

blockquote

long quotation

body

document body

div

br

forced line break

button

push button

caption

table caption

center

shorthand for div align=center

cite

citation

code

computer code fragment

col

table column

colgroup

table column group

col

dd

definition description

del

deleted text

dfn

instance definition

dir

directory list

li

div

generic language/style container

dl

definition list

dd

dt

definition term

em

emphasis

embed

generic embedded object

fieldset

form control group

font

local change to font

form

interactive form

fieldset

frame

subwindow

frameset

window subdivision

noframes

h1

heading

h2

heading

h3

heading

h4

heading

h5

heading

h6

heading

head

document head

hr

horizontal rule

html

document root element

i

italic text style

iframe

inline subwindow

img

embedded image

input

form control

ins

inserted text

isindex

single line prompt

kbd

text to be entered by the user

label

form field label text

legend

fieldset legend

li

list item

link

a media-independent link

map

client-side image map

menu

menu list

meta

generic metainformation

noframes

alternate content container for non frame-based rendering

body

noscript

alternate content container for non script-based rendering

div

object

generic embedded object

div

ol

ordered list

li

optgroup

option group

option

option

selectable choice

p

paragraph

param

named property value

pre

preformatted text

q

short inline quotation

s

strike-through text style

samp

sample program output, scripts, etc.

script

script statements

select

option selector

small

small text style

span

generic language/style container

strike

strike-through text

strong

strong emphasis

style

style info

sub

subscript

sup

superscript

table



tr

tbody

table body

tr

td

table data cell

textarea

multi-line text field

tfoot

table footer

tr

th

table header cell

thead

table header

tr

title

document title

tr

table row

td

tt

teletype or monospaced text style

u

underlined text style

ul

unordered list

li

var

instance of a variable or program argument

form

form

p

hr

h1

h2

h3

h4

h5

h6

dl

ul

ol

menu

dir

address

pre

listing

xmp

head

head

p

title

p

body

head

style

link

title

p

frameset

head

style

link

title

p

li

p

h1

h2

h3

h4

h5

h6

dl

address

pre

listing

xmp

head

li

hr

p

head

h1

p

head

h2

p

head

h3

p

head

h4

p

head

h5

p

head

h6

p

head

dir

p

head

address

p

head

ul

pre

p

head

ul

listing

p

head

xmp

p

head

blockquote

p

head

dl

p

dt

menu

dir

address

pre

listing

xmp

head

dt

p

menu

dir

address

pre

listing

xmp

head

dd

dd

p

menu

dir

address

pre

listing

xmp

head

dt

ul

p

head

ol

menu

dir

address

pre

listing

xmp

ol

p

head

ul

menu

p

head

ul

p

p

head

h1

h2

h3

h4

h5

h6

div

p

head

noscript

p

head

center

font

b

i

p

head

a

a

caption

p

colgroup

caption

colgroup

col

p

col

caption

col

p

table

p

head

h1

h2

h3

h4

h5

h6

pre

listing

xmp

a

th

th

td

p

span

font

a

b

i

u

td

th

td

p

span

font

a

b

i

u

tr

th

td

tr

caption

col

colgroup

p

thead

caption

col

colgroup

tfoot

th

td

tr

caption

col

colgroup

thead

tbody

p

tbody

th

td

tr

caption

col

colgroup

thead

tfoot

tbody

p

optgroup

option

option

option

fieldset

legend

p

head

h1

h2

h3

h4

h5

h6

pre

listing

xmp

a

html

head

on

onclick

ondblclick

onmousedown

onmouseup

onmouseover

onmousemove

onmouseout

onkeypress

onkeydown

onkeyup

onload

onunload

onfocus

onblur

onsubmit

onrest

onchange

onselect

div

td

th

tr

thead

tbody

tfoot

table

head

body

html

endtag

Opening and ending tag mismatch: %s and %s\n

head

body

html

s children would autoclose the * given tag. * * Returns 1 if autoclose, 0 otherwise */ int htmlAutoCloseTag(htmlDocPtr doc, const xmlChar *name, htmlNodePtr elem) { htmlNodePtr child; if (elem == NULL) return(1); if (xmlStrEqual(name, elem->name)) return(0); if (htmlCheckAutoClose(elem->name, name)) return(1); child = elem->children; while (child != NULL) { if (htmlAutoCloseTag(doc, name, child)) return(1); child = child->next; } return(0); } /** * htmlIsAutoClosed: * @doc: the HTML document * @elem: the HTML element * * The HTML DTD allows a tag to implicitly close other tags. * The list is kept in htmlStartClose array. This function checks * if a tag is autoclosed by one of it

html

html

html

body

head

script

style

meta

link

title

base

head

head

noframes

frame

frameset

body

head

body

body

p

p

p

p

p

p

p

p

on

o

n

quot

quotation mark = APL quote, U+0022 ISOnum

amp

ampersand, U+0026 ISOnum

apos

single quote

lt

less-than sign, U+003C ISOnum

gt

greater-than sign, U+003E ISOnum

nbsp

no-break space = non-breaking space, U+00A0 ISOnum

iexcl

inverted exclamation mark, U+00A1 ISOnum

cent

cent sign, U+00A2 ISOnum

pound

pound sign, U+00A3 ISOnum

curren

currency sign, U+00A4 ISOnum

yen

yen sign = yuan sign, U+00A5 ISOnum

brvbar

broken bar = broken vertical bar, U+00A6 ISOnum

sect

section sign, U+00A7 ISOnum

uml

diaeresis = spacing diaeresis, U+00A8 ISOdia

copy

copyright sign, U+00A9 ISOnum

ordf

feminine ordinal indicator, U+00AA ISOnum

laquo

left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum

not

not sign, U+00AC ISOnum

shy

soft hyphen = discretionary hyphen, U+00AD ISOnum

reg

registered sign = registered trade mark sign, U+00AE ISOnum

macr

macron = spacing macron = overline = APL overbar, U+00AF ISOdia

deg

degree sign, U+00B0 ISOnum

plusmn

plus-minus sign = plus-or-minus sign, U+00B1 ISOnum

sup2

superscript two = superscript digit two = squared, U+00B2 ISOnum

sup3

superscript three = superscript digit three = cubed, U+00B3 ISOnum

acute

acute accent = spacing acute, U+00B4 ISOdia

micro

micro sign, U+00B5 ISOnum

para

pilcrow sign = paragraph sign, U+00B6 ISOnum

middot

middle dot = Georgian comma Greek middle dot, U+00B7 ISOnum

cedil

cedilla = spacing cedilla, U+00B8 ISOdia

sup1

superscript one = superscript digit one, U+00B9 ISOnum

ordm

masculine ordinal indicator, U+00BA ISOnum

raquo

right-pointing double angle quotation mark right pointing guillemet, U+00BB ISOnum

frac14

vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum

frac12

vulgar fraction one half = fraction one half, U+00BD ISOnum

frac34

vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum

iquest

inverted question mark = turned question mark, U+00BF ISOnum

Agrave

latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1

Aacute

latin capital letter A with acute, U+00C1 ISOlat1

Acirc

latin capital letter A with circumflex, U+00C2 ISOlat1

Atilde

latin capital letter A with tilde, U+00C3 ISOlat1

Auml

latin capital letter A with diaeresis, U+00C4 ISOlat1

Aring

latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1

AElig

latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1

Ccedil

latin capital letter C with cedilla, U+00C7 ISOlat1

Egrave

latin capital letter E with grave, U+00C8 ISOlat1

Eacute

latin capital letter E with acute, U+00C9 ISOlat1

Ecirc

latin capital letter E with circumflex, U+00CA ISOlat1

Euml

latin capital letter E with diaeresis, U+00CB ISOlat1

Igrave

latin capital letter I with grave, U+00CC ISOlat1

Iacute

latin capital letter I with acute, U+00CD ISOlat1

Icirc

latin capital letter I with circumflex, U+00CE ISOlat1

Iuml

latin capital letter I with diaeresis, U+00CF ISOlat1

ETH

latin capital letter ETH, U+00D0 ISOlat1

Ntilde

latin capital letter N with tilde, U+00D1 ISOlat1

Ograve

latin capital letter O with grave, U+00D2 ISOlat1

Oacute

latin capital letter O with acute, U+00D3 ISOlat1

Ocirc

latin capital letter O with circumflex, U+00D4 ISOlat1

Otilde

latin capital letter O with tilde, U+00D5 ISOlat1

Ouml

latin capital letter O with diaeresis, U+00D6 ISOlat1

times

multiplication sign, U+00D7 ISOnum

Oslash

latin capital letter O with stroke latin capital letter O slash, U+00D8 ISOlat1

Ugrave

latin capital letter U with grave, U+00D9 ISOlat1

Uacute

latin capital letter U with acute, U+00DA ISOlat1

Ucirc

latin capital letter U with circumflex, U+00DB ISOlat1

Uuml

latin capital letter U with diaeresis, U+00DC ISOlat1

Yacute

latin capital letter Y with acute, U+00DD ISOlat1

THORN

latin capital letter THORN, U+00DE ISOlat1

szlig

latin small letter sharp s = ess-zed, U+00DF ISOlat1

agrave

latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1

aacute

latin small letter a with acute, U+00E1 ISOlat1

acirc

latin small letter a with circumflex, U+00E2 ISOlat1

atilde

latin small letter a with tilde, U+00E3 ISOlat1

auml

latin small letter a with diaeresis, U+00E4 ISOlat1

aring

latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1

aelig

latin small letter ae = latin small ligature ae, U+00E6 ISOlat1

ccedil

latin small letter c with cedilla, U+00E7 ISOlat1

egrave

latin small letter e with grave, U+00E8 ISOlat1

eacute

latin small letter e with acute, U+00E9 ISOlat1

ecirc

latin small letter e with circumflex, U+00EA ISOlat1

euml

latin small letter e with diaeresis, U+00EB ISOlat1

igrave

latin small letter i with grave, U+00EC ISOlat1

iacute

latin small letter i with acute, U+00ED ISOlat1

icirc

latin small letter i with circumflex, U+00EE ISOlat1

iuml

latin small letter i with diaeresis, U+00EF ISOlat1

eth

latin small letter eth, U+00F0 ISOlat1

ntilde

latin small letter n with tilde, U+00F1 ISOlat1

ograve

latin small letter o with grave, U+00F2 ISOlat1

oacute

latin small letter o with acute, U+00F3 ISOlat1

ocirc

latin small letter o with circumflex, U+00F4 ISOlat1

otilde

latin small letter o with tilde, U+00F5 ISOlat1

ouml

latin small letter o with diaeresis, U+00F6 ISOlat1

divide

division sign, U+00F7 ISOnum

oslash

latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1

ugrave

latin small letter u with grave, U+00F9 ISOlat1

uacute

latin small letter u with acute, U+00FA ISOlat1

ucirc

latin small letter u with circumflex, U+00FB ISOlat1

uuml

latin small letter u with diaeresis, U+00FC ISOlat1

yacute

latin small letter y with acute, U+00FD ISOlat1

thorn

latin small letter thorn with, U+00FE ISOlat1

yuml

latin small letter y with diaeresis, U+00FF ISOlat1

OElig

latin capital ligature OE, U+0152 ISOlat2

oelig

latin small ligature oe, U+0153 ISOlat2

Scaron

latin capital letter S with caron, U+0160 ISOlat2

scaron

latin small letter s with caron, U+0161 ISOlat2

Yuml

latin capital letter Y with diaeresis, U+0178 ISOlat2

fnof

latin small f with hook = function = florin, U+0192 ISOtech

circ

modifier letter circumflex accent, U+02C6 ISOpub

tilde

small tilde, U+02DC ISOdia

Alpha

greek capital letter alpha, U+0391

Beta

greek capital letter beta, U+0392

Gamma

greek capital letter gamma, U+0393 ISOgrk3

Delta

greek capital letter delta, U+0394 ISOgrk3

Epsilon

greek capital letter epsilon, U+0395

Zeta

greek capital letter zeta, U+0396

Eta

greek capital letter eta, U+0397

Theta

greek capital letter theta, U+0398 ISOgrk3

Iota

greek capital letter iota, U+0399

Kappa

greek capital letter kappa, U+039A

Lambda

greek capital letter lambda, U+039B ISOgrk3

Mu

greek capital letter mu, U+039C

Nu

greek capital letter nu, U+039D

Xi

greek capital letter xi, U+039E ISOgrk3

Omicron

greek capital letter omicron, U+039F

Pi

greek capital letter pi, U+03A0 ISOgrk3

Rho

greek capital letter rho, U+03A1

Sigma

greek capital letter sigma, U+03A3 ISOgrk3

Tau

greek capital letter tau, U+03A4

Upsilon

greek capital letter upsilon, U+03A5 ISOgrk3

Phi

greek capital letter phi, U+03A6 ISOgrk3

Chi

greek capital letter chi, U+03A7

Psi

greek capital letter psi, U+03A8 ISOgrk3

Omega

greek capital letter omega, U+03A9 ISOgrk3

alpha

greek small letter alpha, U+03B1 ISOgrk3

beta

greek small letter beta, U+03B2 ISOgrk3

gamma

greek small letter gamma, U+03B3 ISOgrk3

delta

greek small letter delta, U+03B4 ISOgrk3

epsilon

greek small letter epsilon, U+03B5 ISOgrk3

zeta

greek small letter zeta, U+03B6 ISOgrk3

eta

greek small letter eta, U+03B7 ISOgrk3

theta

greek small letter theta, U+03B8 ISOgrk3

iota

greek small letter iota, U+03B9 ISOgrk3

kappa

greek small letter kappa, U+03BA ISOgrk3

lambda

greek small letter lambda, U+03BB ISOgrk3

mu

greek small letter mu, U+03BC ISOgrk3

nu

greek small letter nu, U+03BD ISOgrk3

xi

greek small letter xi, U+03BE ISOgrk3

omicron

greek small letter omicron, U+03BF NEW

pi

greek small letter pi, U+03C0 ISOgrk3

rho

greek small letter rho, U+03C1 ISOgrk3

sigmaf

greek small letter final sigma, U+03C2 ISOgrk3

sigma

greek small letter sigma, U+03C3 ISOgrk3

tau

greek small letter tau, U+03C4 ISOgrk3

upsilon

greek small letter upsilon, U+03C5 ISOgrk3

phi

greek small letter phi, U+03C6 ISOgrk3

chi

greek small letter chi, U+03C7 ISOgrk3

psi

greek small letter psi, U+03C8 ISOgrk3

omega

greek small letter omega, U+03C9 ISOgrk3

thetasym

greek small letter theta symbol, U+03D1 NEW

upsih

greek upsilon with hook symbol, U+03D2 NEW

piv

greek pi symbol, U+03D6 ISOgrk3

ensp

en space, U+2002 ISOpub

emsp

em space, U+2003 ISOpub

thinsp

thin space, U+2009 ISOpub

zwnj

zero width non-joiner, U+200C NEW RFC 2070

zwj

zero width joiner, U+200D NEW RFC 2070

lrm

left-to-right mark, U+200E NEW RFC 2070

rlm

right-to-left mark, U+200F NEW RFC 2070

ndash

en dash, U+2013 ISOpub

mdash

em dash, U+2014 ISOpub

lsquo

left single quotation mark, U+2018 ISOnum

rsquo

right single quotation mark, U+2019 ISOnum

sbquo

single low-9 quotation mark, U+201A NEW

ldquo

left double quotation mark, U+201C ISOnum

rdquo

right double quotation mark, U+201D ISOnum

bdquo

double low-9 quotation mark, U+201E NEW

dagger

dagger, U+2020 ISOpub

Dagger

double dagger, U+2021 ISOpub

bull

bullet = black small circle, U+2022 ISOpub

hellip

horizontal ellipsis = three dot leader, U+2026 ISOpub

permil

per mille sign, U+2030 ISOtech

prime

prime = minutes = feet, U+2032 ISOtech

Prime

double prime = seconds = inches, U+2033 ISOtech

lsaquo

single left-pointing angle quotation mark, U+2039 ISO proposed

rsaquo

single right-pointing angle quotation mark, U+203A ISO proposed

oline

overline = spacing overscore, U+203E NEW

frasl

fraction slash, U+2044 NEW

euro

euro sign, U+20AC NEW

image

blackletter capital I = imaginary part, U+2111 ISOamso

weierp

script capital P = power set = Weierstrass p, U+2118 ISOamso

real

blackletter capital R = real part symbol, U+211C ISOamso

trade

trade mark sign, U+2122 ISOnum

alefsym

alef symbol = first transfinite cardinal, U+2135 NEW

larr

leftwards arrow, U+2190 ISOnum

uarr

upwards arrow, U+2191 ISOnum

rarr

rightwards arrow, U+2192 ISOnum

darr

downwards arrow, U+2193 ISOnum

harr

left right arrow, U+2194 ISOamsa

crarr

downwards arrow with corner leftwards = carriage return, U+21B5 NEW

lArr

leftwards double arrow, U+21D0 ISOtech

uArr

upwards double arrow, U+21D1 ISOamsa

rArr

rightwards double arrow, U+21D2 ISOtech

dArr

downwards double arrow, U+21D3 ISOamsa

hArr

left right double arrow, U+21D4 ISOamsa

forall

for all, U+2200 ISOtech

part

partial differential, U+2202 ISOtech

exist

there exists, U+2203 ISOtech

empty

empty set = null set = diameter, U+2205 ISOamso

nabla

nabla = backward difference, U+2207 ISOtech

isin

element of, U+2208 ISOtech

notin

not an element of, U+2209 ISOtech

ni

contains as member, U+220B ISOtech

prod

n-ary product = product sign, U+220F ISOamsb

sum

n-ary summation, U+2211 ISOamsb

minus

minus sign, U+2212 ISOtech

lowast

asterisk operator, U+2217 ISOtech

radic

square root = radical sign, U+221A ISOtech

prop

proportional to, U+221D ISOtech

infin

infinity, U+221E ISOtech

ang

angle, U+2220 ISOamso

and

logical and = wedge, U+2227 ISOtech

or

logical or = vee, U+2228 ISOtech

cap

intersection = cap, U+2229 ISOtech

cup

union = cup, U+222A ISOtech

int

integral, U+222B ISOtech

there4

therefore, U+2234 ISOtech

sim

tilde operator = varies with = similar to, U+223C ISOtech

cong

approximately equal to, U+2245 ISOtech

asymp

almost equal to = asymptotic to, U+2248 ISOamsr

ne

not equal to, U+2260 ISOtech

equiv

identical to, U+2261 ISOtech

le

less-than or equal to, U+2264 ISOtech

ge

greater-than or equal to, U+2265 ISOtech

sub

subset of, U+2282 ISOtech

sup

superset of, U+2283 ISOtech

nsub

not a subset of, U+2284 ISOamsn

sube

subset of or equal to, U+2286 ISOtech

supe

superset of or equal to, U+2287 ISOtech

oplus

circled plus = direct sum, U+2295 ISOamsb

otimes

circled times = vector product, U+2297 ISOamsb

perp

up tack = orthogonal to = perpendicular, U+22A5 ISOtech

sdot

dot operator, U+22C5 ISOamsb

lceil

left ceiling = apl upstile, U+2308 ISOamsc

rceil

right ceiling, U+2309 ISOamsc

lfloor

left floor = apl downstile, U+230A ISOamsc

rfloor

right floor, U+230B ISOamsc

lang

left-pointing angle bracket = bra, U+2329 ISOtech

rang

right-pointing angle bracket = ket, U+232A ISOtech

loz

lozenge, U+25CA ISOpub

spades

black spade suit, U+2660 ISOpub

clubs

black club suit = shamrock, U+2663 ISOpub

hearts

black heart suit = valentine, U+2665 ISOpub

diams

black diamond suit, U+2666 ISOpub

growing buffer\n

s unicode value * * Lookup the given entity in EntitiesTable * * TODO: the linear scan is really ugly, an hash table is really needed. * * Returns the associated htmlEntityDescPtr if found, NULL otherwise. */ const htmlEntityDesc * htmlEntityValueLookup(unsigned int value) { unsigned int i; for (i = 0;i < (sizeof(html40EntitiesTable)/ sizeof(html40EntitiesTable[0]));i++) { if (html40EntitiesTable[i].value >= value) { if (html40EntitiesTable[i].value > value) break; return((htmlEntityDescPtr) &html40EntitiesTable[i]); } } return(NULL); } /** * UTF8ToHtml: * @out: a pointer to an array of bytes to store the result * @outlen: the length of @out * @in: a pointer to an array of UTF-8 chars * @inlen: the length of @in * * Take a block of UTF-8 chars in and try to convert it to an ASCII * plus HTML entities block of chars out. * * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise * The value of @inlen after return is the number of octets consumed * as the return value is positive, else unpredictable. * The value of @outlen after return is the number of octets consumed. */ int UTF8ToHtml(unsigned char* out, int *outlen, const unsigned char* in, int *inlen) { const unsigned char* processed = in; const unsigned char* outend; const unsigned char* outstart = out; const unsigned char* instart = in; const unsigned char* inend; unsigned int c, d; int trailing; if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1); if (in == NULL) { /* * initialization nothing to do */ *outlen = 0; *inlen = 0; return(0); } inend = in + (*inlen); outend = out + (*outlen); while (in < inend) { d = *in++; if (d < 0x80) { c= d; trailing= 0; } else if (d < 0xC0) { /* trailing byte in leading position */ *outlen = out - outstart; *inlen = processed - instart; return(-2); } else if (d < 0xE0) { c= d & 0x1F; trailing= 1; } else if (d < 0xF0) { c= d & 0x0F; trailing= 2; } else if (d < 0xF8) { c= d & 0x07; trailing= 3; } else { /* no chance for this in Ascii */ *outlen = out - outstart; *inlen = processed - instart; return(-2); } if (inend - in < trailing) { break; } for ( ; trailing; trailing--) { if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80)) break; c <<= 6; c |= d & 0x3F; } /* assertion: c is a single UTF-4 value */ if (c < 0x80) { if (out + 1 >= outend) break; *out++ = c; } else { int len; const htmlEntityDesc * ent; const char *cp; char nbuf[16]; /* * Try to lookup a predefined HTML entity for it */ ent = htmlEntityValueLookup(c); if (ent == NULL) { snprintf(nbuf, sizeof(nbuf), "#%u", c); cp = nbuf; } else cp = ent->name; len = strlen(cp); if (out + 2 + len >= outend) break; *out++ =

; memcpy(out, cp, len); out += len; *out++ =

; } processed = in; } *outlen = out - outstart; *inlen = processed - instart; return(0); } /** * htmlEncodeEntities: * @out: a pointer to an array of bytes to store the result * @outlen: the length of @out * @in: a pointer to an array of UTF-8 chars * @inlen: the length of @in * @quoteChar: the quote character to escape (

) or zero. * * Take a block of UTF-8 chars in and try to convert it to an ASCII * plus HTML entities block of chars out. * * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise * The value of @inlen after return is the number of octets consumed * as the return value is positive, else unpredictable. * The value of @outlen after return is the number of octets consumed. */ int htmlEncodeEntities(unsigned char* out, int *outlen, const unsigned char* in, int *inlen, int quoteChar) { const unsigned char* processed = in; const unsigned char* outend; const unsigned char* outstart = out; const unsigned char* instart = in; const unsigned char* inend; unsigned int c, d; int trailing; if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) return(-1); outend = out + (*outlen); inend = in + (*inlen); while (in < inend) { d = *in++; if (d < 0x80) { c= d; trailing= 0; } else if (d < 0xC0) { /* trailing byte in leading position */ *outlen = out - outstart; *inlen = processed - instart; return(-2); } else if (d < 0xE0) { c= d & 0x1F; trailing= 1; } else if (d < 0xF0) { c= d & 0x0F; trailing= 2; } else if (d < 0xF8) { c= d & 0x07; trailing= 3; } else { /* no chance for this in Ascii */ *outlen = out - outstart; *inlen = processed - instart; return(-2); } if (inend - in < trailing) break; while (trailing--) { if (((d= *in++) & 0xC0) != 0x80) { *outlen = out - outstart; *inlen = processed - instart; return(-2); } c <<= 6; c |= d & 0x3F; } /* assertion: c is a single UTF-4 value */ if ((c < 0x80) && (c != (unsigned int) quoteChar) && (c != '&') && (c != '<') && (c != '>')) { if (out >= outend) break; *out++ = c; } else { const htmlEntityDesc * ent; const char *cp; char nbuf[16]; int len; /* * Try to lookup a predefined HTML entity for it */ ent = htmlEntityValueLookup(c); if (ent == NULL) { snprintf(nbuf, sizeof(nbuf),

, c); cp = nbuf; } else cp = ent->name; len = strlen(cp); if (out + 2 + len > outend) break; *out++ = '&'; memcpy(out, cp, len); out += len; *out++ = ';'; } processed = in; } *outlen = out - outstart; *inlen = processed - instart; return(0); } /************************************************************************ * * * Commodity functions to handle streams * * * ************************************************************************/ /** * htmlNewInputStream: * @ctxt: an HTML parser context * * Create a new input stream structure * Returns the new input stream or NULL */ static htmlParserInputPtr htmlNewInputStream(htmlParserCtxtPtr ctxt) { htmlParserInputPtr input; input = (xmlParserInputPtr) xmlMalloc(sizeof(htmlParserInput)); if (input == NULL) { htmlErrMemory(ctxt,

t allocate a new input stream\n"); return(NULL); } memset(input, 0, sizeof(htmlParserInput)); input->filename = NULL; input->directory = NULL; input->base = NULL; input->cur = NULL; input->buf = NULL; input->line = 1; input->col = 1; input->buf = NULL; input->free = NULL; input->version = NULL; input->consumed = 0; input->length = 0; return(input); } /************************************************************************ * * * Commodity functions, cleanup needed ? * * * ************************************************************************/ /* * all tags allowing pc data from the html 4.01 loose dtd * NOTE: it might be more apropriate to integrate this information * into the html40ElementTable array but I don

a

abbr

acronym

address

applet

b

bdo

big

blockquote

body

button

caption

center

cite

code

dd

del

dfn

div

dt

em

font

form

h1

h2

h3

h4

h5

h6

i

iframe

ins

kbd

label

legend

li

noframes

noscript

object

p

pre

q

s

samp

small

span

strike

strong

td

th

tt

u

var

<

html

head

body

-//W3C//DTD HTML 4.01//EN

-//W3C//DTD HTML 4//EN

b

p

HTML document creation failed\n

html

http://www.w3.org/TR/REC-html40/loose.dtd

-//W3C//DTD HTML 4.0 Transitional//EN

_

:

.

:

-

_

.

A

Z

t consume the data * from the stream, it

_

:

:

-

_

A

Z

_

:

_

-

:

.



>

/

_

:



>

/

.

-

_

:

buffer allocation failed\n

>

&

#

&

&

&

;

&

htmlParseEntityRef: no name\n

;

s ugly !!! */ NEXT; } else { htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, "htmlParseEntityRef: expecting

\n", NULL, NULL); if (str != NULL) *str = name; } } } return(ent); } /** * htmlParseAttValue: * @ctxt: an HTML parser context * * parse a value for an attribute * Note: the parser won

"

"

"

AttValue: \" expected\n

\'

\'

\'

AttValue: ' expected\n

s an HTMLism, the attribute value may not be quoted */ ret = htmlParseHTMLAttribute(ctxt, 0); if (ret == NULL) { htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE, "AttValue: no value found\n", NULL, NULL); } } return(ret); } /** * htmlParseSystemLiteral: * @ctxt: an HTML parser context * * parse an HTML Literal * * [11] SystemLiteral ::= (

' [^

"

'

]* "

) * * Returns the SystemLiteral parsed or NULL */ static xmlChar * htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) { const xmlChar *q; xmlChar *ret = NULL; if (CUR == '

) { NEXT; q = CUR_PTR; while ((IS_CHAR_CH(CUR)) && (CUR !=

')) NEXT; if (!IS_CHAR_CH(CUR)) { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,

, NULL, NULL); } else { ret = xmlStrndup(q, CUR_PTR - q); NEXT; } } else if (CUR == '\'') { NEXT; q = CUR_PTR; while ((IS_CHAR_CH(CUR)) && (CUR != '\'')) NEXT; if (!IS_CHAR_CH(CUR)) { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,

, NULL, NULL); } else { ret = xmlStrndup(q, CUR_PTR - q); NEXT; } } else { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,

expected\n", NULL, NULL); } return(ret); } /** * htmlParsePubidLiteral: * @ctxt: an HTML parser context * * parse an HTML public literal * * [12] PubidLiteral ::=

' PubidChar* '

| "

(PubidChar -

")* "

* * Returns the PubidLiteral parsed or NULL. */ static xmlChar * htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) { const xmlChar *q; xmlChar *ret = NULL; /* * Name ::= (Letter | '_') (NameChar)* */ if (CUR == '

) { NEXT; q = CUR_PTR; while (IS_PUBIDCHAR_CH(CUR)) NEXT; if (CUR !=

') { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,

, NULL, NULL); } else { ret = xmlStrndup(q, CUR_PTR - q); NEXT; } } else if (CUR == '\'') { NEXT; q = CUR_PTR; while ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\'')) NEXT; if (CUR != '\'') { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,

, NULL, NULL); } else { ret = xmlStrndup(q, CUR_PTR - q); NEXT; } } else { htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,

or ' expected\n

onXXX

<

/

</

Element %s embeds close tag\n

A

Z

a

z

Invalid char in CDATA 0x%X\n

]]>

]]>

<

<

&

&

Invalid char in CDATA 0x%X\n

SYSTEM

PUBLIC

PUBLIC

S

Y

S

T

E

M

Space required after 'SYSTEM'\n

htmlParseExternalID: SYSTEM, no URI\n

P

U

B

L

I

C

Space required after 'PUBLIC'\n

htmlParseExternalID: PUBLIC, no Public Identifier\n

"

\'

<?

?>

?>

<

?

>

ParsePI: PI %s space expected\n

>

>

ParsePI: PI %s never end ...\n

PI is not started correctly

<!--

-

-

-

-->

<

!

-

-

buffer allocation failed\n

>

-

-

growing buffer failed\n

Comment not terminated \n<!--%.50s\n

&#

;

&#x

;

htmlParseCharRef: context error\n

&

#

x

X

;

0

9

0

a

f

a

A

F

A

htmlParseCharRef: missing semicolumn\n

;

&

#

;

0

9

0

htmlParseCharRef: missing semicolumn\n

;

htmlParseCharRef: invalid value\n

htmlParseCharRef: invalid xmlChar value %d\n

<!DOCTYPE

[

]

>

<!DOCTYPE

htmlParseDocTypeDecl : no DOCTYPE name !\n

HTML

>

DOCTYPE improperly terminated\n

t try to resynchronize ... */ } NEXT; /* * Create or update the document accordingly to the DOCTYPE */ if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) && (!ctxt->disableSAX)) ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI); /* * Cleanup, since we don

=

error parsing attribute name\n

=

charset=

charset =



\t

htmlCheckEncoding: wrong encoding meta\n

htmlCheckEncoding: encoder error\n

http-equiv

Content-Type

content

t parse the tag closing chars. * * [40] STag ::=

Name (S Attribute)* S?

* * [44] EmptyElemTag ::=

Name (S Attribute)* S?

* * With namespace: * * [NS 8] STag ::=

QName (S Attribute)* S?

* * [NS 10] EmptyElement ::=

QName (S Attribute)* S?

* * Returns 0 in case of success, -1 in case of error and 1 if discarded */ static int htmlParseStartTag(htmlParserCtxtPtr ctxt) { const xmlChar *name; const xmlChar *attname; xmlChar *attvalue; const xmlChar **atts; int nbatts = 0; int maxatts; int meta = 0; int i; int discardtag = 0; if (ctxt->instate == XML_PARSER_EOF) return(-1); if ((ctxt == NULL) || (ctxt->input == NULL)) { htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR, "htmlParseStartTag: context error\n", NULL, NULL); return -1; } if (CUR !=

) return -1; NEXT; atts = ctxt->atts; maxatts = ctxt->maxatts; GROW; name = htmlParseHTMLName(ctxt); if (name == NULL) { htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED, "htmlParseStartTag: invalid element name\n", NULL, NULL); /* Dump the bogus tag like browsers do */ while ((IS_CHAR_CH(CUR)) && (CUR !=

) && (ctxt->instate != XML_PARSER_EOF)) NEXT; return -1; } if (xmlStrEqual(name, BAD_CAST"meta")) meta = 1; /* * Check for auto-closure of HTML elements. */ htmlAutoClose(ctxt, name); /* * Check for implied HTML elements. */ htmlCheckImplied(ctxt, name); /* * Avoid html at any level > 0, head at any level != 1 * or any attempt to recurse body */ if ((ctxt->nameNr > 0) && (xmlStrEqual(name, BAD_CAST"html"))) { htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR, "htmlParseStartTag: misplaced <html> tag\n", name, NULL); discardtag = 1; ctxt->depth++; } if ((ctxt->nameNr != 1) && (xmlStrEqual(name, BAD_CAST"head"))) { htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR, "htmlParseStartTag: misplaced <head> tag\n", name, NULL); discardtag = 1; ctxt->depth++; } if (xmlStrEqual(name, BAD_CAST"body")) { int indx; for (indx = 0;indx < ctxt->nameNr;indx++) { if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST"body")) { htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR, "htmlParseStartTag: misplaced <body> tag\n", name, NULL); discardtag = 1; ctxt->depth++; } } } /* * Now parse the attributes, it ends up with the ending * * (S Attribute)* S? */ SKIP_BLANKS; while ((IS_CHAR_CH(CUR)) && (CUR !=

) && ((CUR !=

) || (NXT(1) !=

))) { long cons = ctxt->nbChars; GROW; attname = htmlParseAttribute(ctxt, &attvalue); if (attname != NULL) { /* * Well formedness requires at most one declaration of an attribute */ for (i = 0; i < nbatts;i += 2) { if (xmlStrEqual(atts[i], attname)) { htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED, "Attribute %s redefined\n", attname, NULL); if (attvalue != NULL) xmlFree(attvalue); goto failed; } } /* * Add the pair to atts */ if (atts == NULL) { maxatts = 22; /* allow for 10 attrs by default */ atts = (const xmlChar **) xmlMalloc(maxatts * sizeof(xmlChar *)); if (atts == NULL) { htmlErrMemory(ctxt, NULL); if (attvalue != NULL) xmlFree(attvalue); goto failed; } ctxt->atts = atts; ctxt->maxatts = maxatts; } else if (nbatts + 4 > maxatts) { const xmlChar **n; maxatts *= 2; n = (const xmlChar **) xmlRealloc((void *) atts, maxatts * sizeof(const xmlChar *)); if (n == NULL) { htmlErrMemory(ctxt, NULL); if (attvalue != NULL) xmlFree(attvalue); goto failed; } atts = n; ctxt->atts = atts; ctxt->maxatts = maxatts; } atts[nbatts++] = attname; atts[nbatts++] = attvalue; atts[nbatts] = NULL; atts[nbatts + 1] = NULL; } else { if (attvalue != NULL) xmlFree(attvalue); /* Dump the bogus attribute string up to the next blank or * the end of the tag. */ while ((IS_CHAR_CH(CUR)) && !(IS_BLANK_CH(CUR)) && (CUR !=

) && ((CUR !=

) || (NXT(1) !=

))) NEXT; } failed: SKIP_BLANKS; if (cons == ctxt->nbChars) { htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR, "htmlParseStartTag: problem parsing attributes\n", NULL, NULL); break; } } /* * Handle specific association to the META tag */ if (meta && (nbatts != 0)) htmlCheckMeta(ctxt, atts); /* * SAX: Start of Element ! */ if (!discardtag) { htmlnamePush(ctxt, name); if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) { if (nbatts != 0) ctxt->sax->startElement(ctxt->userData, name, atts); else ctxt->sax->startElement(ctxt->userData, name, NULL); } } if (atts != NULL) { for (i = 1;i < nbatts;i += 2) { if (atts[i] != NULL) xmlFree((xmlChar *) atts[i]); } } return(discardtag); } /** * htmlParseEndTag: * @ctxt: an HTML parser context * * parse an end of tag * * [42] ETag ::=

Name S?

* * With namespace * * [NS 9] ETag ::=

QName S?

* * Returns 1 if the current level should be closed. */ static int htmlParseEndTag(htmlParserCtxtPtr ctxt) { const xmlChar *name; const xmlChar *oldname; int i, ret; if ((CUR !=

) || (NXT(1) !=

)) { htmlParseErr(ctxt, XML_ERR_LTSLASH_REQUIRED, "htmlParseEndTag:

not found\n", NULL, NULL); return (0); } SKIP(2); name = htmlParseHTMLName(ctxt); if (name == NULL) return (0); /* * We should definitely be at the ending "S?

" part */ SKIP_BLANKS; if ((!IS_CHAR_CH(CUR)) || (CUR !=

)) { htmlParseErr(ctxt, XML_ERR_GT_REQUIRED, "End tag : expected

\n", NULL, NULL); if (ctxt->recovery) { /* * We

\0

>

t pop them * out now. */ if ((ctxt->depth > 0) && (xmlStrEqual(name, BAD_CAST "html") || xmlStrEqual(name, BAD_CAST "body") || xmlStrEqual(name, BAD_CAST "head"))) { ctxt->depth--; return (0); } /* * If the name read is not one of the element in the parsing stack * then return, it

Unexpected end tag : %s\n

Opening and ending tag mismatch: %s and %s\n

&

#

&

&

;

s parent or children is ending. */ if ((CUR ==

) && (NXT(1) ==

)) { if (htmlParseEndTag(ctxt) && ((currentNode != NULL) || (ctxt->nameNr == 0))) { if (currentNode != NULL) xmlFree(currentNode); return; } continue; /* while */ } else if ((CUR ==

) && ((IS_ASCII_LETTER(NXT(1))) || (NXT(1) ==

) || (NXT(1) ==

))) { name = htmlParseHTMLName_nonInvasive(ctxt); if (name == NULL) { htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED, "htmlParseStartTag: invalid element name\n", NULL, NULL); /* Dump the bogus tag like browsers do */ while ((IS_CHAR_CH(CUR)) && (CUR !=

)) NEXT; if (currentNode != NULL) xmlFree(currentNode); return; } if (ctxt->name != NULL) { if (htmlCheckAutoClose(name, ctxt->name) == 1) { htmlAutoClose(ctxt, name); continue; } } } /* * Has this node been popped out during parsing of * the next element */ if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) && (!xmlStrEqual(currentNode, ctxt->name))) { if (currentNode != NULL) xmlFree(currentNode); return; } if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST"script")) || (xmlStrEqual(currentNode, BAD_CAST"style")))) { /* * Handle SCRIPT/STYLE separately */ htmlParseScript(ctxt); } else { /* * Sometimes DOCTYPE arrives in the middle of the document */ if ((CUR ==

) && (NXT(1) ==

) && (UPP(2) ==

) && (UPP(3) ==

) && (UPP(4) ==

) && (UPP(5) ==

) && (UPP(6) ==

) && (UPP(7) ==

) && (UPP(8) ==

)) { htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR, "Misplaced DOCTYPE declaration\n", BAD_CAST "DOCTYPE" , NULL); htmlParseDocTypeDecl(ctxt); } /* * First case : a comment */ if ((CUR ==

) && (NXT(1) ==

) && (NXT(2) ==

) && (NXT(3) ==

)) { htmlParseComment(ctxt); } /* * Second case : a Processing Instruction. */ else if ((CUR ==

) && (NXT(1) ==

)) { htmlParsePI(ctxt); } /* * Third case : a sub-element. */ else if (CUR ==

) { htmlParseElement(ctxt); } /* * Fourth case : a reference. If if has not been resolved, * parsing returns it

&

detected an error in element content\n

htmlParseElement: context error\n

>

Tag %s invalid\n

/

>

>

Couldn't find end of Start Tag %s\n

htmlParseDocument: context error\n

<

Document is empty\n

<

!

-

-

<

?

<

!

D

O

C

T

Y

P

E

<

!

-

-

<

?

html

-//W3C//DTD HTML 4.0 Transitional//EN

http://www.w3.org/TR/REC-html40/loose.dtd

htmlInitParserCtxt: out of memory\n

htmlInitParserCtxt: out of memory\n

htmlInitParserCtxt: out of memory\n

htmlInitParserCtxt: out of memory\n

htmlInitParserCtxt: out of memory\n

NewParserCtxt: out of memory\n

Unsupported encoding %s\n

Unsupported encoding %s\n

<

!

-

-

"

\'

-

-

>

HPP: lookup '%c' found at %d\n

HPP: lookup '%c%c' found at %d\n

HPP: lookup '%c%c%c' found at %d\n

HPP: lookup '%c' failed\n

HPP: lookup '%c%c' failed\n

HPP: lookup '%c%c%c' failed\n

<

!

-

-

-

-

>

HPP: try EOF\n

HPP: try START\n

HPP: try MISC\n

HPP: try COMMENT\n

HPP: try PROLOG\n

HPP: try START_TAG\n

HPP: try CONTENT\n

HPP: try CDATA_SECTION\n

HPP: try END_TAG\n

HPP: try ENTITY_DECL\n

HPP: try ENTITY_VALUE\n

HPP: try ATTRIBUTE_VALUE\n

HPP: try DTD\n

HPP: try EPILOG\n

HPP: try PI\n

HPP: try SYSTEM_LITERAL\n

<

!

D

O

C

T

Y

P

E

>

HPP: Parsing internal subset\n

HPP: entering PROLOG\n

HPP: entering MISC\n

<

!

-

-

-

-

>

HPP: Parsing Comment\n

<

?

>

HPP: Parsing PI\n

<

!

D

O

C

T

Y

P

E

>

HPP: Parsing internal subset\n

HPP: entering PROLOG\n

<

!

HPP: entering START_TAG\n

<

!

-

-

-

-

>

HPP: Parsing Comment\n

<

?

>

HPP: Parsing PI\n

<

!

HPP: entering START_TAG\n

<

!

-

-

-

-

>

HPP: Parsing Comment\n

<

?

>

HPP: Parsing PI\n

<

!

HPP: entering EOF\n

<

HPP: entering CONTENT\n

/

HPP: entering END_TAG\n

>

>

Tag %s invalid\n

/

>

HPP: entering CONTENT\n

>

Couldn't find end of Start Tag %s\n

HPP: entering CONTENT\n

HPP: entering CONTENT\n

<

&

script

style

<

/

<

/

HPP: entering END_TAG\n

<

!

D

O

C

T

Y

P

E

>

Misplaced DOCTYPE declaration\n

DOCTYPE

<

!

-

-

-

-

>

HPP: Parsing Comment\n

<

?

>

HPP: Parsing PI\n

<

!

<

/

HPP: entering END_TAG\n

<

HPP: entering START_TAG\n

&

; >/

HPP: Parsing Reference\n

<&

HPP: Parsing char data\n

detected an error in element content\n

>

HPP: entering CONTENT\n

HPP: internal error, state == CDATA\n

HPP: entering CONTENT\n

HPP: internal error, state == DTD\n

HPP: entering CONTENT\n

HPP: internal error, state == COMMENT\n

HPP: entering CONTENT\n

HPP: internal error, state == PI\n

HPP: entering CONTENT\n

HPP: internal error, state == ENTITY_DECL\n

HPP: entering CONTENT\n

HPP: internal error, state == ENTITY_VALUE\n

HPP: entering DTD\n

HPP: internal error, state == ATTRIBUTE_VALUE\n

HPP: entering START_TAG\n

HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n

HPP: entering CONTENT\n

HPP: internal error, state == XML_PARSER_IGNORE\n

HPP: entering CONTENT\n

HPP: internal error, state == XML_PARSER_LITERAL\n

HPP: entering CONTENT\n

html

-//W3C//DTD HTML 4.0 Transitional//EN

http://www.w3.org/TR/REC-html40/loose.dtd

HPP: done %d\n

htmlParseChunk: context error\n

HPP: pushed %d\n

encoder error\n

HPP: pushed %d\n

charset=

out of memory\n

dict

elfgcchack.h

0xxxxxxx

0xxxxx

0xxxxxx

0xxxx

0xxxxxx

0xxxxxx

0x110000

0x80)

0xc0)

0x80)

0xe0)

0xe0)

0xc0)

0x80)

0xf0)

0xf0)

0xf8)

0xf0)

0xc0)

0x80))

0x7)

0x3f)

0x3f)

0x3f;

0xf)

0x3f)

0x3f;

0x1f)

0x3f;

0x%X

0x%X

0x80)

0x%02X

0x%02X

0x%02X

0x%02X\n",

0x%02X\n",

0x80)

0xC0)

0xE0)

0x1F;

0xF0)

0x0F;

0xF8)

0x07;

0xC0)

0x80))

0x3F;

0x80)

0x80)

0xC0)

0xE0)

0x1F;

0xF0)

0x0F;

0xF8)

0x07;

0xC0)

0x80)

0x3F;

0x80)

0x20;

0x20;

0x61)

0x7A))

0x41)

0x5A))

0x61)

0x7A))

0x41)

0x5A))

0x30)

0x39))

0x80))

0x80)

0x800)

0x1F)

0xC0;

0x10000)

0x0F)

0xE0;

0x07)

0xF0;

0x3F)

0x80;

0x80)

0x800)

0x1F)

0xC0;

0x10000)

0x0F)

0xE0;

0x07)

0xF0;

0x3F)

0x80;

0x80)

0x800)

0x1F)

0xC0;

0x10000)

0x0F)

0xE0;

0x07)

0xF0;

0x3F)

0x80;

0x%X\n",

0x%X\n",

0x80)

0x800)

0x1F)

0xC0;

0x10000)

0x0F)

0xE0;

0x07)

0xF0;

0x3F)

0x80;

0x80)

0x800)

0x1F)

0xC0;

0x10000)

0x0F)

0xE0;

0x07)

0xF0;

0x3F)

0x80;

0x0;

Summary: interface for an HTML 4.0 non-verifying parser Description: this module implements an HTML 4.0 non-verifying parser with API compatible with the XML parser ones. It should be able to parse "real world" HTML, even if severely broken from a specification point of view. Copy: See Copyright for the status of this software. Author: Daniel Veillard

Most of the back-end structures from XML and HTML are shared.

Internal description of an HTML element, representing HTML 4.01 and XHTML 1.0 (which share the same structure).

The tag name

Whether the start tag can be implied

Whether the end tag can be implied

Whether the end tag should be saved

Is this an empty element ?

Is this a deprecated element ?

1: only in Loose DTD, 2: only Frameset one

is this a block 0 or inline 1 element

the description

NRK Jan.2003 New fields encapsulating HTML structure Bugs: This is a very limited representation. It fails to tell us when an element requires subelements (we only have whether they're allowed or not), and it doesn't tell us where CDATA and PCDATA are allowed. Some element relationships are not fully represented: these are flagged with the word MODIFIER

allowed sub-elements of this element

subelement for suggested auto-repair if necessary or NULL

Optional Attributes

Additional deprecated attributes

Required attributes

Internal description of an HTML entity.

the UNICODE value for the character

The entity name

the description

There is only few public functions.

Interfaces for the Push mode.

LIBXML_PUSH_ENABLED

New set of simpler/more flexible APIs

xmlParserOption: This is the set of XML parser options that can be passed down to the xmlReadDoc() and similar calls.

Relaxed parsing

suppress error reports

suppress warning reports

pedantic error reporting

remove blank nodes

Forbid network access

compact small text nodes

NRK/Jan2003: further knowledge of HTML structure

something we don't check at all

VALID bit set so ( & HTML_VALID ) is TRUE

Using htmlElemDesc rather than name here, to emphasise the fact that otherwise there's a lookup overhead

htmlDefaultSubelement: @elt: HTML element Returns the default subelement for this element

htmlElementAllowedHereDesc: @parent: HTML parent element @elt: HTML element Checks whether an HTML element description may be a direct child of the specified element. Returns 1 if allowed; 0 otherwise.

htmlRequiredAttrs: @elt: HTML element Returns the attributes required for the specified element.

LIBXML_HTML_ENABLED

__HTML_PARSER_H__

real world

C

re * allowed or not), and it doesn

t check at all */ HTML_INVALID = 0x1 , HTML_DEPRECATED = 0x2 , HTML_VALID = 0x4 , HTML_REQUIRED = 0xc /* VALID bit set so ( & HTML_VALID ) is TRUE */ } htmlStatus ; /* Using htmlElemDesc rather than name here, to emphasise the fact that otherwise there

0x1

0x2

0x4

0xc

