SAX2.c : Default SAX2 handler to build a tree. See Copyright for the status of this software. Daniel Veillard <daniel@veillard.com>

Define SIZE_T_MAX unless defined through <limits.h>.

!SIZE_T_MAX

#define DEBUG_SAX2

#define DEBUG_SAX2_TREE

TODO: macro to flag unimplemented blocks XML_CATALOG_PREFER user env to select between system/public prefered option. C.f. Richard Tobin <richard@cogsci.ed.ac.uk> > Just FYI, I am using an environment variable XML_CATALOG_PREFER with > values "system" and "public". I have made the default be "system" to > match yours.

xmlSAX2ErrMemory: @ctxt: an XML validation parser context @msg: a string to accompany the error message

xmlValidError: @ctxt: an XML validation parser context @error: the error number @msg: the error message @str1: extra data @str2: extra data Handle a validation error

xmlFatalErrMsg: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: an error string @str2: an error string Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlWarnMsg: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: an error string @str2: an error string Handle a parser warning

xmlNsErrMsg: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: an error string @str2: an error string Handle a namespace error

xmlNsWarnMsg: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: an error string Handle a namespace warning

xmlSAX2GetPublicId: @ctx: the user data (XML parser context) Provides the public ID e.g. "-//SGMLSOURCE//DTD DEMO//EN" Returns a xmlChar

xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;

xmlSAX2GetSystemId: @ctx: the user data (XML parser context) Provides the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd Returns a xmlChar

xmlSAX2GetLineNumber: @ctx: the user data (XML parser context) Provide the line number of the current parsing point. Returns an int

xmlSAX2GetColumnNumber: @ctx: the user data (XML parser context) Provide the column number of the current parsing point. Returns an int

xmlSAX2IsStandalone: @ctx: the user data (XML parser context) Is this document tagged standalone ? Returns 1 if true

xmlSAX2HasInternalSubset: @ctx: the user data (XML parser context) Does this document has an internal subset Returns 1 if true

xmlSAX2HasExternalSubset: @ctx: the user data (XML parser context) Does this document has an external subset Returns 1 if true

xmlSAX2InternalSubset: @ctx: the user data (XML parser context) @name: the root element name @ExternalID: the external ID @SystemID: the SYSTEM ID (e.g. filename or URL) Callback on internal subset declaration.

xmlSAX2ExternalSubset: @ctx: the user data (XML parser context) @name: the root element name @ExternalID: the external ID @SystemID: the SYSTEM ID (e.g. filename or URL) Callback on external subset declaration.

Try to fetch and parse the external subset.

Ask the Entity resolver to load the damn thing

make sure we won't destroy the main document context

On the fly encoding conversion if needed

let's parse that entity knowing it's an external subset.

Free up the external entities

Restore the parsing context of the main entity

ctxt->wellFormed = oldwellFormed;

xmlSAX2ResolveEntity: @ctx: the user data (XML parser context) @publicId: The public ID of the entity @systemId: The system ID of the entity The entity loader, to control the loading of external entities, the application can either: - override this xmlSAX2ResolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it's own entity resolution routine Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

xmlSAX2GetEntity: @ctx: the user data (XML parser context) @name: The entity name Get an entity by name Returns the xmlEntityPtr if found.

for validation purposes we really need to fetch and parse the external entity

xmlSAX2GetParameterEntity: @ctx: the user data (XML parser context) @name: The entity name Get a parameter entity by name Returns the xmlEntityPtr if found.

xmlSAX2EntityDecl: @ctx: the user data (XML parser context) @name: the entity name @type: the entity type @publicId: The public ID of the entity @systemId: The system ID of the entity @content: the entity value (without processing). An entity definition has been parsed

xmlSAX2AttributeDecl: @ctx: the user data (XML parser context) @elem: the name of the element @fullname: the attribute name @type: the attribute type @def: the type of default value @defaultValue: the attribute default value @tree: the tree of enumerated value set An attribute definition has been parsed

Raise the error but keep the validity flag

TODO: optimize name/prefix allocation

LIBXML_VALID_ENABLED

xmlSAX2ElementDecl: @ctx: the user data (XML parser context) @name: the element name @type: the element type @content: the element value tree An element definition has been parsed

LIBXML_VALID_ENABLED

xmlSAX2NotationDecl: @ctx: the user data (XML parser context) @name: The name of the notation @publicId: The public ID of the entity @systemId: The system ID of the entity What to do when a notation declaration has been parsed.

LIBXML_VALID_ENABLED

xmlSAX2UnparsedEntityDecl: @ctx: the user data (XML parser context) @name: The name of the entity @publicId: The public ID of the entity @systemId: The system ID of the entity @notationName: the name of the notation What to do when an unparsed entity declaration is parsed

xmlSAX2SetDocumentLocator: @ctx: the user data (XML parser context) @loc: A SAX Locator Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.

xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;

xmlSAX2StartDocument: @ctx: the user data (XML parser context) called when the document start being processed.

xmlSAX2EndDocument: @ctx: the user data (XML parser context) called when the document end has been detected.

LIBXML_VALID_ENABLED

Grab the encoding if it was added on-the-fly

xmlSAX2AttributeInternal: @ctx: the user data (XML parser context) @fullname: The attribute name, including namespace prefix @value: The attribute value @prefix: the prefix on the element node Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.

Split the full name into a namespace prefix and the tag name

Do the last stage of the attribute normalization Needed for HTML too: http://www.w3.org/TR/html4/types.html#h-6.2

LIBXML_VALID_ENABLED

Check whether it's a namespace definition

a default namespace definition

Validate also for namespace decls, they are attributes from an XML-1.0 perspective

LIBXML_VALID_ENABLED

a standard namespace definition

Validate also for namespace decls, they are attributes from an XML-1.0 perspective

LIBXML_VALID_ENABLED

!!!!!! <a toto:arg="" xmlns:toto="http://toto.com">

If we don't substitute entities, the validation should be done on a value with replaced entities anyway.

Do the last stage of the attribute normalization It need to be done twice ... it's an extra burden related to the ability to keep xmlSAX2References in attributes

LIBXML_VALID_ENABLED

when validating, the ID registration is done at the attribute validation level. Otherwise we have to do specific handling here.

Add the xml:id value Open issue: normalization of the value.

xmlCheckDefaultedAttributes: Check defaulted attributes from the DTD

Check against defaulted attributes from the external subset if the document is stamped as standalone

Check that the attribute is not declared in the serialization

Actually insert defaulted values when needed

Make sure that attributes redefinition occuring in the internal subset are not overriden by definitions in the external subset.

the element should be instantiated in the tree if: - this is a namespace prefix - the user required for completion in the tree like XSLT - there isn't already an attribute definition in the internal subset overriding it.

Check that the attribute is not declared in the serialization

xmlSAX2StartElement: @ctx: the user data (XML parser context) @fullname: The element name, including namespace prefix @atts: An array of name/value attributes pairs, NULL terminated called when an opening tag has been processed.

First check on validity:

Split the full name into a namespace prefix and the tag name

Note : the namespace resolution is deferred until the end of the attributes parsing, since local namespace can be defined as an attribute at this level.

We are parsing a new node.

Link the child element

Insert all the defaulted attributes from the DTD especially namespaces

process all the attributes whose name start with "xmlns"

Search the namespace, note that since the attributes have been processed, the local namespaces are available.

set the namespace node, making sure that if the default namspace is unbound on a parent we simply kee it NULL

process all the other attributes

Next ones

If it's the Document root, finish the DTD validation and check the document root element for validity

LIBXML_VALID_ENABLED

xmlSAX2EndElement: @ctx: the user data (XML parser context) @name: The element name called when the end of an element has been detected.

Capture end position and add node

LIBXML_VALID_ENABLED

end of parsing of this node.

LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLE

xmlSAX2TextNode: @ctxt: the parser context @str: the input string @len: the string length Remove the entities from an attribute value Returns the newly allocated string or NULL if not needed or error

Allocate

intern the formatting blanks found between tags, or the very short strings

store the string in the node overrithing properties and nsDef

xmlSAX2DecodeAttrEntities: @ctxt: the parser context @str: the input string @len: the string length Remove the entities from an attribute value Returns the newly allocated string or NULL if not needed or error

LIBXML_VALID_ENABLED

xmlSAX2AttributeNs: @ctx: the user data (XML parser context) @localname: the local name of the attribute @prefix: the attribute namespace prefix if available @URI: the attribute namespace name if available @value: Start of the attribute value @valueend: end of the attribute value Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.

Note: if prefix == NULL, the attribute is not in the default namespace

allocate the node

link at the end to preserv order, TODO speed up with a last

We know that if there is an entity reference, then the string has been dup'ed and terminates with 0 otherwise with ' or "

If we don't substitute entities, the validation should be done on a value with replaced entities anyway.

That should already be normalized. cheaper to finally allocate here than duplicate entry points in the full validation code

dup now contains a string of the flattened attribute content with entities substitued. Check if we need to apply an extra layer of normalization. It need to be done twice ... it's an extra burden related to the ability to keep references in attributes

if entities already have been substitued, then the attribute as passed is already normalized

LIBXML_VALID_ENABLED

when validating, the ID registration is done at the attribute validation level. Otherwise we have to do specific handling here.

Add the xml:id value Open issue: normalization of the value.

might be worth duplicate entry points and not copy

xmlSAX2StartElementNs: @ctx: the user data (XML parser context) @localname: the local name of the element @prefix: the element namespace prefix if available @URI: the element namespace name if available @nb_namespaces: number of namespace definitions on that node @namespaces: pointer to the array of prefix/URI pairs namespace definitions @nb_attributes: the number of attributes on that node @nb_defaulted: the number of defaulted attributes. @attributes: pointer to the array of (localname/prefix/URI/value/end) attribute values. SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.

First check on validity:

allocate the node

Build the namespace list

LIBXML_VALID_ENABLED

We are parsing a new node.

Link the child element

Insert the defaulted attributes from the DTD only if requested:

Search the namespace if it wasn't already found Note that, if prefix is NULL, this searches for the default Ns

process all the other attributes

If it's the Document root, finish the DTD validation and check the document root element for validity

LIBXML_VALID_ENABLED

xmlSAX2EndElementNs: @ctx: the user data (XML parser context) @localname: the local name of the element @prefix: the element namespace prefix if available @URI: the element namespace name if available SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.

Capture end position and add node

LIBXML_VALID_ENABLED

end of parsing of this node.

xmlSAX2Reference: @ctx: the user data (XML parser context) @name: The entity name called when an entity xmlSAX2Reference is detected.

xmlSAX2Characters: @ctx: the user data (XML parser context) @ch: a xmlChar string @len: the number of xmlChar receiving some chars from the parser.

Handle the data if any. If there is no child add it as content, otherwise if the last child is text, concatenate it, else create a new node of type text.

Here we needed an accelerator mechanism in case of very large elements. Use an attribute in the structure !!!

The whole point of maintaining nodelen and nodemem, xmlTextConcat is too costly, i.e. compute length, reallocate a new buffer, move data, append ch. Here We try to minimaze realloc() uses and avoid copying and recomputing length over and over.

Mixed content, first time

xmlSAX2IgnorableWhitespace: @ctx: the user data (XML parser context) @ch: a xmlChar string @len: the number of xmlChar receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use xmlSAX2Characters

xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;

xmlSAX2ProcessingInstruction: @ctx: the user data (XML parser context) @target: the target name @data: the PI data's A processing instruction has been parsed.

xmlSAX2Comment: @ctx: the user data (XML parser context) @value: the xmlSAX2Comment content A xmlSAX2Comment has been parsed.

xmlSAX2CDataBlock: @ctx: the user data (XML parser context) @value: The pcdata content @len: the block length called when a pcdata block has been parsed

xmlSAXDefaultVersion: @version: the version, 1 or 2 Set the default version of SAX used globally by the library. By default, during initialization the default is set to 2. Note that it is generally a better coding style to use xmlSAXVersion() to set up the version explicitly for a given parsing context. Returns the previous value in case of success and -1 in case of error.

LIBXML_SAX1_ENABLED

xmlSAXVersion: @hdlr: the SAX handler @version: the version, 1 or 2 Initialize the default XML SAX handler according to the version Returns 0 in case of success and -1 in case of error.

LIBXML_SAX1_ENABLED

xmlSAX2InitDefaultSAXHandler: @hdlr: the SAX handler @warning: flag if non-zero sets the handler warning procedure Initialize the default XML SAX2 handler

xmlDefaultSAXHandlerInit: Initialize the default SAX2 handler

LIBXML_SAX1_ENABLED

xmlSAX2InitHtmlDefaultSAXHandler: @hdlr: the SAX handler Initialize the default HTML SAX2 handler

htmlDefaultSAXHandlerInit: Initialize the default SAX handler

LIBXML_HTML_ENABLED

xmlSAX2InitDocbDefaultSAXHandler: @hdlr: the SAX handler Initialize the default DocBook SAX2 handler

docbDefaultSAXHandlerInit: Initialize the default SAX handler

LIBXML_DOCB_ENABLED

SGMLSOURCE//DTD DEMO//EN"

www.sgmlsource.com/dtds/memo.dtd

www.w3.org/TR/html4/types.html#h-6.2

toto.com"> */

libxml.h

system

public

system

Unimplemented block at %s:%d\n

%s: out of memory\n

-//SGMLSOURCE//DTD DEMO//EN

SAX.xmlSAX2InternalSubset(%s, %s, %s)\n

xmlSAX2InternalSubset

SAX.xmlSAX2ExternalSubset(%s, %s, %s)\n

t destroy the main document context */ oldinput = ctxt->input; oldinputNr = ctxt->inputNr; oldinputMax = ctxt->inputMax; oldinputTab = ctxt->inputTab; oldcharset = ctxt->charset; ctxt->inputTab = (xmlParserInputPtr *) xmlMalloc(5 * sizeof(xmlParserInputPtr)); if (ctxt->inputTab == NULL) { xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset"); ctxt->input = oldinput; ctxt->inputNr = oldinputNr; ctxt->inputMax = oldinputMax; ctxt->inputTab = oldinputTab; ctxt->charset = oldcharset; return; } ctxt->inputNr = 0; ctxt->inputMax = 5; ctxt->input = NULL; xmlPushInput(ctxt, input); /* * On the fly encoding conversion if needed */ if (ctxt->input->length >= 4) { enc = xmlDetectCharEncoding(ctxt->input->cur, 4); xmlSwitchEncoding(ctxt, enc); } if (input->filename == NULL) input->filename = (char *) xmlCanonicPath(SystemID); input->line = 1; input->col = 1; input->base = ctxt->input->cur; input->cur = ctxt->input->cur; input->free = NULL; /* * let

s an external subset. */ xmlParseExternalSubset(ctxt, ExternalID, SystemID); /* * Free up the external entities */ while (ctxt->inputNr > 1) xmlPopInput(ctxt); xmlFreeInputStream(ctxt->input); xmlFree(ctxt->inputTab); /* * Restore the parsing context of the main entity */ ctxt->input = oldinput; ctxt->inputNr = oldinputNr; ctxt->inputMax = oldinputMax; ctxt->inputTab = oldinputTab; ctxt->charset = oldcharset; /* ctxt->wellFormed = oldwellFormed; */ } } /** * xmlSAX2ResolveEntity: * @ctx: the user data (XML parser context) * @publicId: The public ID of the entity * @systemId: The system ID of the entity * * The entity loader, to control the loading of external entities, * the application can either: * - override this xmlSAX2ResolveEntity() callback in the SAX block * - or better use the xmlSetExternalEntityLoader() function to * set up it

SAX.xmlSAX2ResolveEntity(%s, %s)\n

SAX.xmlSAX2GetEntity(%s)\n

Entity(%s) document marked standalone but requires external subset\n

Failure to process entity %s\n

SAX.xmlSAX2GetParameterEntity(%s)\n

SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\n

Entity(%s) already defined in the internal subset\n

Entity(%s) already defined in the external subset\n

SAX.xmlSAX2EntityDecl(%s) called while not in subset\n

SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\n

xml:id

xml:id : attribute type should be ID\n

SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n

SAX.xmlSAX2ElementDecl(%s, %d, ...)\n

SAX.xmlSAX2ElementDecl(%s) called while not in subset\n

SAX.xmlSAX2NotationDecl(%s, %s, %s)\n

SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n

SAX.xmlSAX2NotationDecl(%s) called while not in subset\n

SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\n

Entity(%s) already defined in the internal subset\n

Entity(%s) already defined in the external subset\n

SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n

SAX.xmlSAX2SetDocumentLocator()\n

SAX.xmlSAX2StartDocument()\n

xmlSAX2StartDocument

libxml2 built without HTML support\n

xmlSAX2StartDocument

xmlSAX2StartDocument

SAX.xmlSAX2EndDocument()\n

xmlns

invalid namespace declaration '%s'\n

Avoid attribute ending with ':' like '%s'\n

xmlSAX2StartElement

s a namespace definition */ if ((!ctxt->html) && (ns == NULL) && (name[0] ==

) && (name[1] ==

) && (name[2] ==

) && (name[3] ==

) && (name[4] ==

) && (name[5] == 0)) { xmlNsPtr nsret; xmlChar *val; if (!ctxt->replaceEntities) { ctxt->depth++; val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF, 0,0,0); ctxt->depth--; } else { val = (xmlChar *) value; } if (val[0] != 0) { xmlURIPtr uri; uri = xmlParseURI((const char *)val); if (uri == NULL) { if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL)) ctxt->sax->warning(ctxt->userData, "xmlns: %s not a valid URI\n", val); } else { if (uri->scheme == NULL) { if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL)) ctxt->sax->warning(ctxt->userData, "xmlns: URI %s is not absolute\n", val); } xmlFreeURI(uri); } } /* a default namespace definition */ nsret = xmlNewNs(ctxt->node, val, NULL); #ifdef LIBXML_VALID_ENABLED /* * Validate also for namespace decls, they are attributes from * an XML-1.0 perspective */ if (nsret != NULL && ctxt->validate && ctxt->wellFormed && ctxt->myDoc && ctxt->myDoc->intSubset) ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc, ctxt->node, prefix, nsret, val); #endif /* LIBXML_VALID_ENABLED */ if (name != NULL) xmlFree(name); if (nval != NULL) xmlFree(nval); if (val != value) xmlFree(val); return; } if ((!ctxt->html) && (ns != NULL) && (ns[0] ==

) && (ns[1] ==

) && (ns[2] ==

) && (ns[3] ==

) && (ns[4] ==

) && (ns[5] == 0)) { xmlNsPtr nsret; xmlChar *val; if (!ctxt->replaceEntities) { ctxt->depth++; val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF, 0,0,0); ctxt->depth--; if (val == NULL) { xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement"); xmlFree(ns); if (name != NULL) xmlFree(name); return; } } else { val = (xmlChar *) value; } if (val[0] == 0) { xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY, "Empty namespace name for prefix %s\n", name, NULL); } if ((ctxt->pedantic != 0) && (val[0] != 0)) { xmlURIPtr uri; uri = xmlParseURI((const char *)val); if (uri == NULL) { xmlNsWarnMsg(ctxt, XML_WAR_NS_URI, "xmlns:%s: %s not a valid URI\n", name, value); } else { if (uri->scheme == NULL) { xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE, "xmlns:%s: URI %s is not absolute\n", name, value); } xmlFreeURI(uri); } } /* a standard namespace definition */ nsret = xmlNewNs(ctxt->node, val, name); xmlFree(ns); #ifdef LIBXML_VALID_ENABLED /* * Validate also for namespace decls, they are attributes from * an XML-1.0 perspective */ if (nsret != NULL && ctxt->validate && ctxt->wellFormed && ctxt->myDoc && ctxt->myDoc->intSubset) ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc, ctxt->node, prefix, nsret, value); #endif /* LIBXML_VALID_ENABLED */ if (name != NULL) xmlFree(name); if (nval != NULL) xmlFree(nval); if (val != value) xmlFree(val); return; } if (ns != NULL) { namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns); if (namespace == NULL) { xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, "Namespace prefix %s of attribute %s is not defined\n", ns, name); } else { xmlAttrPtr prop; prop = ctxt->node->properties; while (prop != NULL) { if (prop->ns != NULL) { if ((xmlStrEqual(name, prop->name)) && ((namespace == prop->ns) || (xmlStrEqual(namespace->href, prop->ns->href)))) { xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED, "Attribute %s in %s redefined\n", name, namespace->href); ctxt->wellFormed = 0; if (ctxt->recovery == 0) ctxt->disableSAX = 1; goto error; } } prop = prop->next; } } } else { namespace = NULL; } /* !!!!!! <a toto:arg="" xmlns:toto="http://toto.com"> */ ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL); if (ret != NULL) { if ((ctxt->replaceEntities == 0) && (!ctxt->html)) { xmlNodePtr tmp; ret->children = xmlStringGetNodeList(ctxt->myDoc, value); tmp = ret->children; while (tmp != NULL) { tmp->parent = (xmlNodePtr) ret; if (tmp->next == NULL) ret->last = tmp; tmp = tmp->next; } } else if (value != NULL) { ret->children = xmlNewDocText(ctxt->myDoc, value); ret->last = ret->children; if (ret->children != NULL) ret->children->parent = (xmlNodePtr) ret; } } #ifdef LIBXML_VALID_ENABLED if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed && ctxt->myDoc && ctxt->myDoc->intSubset) { /* * If we don

s an extra burden related * to the ability to keep xmlSAX2References in attributes */ nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc, ctxt->node, fullname, val); if (nvalnorm != NULL) { xmlFree(val); val = nvalnorm; } ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc, ctxt->node, ret, val); xmlFree(val); } } else { ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc, ctxt->node, ret, value); } } else #endif /* LIBXML_VALID_ENABLED */ if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) && (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) || ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) { /* * when validating, the ID registration is done at the attribute * validation level. Otherwise we have to do specific handling here. */ if (xmlStrEqual(fullname, BAD_CAST "xml:id")) { /* * Add the xml:id value * * Open issue: normalization of the value. */ if (xmlValidateNCName(value, 1) != 0) { xmlErrValid(ctxt, XML_DTD_XMLID_VALUE, "xml:id : attribute value %s is not an NCName\n", (const char *) value, NULL); } xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret); } else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret); else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) xmlAddRef(&ctxt->vctxt, ctxt->myDoc, value, ret); } error: if (nval != NULL) xmlFree(nval); if (ns != NULL) xmlFree(ns); } /* * xmlCheckDefaultedAttributes: * * Check defaulted attributes from the DTD */ static void xmlCheckDefaultedAttributes(xmlParserCtxtPtr ctxt, const xmlChar *name, const xmlChar *prefix, const xmlChar **atts) { xmlElementPtr elemDecl; const xmlChar *att; int internal = 1; int i; elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->intSubset, name, prefix); if (elemDecl == NULL) { elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix); internal = 0; } process_external_subset: if (elemDecl != NULL) { xmlAttributePtr attr = elemDecl->attributes; /* * Check against defaulted attributes from the external subset * if the document is stamped as standalone */ if ((ctxt->myDoc->standalone == 1) && (ctxt->myDoc->extSubset != NULL) && (ctxt->validate)) { while (attr != NULL) { if ((attr->defaultValue != NULL) && (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset, attr->elem, attr->name, attr->prefix) == attr) && (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset, attr->elem, attr->name, attr->prefix) == NULL)) { xmlChar *fulln; if (attr->prefix != NULL) { fulln = xmlStrdup(attr->prefix); fulln = xmlStrcat(fulln, BAD_CAST ":"); fulln = xmlStrcat(fulln, attr->name); } else { fulln = xmlStrdup(attr->name); } if (fulln == NULL) { xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement"); break; } /* * Check that the attribute is not declared in the * serialization */ att = NULL; if (atts != NULL) { i = 0; att = atts[i]; while (att != NULL) { if (xmlStrEqual(att, fulln)) break; i += 2; att = atts[i]; } } if (att == NULL) { xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED, "standalone: attribute %s on %s defaulted from external subset\n", (const char *)fulln, (const char *)attr->elem); } xmlFree(fulln); } attr = attr->nexth; } } /* * Actually insert defaulted values when needed */ attr = elemDecl->attributes; while (attr != NULL) { /* * Make sure that attributes redefinition occuring in the * internal subset are not overriden by definitions in the * external subset. */ if (attr->defaultValue != NULL) { /* * the element should be instantiated in the tree if: * - this is a namespace prefix * - the user required for completion in the tree * like XSLT * - there isn

xmlns

xmlns

xmlSAX2StartElement

SAX.xmlSAX2StartElement(%s)\n

Validation failed: no DTD found !

xmlSAX2StartElement

Setting %s as root\n

pushing(%s)\n

adding child %s to %s\n

adding sibling %s to

xmlns

x

m

l

n

s

Namespace prefix %s is not defined\n

x

m

l

n

s

s the Document root, finish the DTD validation and * check the document root element for validity */ if ((ctxt->validate) && (ctxt->vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) { int chk; chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc); if (chk <= 0) ctxt->valid = 0; if (chk < 0) ctxt->wellFormed = 0; ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc); ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1; } #endif /* LIBXML_VALID_ENABLED */ if (prefix != NULL) xmlFree(prefix); } /** * xmlSAX2EndElement: * @ctx: the user data (XML parser context) * @name: The element name * * called when the end of an element has been detected. */ void xmlSAX2EndElement(void *ctx, const xmlChar *name ATTRIBUTE_UNUSED) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserNodeInfo node_info; xmlNodePtr cur; if (ctx == NULL) return; cur = ctxt->node; #ifdef DEBUG_SAX if (name == NULL) xmlGenericError(xmlGenericErrorContext, "SAX.xmlSAX2EndElement(NULL)\n"); else xmlGenericError(xmlGenericErrorContext, "SAX.xmlSAX2EndElement(%s)\n", name); #endif /* Capture end position and add node */ if (cur != NULL && ctxt->record_info) { node_info.end_pos = ctxt->input->cur - ctxt->input->base; node_info.end_line = ctxt->input->line; node_info.node = cur; xmlParserAddNodeInfo(ctxt, &node_info); } ctxt->nodemem = -1; #ifdef LIBXML_VALID_ENABLED if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc && ctxt->myDoc->intSubset) ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc, cur); #endif /* LIBXML_VALID_ENABLED */ /* * end of parsing of this node. */ #ifdef DEBUG_SAX_TREE xmlGenericError(xmlGenericErrorContext, "popping(%s)\n", cur->name); #endif nodePop(ctxt); } #endif /* LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLE */ /* * xmlSAX2TextNode: * @ctxt: the parser context * @str: the input string * @len: the string length * * Remove the entities from an attribute value * * Returns the newly allocated string or NULL if not needed or error */ static xmlNodePtr xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) { xmlNodePtr ret; const xmlChar *intern = NULL; /* * Allocate */ if (ctxt->freeElems != NULL) { ret = ctxt->freeElems; ctxt->freeElems = ret->next; ctxt->freeElemsNr--; } else { ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode)); } if (ret == NULL) { xmlErrMemory(ctxt, "xmlSAX2Characters"); return(NULL); } memset(ret, 0, sizeof(xmlNode)); /* * intern the formatting blanks found between tags, or the * very short strings */ if (ctxt->dictNames) { xmlChar cur = str[len]; if ((len < (int) (2 * sizeof(void *))) && (ctxt->options & XML_PARSE_COMPACT)) { /* store the string in the node overrithing properties and nsDef */ xmlChar *tmp = (xmlChar *) &(ret->properties); memcpy(tmp, str, len); tmp[len] = 0; intern = tmp; } else if ((len <= 3) && ((cur ==

') || (cur == '\'') || ((cur == '<') && (str[len + 1] != '!')))) { intern = xmlDictLookup(ctxt->dict, str, len); } else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') && (str[len + 1] != '!')) { int i; for (i = 1;i < len;i++) { if (!IS_BLANK_CH(str[i])) goto skip; } intern = xmlDictLookup(ctxt->dict, str, len); } } skip: ret->type = XML_TEXT_NODE; ret->name = xmlStringText; if (intern == NULL) { ret->content = xmlStrndup(str, len); if (ret->content == NULL) { xmlSAX2ErrMemory(ctxt,

); xmlFree(ret); return(NULL); } } else ret->content = (xmlChar *) intern; if (ctxt->input != NULL) ret->line = ctxt->input->line; if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)) xmlRegisterNodeDefaultValue(ret); return(ret); } #ifdef LIBXML_VALID_ENABLED /* * xmlSAX2DecodeAttrEntities: * @ctxt: the parser context * @str: the input string * @len: the string length * * Remove the entities from an attribute value * * Returns the newly allocated string or NULL if not needed or error */ static xmlChar * xmlSAX2DecodeAttrEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, const xmlChar *end) { const xmlChar *in; xmlChar *ret; in = str; while (in < end) if (*in++ == '&') goto decode; return(NULL); decode: ctxt->depth++; ret = xmlStringLenDecodeEntities(ctxt, str, end - str, XML_SUBSTITUTE_REF, 0,0,0); ctxt->depth--; return(ret); } #endif /* LIBXML_VALID_ENABLED */ /** * xmlSAX2AttributeNs: * @ctx: the user data (XML parser context) * @localname: the local name of the attribute * @prefix: the attribute namespace prefix if available * @URI: the attribute namespace name if available * @value: Start of the attribute value * @valueend: end of the attribute value * * Handle an attribute that has been read by the parser. * The default handling is to convert the attribute into an * DOM subtree and past it in a new xmlAttr element added to * the element. */ static void xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt, const xmlChar * localname, const xmlChar * prefix, const xmlChar * value, const xmlChar * valueend) { xmlAttrPtr ret; xmlNsPtr namespace = NULL; xmlChar *dup = NULL; /* * Note: if prefix == NULL, the attribute is not in the default namespace */ if (prefix != NULL) namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix); /* * allocate the node */ if (ctxt->freeAttrs != NULL) { ret = ctxt->freeAttrs; ctxt->freeAttrs = ret->next; ctxt->freeAttrsNr--; memset(ret, 0, sizeof(xmlAttr)); ret->type = XML_ATTRIBUTE_NODE; ret->parent = ctxt->node; ret->doc = ctxt->myDoc; ret->ns = namespace; if (ctxt->dictNames) ret->name = localname; else ret->name = xmlStrdup(localname); /* link at the end to preserv order, TODO speed up with a last */ if (ctxt->node->properties == NULL) { ctxt->node->properties = ret; } else { xmlAttrPtr prev = ctxt->node->properties; while (prev->next != NULL) prev = prev->next; prev->next = ret; ret->prev = prev; } if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)) xmlRegisterNodeDefaultValue((xmlNodePtr)ret); } else { if (ctxt->dictNames) ret = xmlNewNsPropEatName(ctxt->node, namespace, (xmlChar *) localname, NULL); else ret = xmlNewNsProp(ctxt->node, namespace, localname, NULL); if (ret == NULL) { xmlErrMemory(ctxt,

); return; } } if ((ctxt->replaceEntities == 0) && (!ctxt->html)) { xmlNodePtr tmp; /* * We know that if there is an entity reference, then * the string has been dup'ed and terminates with 0 * otherwise with ' or

t substitute entities, the validation should be * done on a value with replaced entities anyway. */ if (!ctxt->replaceEntities) { dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend); if (dup == NULL) { if (*valueend == 0) { ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc, ctxt->node, ret, value); } else { /* * That should already be normalized. * cheaper to finally allocate here than duplicate * entry points in the full validation code */ dup = xmlStrndup(value, valueend - value); ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc, ctxt->node, ret, dup); } } else { /* * dup now contains a string of the flattened attribute * content with entities substitued. Check if we need to * apply an extra layer of normalization. * It need to be done twice ... it

i

d

xml:id : attribute value %s is not an NCName\n

Validation failed: no DTD found !

xmlSAX2StartElementNs

xmlSAX2StartElementNs

xmlSAX2StartElementNs

t already found * Note that, if prefix is NULL, this searches for the default Ns */ if ((URI != NULL) && (ret->ns == NULL)) { ret->ns = xmlSearchNs(ctxt->myDoc, parent, prefix); if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) { ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix); } if (ret->ns == NULL) { ns = xmlNewNs(ret, NULL, prefix); if (ns == NULL) { xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs"); return; } if (prefix != NULL) xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, "Namespace prefix %s was not found\n", prefix, NULL); else xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, "Namespace default prefix was not found\n", NULL, NULL); } } /* * process all the other attributes */ if (nb_attributes > 0) { for (j = 0,i = 0;i < nb_attributes;i++,j+=5) { xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1], attributes[j+3], attributes[j+4]); } } #ifdef LIBXML_VALID_ENABLED /* * If it

SAX.xmlSAX2Reference(%s)\n

#

add xmlSAX2Reference %s to %s \n

SAX.xmlSAX2Characters(%.30s, %d)\n

add chars: ctxt->node == NULL !\n

add chars to %s \n

xmlSAX2Characters

xmlSAX2Characters: huge text node

xmlSAX2Characters overflow prevented

xmlSAX2Characters

xmlSAX2Characters

SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\n

SAX.xmlSAX2ProcessingInstruction(%s, %s)\n

Setting PI %s as root\n

adding PI %s child to %s\n

adding PI %s sibling to

SAX.xmlSAX2Comment(%s)\n

Setting xmlSAX2Comment as root\n

adding xmlSAX2Comment child to %s\n

adding xmlSAX2Comment sibling to

SAX.pcdata(%.10s, %d)\n

add chars to %s \n

elfgcchack.h

Summary: SAX2 parser interface used to build the DOM tree Description: those are the default SAX2 interfaces used by the library when building DOM tree. Copy: See Copyright for the status of this software. Author: Daniel Veillard

LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED

LIBXML_SAX1_ENABLED

__XML_SAX2_H__

C

