dict.c: dictionary of reusable strings, just used to avoid allocation and freeing operations. Copyright (C) 2003 Daniel Veillard. Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER. Author: daniel@veillard.com

#define DEBUG_GROW

#define DICT_DEBUG_PATTERNS

!WITH_BIG_KEY

WITH_BIG_KEY

An entry in the dictionnary

The entire dictionnary

A mutex for modifying the reference counter for shared dictionaries.

Whether the dictionary mutex was initialized.

xmlInitializeDict: Do the dictionary mutex initialization. this function is not thread safe, initialization should preferably be done once at startup

xmlDictCleanup: Free the dictionary mutex.

xmlDictAddString: @dict: the dictionnary @name: the name of the userdata @len: the length of the name, if -1 it is recomputed Add the string to the array[s] Returns the pointer of the local string, or NULL in case of error.

+ sizeof(_xmlDictStrings) == 1024

Not found, need to allocate

exponential growth

just in case !

xmlDictAddQString: @dict: the dictionnary @prefix: the prefix of the userdata @plen: the prefix length @name: the name of the userdata @len: the length of the name, if -1 it is recomputed Add the QName to the array[s] Returns the pointer of the local string, or NULL in case of error.

+ sizeof(_xmlDictStrings) == 1024

Not found, need to allocate

exponential growth

just in case !

xmlDictComputeBigKey: Calculate a hash key using a good hash function that works well for larger hash table sizes. Hash function by "One-at-a-Time Hash" see http://burtleburtle.net/bob/hash/doobs.html

xmlDictComputeBigQKey: Calculate a hash key for two strings using a good hash function that works well for larger hash table sizes. Hash function by "One-at-a-Time Hash" see http://burtleburtle.net/bob/hash/doobs.html Neither of the two strings must be NULL.

WITH_BIG_KEY

xmlDictComputeFastKey: Calculate a hash key using a fast hash function that works well for low hash table fill.

xmlDictComputeFastQKey: Calculate a hash key for two strings using a fast hash function that works well for low hash table fill. Neither of the two strings must be NULL.

xmlDictCreate: Create a new dictionary Returns the newly created dictionnary, or NULL if an error occured.

xmlDictCreateSub: @sub: an existing dictionnary Create a new dictionary, inheriting strings from the read-only dictionnary @sub. On lookup, strings are first searched in the new dictionnary, then in @sub, and if not found are created in the new dictionnary. Returns the newly created dictionnary, or NULL if an error occured.

xmlDictReference: @dict: the dictionnary Increment the reference counter of a dictionary Returns 0 in case of success and -1 in case of error

xmlDictGrow: @dict: the dictionnary @size: the new size of the dictionnary resize the dictionnary Returns 0 in case of success, -1 in case of failure

f the two loops are merged, there would be situations where a new entry needs to allocated and data copied into it from the main dict. It is nicer to run through the array twice, first copying all the elements in the main array (less probability of allocate) and then the rest, so we only free in the second loop.

we don't have much ways to alert from herei result is loosing an entry and unicity garantee

put back the entry in the new dict

xmlDictFree: @dict: the dictionnary Free the hash @dict and its contents. The userdata is deallocated with @f if provided.

decrement the counter, it may be shared by a parser and docs

xmlDictLookup: @dict: the dictionnary @name: the name of the userdata @len: the length of the name, if -1 it is recomputed Add the @name to the dictionnary @dict if not present. Returns the internal copy of the name or NULL in case of internal error

Check for duplicate and insertion location.

we cannot always reuse the same okey for the subdict

Note that entry may have been freed at this point by xmlDictGrow

xmlDictExists: @dict: the dictionnary @name: the name of the userdata @len: the length of the name, if -1 it is recomputed Check if the @name exists in the dictionnary @dict. Returns the internal copy of the name or NULL if not found.

Check for duplicate and insertion location.

we cannot always reuse the same okey for the subdict

not found

xmlDictQLookup: @dict: the dictionnary @prefix: the prefix @name: the name Add the QName @prefix:@name to the hash @dict if not present. Returns the internal copy of the QName or NULL in case of internal error

Check for duplicate and insertion location.

we cannot always reuse the same okey for the subdict

Note that entry may have been freed at this point by xmlDictGrow

xmlDictOwns: @dict: the dictionnary @str: the string check if a string is owned by the disctionary Returns 1 if true, 0 if false and -1 in case of error -1 in case of error

xmlDictSize: @dict: the dictionnary Query the number of elements installed in the hash @dict. Returns the number of elements in the dictionnary or -1 in case of error

burtleburtle.net/bob/hash/doobs.html

burtleburtle.net/bob/hash/doobs.html



libxml.h

-

+

=

+

:

One-at-a-Time Hash

One-at-a-Time Hash

:

:

:

C

R

*

xmlDictGrow : from %d to %d, %d elems\n

elfgcchack.h

Summary: string dictionnary Description: dictionary of reusable strings, just used to avoid allocation and freeing operations. Copy: See Copyright for the status of this software. Author: Daniel Veillard

The dictionnary.

Constructor and destructor.

Lookup of entry in the dictionnary.

Cleanup function

! __XML_DICT_H__

C

