entities.c : implementation for the XML entities handling See Copyright for the status of this software. daniel@veillard.com

The XML predefined entities.

xmlEntitiesErrMemory: @extra: extra informations Handle an out of memory condition

xmlEntitiesErr: @code: the error code @msg: the message Handle an out of memory condition

xmlFreeEntity : clean-up an entity record.

xmlCreateEntity: internal routine doing the entity node strutures allocations

fill the structure.

to be computed by the layer knowing the defining entity

xmlAddEntity : register a new entity for an entities table.

entity was already defined at another level.

xmlGetPredefinedEntity: @name: the entity name Check whether this name is an predefined entity. Returns NULL if not, otherwise the entity

xmlAddDtdEntity: @doc: the document @name: the entity name @type: the entity type XML_xxx_yyy_ENTITY @ExternalID: the entity external ID if available @SystemID: the entity system ID if available @content: the entity content Register a new entity for this document DTD external subset. Returns a pointer to the entity or NULL in case of error

Link it to the DTD

xmlAddDocEntity: @doc: the document @name: the entity name @type: the entity type XML_xxx_yyy_ENTITY @ExternalID: the entity external ID if available @SystemID: the entity system ID if available @content: the entity content Register a new entity for this document. Returns a pointer to the entity or NULL in case of error

Link it to the DTD

xmlNewEntity: @doc: the document @name: the entity name @type: the entity type XML_xxx_yyy_ENTITY @ExternalID: the entity external ID if available @SystemID: the entity system ID if available @content: the entity content Create a new entity, this differs from xmlAddDocEntity() that if the document is NULL or has no internal subset defined, then an unlinked entity structure will be returned, it is then the responsability of the caller to link it to the document later or free it when not needed anymore. Returns a pointer to the entity or NULL in case of error

xmlGetEntityFromTable: @table: an entity table @name: the entity name @parameter: look for parameter entities Do an entity lookup in the table. returns the corresponding parameter entity, if found. Returns A pointer to the entity structure or NULL if not found.

xmlGetParameterEntity: @doc: the document referencing the entity @name: the entity name Do an entity lookup in the internal and external subsets and returns the corresponding parameter entity, if found. Returns A pointer to the entity structure or NULL if not found.

xmlGetDtdEntity: @doc: the document referencing the entity @name: the entity name Do an entity lookup in the DTD entity hash table and returns the corresponding entity, if found. Note: the first argument is the document node, not the DTD node. Returns A pointer to the entity structure or NULL if not found.

xmlGetDocEntity: @doc: the document referencing the entity @name: the entity name Do an entity lookup in the document entity hash table and returns the corresponding entity, otherwise a lookup is done in the predefined entities too. Returns A pointer to the entity structure or NULL if not found.

Macro used to grow the current buffer.

xmlEncodeEntitiesReentrant: @doc: the document containing the string @input: A string to convert to XML. Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. Contrary to xmlEncodeEntities, this routine is reentrant, and result must be deallocated. Returns A newly allocated string with the substitution done.

allocate an translation buffer.

By default one have to encode at least '<', '>', '"' and '&' !

default case, just copy !

Bjørn Reese <br@sseusa.com> provided the patch xmlChar xc; xc = (cur & 0x3F) << 6; if (cur[1] != 0) { xc += (++cur) & 0x3F; out++ = xc; } else

We assume we have UTF-8 input.

We could do multiple things here. Just save as a char ref

xmlEncodeSpecialChars: @doc: the document containing the string @input: A string to convert to XML. Do a global encoding of a string, replacing the predefined entities this routine is reentrant, and result must be deallocated. Returns A newly allocated string with the substitution done.

allocate an translation buffer.

By default one have to encode at least '<', '>', '"' and '&' !

Works because on UTF-8, all extended sequences cannot result in bytes in the ASCII range.

xmlCreateEntitiesTable: create and initialize an empty entities hash table. This really doesn't make sense and should be deprecated Returns the xmlEntitiesTablePtr just created or NULL in case of error.

xmlFreeEntityWrapper: @entity: An entity @name: its name Deallocate the memory used by an entities in the hash table.

xmlFreeEntitiesTable: @table: An entity table Deallocate the memory used by an entities hash table.

xmlCopyEntity: @ent: An entity Build a copy of an entity Returns the new xmlEntitiesPtr or NULL in case of error.

xmlCopyEntitiesTable: @table: An entity table Build a copy of an entity table. Returns the new xmlEntitiesTablePtr or NULL in case of error.

LIBXML_TREE_ENABLED

xmlDumpEntityContent: @buf: An XML buffer. @content: The entity content. This will dump the quoted string value, taking care of the special treatment required by %

xmlDumpEntityDecl: @buf: An XML buffer. @ent: An entity table This will dump the content of the entity table as an XML DTD definition

Should be true !

xmlDumpEntityDeclScan: @ent: An entity table @buf: An XML buffer. When using the hash table scan function, arguments need to be reversed

xmlDumpEntitiesTable: @buf: An XML buffer. @table: An entity table This will dump the content of the entity table as an XML DTD definition

LIBXML_OUTPUT_ENABLED

libxml.h

lt

<

<

gt

>

>

amp

&

&

quot

\"

\"

apos

'

'

xmlCreateEntity: malloc failed

l

lt

g

gt

a

amp

apos

q

quot

xmlAddDtdEntity: document is NULL

xmlAddDtdEntity: document without external subset

xmlAddDocEntity: document is NULL

xmlAddDocEntity: document without internal subset

xmlEncodeEntitiesReentrant: realloc failed

xmlEncodeEntitiesReentrant: malloc failed

\0

<

>

"

&

<

&

l

t

;

>

&

g

t

;

&

&

a

m

p

;

\n

\t

\r

xmlEncodeEntitiesReentrant : input not UTF-8

ISO-8859-1

&#%d;

xmlEncodeEntitiesReentrant : char out of range\n

ISO-8859-1

&#%d;

&#x%X;

&#%d;

xmlEncodeSpecialChars: malloc failed

\0

<

>

"

&

<

&

l

t

;

>

&

g

t

;

&

&

a

m

p

;

"

&

q

u

o

t

;

\r

&

#

1

3

;

t make sense and should be deprecated * * Returns the xmlEntitiesTablePtr just created or NULL in case of error. */ xmlEntitiesTablePtr xmlCreateEntitiesTable(void) { return((xmlEntitiesTablePtr) xmlHashCreate(0)); } /** * xmlFreeEntityWrapper: * @entity: An entity * @name: its name * * Deallocate the memory used by an entities in the hash table. */ static void xmlFreeEntityWrapper(xmlEntityPtr entity, const xmlChar *name ATTRIBUTE_UNUSED) { if (entity != NULL) xmlFreeEntity(entity); } /** * xmlFreeEntitiesTable: * @table: An entity table * * Deallocate the memory used by an entities hash table. */ void xmlFreeEntitiesTable(xmlEntitiesTablePtr table) { xmlHashFree(table, (xmlHashDeallocator) xmlFreeEntityWrapper); } #ifdef LIBXML_TREE_ENABLED /** * xmlCopyEntity: * @ent: An entity * * Build a copy of an entity * * Returns the new xmlEntitiesPtr or NULL in case of error. */ static xmlEntityPtr xmlCopyEntity(xmlEntityPtr ent) { xmlEntityPtr cur; cur = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity)); if (cur == NULL) { xmlEntitiesErrMemory("xmlCopyEntity:: malloc failed"); return(NULL); } memset(cur, 0, sizeof(xmlEntity)); cur->type = XML_ENTITY_DECL; cur->etype = ent->etype; if (ent->name != NULL) cur->name = xmlStrdup(ent->name); if (ent->ExternalID != NULL) cur->ExternalID = xmlStrdup(ent->ExternalID); if (ent->SystemID != NULL) cur->SystemID = xmlStrdup(ent->SystemID); if (ent->content != NULL) cur->content = xmlStrdup(ent->content); if (ent->orig != NULL) cur->orig = xmlStrdup(ent->orig); if (ent->URI != NULL) cur->URI = xmlStrdup(ent->URI); return(cur); } /** * xmlCopyEntitiesTable: * @table: An entity table * * Build a copy of an entity table. * * Returns the new xmlEntitiesTablePtr or NULL in case of error. */ xmlEntitiesTablePtr xmlCopyEntitiesTable(xmlEntitiesTablePtr table) { return(xmlHashCopy(table, (xmlHashCopier) xmlCopyEntity)); } #endif /* LIBXML_TREE_ENABLED */ #ifdef LIBXML_OUTPUT_ENABLED /** * xmlDumpEntityContent: * @buf: An XML buffer. * @content: The entity content. * * This will dump the quoted string value, taking care of the special * treatment required by % */ static void xmlDumpEntityContent(xmlBufferPtr buf, const xmlChar *content) { if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return; if (xmlStrchr(content,

)) { const xmlChar * base, *cur; xmlBufferCCat(buf, "\""); base = cur = content; while (*cur != 0) { if (*cur ==

') { if (base != cur) xmlBufferAdd(buf, base, cur - base); xmlBufferAdd(buf, BAD_CAST

, 6); cur++; base = cur; } else if (*cur == '%') { if (base != cur) xmlBufferAdd(buf, base, cur - base); xmlBufferAdd(buf, BAD_CAST

, 6); cur++; base = cur; } else { cur++; } } if (base != cur) xmlBufferAdd(buf, base, cur - base); xmlBufferCCat(buf,



<!ENTITY



>\n

<!ENTITY

PUBLIC



SYSTEM

>\n

<!ENTITY

PUBLIC



SYSTEM

NDATA

>\n

<!ENTITY %



>\n

<!ENTITY %

PUBLIC



SYSTEM

>\n

xmlDumpEntitiesDecl: internal: unknown type entity type

elfgcchack.h

0x20)

0x80))

0x80)

0x3F)

0x3F;

0xC0)

0xE0)

0x1F;

0x3F;

0xF0)

0x0F;

0x3F;

0x3F;

0xF8)

0x07;

0x3F;

0x3F;

0x3F;

Summary: interface for the XML entities handling Description: this module provides some of the entity API needed for the parser and applications. Copy: See Copyright for the status of this software. Author: Daniel Veillard

The different valid entity types.

An unit of storage for an entity, contains the string, the value and the linkind data needed for the linking in the hash table.

application data

XML_ENTITY_DECL, must be second !

Entity name

First child link

Last child link

-> DTD

next sibling link

previous sibling link

the containing document

content without ref substitution

content or ndata if unparsed

the content length

The entity type

External identifier for PUBLIC

URI for a SYSTEM or PUBLIC Entity

unused

the full URI as computed

does the entity own the childrens

was the entity content checked

this is also used to count entites references done from that entity

All entities are stored in an hash table. There is 2 separate hash tables for global and parameter entities.

External functions:

LIBXML_LEGACY_ENABLED

LIBXML_LEGACY_ENABLED

LIBXML_TREE_ENABLED

LIBXML_OUTPUT_ENABLED

LIBXML_LEGACY_ENABLED

__XML_ENTITIES_H__

C

