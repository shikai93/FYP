error.c: module displaying/handling XML parser errors See Copyright for the status of this software. Daniel Veillard <daniel@veillard.com>

Handling of out of context errors

xmlGenericErrorDefaultFunc: @ctx: an error context @msg: the message to display/transmit @...: extra parameters for the message display Default handler for out of context error messages.

initGenericErrorDefaultFunc: @handler: the handler Set or reset (if NULL) the default handler for generic errors to the builtin error function.

xmlSetGenericErrorFunc: @ctx: the new error handling context @handler: the new handler function Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE than stderr by setting @ctx to this file handle and @handler to NULL. For multi-threaded applications, this must be set separately for each thread.

xmlSetStructuredErrorFunc: @ctx: the new error handling context @handler: the new handler function Function to reset the handler and the error context for out of context structured error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler For multi-threaded applications, this must be set separately for each thread.

Handling of parsing errors

xmlParserPrintFileInfo: @input: an xmlParserInputPtr input Displays the associated file and line informations for the current input

xmlParserPrintFileContext: @input: an xmlParserInputPtr input Displays current context within the input content for error tracking

GCC warns if signed, because compared with sizeof()

space for 80 chars + line terminator

skip backwards over any end-of-lines

search backwards for beginning-of-line (to max buff size)

calculate the error position in terms of the current position

search forward for end-of-line (to max buff size)

copy selected text to our buffer

print out the selected text

create blank line with problem pointer

(leave buffer space for pointer + line terminator)

xmlParserPrintFileContext: @input: an xmlParserInputPtr input Displays current context within the input content for error tracking

xmlReportError: @err: the error @ctx: the parser context or NULL @str: the formatted error message Report an erro with its context, replace the 4 old error/warning routines.

Maintain the compatibility with the legacy error handling

__xmlRaiseError: @schannel: the structured callback channel @channel: the old callback channel @data: the callback data @ctx: the parser context or NULL @ctx: the parser context or NULL @domain: the domain for the error @code: the code for the error @level: the xmlErrorLevel for the error @file: the file source of the error (or NULL) @line: the line of the error or 0 if N/A @str1: extra string info @str2: extra string info @str3: extra string info @int1: extra int info @col: column number of the error or 0 if N/A @msg: the message to display/transmit @...: extra parameters for the message display Update the appropriate global or contextual error structure, then forward the error message down the parser or generic error callback handler

Check if structured error handler set

if user has defined handler, change data ptr to user's choice

Formatting the message

specific processing if a parser context is provided

file = (const char ) node->doc->URL;

Save the information about the error

We check if the error is within an XInclude section and, if so, attempt to print out the href of the XInclude instead of the usual "base" (doc->URL) for the node (bug 152623).

Find the callback channel if channel param is NULL

__xmlSimpleError: @domain: where the error comes from @code: the error code @node: the context node @extra: extra informations Handle an out of memory condition

xmlParserError: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format an error messages, gives file, line, position and extra parameters.

xmlParserWarning: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a warning messages, gives file, line, position and extra parameters.

Handling of validation errors

xmlParserValidityError: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format an validity error messages, gives file, line, position and extra parameters.

xmlParserValidityWarning: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a validity warning messages, gives file, line, position and extra parameters.

Extended Error Handling

xmlGetLastError: Get the last global error registered. This is per thread if compiled with thread support. Returns NULL if no error occured or a pointer to the error

xmlResetError: @err: pointer to the error. Cleanup the error.

xmlResetLastError: Cleanup the last global error registered. For parsing error this does not change the well-formedness result.

xmlCtxtGetLastError: @ctx: an XML parser context Get the last parsing error registered. Returns NULL if no error occured or a pointer to the error

xmlCtxtResetLastError: @ctx: an XML parser context Cleanup the last global error registered. For parsing error this does not change the well-formedness result.

xmlCopyError: @from: a source error @to: a target error Save the original error to the new place. Returns 0 in case of success and -1 in case of error.

libxml.h

%s:%d:

Entity: line %d:

\n

\r

\n

\r

\n

\r

\n

\r

%s\n

\t



^

%s\n

%s:%d:

Entity: line %d:

%s:%d:

Entity: line %d:

element %s:

parser

namespace

validity

HTML parser

memory

output

I/O

XInclude

XPath

parser

regexp

module

Schemas validity

Schemas parser

Relax-NG parser

Relax-NG validity

Catalog

C14N

XSLT

encoding

:

warning :

error :

error :

\n

%s\n

%s

%s\n

out of memory error

%s:%d: \n

Entity: line %d: \n

%s\n



^

%s\n

s choice */ if (schannel != NULL) data = xmlStructuredErrorContext; } if ((domain == XML_FROM_VALID) && ((channel == xmlParserValidityError) || (channel == xmlParserValidityWarning))) { ctxt = (xmlParserCtxtPtr) ctx; if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC)) schannel = ctxt->sax->serror; } if (code == XML_ERR_OK) return; /* * Formatting the message */ if (msg == NULL) { str = (char *) xmlStrdup(BAD_CAST "No error message provided"); } else { XML_GET_VAR_STR(msg, str); } /* * specific processing if a parser context is provided */ if (ctxt != NULL) { if (file == NULL) { input = ctxt->input; if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) { input = ctxt->inputTab[ctxt->inputNr - 2]; } if (input != NULL) { file = input->filename; line = input->line; col = input->col; } } to = &ctxt->lastError; } else if ((node != NULL) && (file == NULL)) { int i; if ((node->doc != NULL) && (node->doc->URL != NULL)) { baseptr = node; /* file = (const char *) node->doc->URL; */ } for (i = 0; ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE)); i++) node = node->parent; if ((baseptr == NULL) && (node != NULL) && (node->doc != NULL) && (node->doc->URL != NULL)) baseptr = node; if ((node != NULL) && (node->type == XML_ELEMENT_NODE)) line = node->line; } /* * Save the information about the error */ xmlResetError(to); to->domain = domain; to->code = code; to->message = str; to->level = level; if (file != NULL) to->file = (char *) xmlStrdup((const xmlChar *) file); else if (baseptr != NULL) { #ifdef LIBXML_XINCLUDE_ENABLED /* * We check if the error is within an XInclude section and, * if so, attempt to print out the href of the XInclude instead * of the usual "base" (doc->URL) for the node (bug 152623). */ xmlNodePtr prev = baseptr; int inclcount = 0; while (prev != NULL) { if (prev->prev == NULL) prev = prev->parent; else { prev = prev->prev; if (prev->type == XML_XINCLUDE_START) { if (--inclcount < 0) break; } else if (prev->type == XML_XINCLUDE_END) inclcount++; } } if (prev != NULL) { if (prev->type == XML_XINCLUDE_START) { prev->type = XML_ELEMENT_NODE; to->file = (char *) xmlGetProp(prev, BAD_CAST "href"); prev->type = XML_XINCLUDE_START; } else { to->file = (char *) xmlGetProp(prev, BAD_CAST "href"); } } else #endif to->file = (char *) xmlStrdup(baseptr->doc->URL); if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) { to->file = (char *) xmlStrdup(node->doc->URL); } } to->line = line; if (str1 != NULL) to->str1 = (char *) xmlStrdup((const xmlChar *) str1); if (str2 != NULL) to->str2 = (char *) xmlStrdup((const xmlChar *) str2); if (str3 != NULL) to->str3 = (char *) xmlStrdup((const xmlChar *) str3); to->int1 = int1; to->int2 = col; to->node = node; to->ctxt = ctx; if (to != &xmlLastError) xmlCopyError(to,&xmlLastError); /* * Find the callback channel if channel param is NULL */ if ((ctxt != NULL) && (channel == NULL) && (xmlStructuredError == NULL) && (ctxt->sax != NULL)) { if (level == XML_ERR_WARNING) channel = ctxt->sax->warning; else channel = ctxt->sax->error; data = ctxt->userData; } else if (channel == NULL) { if ((schannel == NULL) && (xmlStructuredError != NULL)) { schannel = xmlStructuredError; data = xmlStructuredErrorContext; } else { channel = xmlGenericError; if (!data) { data = xmlGenericErrorContext; } } } if (schannel != NULL) { schannel(data, to); return; } if (channel == NULL) return; if ((channel == xmlParserError) || (channel == xmlParserWarning) || (channel == xmlParserValidityError) || (channel == xmlParserValidityWarning)) xmlReportError(to, ctxt, str, NULL, NULL); else if ((channel == (xmlGenericErrorFunc) fprintf) || (channel == xmlGenericErrorDefaultFunc)) xmlReportError(to, ctxt, str, channel, data); else channel(data, "%s", str); } /** * __xmlSimpleError: * @domain: where the error comes from * @code: the error code * @node: the context node * @extra: extra informations * * Handle an out of memory condition */ void __xmlSimpleError(int domain, int code, xmlNodePtr node, const char *msg, const char *extra) { if (code == XML_ERR_NO_MEMORY) { if (extra) __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain, XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra, NULL, NULL, 0, 0, "Memory allocation failed : %s\n", extra); else __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain, XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "Memory allocation failed\n"); } else { __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain, code, XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0, msg, extra); } } /** * xmlParserError: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format an error messages, gives file, line, position and * extra parameters. */ void XMLCDECL xmlParserError(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input = NULL; xmlParserInputPtr cur = NULL; char * str; if (ctxt != NULL) { input = ctxt->input; if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) { cur = input; input = ctxt->inputTab[ctxt->inputNr - 2]; } xmlParserPrintFileInfo(input); } xmlGenericError(xmlGenericErrorContext, "error: "); XML_GET_VAR_STR(msg, str); xmlGenericError(xmlGenericErrorContext, "%s", str); if (str != NULL) xmlFree(str); if (ctxt != NULL) { xmlParserPrintFileContext(input); if (cur != NULL) { xmlParserPrintFileInfo(cur); xmlGenericError(xmlGenericErrorContext, "\n"); xmlParserPrintFileContext(cur); } } } /** * xmlParserWarning: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a warning messages, gives file, line, position and * extra parameters. */ void XMLCDECL xmlParserWarning(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input = NULL; xmlParserInputPtr cur = NULL; char * str; if (ctxt != NULL) { input = ctxt->input; if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) { cur = input; input = ctxt->inputTab[ctxt->inputNr - 2]; } xmlParserPrintFileInfo(input); } xmlGenericError(xmlGenericErrorContext, "warning: "); XML_GET_VAR_STR(msg, str); xmlGenericError(xmlGenericErrorContext, "%s", str); if (str != NULL) xmlFree(str); if (ctxt != NULL) { xmlParserPrintFileContext(input); if (cur != NULL) { xmlParserPrintFileInfo(cur); xmlGenericError(xmlGenericErrorContext, "\n"); xmlParserPrintFileContext(cur); } } } /************************************************************************ * * * Handling of validation errors * * * ************************************************************************/ /** * xmlParserValidityError: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format an validity error messages, gives file, * line, position and extra parameters. */ void XMLCDECL xmlParserValidityError(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input = NULL; char * str; int len = xmlStrlen((const xmlChar *) msg); static int had_info = 0; if ((len > 1) && (msg[len - 2] !=

)) { if (ctxt != NULL) { input = ctxt->input; if ((input->filename == NULL) && (ctxt->inputNr > 1)) input = ctxt->inputTab[ctxt->inputNr - 2]; if (had_info == 0) { xmlParserPrintFileInfo(input); } } xmlGenericError(xmlGenericErrorContext, "validity error: "); had_info = 0; } else { had_info = 1; } XML_GET_VAR_STR(msg, str); xmlGenericError(xmlGenericErrorContext, "%s", str); if (str != NULL) xmlFree(str); if ((ctxt != NULL) && (input != NULL)) { xmlParserPrintFileContext(input); } } /** * xmlParserValidityWarning: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a validity warning messages, gives file, line, * position and extra parameters. */ void XMLCDECL xmlParserValidityWarning(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input = NULL; char * str; int len = xmlStrlen((const xmlChar *) msg); if ((ctxt != NULL) && (len != 0) && (msg[len - 1] !=

validity warning:

%s

elfgcchack.h

