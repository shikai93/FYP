libxml.h: internal header only used during the compilation of libxml See COPYRIGHT for the status of this software Author: breese@users.sourceforge.net

Windows CE compatibility definitions and functions This is needed to compile libxml2 for Windows CE. At least I tested it with WinCE 5.0 for Emulator and WinCE 4.2/SH4 target

pull definition of size_t

TRIO_REPLACE_STDIO: This macro is defined if teh trio string formatting functions are to be used instead of the default stdio ones.

Internal variable indicating if a callback has been registered for node creation/destruction. It avoids spending a lot of time in locking function while checking if the callback exists.

internal error reporting routines, shared but not partof the API.

internal function of HTML parser needed for xmlParseInNodeContext but not part of the API

internal global initialization critical section routines.

! __XML_LIBXML_H__

config-mac.h

config.h

trio.h

elfgcchack.h

libxml.c: this modules implements the main part of the glue of the libxml2 library and the Python interpreter. It provides the entry points where an automatically generated stub is either unpractical or would not match cleanly the Python model. If compiled with MERGED_MODULES, the entry point will be used to initialize both the libxml2 and the libxslt wrappers See Copyright for the status of this software. daniel@veillard.com

#include "config.h"

#define DEBUG

#define DEBUG_SAX

#define DEBUG_XPATH

#define DEBUG_ERROR

#define DEBUG_MEMORY

#define DEBUG_FILES

#define DEBUG_LOADER

TODO: macro to flag unimplemented blocks

the following vars are used for XPath extensions, but are also referenced within the parser cleanup routine.

Memory debug interface

forward declare

First initialize the library and grab the old memory handlers and switch the library to memory debugging

cleanup first, because some memory has been allocated with the non-debug malloc in xmlInitParser when the python module was imported

reinitialize

Need to confirm whether we really want to do this (required for memcheck) in all cases...

if ext funcs declared

Handling Python FILE I/O at the C level The raw I/O attack diectly the File objects, while the other routines address the ioWrapper instance instead

xmlPythonFileCloseUnref: @context: the I/O context Close an I/O channel

xmlPythonFileReadRaw: @context: the I/O context @buffer: where to drop data @len: number of bytes to write Read @len bytes to @buffer from the Python file in the I/O channel Returns the number of bytes read

xmlPythonFileRead: @context: the I/O context @buffer: where to drop data @len: number of bytes to write Read @len bytes to @buffer from the I/O channel. Returns the number of bytes read

xmlFileWrite: @context: the I/O context @buffer: where to drop data @len: number of bytes to write Write @len bytes from @buffer to the I/O channel. Returns the number of bytes written

xmlPythonFileClose: @context: the I/O context Close an I/O channel

xmlOutputBufferCreatePythonFile: @file: a PyFile_Type @encoder: the encoding converter or NULL Create a buffered output for the progressive saving to a PyFile_Type buffered C I/O Returns the new parser output or NULL

Py_INCREF(file);

libxml_outputBufferGetPythonFile: @buffer: the I/O buffer read the Python I/O from the CObject Returns the new parser output or NULL

Buffer may already have been destroyed elsewhere. This is harmless.

xmlSaveTo() freed the memory pointed to by buf, so record that in the Python object.

xmlSaveFormatFileTo() freed the memory pointed to by buf, so record that in the Python object

LIBXML_OUTPUT_ENABLED

xmlParserInputBufferCreatePythonFile: @file: a PyFile_Type @encoder: the encoding converter or NULL Create a buffered output for the progressive saving to a PyFile_Type buffered C I/O Returns the new parser output or NULL

Py_INCREF(file);

Providing the resolver at the Python level

Handling SAX/xmllib/sgmlop callback interfaces

the xmllib interface always generate a dictionnary, possibly empty

The reference to the handler is released there

TODO: wrap in an elementContent object

Py_XINCREF(Py_None); isn't the reference just borrowed ???

TODO pythonIsStandalone,

TODO pythonHasInternalSubset,

TODO pythonHasExternalSubset,

TODO pythonResolveEntity,

TODO pythonGetEntity,

OBSOLETED pythonSetDocumentLocator,

TODO pythonGetParameterEntity,

TODO mograte to SAX2

Handling of specific parser context

The reference is released in pythonEndDocument()

The reference is released in pythonEndDocument()

LIBXML_HTML_ENABLED

The reference is released in pythonEndDocument()

The reference is released in pythonEndDocument()

LIBXML_HTML_ENABLED

Error message callback

helper to build a xmlMalloc'ed string from a format and va_list

disabled the loop, the repeated call to vsnprintf without reset of ap in case the initial buffer was too small segfaulted on x86_64 we now directly vsnprintf on a large buffer.

TODO: check f is a function !

Per parserCtxt error handler

TODO: manage for the exception to be propagated...

TODO: check f is a function !

no python error handler registered

xmlValidCtxt stuff

TODO: manage for the exception to be propagated...

TODO: manage for the exception to be propagated...

TODO: check warn and error is a function !

Per xmlTextReader error handler

TODO: manage for the exception to be propagated...

clear previous error handler

ok, it's our error handler!

there already an arg, and it's not ours, there is definitely something wrong going on here... we don't know how to free it, so we bail out...

set new error handler

ok, it's our error handler!

f is null or it's not our error handler

ok, it's our error handler!

else, something wrong happened, because the error handler is not owned by the python bindings...

XPath extensions

Find the function, it should be there it was there at lookup

TODO (ctxt == libxml_xpathCallbacks[i].ctx) &&

This is called once only. The address is then stored in the XPath expression evaluation, the proper object to call can then still be found using the execution context function and functionURI fields.

Global properties access

Specific accessor functions

Serialization front-end

LIBXML_HTML_ENABLED

LIBXML_HTML_ENABLED

LIBXML_HTML_ENABLED

LIBXML_OUTPUT_ENABLED

Extra stuff

Local Catalog stuff

RelaxNG error handler registration

TODO: manage for the exception to be propagated...

TODO: manage for the exception to be propagated...

first time to set the error handlers

TODO: check warn and error is a function !

TODO: manage for the exception to be propagated...

TODO: manage for the exception to be propagated...

first time to set the error handlers

TODO: check warn and error is a function !

XML Canonicalization c14n

NOTE: the array should be freed, but the strings are shared with the python strings and so must not be freed.

To compare two node objects, we compare their pointer addresses

For simplicity, we use the node pointer address as a hash value

The registration stuff

LIBXML_OUTPUT_ENABLED

intialize the python extension module

initialize libxml2

config.h

libxml_wrap.h

libxml2-py.h

trio.h

Unimplemented block at %s:%d\n

i:xmlDebugMemory

libxml_xmlDebugMemory(%d) called\n

xmlPythonFileCloseUnref\n

close

()

xmlPythonFileReadRaw: %d\n

read

(i)

xmlPythonFileReadRaw: result is NULL\n

xmlPythonFileReadRaw: result is not a String\n

xmlPythonFileRead: %d\n

io_read

(i)

xmlPythonFileRead: result is NULL\n

xmlPythonFileRead: result is not a String\n

xmlPythonFileWrite: %d\n

io_write

io_write

(O)

write

write

(O)

xmlPythonFileWrite: result is NULL\n

xmlPythonFileWrite: result is not an Int nor None\n

xmlPythonFileClose\n

io_close

io_close

()

flush

flush

()

Oz:xmlOutputBufferCreate

libxml_xmlCreateOutputBuffer: buffer == NULL\n

O:outputBufferGetPythonFile

outputBufferGetPythonFile: obj == NULL\n

outputBufferGetPythonFile: not a python file wrapper\n

O:xmlOutputBufferClose

O:xmlOutputBufferFlush

OOz:xmlSaveFileTo

OOzi:xmlSaveFormatFileTo

Oz:xmlParserInputBufferCreate

libxml_xmlParserInputBufferCreate: buffer == NULL\n

pythonExternalEntityLoader: ready to call\n

(ssO)

pythonExternalEntityLoader: result

\n

read

pythonExternalEntityLoader: can't read %s\n

O:libxml_xmlSetEntityLoader

libxml_xmlSetEntityLoader\n

pythonStartElement(%s) called\n

startElement

start

startElement

sO

start

sO

pythonStartDocument() called\n

startDocument

startDocument

pythonEndDocument() called\n

endDocument

endDocument

pythonEndElement(%s) called\n

endElement

endElement

s

end

end

s

pythonReference(%s) called\n

reference

reference

s

pythonCharacters(%s, %d) called\n

characters

data

characters

s#

data

s#

pythonIgnorableWhitespace(%s, %d) called\n

ignorableWhitespace

data

ignorableWhitespace

s#

data

s#

pythonProcessingInstruction(%s, %s) called\n

processingInstruction

processingInstruction

ss

pythonComment(%s) called\n

comment

comment

s

pythonWarning(%s) called\n

warning

warning

s

pythonError(%s) called\n

error

error

s

pythonFatalError(%s) called\n

fatalError

fatalError

s

pythonCdataBlock(%s, %d) called\n

cdataBlock

cdata

cdataBlock

s#

cdata

s#

pythonExternalSubset(%s, %s, %s) called\n

externalSubset

externalSubset

sss

entityDecl

entityDecl

sisss

notationDecl

notationDecl

sss

attributeDecl

attributeDecl

ssiisO

elementDecl

pythonElementDecl: xmlElementContentPtr wrapper missing !\n

t the reference just borrowed ??? */ result = PyObject_CallMethod(handler, (char *) "elementDecl", (char *) "siO", name, type, obj); if (PyErr_Occurred()) PyErr_Print(); Py_XDECREF(result); } } static void pythonUnparsedEntityDecl(void *user_data, const xmlChar * name, const xmlChar * publicId, const xmlChar * systemId, const xmlChar * notationName) { PyObject *handler; PyObject *result; handler = (PyObject *) user_data; if (PyObject_HasAttrString(handler, (char *) "unparsedEntityDecl")) { result = PyObject_CallMethod(handler, (char *) "unparsedEntityDecl", (char *) "ssss", name, publicId, systemId, notationName); if (PyErr_Occurred()) PyErr_Print(); Py_XDECREF(result); } } static void pythonInternalSubset(void *user_data, const xmlChar * name, const xmlChar * ExternalID, const xmlChar * SystemID) { PyObject *handler; PyObject *result; #ifdef DEBUG_SAX printf("pythonInternalSubset(%s, %s, %s) called\n", name, ExternalID, SystemID); #endif handler = (PyObject *) user_data; if (PyObject_HasAttrString(handler, (char *) "internalSubset")) { result = PyObject_CallMethod(handler, (char *) "internalSubset", (char *) "sss", name, ExternalID, SystemID); if (PyErr_Occurred()) PyErr_Print(); Py_XDECREF(result); } } static xmlSAXHandler pythonSaxHandler = { pythonInternalSubset, NULL, /* TODO pythonIsStandalone, */ NULL, /* TODO pythonHasInternalSubset, */ NULL, /* TODO pythonHasExternalSubset, */ NULL, /* TODO pythonResolveEntity, */ NULL, /* TODO pythonGetEntity, */ pythonEntityDecl, pythonNotationDecl, pythonAttributeDecl, pythonElementDecl, pythonUnparsedEntityDecl, NULL, /* OBSOLETED pythonSetDocumentLocator, */ pythonStartDocument, pythonEndDocument, pythonStartElement, pythonEndElement, pythonReference, pythonCharacters, pythonIgnorableWhitespace, pythonProcessingInstruction, pythonComment, pythonWarning, pythonError, pythonFatalError, NULL, /* TODO pythonGetParameterEntity, */ pythonCdataBlock, pythonExternalSubset, 1, NULL, /* TODO mograte to SAX2 */ NULL, NULL, NULL }; /************************************************************************ * * * Handling of specific parser context * * * ************************************************************************/ PyObject * libxml_xmlCreatePushParser(ATTRIBUTE_UNUSED PyObject * self, PyObject * args) { const char *chunk; int size; const char *URI; PyObject *pyobj_SAX = NULL; xmlSAXHandlerPtr SAX = NULL; xmlParserCtxtPtr ret; PyObject *pyret; if (!PyArg_ParseTuple (args, (char *) "Oziz:xmlCreatePushParser", &pyobj_SAX, &chunk, &size, &URI)) return (NULL); #ifdef DEBUG printf("libxml_xmlCreatePushParser(%p, %s, %d, %s) called\n", pyobj_SAX, chunk, size, URI); #endif if (pyobj_SAX != Py_None) { SAX = &pythonSaxHandler; Py_INCREF(pyobj_SAX); /* The reference is released in pythonEndDocument() */ } ret = xmlCreatePushParserCtxt(SAX, pyobj_SAX, chunk, size, URI); pyret = libxml_xmlParserCtxtPtrWrap(ret); return (pyret); } PyObject * libxml_htmlCreatePushParser(ATTRIBUTE_UNUSED PyObject * self, PyObject * args) { #ifdef LIBXML_HTML_ENABLED const char *chunk; int size; const char *URI; PyObject *pyobj_SAX = NULL; xmlSAXHandlerPtr SAX = NULL; xmlParserCtxtPtr ret; PyObject *pyret; if (!PyArg_ParseTuple (args, (char *) "Oziz:htmlCreatePushParser", &pyobj_SAX, &chunk, &size, &URI)) return (NULL); #ifdef DEBUG printf("libxml_htmlCreatePushParser(%p, %s, %d, %s) called\n", pyobj_SAX, chunk, size, URI); #endif if (pyobj_SAX != Py_None) { SAX = &pythonSaxHandler; Py_INCREF(pyobj_SAX); /* The reference is released in pythonEndDocument() */ } ret = htmlCreatePushParserCtxt(SAX, pyobj_SAX, chunk, size, URI, XML_CHAR_ENCODING_NONE); pyret = libxml_xmlParserCtxtPtrWrap(ret); return (pyret); #else Py_INCREF(Py_None); return (Py_None); #endif /* LIBXML_HTML_ENABLED */ } PyObject * libxml_xmlSAXParseFile(ATTRIBUTE_UNUSED PyObject * self, PyObject * args) { int recover; const char *URI; PyObject *pyobj_SAX = NULL; xmlSAXHandlerPtr SAX = NULL; if (!PyArg_ParseTuple(args, (char *) "Osi:xmlSAXParseFile", &pyobj_SAX, &URI, &recover)) return (NULL); #ifdef DEBUG printf("libxml_xmlSAXParseFile(%p, %s, %d) called\n", pyobj_SAX, URI, recover); #endif if (pyobj_SAX == Py_None) { Py_INCREF(Py_None); return (Py_None); } SAX = &pythonSaxHandler; Py_INCREF(pyobj_SAX); /* The reference is released in pythonEndDocument() */ xmlSAXUserParseFile(SAX, pyobj_SAX, URI); Py_INCREF(Py_None); return (Py_None); } PyObject * libxml_htmlSAXParseFile(ATTRIBUTE_UNUSED PyObject * self, PyObject * args) { #ifdef LIBXML_HTML_ENABLED const char *URI; const char *encoding; PyObject *pyobj_SAX = NULL; xmlSAXHandlerPtr SAX = NULL; if (!PyArg_ParseTuple (args, (char *) "Osz:htmlSAXParseFile", &pyobj_SAX, &URI, &encoding)) return (NULL); #ifdef DEBUG printf("libxml_htmlSAXParseFile(%p, %s, %s) called\n", pyobj_SAX, URI, encoding); #endif if (pyobj_SAX == Py_None) { Py_INCREF(Py_None); return (Py_None); } SAX = &pythonSaxHandler; Py_INCREF(pyobj_SAX); /* The reference is released in pythonEndDocument() */ htmlSAXParseFile(URI, encoding, SAX, pyobj_SAX); Py_INCREF(Py_None); return (Py_None); #else Py_INCREF(Py_None); return (Py_None); #endif /* LIBXML_HTML_ENABLED */ } /************************************************************************ * * * Error message callback * * * ************************************************************************/ static PyObject *libxml_xmlPythonErrorFuncHandler = NULL; static PyObject *libxml_xmlPythonErrorFuncCtxt = NULL; /* helper to build a xmlMalloc

libxml_xmlErrorFuncHandler(%p, %s, ...) called\n

libxml_xmlErrorInitialize() called\n

OO:xmlRegisterErrorHandler

libxml_xmlRegisterErrorHandler(%p, %p) called\n

libxml_xmlParserCtxtGenericErrorFuncHandler(%p, %s, ...) called\n

OOO:xmlParserCtxtSetErrorHandler

O:xmlParserCtxtGetErrorHandler

O:xmlFreeParserCtxt

libxml_xmlValidCtxtGenericErrorFuncHandler(%p, %d, %s, ...) called\n

libxml_xmlValidCtxtGenericWarningFuncHandler(%p, %d, %s, ...) called\n

OOO|O:xmlSetValidErrors

libxml_xmlSetValidErrors(%p, %p, %p) called\n

O:xmlFreeValidCtxt

OOO:xmlTextReaderSetErrorHandler

s our error handler! */ pyCtxt = (xmlTextReaderPyCtxtPtr)arg; Py_XDECREF(pyCtxt->f); Py_XDECREF(pyCtxt->arg); xmlFree(pyCtxt); } else { /* * there already an arg, and it

t know how to free it, so we bail out... */ py_retval = libxml_intWrap(-1); return(py_retval); } } xmlTextReaderSetErrorHandler(reader,NULL,NULL); /* set new error handler */ if (pyobj_f != Py_None) { pyCtxt = (xmlTextReaderPyCtxtPtr)xmlMalloc(sizeof(xmlTextReaderPyCtxt)); if (pyCtxt == NULL) { py_retval = libxml_intWrap(-1); return(py_retval); } Py_XINCREF(pyobj_f); pyCtxt->f = pyobj_f; Py_XINCREF(pyobj_arg); pyCtxt->arg = pyobj_arg; xmlTextReaderSetErrorHandler(reader, (xmlTextReaderErrorFunc) libxml_xmlTextReaderErrorCallback, pyCtxt); } py_retval = libxml_intWrap(1); return(py_retval); } static PyObject * libxml_xmlTextReaderGetErrorHandler(ATTRIBUTE_UNUSED PyObject *self, PyObject *args) { xmlTextReaderPtr reader; xmlTextReaderPyCtxtPtr pyCtxt; xmlTextReaderErrorFunc f; void *arg; PyObject *pyobj_reader; PyObject *py_retval; if (!PyArg_ParseTuple(args, (char *)"O:xmlTextReaderSetErrorHandler", &pyobj_reader)) return(NULL); reader = (xmlTextReaderPtr) PyxmlTextReader_Get(pyobj_reader); xmlTextReaderGetErrorHandler(reader,&f,&arg); py_retval = PyTuple_New(2); if (f == (xmlTextReaderErrorFunc)libxml_xmlTextReaderErrorCallback) { /* ok, it

s not our error handler */ PyTuple_SetItem(py_retval, 0, Py_None); Py_XINCREF(Py_None); PyTuple_SetItem(py_retval, 1, Py_None); Py_XINCREF(Py_None); } return(py_retval); } static PyObject * libxml_xmlFreeTextReader(ATTRIBUTE_UNUSED PyObject *self, PyObject *args) { xmlTextReaderPtr reader; PyObject *pyobj_reader; xmlTextReaderPyCtxtPtr pyCtxt; xmlTextReaderErrorFunc f; void *arg; if (!PyArg_ParseTuple(args, (char *)"O:xmlFreeTextReader", &pyobj_reader)) return(NULL); if (!PyCObject_Check(pyobj_reader)) { Py_INCREF(Py_None); return(Py_None); } reader = (xmlTextReaderPtr) PyxmlTextReader_Get(pyobj_reader); if (reader == NULL) { Py_INCREF(Py_None); return(Py_None); } xmlTextReaderGetErrorHandler(reader,&f,&arg); if (arg != NULL) { if (f == (xmlTextReaderErrorFunc) libxml_xmlTextReaderErrorCallback) { /* ok, it

libxml_xmlXPathFuncCallback called name %s URI %s\n

libxml_xmlXPathFuncCallback: internal error %s not found !\n

libxml_xmlXPathFuncLookupFunc(%p, %s, %s) called\n

libxml_xpathCallbacksInitialized called\n

OszO:registerXPathFunction

libxml_registerXPathFunction(%p, %s, %s) called\n

O:name

libxml_name: cur = %p type %d\n

O:doc

libxml_doc: cur = %p\n

O:properties

O:next

libxml_next: cur = %p\n

O:prev

libxml_prev: cur = %p\n

O:children

libxml_children: cur = %p\n

O:last

libxml_last: cur = %p\n

O:parent

libxml_parent: cur = %p\n

O:last

libxml_type: cur = %p\n

element

attribute

text

cdata

entity_ref

entity

pi

comment

document_xml

doctype

fragment

notation

document_html

dtd

elem_decl

attribute_decl

entity_decl

namespace

xinclude_start

xinclude_end

document_docbook

libxml_type: cur = %p: %s\n

O:xmlNodeGetNsDefs

Oz:xmlNodeRemoveNsDef

O:xmlNodeGetNs

Ozi:serializeNode

OOzi:serializeNode

HTML

ascii

s:xmlNewNode

NewNode: %s : %p\n

Os:addLocalCatalog

LocalCatalog: %s\n

libxml_xmlRelaxNGValidityGenericErrorFuncHandler(%p, %s, ...) called\n

libxml_xmlRelaxNGValidityGenericWarningFuncHandler(%p, %s, ...) called\n

OOO|O:xmlRelaxNGSetValidErrors

libxml_xmlRelaxNGSetValidErrors(%p, %p, %p) called\n

O:xmlRelaxNGFreeValidCtxt

libxml_xmlSchemaValiditiyGenericErrorFuncHandler(%p, %s, ...) called\n

libxml_xmlSchemaValidityGenericWarningFuncHandler(%p, %s, ...) called\n

OOO|O:xmlSchemaSetValidErrors

libxml_xmlSchemaSetValidErrors(%p, %p, %p) called\n

O:xmlSchemaFreeValidCtxt

must be a tuple or list of nodes.





must be a tuple or list of strings.



must be a tuple or list of strings.

OOiOi:C14NDocDumpMemory

bad document.

libxml2 xmlC14NDocDumpMemory failure.

OOiOiO:C14NDocSaveTo

bad document.

bad file.

bad file.

libxml2 xmlC14NDocSaveTo failure.

O:getObjDesc

s

OO:compareNodesEqual

i

i

O:nodeHash

libxml2-export.c

name

children

properties

last

prev

next

parent

type

doc

xmlNewNode

xmlNodeRemoveNsDef

xmlSetValidErrors

xmlFreeValidCtxt

serializeNode

saveNodeTo

outputBufferCreate

outputBufferGetPythonFile

xmlOutputBufferClose

xmlOutputBufferFlush

xmlSaveFileTo

xmlSaveFormatFileTo

inputBufferCreate

setEntityLoader

xmlRegisterErrorHandler

xmlParserCtxtSetErrorHandler

xmlParserCtxtGetErrorHandler

xmlFreeParserCtxt

xmlTextReaderSetErrorHandler

xmlTextReaderGetErrorHandler

xmlFreeTextReader

addLocalCatalog

xmlRelaxNGSetValidErrors

xmlRelaxNGFreeValidCtxt

xmlSchemaSetValidErrors

xmlSchemaFreeValidCtxt

xmlC14NDocDumpMemory

xmlC14NDocSaveTo

getObjDesc

compareNodesEqual

nodeHash

libxml2mod

