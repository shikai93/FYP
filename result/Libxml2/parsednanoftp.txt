nanoftp.c: basic FTP client support Reference: RFC 959

TESTING

TESTING

#define DEBUG_FTP 1

A couple portability macros

the protocol name

the host name

the port

the path within the URL

user string

passwd string

this is large enough to hold IPv6 addres

the socket address struct

currently we support only passive !!!

the file descriptor for the control socket

the file descriptor for the data socket

WRITE / READ / CLOSED

the protocol return value

buffer for data received from the control connection

the proxy name if any

the proxy port if any

user for proxy authentication

passwd for proxy authentication

uses TYPE or a@b ?

xmlFTPErrMemory: @extra: extra informations Handle an out of memory condition

xmlNanoFTPInit: Initialize the FTP protocol layer. Currently it just checks for proxy informations, and get the hostname

xmlNanoFTPCleanup: Cleanup the FTP protocol layer. This cleanup proxy informations.

xmlNanoFTPProxy: @host: the proxy host name @port: the proxy port @user: the proxy user name @passwd: the proxy password @type: the type of proxy 1 for using SITE, 2 for USER a@b Setup the FTP proxy informations. This can also be done by using ftp_proxy ftp_proxy_user and ftp_proxy_password environment variables.

xmlNanoFTPScanURL: @ctx: an FTP context @URL: The URL used to initialize the context (Re)Initialize an FTP context by parsing the URL and finding the protocol host port and path it indicates.

Clear any existing data from the context

xmlNanoFTPUpdateURL: @ctx: an FTP context @URL: The URL used to update the context Update an FTP context by parsing the URL and finding new path it indicates. If there is an error in the protocol, hostname, port or other information, the error is raised. It indicates a new connection has to be established. Returns 0 if Ok, -1 in case of error (other host).

xmlNanoFTPScanProxy: @URL: The proxy URL used to initialize the proxy context (Re)Initialize the FTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like ftp://myproxy/ or ftp://myproxy:3128/ A NULL URL cleans up proxy informations.

xmlNanoFTPNewCtxt: @URL: The URL used to initialize the context Allocate and initialize a new FTP context. Returns an FTP context or NULL in case of error.

xmlNanoFTPFreeCtxt: @ctx: an FTP context Frees the context after closing the connection.

xmlNanoFTPParseResponse: @buf: the buffer containing the response @len: the buffer length Parsing of the server answer, we just extract the code. returns 0 for errors +XXX for last line of response -XXX for response to be continued

xmlNanoFTPGetMore: @ctx: an FTP context Read more information from the FTP control connection Returns the number of bytes read, < 0 indicates an error

First pack the control buffer

Read the amount left on the control connection

xmlNanoFTPReadResponse: @ctx: an FTP context Read the response from the FTP server after a command. Returns the code number

Assumes everything up to controlBuf[controlBufIndex] has been read and analyzed.

Successfully scanned the control code, scratch till the end of the line, but keep the index to be able to analyze the result if needed.

xmlNanoFTPGetResponse: @ctx: an FTP context Get the response from the FTP server after a command. Returns the code number

xmlNanoFTPCheckResponse: @ctx: an FTP context Check if there is a response from the FTP server after a command. Returns the code number, or 0

Send the user authentication

Send the password authentication

xmlNanoFTPQuit: @ctx: an FTP context Send a QUIT command to the server Returns -1 in case of error, 0 otherwise

Just to be consistent, even though we know it can't have a % in it

xmlNanoFTPConnect: @ctx: an FTP context Tries to open a control connection Returns -1 in case of error, 0 otherwise

do the blocking DNS query.

Prepare the socket

Do the connect.

Wait for the HELLO from the server.

State diagram for the login operation on the FTP server Reference: RFC 959 1 +---+ USER +---+------------->+---+ | B |---------->| W | 2 ---->| E | +---+ +---+------ | -->+---+ | | | | | 3 | | 4,5 | | | -------------- ----- | | | | | | | | | | | | | | --------- | | 1| | | | V | | | | +---+ PASS +---+ 2 | ------>+---+ | |---------->| W |------------->| S | +---+ +---+ ---------->+---+ | | | | | 3 | |4,5| | | -------------- -------- | | | | | | | | | | | | ----------- | 1,3| | | | V | 2| | | +---+ ACCT +---+-- | ----->+---+ | |---------->| W | 4,5 -------->| F | +---+ +---+------------->+---+ Of course in case of using a proxy this get really nasty and is not standardized at all :-(

We need proxy auth

We assume we don't need more authentication to the proxy and that it succeeded :-\

we will try in sequence

Using SITE command

we assume it worked :-\ 1 is error for SITE command

USER user@host command

we assume it worked :-\

we assume it worked :-\

If you need support for other Proxy authentication scheme send the code or at least the sequence in use.

Non-proxy handling.

xmlNanoFTPConnectTo: @server: an FTP server name @port: the port (use 21 if 0) Tries to open a control connection to the given server/port Returns an fTP context or NULL if it failed

xmlNanoFTPCwd: @ctx: an FTP context @directory: a directory on the server Tries to change the remote directory Returns -1 incase of error, 1 if CWD worked, 0 if it failed

Expected response code for CWD: CWD 250 500, 501, 502, 421, 530, 550

xmlNanoFTPDele: @ctx: an FTP context @file: a file or directory on the server Tries to delete an item (file or directory) from server Returns -1 incase of error, 1 if DELE worked, 0 if it failed

Expected response code for DELE: DELE 250 450, 550 500, 501, 502, 421, 530

xmlNanoFTPGetConnection: @ctx: an FTP context Try to open a data connection to the server. Currently only passive mode is supported. Returns -1 incase of error, 0 otherwise

retry with an active connection

xmlNanoFTPCloseConnection: @ctx: an FTP context Close the data connection from the server Returns -1 incase of error, 0 otherwise

xmlNanoFTPParseList: @list: some data listing received from the server @callback: the user callback @userData: the user callback data Parse at most one entry from the listing. Returns -1 incase of error, the length of data parsed otherwise

xmlNanoFTPList: @ctx: an FTP context @callback: the user callback @userData: the user callback data @filename: optional files to list Do a listing on the server. All files info are passed back in the callbacks. Returns -1 incase of error, 0 otherwise

xmlNanoFTPGetSocket: @ctx: an FTP context @filename: the file to retrieve (or NULL if path is in context). Initiate fetch of the given file from the server. Returns the socket for the data connection, or <0 in case of error

xmlNanoFTPGet: @ctx: an FTP context @callback: the user callback @userData: the user callback data @filename: the file to retrieve Fetch the given file from the server. All data are passed back in the callbacks. The last callback has a size of 0 block. Returns -1 incase of error, 0 otherwise

xmlNanoFTPRead: @ctx: the FTP context @dest: a buffer @len: the buffer length This function tries to read @len bytes from the existing FTP connection and saves them in @dest. This is a blocking call. Returns the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error.

xmlNanoFTPOpen: @URL: the URL to the resource Start to fetch the given ftp:// resource Returns an FTP context, or NULL

xmlNanoFTPClose: @ctx: an FTP context Close the connection and both control and transport Returns -1 incase of error, 0 otherwise

Basic test in Standalone mode

STANDALONE

!LIBXML_FTP_ENABLED

STANDALONE

LIBXML_FTP_ENABLED

myproxy/ or ftp://myproxy:3128/

resource

", URL, 6)) return(NULL);

libxml.h

no_proxy

*

ftp_proxy

FTP_PROXY

ftp_proxy_user

ftp_proxy_password

/

:

/

Removing FTP proxy info\n

Using FTP proxy %s\n

ftp

Syntax Error\n

allocating FTP context

0

9

0

0

9

0

0

9

0

-

xmlNanoFTPGetMore : controlBufIndex = %d\n

xmlNanoFTPGetMore : controlBufUsed = %d\n

xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\n

xmlNanoFTPGetMore : buffer full %d \n

recv failed

xmlNanoFTPGetMore : read %d [%d - %d]\n

\n<<<\n%s\n--\n

\n

\n

\r

\n

\r

\n---\n%s\n--\n

Got %d\n

select

USER anonymous\r\n

USER %s\r\n

%s

send failed

PASS anonymous@\r\n

PASS %s\r\n

%s

send failed

QUIT\r\n

%s

t have a % in it */ #endif res = send(ctxt->controlFd, buf, len, 0); if (res < 0) { __xmlIOErr(XML_FROM_FTP, 0, "send failed"); return(res); } return(0); } /** * xmlNanoFTPConnect: * @ctx: an FTP context * * Tries to open a control connection * * Returns -1 in case of error, 0 otherwise */ int xmlNanoFTPConnect(void *ctx) { xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx; struct hostent *hp; int port; int res; int addrlen = sizeof (struct sockaddr_in); if (ctxt == NULL) return(-1); if (ctxt->hostname == NULL) return(-1); /* * do the blocking DNS query. */ if (proxy) { port = proxyPort; } else { port = ctxt->port; } if (port == 0) port = 21; memset (&ctxt->ftpAddr, 0, sizeof(ctxt->ftpAddr)); #ifdef SUPPORT_IP6 if (have_ipv6 ()) { struct addrinfo hints, *tmp, *result; result = NULL; memset (&hints, 0, sizeof(hints)); hints.ai_socktype = SOCK_STREAM; if (proxy) { if (getaddrinfo (proxy, NULL, &hints, &result) != 0) { __xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed"); return (-1); } } else if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) { __xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed"); return (-1); } for (tmp = result; tmp; tmp = tmp->ai_next) if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6) break; if (!tmp) { if (result) freeaddrinfo (result); __xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed"); return (-1); } if (tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) { __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname address mismatch"); return (-1); } if (tmp->ai_family == AF_INET6) { memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen); ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port); ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0); } else { memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen); ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port); ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0); } addrlen = tmp->ai_addrlen; freeaddrinfo (result); } else #endif { if (proxy) hp = gethostbyname (proxy); else hp = gethostbyname (ctxt->hostname); if (hp == NULL) { __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname failed"); return (-1); } if ((unsigned int) hp->h_length > sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) { __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname address mismatch"); return (-1); } /* * Prepare the socket */ ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET; memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr, hp->h_addr_list[0], hp->h_length); ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port = (u_short)htons ((unsigned short)port); ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0); addrlen = sizeof (struct sockaddr_in); } if (ctxt->controlFd < 0) { __xmlIOErr(XML_FROM_FTP, 0, "socket failed"); return(-1); } /* * Do the connect. */ if (connect(ctxt->controlFd, (struct sockaddr *) &ctxt->ftpAddr, addrlen) < 0) { __xmlIOErr(XML_FROM_FTP, 0, "Failed to create a connection"); closesocket(ctxt->controlFd); ctxt->controlFd = -1; ctxt->controlFd = -1; return(-1); } /* * Wait for the HELLO from the server. */ res = xmlNanoFTPGetResponse(ctxt); if (res != 2) { closesocket(ctxt->controlFd); ctxt->controlFd = -1; ctxt->controlFd = -1; return(-1); } /* * State diagram for the login operation on the FTP server * * Reference: RFC 959 * * 1 * +---+ USER +---+------------->+---+ * | B |---------->| W | 2 ---->| E | * +---+ +---+------ | -->+---+ * | | | | | * 3 | | 4,5 | | | * -------------- ----- | | | * | | | | | * | | | | | * | --------- | * | 1| | | | * V | | | | * +---+ PASS +---+ 2 | ------>+---+ * | |---------->| W |------------->| S | * +---+ +---+ ---------->+---+ * | | | | | * 3 | |4,5| | | * -------------- -------- | * | | | | | * | | | | | * | ----------- * | 1,3| | | | * V | 2| | | * +---+ ACCT +---+-- | ----->+---+ * | |---------->| W | 4,5 -------->| F | * +---+ +---+------------->+---+ * * Of course in case of using a proxy this get really nasty and is not * standardized at all :-( */ if (proxy) { int len; char buf[400]; if (proxyUser != NULL) { /* * We need proxy auth */ snprintf(buf, sizeof(buf), "USER %s\r\n", proxyUser); buf[sizeof(buf) - 1] = 0; len = strlen(buf); #ifdef DEBUG_FTP xmlGenericError(xmlGenericErrorContext, "%s", buf); #endif res = send(ctxt->controlFd, buf, len, 0); if (res < 0) { __xmlIOErr(XML_FROM_FTP, 0, "send failed"); closesocket(ctxt->controlFd); ctxt->controlFd = -1; return(res); } res = xmlNanoFTPGetResponse(ctxt); switch (res) { case 2: if (proxyPasswd == NULL) break; case 3: if (proxyPasswd != NULL) snprintf(buf, sizeof(buf), "PASS %s\r\n", proxyPasswd); else snprintf(buf, sizeof(buf), "PASS anonymous@\r\n"); buf[sizeof(buf) - 1] = 0; len = strlen(buf); #ifdef DEBUG_FTP xmlGenericError(xmlGenericErrorContext, "%s", buf); #endif res = send(ctxt->controlFd, buf, len, 0); if (res < 0) { __xmlIOErr(XML_FROM_FTP, 0, "send failed"); closesocket(ctxt->controlFd); ctxt->controlFd = -1; return(res); } res = xmlNanoFTPGetResponse(ctxt); if (res > 3) { closesocket(ctxt->controlFd); ctxt->controlFd = -1; return(-1); } break; case 1: break; case 4: case 5: case -1: default: closesocket(ctxt->controlFd); ctxt->controlFd = -1; return(-1); } } /* * We assume we don

SITE %s\r\n

%s

send failed

USER anonymous@%s\r\n

USER %s@%s\r\n

%s

send failed

PASS anonymous@\r\n

PASS %s\r\n

%s

send failed

FTP server asking for ACCNT on anonymous\n

CWD %s\r\n

%s

send failed

DELE %s\r\n

%s

send failed

socket failed

EPSV\r\n

PASV\r\n

%s

send failed

0

9

\0

%u

Invalid answer to EPSV\n

%u,%u,%u,%u,%u,%u

Invalid answer to PASV\n

Failed to create a data connection

bind failed

listen failed

EPRT |2|%s|%s|\r\n

PORT %d,%d,%d,%d,%d,%d\r\n

%s

send failed

select

xmlNanoFTPCloseConnection: timeout\n

total



0

9

0



\n

\r

+



\n

\r





0

9

0











0

9

0







0

9

0



:

:

0

9

0

:

0

9

0

0

9

0



\n

\r

\n

\r

\n

\r

LIST -L\r\n

/

LIST -L %s\r\n

%s

send failed

select

recv

TYPE I\r\n

%s

send failed

RETR %s\r\n

RETR %s\r\n

%s

send failed

select

recv failed

recv failed

Recvd %d bytes\n

ftp://

%s %s %s %ld %s\n

Couldn't connect to %s\n

localhost

Couldn't connect to localhost\n

/tmp/tstdata

w

Failed to get file\n

%s : FTP support not compiled in\n

elfgcchack.h

0xff);

0xff,

0xff,

0xff,

0xff,

0xff,

0xff);

Summary: minimal FTP implementation Description: minimal FTP implementation allowing to fetch resources like external subset. Copy: See Copyright for the status of this software. Author: Daniel Veillard

ftpListCallback: @userData: user provided data for the callback @filename: the file name (including "->" when links are shown) @attrib: the attribute string @owner: the owner string @group: the group string @size: the file size @links: the link count @year: the year @month: the month @day: the day @hour: the hour @minute: the minute A callback for the xmlNanoFTPList command. Note that only one of year and day:minute are specified.

ftpDataCallback: @userData: the user provided context @data: the data received @len: its size in bytes A callback for the xmlNanoFTPGet command.

Init

Creating/freeing contexts.

Opening/closing session connections.

Rather internal commands.

CD/DIR/GET handlers.

LIBXML_FTP_ENABLED

__NANO_FTP_H__

C

->

