nanohttp.c: minimalist HTTP GET implementation to fetch external subsets. focuses on size, streamability, reentrancy and portability This is clearly not a general purpose HTTP implementation If you look for one, check: http://www.w3.org/Library/ See Copyright for the status of this software. daniel@veillard.com

for xmlStr(n)casecmp()

A couple portability macros

the protocol name

the host name

the port

the path within the URL

the query string

the file descriptor for the socket

WRITE / READ / CLOSED

buffer sent (zero terminated)

index within the buffer sent

the receiving buffer

the start of the content

the next byte to read from network

the next byte to give back to the client

len of the input buffer

return code for last operation

the protocol return value

the protocol version

specified content length from HTTP header

the MIME type for the input

the new URL in case of redirect

contents of {WWW,Proxy}-Authenticate header

encoding extracted from the contentType

Mime-Type extracted from the contentType

Zlib stream object

"Content-Encoding: gzip" was detected

the proxy name if any

the proxy port if any

the select() timeout in seconds

xmlHTTPErrMemory: @extra: extra informations Handle an out of memory condition

A portability function

xmlNanoHTTPInit: Initialize the HTTP protocol layer. Currently it just checks for proxy informations

xmlNanoHTTPCleanup: Cleanup the HTTP protocol layer.

xmlNanoHTTPScanURL: @ctxt: an HTTP context @URL: The URL used to initialize the context (Re)Initialize an HTTP context by parsing the URL and finding the protocol host port and path it indicates.

Clear any existing data from the context

xmlNanoHTTPScanProxy: @URL: The proxy URL used to initialize the proxy context (Re)Initialize the HTTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like http://myproxy/ or http://myproxy:3128/ A NULL URL cleans up proxy informations.

xmlNanoHTTPNewCtxt: @URL: The URL used to initialize the context Allocate and initialize a new HTTP context. Returns an HTTP context or NULL in case of error.

xmlNanoHTTPFreeCtxt: @ctxt: an HTTP context Frees the context after closing the connection.

xmlNanoHTTPSend: @ctxt: an HTTP context Send the input needed to initiate the processing on the server side Returns number of bytes sent or -1 on error.

No data sent Since non-blocking sockets are used, wait for socket to be writable or default timeout prior to retrying.

!HAVE_POLL_H

xmlNanoHTTPRecv: @ctxt: an HTTP context Read information coming from the HTTP connection. This is a blocking call (but it blocks in select(), not read()). Returns the number of byte read or -1 in case of error.

!HAVE_POLL_H

!HAVE_POLL_H

xmlNanoHTTPReadLine: @ctxt: an HTTP context Read one line in the HTTP server output, usually for extracting the HTTP protocol informations from the answer header. Returns a newly allocated string with a copy of the line, or NULL which indicate the end of the input.

xmlNanoHTTPScanAnswer: @ctxt: an HTTP context @line: an HTTP header line Try to extract useful informations from the server answer. We currently parse and process: - The HTTP revision/ return code - The Content-Type, Mime-Type and charset used - The Location for redirect processing. Returns -1 in case of failure, the file descriptor number otherwise

xmlNanoHTTPConnectAttempt: @addr: a socket address structure Attempt a connection to the given IP:port endpoint. It forces non-blocking semantic on the socket, and allow 60 seconds for the host to answer. Returns -1 in case of failure, the file descriptor number otherwise

!HAVE_POLL_H

!HAVE_POLL_H

_WINSOCKAPI_

VMS

__BEOS__

O_NONBLOCK

F_NDELAY

!O_NONBLOCK

!__BEOS__

!VMS

!_WINSOCKAPI_

!HAVE_POLL_H

!HAVE_POLL_H

Time out

Ermm.. ??

!HAVE_POLL_H

!HAVE_POLL_H

Solaris error code

pbm

xmlNanoHTTPConnectHost: @host: the host name @port: the port number Attempt a connection to the given host:port endpoint. It tries the multiple IP provided by the DNS if available. Returns -1 in case of failure, the file descriptor number otherwise

for

Okay, I got fed up by the non-portability of this error message extraction code. it work on Linux, if it work on your platform and one want to enable it, send me the defined(foobar) needed

A records (IPv4)

AAAA records (IPv6)

for

xmlNanoHTTPOpen: @URL: The URL to load @contentType: if available the Content-Type information will be returned at that location This function try to open a connection to the indicated resource via HTTP GET. Returns NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller

xmlNanoHTTPOpenRedir: @URL: The URL to load @contentType: if available the Content-Type information will be returned at that location @redir: if available the redirected URL will be returned This function try to open a connection to the indicated resource via HTTP GET. Returns NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller

xmlNanoHTTPRead: @ctx: the HTTP context @dest: a buffer @len: the buffer length This function tries to read @len bytes from the existing HTTP connection and saves them in @dest. This is a blocking call. Returns the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error.

xmlNanoHTTPClose: @ctx: the HTTP context This function closes an HTTP context, it ends up the connection and free all data related to it.

xmlNanoHTTPMethodRedir: @URL: The URL to load @method: the HTTP method to use @input: the input string if any @contentType: the Content-Type information IN and OUT @redir: the redirected URL OUT @headers: the extra headers @ilen: input length This function try to open a connection to the indicated resource via HTTP using the given @method, adding the given extra headers and the input buffer for the request content. Returns NULL in case of failure, otherwise a request handler. The contentType, or redir, if provided must be freed by the caller

reserve for string plus 'Content-Type: \r\n"

1 for '?'

reserve for possible 'Accept-Encoding: gzip' string

reserve space for ':xxxxx', incl. potential proxy

xmlNanoHTTPMethod: @URL: The URL to load @method: the HTTP method to use @input: the input string if any @contentType: the Content-Type information IN and OUT @headers: the extra headers @ilen: input length This function try to open a connection to the indicated resource via HTTP using the given @method, adding the given extra headers and the input buffer for the request content. Returns NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller

xmlNanoHTTPFetch: @URL: The URL to load @filename: the filename where the content should be saved @contentType: if available the Content-Type information will be returned at that location This function try to fetch the indicated resource via HTTP GET and save it's content in the file. Returns -1 in case of failure, 0 incase of success. The contentType, if provided must be freed by the caller

xmlNanoHTTPSave: @ctxt: the HTTP context @filename: the filename where the content should be saved This function saves the output of the HTTP transaction to a file It closes and free the context at the end Returns -1 in case of failure, 0 incase of success.

LIBXML_OUTPUT_ENABLED

xmlNanoHTTPReturnCode: @ctx: the HTTP context Get the latest HTTP return code received Returns the HTTP return code for the request.

xmlNanoHTTPAuthHeader: @ctx: the HTTP context Get the authentication header of an HTTP context Returns the stashed value of the WWW-Authenticate or Proxy-Authenticate header.

xmlNanoHTTPContentLength: @ctx: the HTTP context Provides the specified content length from the HTTP header. Return the specified content length from the HTTP header. Note that a value of -1 indicates that the content length element was not included in the response header.

xmlNanoHTTPRedir: @ctx: the HTTP context Provides the specified redirection URL if available from the HTTP header. Return the specified redirection URL or NULL if not redirected.

xmlNanoHTTPEncoding: @ctx: the HTTP context Provides the specified encoding if specified in the HTTP headers. Return the specified encoding or NULL if not available

xmlNanoHTTPMimeType: @ctx: the HTTP context Provides the specified Mime-Type if specified in the HTTP headers. Return the specified Mime-Type or NULL if not available

xmlNanoHTTPFetchContent: @ctx: the HTTP context @ptr: pointer to set to the content buffer. @len: integer pointer to hold the length of the content Check if all the content was read Returns 0 if all the content was read and available, returns -1 if received content length was less than specified or an error occurred.

Dummy up return input parameters if not provided

But can't work without the context pointer

STANDALONE

!LIBXML_HTTP_ENABLED

STANDALONE

LIBXML_HTTP_ENABLED

www.w3.org/Library/

myproxy/ or http://myproxy:3128/

");

%s:%d%s",

%s%s", method,

libxml.h

Content-Encoding: gzip

no_proxy

*

http_proxy

HTTP_PROXY

/

Removing HTTP proxy info\n

Using HTTP proxy %s\n

http

Syntax Error\n

allocating context

send failed\n

allocating input

allocating input buffer

recv failed\n

\n

\r

HTTP/

0

9

0

.

0

9

0

0

9



\t



\t

0

9

0

9

0



\t

Content-Type:



\t



\t

;

,

charset=



\t

;

,

ContentType:



\t



\t

;

,

charset=



\t

;

,

Location:



\t

/

http://

WWW-Authenticate:



\t

Proxy-Authenticate:



\t

Content-Encoding:



\t

gzip

Content-Length:

socket

socket failed\n

nonblocking

error setting non-blocking IO\n

error connecting to HTTP server

Connect attempt timed out

Connect failed

getsockopt failed\n

Error connecting to remote host

select failed\n

getaddrinfo failed\n

address size mismatch\n

address size mismatch\n



Authoritive host not found

Non-authoritive host not found or server failure.

Non-recoverable errors: FORMERR, REFUSED, or NOTIMP.

Valid name, no data record of requested type.

No error text defined.

Failed to resolve host

address size mismatch\n

address size mismatch\n

xmlNanoHTTPConnectHost: unable to connect to '%s'.\n

GET

http

Not a valid HTTP URI

Failed to identify host in URI

Content-Type: \r\n" */ blen += strlen(*contentType) + 16; if (ctxt->query != NULL) /* 1 for

*/ blen += strlen(ctxt->query) + 1; blen += strlen(method) + strlen(ctxt->path) + 24; #ifdef HAVE_ZLIB_H /* reserve for possible

string */ blen += 23; #endif if (ctxt->port != 80) { /* reserve space for

, incl. potential proxy */ if (proxy) blen += 12; else blen += 6; } bp = (char*)xmlMallocAtomic(blen); if ( bp == NULL ) { xmlNanoHTTPFreeCtxt( ctxt ); xmlHTTPErrMemory("allocating header buffer"); return ( NULL ); } p = bp; if (proxy) { if (ctxt->port != 80) { p += snprintf( p, blen - (p - bp), "%s http://%s:%d%s", method, ctxt->hostname, ctxt->port, ctxt->path ); } else p += snprintf( p, blen - (p - bp), "%s http://%s%s", method, ctxt->hostname, ctxt->path); } else p += snprintf( p, blen - (p - bp), "%s %s", method, ctxt->path); if (ctxt->query != NULL) p += snprintf( p, blen - (p - bp), "?%s", ctxt->query); if (ctxt->port == 80) { p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s\r\n", ctxt->hostname); } else { p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s:%d\r\n", ctxt->hostname, ctxt->port); } #ifdef HAVE_ZLIB_H p += snprintf(p, blen - (p - bp), "Accept-Encoding: gzip\r\n"); #endif if (contentType != NULL && *contentType) p += snprintf(p, blen - (p - bp), "Content-Type: %s\r\n", *contentType); if (headers != NULL) p += snprintf( p, blen - (p - bp), "%s", headers ); if (input != NULL) snprintf(p, blen - (p - bp), "Content-Length: %d\r\n\r\n", ilen ); else snprintf(p, blen - (p - bp), "\r\n"); #ifdef DEBUG_HTTP xmlGenericError(xmlGenericErrorContext, "-> %s%s", proxy? "(Proxy) " : "", bp); if ((blen -= strlen(bp)+1) < 0) xmlGenericError(xmlGenericErrorContext, "ERROR: overflowed buffer by %d bytes\n", -blen); #endif ctxt->outptr = ctxt->out = bp; ctxt->state = XML_NANO_HTTP_WRITE; blen = strlen( ctxt->out ); #ifdef DEBUG_HTTP xmt_bytes = xmlNanoHTTPSend(ctxt, ctxt->out, blen ); if ( xmt_bytes != blen ) xmlGenericError( xmlGenericErrorContext, "xmlNanoHTTPMethodRedir: Only %d of %d %s %s\n", xmt_bytes, blen, "bytes of HTTP headers sent to host", ctxt->hostname ); #else xmlNanoHTTPSend(ctxt, ctxt->out, blen ); #endif if ( input != NULL ) { #ifdef DEBUG_HTTP xmt_bytes = xmlNanoHTTPSend( ctxt, input, ilen ); if ( xmt_bytes != ilen ) xmlGenericError( xmlGenericErrorContext, "xmlNanoHTTPMethodRedir: Only %d of %d %s %s\n", xmt_bytes, ilen, "bytes of HTTP content sent to host", ctxt->hostname ); #else xmlNanoHTTPSend( ctxt, input, ilen ); #endif } ctxt->state = XML_NANO_HTTP_READ; while ((p = xmlNanoHTTPReadLine(ctxt)) != NULL) { if (*p == 0) { ctxt->content = ctxt->inrptr; xmlFree(p); break; } xmlNanoHTTPScanAnswer(ctxt, p); #ifdef DEBUG_HTTP xmlGenericError(xmlGenericErrorContext, "<- %s\n", p); #endif xmlFree(p); } if ((ctxt->location != NULL) && (ctxt->returnValue >= 300) && (ctxt->returnValue < 400)) { #ifdef DEBUG_HTTP xmlGenericError(xmlGenericErrorContext, "\nRedirect to: %s\n", ctxt->location); #endif while ( xmlNanoHTTPRecv(ctxt) > 0 ) ; if (nbRedirects < XML_NANO_HTTP_MAX_REDIR) { nbRedirects++; if (redirURL != NULL) xmlFree(redirURL); redirURL = xmlMemStrdup(ctxt->location); xmlNanoHTTPFreeCtxt(ctxt); goto retry; } xmlNanoHTTPFreeCtxt(ctxt); if (redirURL != NULL) xmlFree(redirURL); #ifdef DEBUG_HTTP xmlGenericError(xmlGenericErrorContext, "xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\n"); #endif return(NULL); } if (contentType != NULL) { if (ctxt->contentType != NULL) *contentType = xmlMemStrdup(ctxt->contentType); else *contentType = NULL; } if ((redir != NULL) && (redirURL != NULL)) { *redir = redirURL; } else { if (redirURL != NULL) xmlFree(redirURL); if (redir != NULL) *redir = NULL; } #ifdef DEBUG_HTTP if (ctxt->contentType != NULL) xmlGenericError(xmlGenericErrorContext, "\nCode %d, content-type

\n\n", ctxt->returnValue, ctxt->contentType); else xmlGenericError(xmlGenericErrorContext, "\nCode %d, no content-type\n\n", ctxt->returnValue); #endif return((void *) ctxt); } /** * xmlNanoHTTPMethod: * @URL: The URL to load * @method: the HTTP method to use * @input: the input string if any * @contentType: the Content-Type information IN and OUT * @headers: the extra headers * @ilen: input length * * This function try to open a connection to the indicated resource * via HTTP using the given @method, adding the given extra headers * and the input buffer for the request content. * * Returns NULL in case of failure, otherwise a request handler. * The contentType, if provided must be freed by the caller */ void* xmlNanoHTTPMethod(const char *URL, const char *method, const char *input, char **contentType, const char *headers, int ilen) { return(xmlNanoHTTPMethodRedir(URL, method, input, contentType, NULL, headers, ilen)); } /** * xmlNanoHTTPFetch: * @URL: The URL to load * @filename: the filename where the content should be saved * @contentType: if available the Content-Type information will be * returned at that location * * This function try to fetch the indicated resource via HTTP GET * and save it

-

-

-

%s: minimal HTTP GET implementation\n

\tusage %s [ URL [ filename ] ]\n

%s : HTTP support not compiled in\n

elfgcchack.h

Summary: minimal HTTP implementation Description: minimal HTTP implementation allowing to fetch resources like external subset. Copy: See Copyright for the status of this software. Author: Daniel Veillard

LIBXML_OUTPUT_ENABLED

LIBXML_HTTP_ENABLED

__NANO_HTTP_H__

C

