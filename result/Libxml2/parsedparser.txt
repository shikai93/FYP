parser.c : an XML 1.0 parser, namespaces and validity support are mostly implemented on top of the SAX interfaces References: The XML specification: http://www.w3.org/TR/REC-xml Original 1.0 version: http://www.w3.org/TR/1998/REC-xml-19980210 XML second edition working draft http://www.w3.org/TR/2000/WD-xml-2e-20000814 Okay this is a big file, the parser core is around 7000 lines, then it is followed by the progressive parser top routines, then the various high level APIs to call the parser and a few miscellaneous functions. A number of helper functions and deprecated ones have been moved to parserInternals.c to reduce this file size. As much as possible the functions are associated with their relative production in the XML specification. A few productions defining the different ranges of character are actually implanted either in parserInternals.h or parserInternals.c The DOM tree build is realized from the default SAX callbacks in the module SAX.c. The routines doing the validation checks are in valid.c and called either from the SAX callbacks or as standalone functions using a preparsed document. See Copyright for the status of this software. daniel@veillard.com

Arbitrary limits set in the parser. See XML_PARSE_HUGE

XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity replacement over the size in byte of the input indicates that you have and eponential behaviour. A value of 10 correspond to at least 3 entity replacement per byte of input.

xmlParserEntityCheck Function to check non-linear entity expansion behaviour This is here to detect and stop exponential linear entity expansion This is not a limitation of the parser but a safety boundary feature. It can be disabled with the XML_PARSE_HUGE parser option.

Do the check based on the replacement size of the entity

A limit on the amount of text data reasonably used

use the number of parsed entities in the replacement

The amount of data parsed counting entities size only once

Check the density of entities for the amount of data knowing an entity reference will take at least 3 bytes

strange we got no data for checking just return

xmlParserMaxDepth: arbitrary depth limit for the XML documents that we allow to process. This is not a limitation of the parser but a safety boundary feature. It can be disabled with the XML_PARSE_HUGE parser option.

List of XML prefixed PI allowed by W3C specs

DEPR void xmlParserHandleReference(xmlParserCtxtPtr ctxt);

LIBXML_LEGACY_ENABLED

Some factorized error routines

xmlErrAttributeDup: @ctxt: an XML parser context @prefix: the attribute prefix @localname: the attribute localname Handle a redefinition of attribute error

xmlFatalErr: @ctxt: an XML parser context @error: the error number @extra: extra information string Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlFatalErrMsg: @ctxt: an XML parser context @error: the error number @msg: the error message Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlWarningMsg: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: extra data @str2: extra data Handle a warning.

xmlValidityError: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: extra data Handle a validity error.

xmlFatalErrMsgInt: @ctxt: an XML parser context @error: the error number @msg: the error message @val: an integer value Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlFatalErrMsgStrIntStr: @ctxt: an XML parser context @error: the error number @msg: the error message @str1: an string info @val: an integer value @str2: an string info Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlFatalErrMsgStr: @ctxt: an XML parser context @error: the error number @msg: the error message @val: a string value Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlErrMsgStr: @ctxt: an XML parser context @error: the error number @msg: the error message @val: a string value Handle a non fatal parser error

xmlNsErr: @ctxt: an XML parser context @error: the error number @msg: the message @info1: extra information string @info2: extra information string Handle a fatal parser error, i.e. violating Well-Formedness constraints

xmlNsWarn @ctxt: an XML parser context @error: the error number @msg: the message @info1: extra information string @info2: extra information string Handle a fatal parser error, i.e. violating Well-Formedness constraints

Library wide options

xmlHasFeature: @feature: the feature to be examined Examines if the library has been compiled with a given feature. Returns a non-zero value if the feature exist, otherwise zero. Returns zero (0) if the feature does not exist or an unknown unknown feature is requested, non-zero otherwise.

SAX2 defaulted attributes handling

xmlDetectSAX2: @ctxt: an XML parser context Do the SAX2 detection and specific intialization

LIBXML_SAX1_ENABLED

number of defaulted attributes on that element

the size of the array

array of localname/prefix/values/external

xmlAttrNormalizeSpace: @src: the source string @dst: the target string Normalize the space in non CDATA attribute values: If the attribute type is not CDATA, then the XML processor MUST further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character. Note that the size of dst need to be at least src, and if one doesn't need to preserve dst (and it doesn't come from a dictionary or read-only) then passing src as dst is just fine. Returns a pointer to the normalized value (dst) or NULL if no conversion is needed.

xmlAttrNormalizeSpace2: @src: the source string Normalize the space in non CDATA attribute values, a slightly more complex front end to avoid allocation problems when running on attribute values coming from the input. Returns a pointer to the normalized value (dst) or NULL if no conversion is needed.

xmlAddDefAttrs: @ctxt: an XML parser context @fullname: the element fullname @fullattr: the attribute fullname @value: the attribute value Add a defaulted attribute for an element

Allows to detect attribute redefinitions

split the element name into prefix:localname , the string found are within the DTD and then not associated to namespace names.

make sure there is some storage

Split the element name into prefix:localname , the string found are within the DTD and hen not associated to namespace names.

intern the string and precompute the end

xmlAddSpecialAttr: @ctxt: an XML parser context @fullname: the element fullname @fullattr: the attribute fullname @type: the attribute type Register this attribute type

xmlCleanSpecialAttrCallback: Removes CDATA attributes from the special attribute table

xmlCleanSpecialAttr: @ctxt: an XML parser context Trim the list of attributes defined to remove all those of type CDATA as they are not special. This call should be done when finishing to parse the DTD and before starting to parse the document root.

xmlCheckLanguageID: @lang: pointer to the string value Checks that the value conforms to the LanguageID production: NOTE: this is somewhat deprecated, those productions were removed from the XML Second edition. [33] LanguageID ::= Langcode ('-' Subcode) [34] Langcode ::= ISO639Code | IanaCode | UserCode [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z]) [36] IanaCode ::= ('i' | 'I') '-' ([a-z] | [A-Z])+ [37] UserCode ::= ('x' | 'X') '-' ([a-z] | [A-Z])+ [38] Subcode ::= ([a-z] | [A-Z])+ Returns 1 if correct 0 otherwise

IANA code

non input consuming

User code

non input consuming

ISO639

non input consuming

non input consuming

Parser stacks related functions and macros

nsPush: @ctxt: an XML parser context @prefix: the namespace prefix or NULL @URL: the namespace name Pushes a new parser namespace on top of the ns stack Returns -1 in case of error, -2 if the namespace should be discarded and the index in the stack otherwise.

in scope

out of scope keep it

nsPop: @ctxt: an XML parser context @nr: the number to pop Pops the top @nr parser prefix/namespace from the ns stack Returns the number of namespaces removed

allow for 10 attrs by default

inputPush: @ctxt: an XML parser context @value: the parser input Pushes a new parser input on top of the input stack Returns -1 in case of error, the index in the stack otherwise

inputPop: @ctxt: an XML parser context Pops the top parser input from the input stack Returns the input just removed

nodePush: @ctxt: an XML parser context @value: the element node Pushes a new element node on top of the node stack Returns -1 in case of error, the index in the stack otherwise

nodePop: @ctxt: an XML parser context Pops the top element node from the node stack Returns the node just removed

nameNsPush: @ctxt: an XML parser context @value: the element name @prefix: the element prefix @URI: the element namespace name Pushes a new element name/prefix/URL on top of the name stack Returns -1 in case of error, the index in the stack otherwise

nameNsPop: @ctxt: an XML parser context Pops the top element/prefix/URI name from the name stack Returns the name just removed

LIBXML_PUSH_ENABLED

namePush: @ctxt: an XML parser context @value: the element name Pushes a new element name on top of the name stack Returns -1 in case of error, the index in the stack otherwise

namePop: @ctxt: an XML parser context Pops the top element name from the name stack Returns the name just removed

Macros for accessing the content. Those should be used only by the parser, and not exported. Dirty macros, i.e. one often need to make assumption on the context to use them CUR_PTR return the current pointer to the xmlChar to be parsed. To be used with extreme caution since operations consuming characters may move the input buffer to a different location ! CUR returns the current xmlChar value, i.e. a 8 bit value if compiled This should be used internally by the parser only to compare to ASCII values otherwise it would break when running with UTF-8 encoding. RAW same as CUR but in the input buffer, bypass any token extraction that may have been done NXT(n) returns the n'th next xmlChar. Same as CUR is should be used only to compare on ASCII based substring. SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined strings without newlines within the parser. NEXT1(l) Skip 1 xmlChar, and must also be used only to skip 1 non-newline ASCII defined char within the parser. Clean macros, not dependent of an ASCII context, expect UTF-8 encoding NEXT Skip to the next character, this does the proper decoding in UTF-8 mode. It also pop-up unfinished entities on the fly. NEXTL(l) Skip the current unicode character of l xmlChars long. CUR_CHAR(l) returns the current unicode character (int), set l to the number of xmlChars used for the encoding [0-5]. CUR_SCHAR same but operate on a string instead of the context COPY_BUF copy the current unicode char to the target buffer, increment the index GROW, SHRINK handling of input buffers

xmlSkipBlankChars: @ctxt: the XML parser context skip all blanks character found at that point in the input streams. It pops up finished entities in the process if allowable at that point. Returns the number of space chars skipped

It's Okay to use CUR/NEXT here since all the blanks are on the ASCII range.

if we are in the document content, go really fast

CHECKED tstblanks.xml

Need to handle support of entities branching here

CHECKED tstblanks.xml

Commodity functions to handle entities

xmlPopInput: @ctxt: an XML parser context xmlPopInput: the current input pointed by ctxt->input came to an end pop it and return the next char. Returns the current xmlChar in the parser context

xmlPushInput: @ctxt: an XML parser context @input: an XML parser input fragment (entity, XML fragment ...). xmlPushInput: switch to a new input stream which is stacked on top of the previous one(s). Returns -1 in case of error or the index in the input stack

xmlParseCharRef: @ctxt: an XML parser context parse Reference declarations [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';' [ WFC: Legal Character ] Characters referred to using character references must match the production for Char. Returns the value parsed (as an int), 0 in case of error

Using RAW/CUR/NEXT is okay since we are working on ASCII range here

loop blocked by count

on purpose to avoid reentrancy problems with NEXT and SKIP

loop blocked by count

on purpose to avoid reentrancy problems with NEXT and SKIP

[ WFC: Legal Character ] Characters referred to using character references must match the production for Char.

xmlParseStringCharRef: @ctxt: an XML parser context @str: a pointer to an index in the string parse Reference declarations, variant parsing from a string rather than an an input flow. [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';' [ WFC: Legal Character ] Characters referred to using character references must match the production for Char. Returns the value parsed (as an int), 0 in case of error, str will be updated to the current value of the index

Non input consuming loop

Non input consuming loops

[ WFC: Legal Character ] Characters referred to using character references must match the production for Char.

xmlNewBlanksWrapperInputStream: @ctxt: an XML parser context @entity: an Entity pointer Create a new input stream for wrapping blanks around a PEReference Returns the new input stream or NULL

xmlParserHandlePEReference: @ctxt: the parser context [69] PEReference ::= '%' Name ';' [ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly. [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it... [ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it... [ WFC: In DTD ] Parameter-entity references may only appear in the DTD. NOTE: misleading but this is handled. A PEReference may have been detected in the current input stream the handling is done accordingly to http://www.w3.org/TR/REC-xml#entproc i.e. - Included in literal in entity values - Included as Parameter Entity reference within DTDs

we just ignore it there

NOTE: in the case of entity values, we don't do the substitution here since we need the literal entity value to be able to save the internal subset of the document. This will be handled by xmlStringDecodeEntities

[WFC: Well-Formedness Constraint: PEs in Internal Subset] In the internal DTD subset, parameter-entity references can occur only where markup declarations can occur, not within markup declarations. In that case this is handled in xmlParseMarkupDecl

[ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it...

[ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it...

handle the extra spaces added before and after c.f. http://www.w3.org/TR/REC-xml#as-PE this is done independently.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines. Note that, since we may have some non-UTF8 encoding (like UTF16, bug 135229), the 'length' is not known, but we can calculate based upon the amount of data in the buffer.

Macro used to grow the current buffer.

xmlStringLenDecodeEntities: @ctxt: the parser context @str: the input string @len: the string length @what: combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF @end: an end marker xmlChar, 0 if none @end2: an end marker xmlChar, 0 if none @end3: an end marker xmlChar, 0 if none Takes a entity string content and process to do the adequate substitutions. [67] Reference ::= EntityRef | CharRef [69] PEReference ::= '%' Name ';' Returns A newly allocated string with the substitution done. The caller must deallocate it !

allocate a translation buffer.

OK loop until we reach one of the ending char or a size limit. we are operating on already parsed values.

non input consuming loop

non input consuming loop

non input consuming loop

xmlStringDecodeEntities: @ctxt: the parser context @str: the input string @what: combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF @end: an end marker xmlChar, 0 if none @end2: an end marker xmlChar, 0 if none @end3: an end marker xmlChar, 0 if none Takes a entity string content and process to do the adequate substitutions. [67] Reference ::= EntityRef | CharRef [69] PEReference ::= '%' Name ';' Returns A newly allocated string with the substitution done. The caller must deallocate it !

Commodity functions, cleanup needed ?

areBlanks: @ctxt: an XML parser context @str: a xmlChar @len: the size of @str @blank_chars: we know the chars are blanks Is this a sequence of blank chars that one can ignore ? Returns 1 if ignorable 0 otherwise.

Don't spend time trying to differentiate them, the same callback is used !

Check for xml:space value.

Check that the string is made of blanks

Look if the element is mixed content in the DTD if available

Otherwise, heuristic :-\

Extra stuff for namespace support Relates to http://www.w3.org/TR/WD-xml-names

xmlSplitQName: @ctxt: an XML parser context @name: an XML parser context @prefix: a xmlChar parse an UTF8 encoded XML qualified name string [NS 5] QName ::= (Prefix ':')? LocalPart [NS 6] Prefix ::= NCName [NS 7] LocalPart ::= NCName Returns the local part, and prefix is updated to get the Prefix if any.

xml: prefix is not really a namespace

nasty but well=formed

tested bigname.xml

Okay someone managed to make a huge name, so he's ready to pay for the processing speed.

tested bigname.xml

Check that the first character is proper to start a new name

tested bigname2.xml

Okay someone managed to make a huge name, so he's ready to pay for the processing speed.

tested bigname2.xml

The parser itself Relates to http://www.w3.org/TR/REC-xml

Routines to parse Name, NCName and NmToken

The two following functions are related to the change of accepted characters for Name and NmToken in the Revision 5 of XML-1.0 They correspond to the modified production [4] and the new production [4a] changes in that revision. Also note that the macros used for the productions Letter, Digit, CombiningChar and Extender are not needed anymore. We still keep compatibility to pre-revision5 parsing semantic if the new XML_PARSE_OLD10 option is given to the parser.

Use the new checks of production [4] [4a] amd [5] of the Update 5 of XML-1.0

accelerators

Use the new checks of production [4] [4a] amd [5] of the Update 5 of XML-1.0

accelerators

!start

!start

!start

!start

Handler for more complex cases

Use the new checks of production [4] [4a] amd [5] of the Update 5 of XML-1.0

accelerators

accelerators

!start

!start

!start

!start

accelerators

test bigname.xml

xmlParseName: @ctxt: an XML parser context parse an XML name. [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender [5] Name ::= (Letter | '_' | ':') (NameChar) [6] Names ::= Name (#x20 Name) Returns the Name parsed or NULL

Accelerator for simple ASCII names

accelerator for special cases

Handler for more complex cases

accelerators

test bigname.xml

xmlParseNCName: @ctxt: an XML parser context @len: lenght of the string parsed parse an XML name. [4NS] NCNameChar ::= Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender [5NS] NCName ::= (Letter | '_') (NCNameChar) Returns the Name parsed or NULL

Accelerator for simple ASCII names

xmlParseNameAndCompare: @ctxt: an XML parser context parse an XML name and compares for match (specialized for endtag parsing) Returns NULL for an illegal name, (xmlChar) 1 for success and the name for mismatch

success

failure (or end of input buffer), check with full function

strings coming from the dictionnary direct compare possible

xmlParseStringName: @ctxt: an XML parser context @str: a pointer to the string pointer (IN/OUT) parse an XML name. [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender [5] Name ::= (Letter | '_' | ':') (NameChar) [6] Names ::= Name (#x20 Name) Returns the Name parsed or NULL. The @str pointer is updated to the current location in the string.

test bigentname.xml

Okay someone managed to make a huge name, so he's ready to pay for the processing speed.

xmlParseNmtoken: @ctxt: an XML parser context parse an XML Nmtoken. [7] Nmtoken ::= (NameChar)+ [8] Nmtokens ::= Nmtoken (#x20 Nmtoken) Returns the Nmtoken parsed or NULL

Okay someone managed to make a huge token, so he's ready to pay for the processing speed.

xmlParseEntityValue: @ctxt: an XML parser context @orig: if non-NULL store a copy of the original entity value parse a value for ENTITY declarations [9] EntityValue ::= '"' ([^%&"] | PEReference | Reference) '"' | "'" ([^%&'] | PEReference | Reference) "'" Returns the EntityValue parsed with reference substituted or NULL

The content of the entity definition is copied in a buffer.

NOTE: 4.4.5 Included in Literal When a parameter entity reference appears in a literal entity value, ... a single or double quote character in the replacement text is always treated as a normal data character and will not terminate the literal. In practice it means we stop the loop only when back at parsing the initial entity and the quote is found

checked

Pop-up of finished entities.

non input consuming

Raise problem w.r.t. '&' and '%' being used in non-entities reference constructs. Note Charref will be handled in xmlStringDecodeEntities()

non input consuming

Then PEReference entities are substituted.

NOTE: 4.4.7 Bypassed When a general entity reference appears in the EntityValue in an entity declaration, it is bypassed and left as is. so XML_SUBSTITUTE_REF is not set here.

xmlParseAttValueComplex: @ctxt: an XML parser context @len: the resulting attribute len @normalize: wether to apply the inner normalization parse a value for an attribute, this is the fallback function of xmlParseAttValue() when the attribute parsing requires handling of non-ASCII characters, or normalization compaction. Returns the AttValue parsed or NULL. The value has to be freed by the caller.

allocate a translation buffer.

OK loop until we reach one of the ending char or a size limit.

checked

The reparsing will be done in xmlStringGetNodeList() called by the attribute() function in SAX.c

non input consuming

This may look absurd but is needed to detect entities problems

Just output the reference

xmlParseAttValue: @ctxt: an XML parser context parse a value for an attribute Note: the parser won't do substitution of entities here, this will be handled later in xmlStringGetNodeList [10] AttValue ::= '"' ([^<&"] | Reference) '"' | "'" ([^<&'] | Reference) "'" 3.3.3 Attribute-Value Normalization: Before the value of an attribute is passed to the application or checked for validity, the XML processor must normalize it as follows: - a character reference is processed by appending the referenced character to the attribute value - an entity reference is processed by recursively processing the replacement text of the entity - a whitespace character (#x20, #xD, #xA, #x9) is processed by appending #x20 to the normalized value, except that only a single #x20 is appended for a "#xD#xA" sequence that is part of an external parsed entity or the literal entity value of an internal parsed entity - other characters are processed by appending them to the normalized value If the declared value is not CDATA, then the XML processor must further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character. All attributes for which no declaration has been read should be treated by a non-validating parser as if declared CDATA. Returns the AttValue parsed or NULL. The value has to be freed by the caller.

xmlParseSystemLiteral: @ctxt: an XML parser context parse an XML Literal [11] SystemLiteral ::= ('"' [^"] '"') | ("'" [^'] "'") Returns the SystemLiteral parsed or NULL

checked

xmlParsePubidLiteral: @ctxt: an XML parser context parse an XML public literal [12] PubidLiteral ::= '"' PubidChar '"' | "'" (PubidChar - "'") "'" Returns the PubidLiteral parsed or NULL.

checked

used for the test in the inner loop of the char data testing

0x9, CR/LF separated

&

<

]

non-ascii

xmlParseCharData: @ctxt: an XML parser context @cdata: int indicating whether we are within a CDATA section parse a CharData section. if we are within a CDATA section ']]>' marks an end of section. The right angle bracket (>) may be represented using the string "&gt;", and must, for compatibility, be escaped using "&gt;" or a character reference when it appears in the string "]]>" in content, when that string is not marking the end of a CDATA section. [14] CharData ::= [^<&] - ([^<&] ']]>' [^<&])

Accelerated common case where input don't need to be modified before passing it to the handler.

something really bad happened in the SAX callback

while

xmlParseCharDataComplex: @ctxt: an XML parser context @cdata: int indicating whether we are within a CDATA section parse a CharData section.this is the fallback function of xmlParseCharData() when the parsing requires handling of non-ASCII characters.

checked

test also done in xmlCurrentChar()

OK the segment is to be consumed as chars.

something really bad happened in the SAX callback

OK the segment is to be consumed as chars.

Generate the error and skip the offending character

xmlParseExternalID: @ctxt: an XML parser context @publicID: a xmlChar receiving PubidLiteral @strict: indicate whether we should restrict parsing to only production [75], see NOTE below Parse an External ID or a Public ID NOTE: Productions [75] and [83] interact badly since [75] can generate 'PUBLIC' S PubidLiteral S SystemLiteral [75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral [83] PublicID ::= 'PUBLIC' S PubidLiteral Returns the function returns SystemLiteral and in the second case publicID receives PubidLiteral, is strict is off it is possible to return NULL and have publicID set.

We don't handle [83] so "S SystemLiteral" is required.

We handle [83] so we return immediately, if "S SystemLiteral" is not detected. From a purely parsing point of view that's a nice mess.

TODO: dangerous, fix !

xmlParseCommentComplex: @ctxt: an XML parser context @buf: the already parsed part of the buffer @len: number of bytes filles in the buffer @size: allocated size of the buffer Skip an XML (SGML) comment <!-- .... --> The spec says that "For compatibility, the string "--" (double-hyphen) must not occur within comments. " This is the slow routine in case the accelerator for ascii didn't work [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-'))) '-->'

Assure there's enough input data

checked

xmlParseComment: @ctxt: an XML parser context Skip an XML (SGML) comment <!-- .... --> The spec says that "For compatibility, the string "--" (double-hyphen) must not occur within comments. " [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-'))) '-->'

Check that there is a comment right here.

Accelerated common case where input don't need to be modified before passing it to the handler.

save current set of data

while

xmlParsePITarget: @ctxt: an XML parser context parse the name of a PI [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l')) Returns the PITarget name or NULL

xmlParseCatalogPI: @ctxt: an XML parser context @catalog: the PI value string parse an XML Catalog Processing Instruction. <?oasis-xml-catalog catalog="http://example.com/catalog.xml"?> Occurs only if allowed by the user and if happening in the Misc part of the document before any doctype informations This will add the given catalog to the parsing context in order to be used if there is a resolution need further down in the document

xmlParsePI: @ctxt: an XML parser context parse an XML Processing Instruction. [16] PI ::= '<?' PITarget (S (Char - (Char '?>' Char)))? '?>' The processing is transfered to SAX once parsed.

this is a Processing Instruction.

Parse the target name and check for special support like namespace.

SAX: PI detected.

checked

SAX: PI detected.

xmlParseNotationDecl: @ctxt: an XML parser context parse a notation declaration [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>' Hence there is actually 3 choices: 'PUBLIC' S PubidLiteral 'PUBLIC' S PubidLiteral S SystemLiteral and 'SYSTEM' S SystemLiteral See the NOTE on xmlParseExternalID().

Parse the IDs.

xmlParseEntityDecl: @ctxt: an XML parser context parse <!ENTITY declarations [70] EntityDecl ::= GEDecl | PEDecl [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>' [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>' [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?) [74] PEDef ::= EntityValue | ExternalID [76] NDataDecl ::= S 'NDATA' S Name [ VC: Notation Declared ] The Name must match the declared name of a notation.

GROW; done in the caller

handle the various case of definitions...

This really ought to be a well formedness error but the XML Core WG decided otherwise c.f. issue E26 of the XML erratas.

Okay this is foolish to block those but not invalid URIs.

For expat compatibility in SAX mode.

This really ought to be a well formedness error but the XML Core WG decided otherwise c.f. issue E26 of the XML erratas.

Okay this is foolish to block those but not invalid URIs.

For expat compatibility in SAX mode. assuming the entity repalcement was asked for

Ugly mechanism to save the raw entity value.

xmlParseDefaultDecl: @ctxt: an XML parser context @value: Receive a possible fixed default value for the attribute Parse an attribute default declaration [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue) [ VC: Required Attribute ] if the default declaration is the keyword #REQUIRED, then the attribute must be specified for all elements of the type in the attribute-list declaration. [ VC: Attribute Default Legal ] The declared default value must meet the lexical constraints of the declared attribute type c.f. xmlValidateAttributeDecl() [ VC: Fixed Attribute Default ] if an attribute has a default value declared with the #FIXED keyword, instances of that attribute must match the default value. [ WFC: No < in Attribute Values ] handled in xmlParseAttValue() returns: XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED or XML_ATTRIBUTE_FIXED.

xmlParseNotationType: @ctxt: an XML parser context parse an Notation attribute type. Note: the leading 'NOTATION' S part has already being parsed... [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name) S? ')' [ VC: Notation Attributes ] Values of this type must match one of the notation names included in the declaration; all notation names in the declaration must be declared. Returns: the notation attribute tree built while parsing

xmlParseEnumerationType: @ctxt: an XML parser context parse an Enumeration attribute type. [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken) S? ')' [ VC: Enumeration ] Values of this type must match one of the Nmtoken tokens in the declaration Returns: the enumeration attribute tree built while parsing

xmlParseEnumeratedType: @ctxt: an XML parser context @tree: the enumeration tree built while parsing parse an Enumerated attribute type. [57] EnumeratedType ::= NotationType | Enumeration [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name) S? ')' Returns: XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION

xmlParseAttributeType: @ctxt: an XML parser context @tree: the enumeration tree built while parsing parse the Attribute list def for an element [54] AttType ::= StringType | TokenizedType | EnumeratedType [55] StringType ::= 'CDATA' [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS' Validity constraints for attribute values syntax are checked in xmlValidateAttributeValue() [ VC: ID ] Values of type ID must match the Name production. A name must not appear more than once in an XML document as a value of this type; i.e., ID values must uniquely identify the elements which bear them. [ VC: One ID per Element Type ] No element type may have more than one ID attribute specified. [ VC: ID Attribute Default ] An ID attribute must have a declared default of #IMPLIED or #REQUIRED. [ VC: IDREF ] Values of type IDREF must match the Name production, and values of type IDREFS must match Names; each IDREF Name must match the value of an ID attribute on some element in the XML document; i.e. IDREF values must match the value of some ID attribute. [ VC: Entity Name ] Values of type ENTITY must match the Name production, values of type ENTITIES must match Names; each Entity Name must match the name of an unparsed entity declared in the DTD. [ VC: Name Token ] Values of type NMTOKEN must match the Nmtoken production; values of type NMTOKENS must match Nmtokens. Returns the attribute type

xmlParseAttributeListDecl: @ctxt: an XML parser context : parse the Attribute list def for an element [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef S? '>' [53] AttDef ::= S Name S AttType S DefaultDecl

xmlParseElementMixedContentDecl: @ctxt: an XML parser context @inputchk: the input used for the current entity, needed for boundary checks parse the declaration for a Mixed Element content The leading '(' and spaces have been skipped in xmlParseElementContentDecl [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name) S? ')' | '(' S? '#PCDATA' S? ')' [ VC: Proper Group/PE Nesting ] applies to [51] too (see [49]) [ VC: No Duplicate Types ] The same name must not appear more than once in a single mixed-content declaration. returns: the list of the xmlElementContentPtr describing the element choices

xmlParseElementChildrenContentDeclPriv: @ctxt: an XML parser context @inputchk: the input used for the current entity, needed for boundary checks @depth: the level of recursion parse the declaration for a Mixed Element content The leading '(' and spaces have been skipped in xmlParseElementContentDecl [47] children ::= (choice | seq) ('?' | '' | '+')? [48] cp ::= (Name | choice | seq) ('?' | '' | '+')? [49] choice ::= '(' S? cp ( S? '|' S? cp ) S? ')' [50] seq ::= '(' S? cp ( S? ',' S? cp ) S? ')' [ VC: Proper Group/PE Nesting ] applies to [49] and [50] TODO Parameter-entity replacement text must be properly nested with parenthesized groups. That is to say, if either of the opening or closing parentheses in a choice, seq, or Mixed construct is contained in the replacement text for a parameter entity, both must be contained in the same replacement text. For interoperability, if a parameter-entity reference appears in a choice, seq, or Mixed construct, its replacement text should not be empty, and neither the first nor last non-blank character of the replacement text should be a connector (| or ,). Returns the tree of xmlElementContentPtr describing the element hierarchy.

Recurse on first child

Each loop we parse one separator and one element.

Detect "Name | Name , Name" error

Detect "Name , Name | Name" error

Recurse on second child

Some normalization: (a | b | c?) == (a | b | c)

Some normalization: (a | b)+ == (a | b) (a | b?)+ == (a | b)

xmlParseElementChildrenContentDecl: @ctxt: an XML parser context @inputchk: the input used for the current entity, needed for boundary checks parse the declaration for a Mixed Element content The leading '(' and spaces have been skipped in xmlParseElementContentDecl [47] children ::= (choice | seq) ('?' | '' | '+')? [48] cp ::= (Name | choice | seq) ('?' | '' | '+')? [49] choice ::= '(' S? cp ( S? '|' S? cp ) S? ')' [50] seq ::= '(' S? cp ( S? ',' S? cp ) S? ')' [ VC: Proper Group/PE Nesting ] applies to [49] and [50] TODO Parameter-entity replacement text must be properly nested with parenthesized groups. That is to say, if either of the opening or closing parentheses in a choice, seq, or Mixed construct is contained in the replacement text for a parameter entity, both must be contained in the same replacement text. For interoperability, if a parameter-entity reference appears in a choice, seq, or Mixed construct, its replacement text should not be empty, and neither the first nor last non-blank character of the replacement text should be a connector (| or ,). Returns the tree of xmlElementContentPtr describing the element hierarchy.

stub left for API/ABI compat

xmlParseElementContentDecl: @ctxt: an XML parser context @name: the name of the element being defined. @result: the Element Content pointer will be stored here if any parse the declaration for an Element content either Mixed or Children, the cases EMPTY and ANY are handled directly in xmlParseElementDecl [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children returns: the type of element content XML_ELEMENT_TYPE_xxx

xmlParseElementDecl: @ctxt: an XML parser context parse an Element declaration. [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>' [ VC: Unique Element Type Declaration ] No element type may be declared more than once Returns the type of the element, or -1 in case of error

GROW; done in the caller

Element must always be empty.

Element is a generic container.

[ WFC: PEs in Internal Subset ] error handling.

Pop-up of finished entities.

this is a trick: if xmlAddElementDecl is called, instead of copying the full tree it is plugged directly if called from the parser. Avoid duplicating the interfaces or change the API/ABI

xmlParseConditionalSections @ctxt: an XML parser context [61] conditionalSect ::= includeSect | ignoreSect [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>' [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents ']]>' [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore) [65] Ignore ::= Char - (Char ('<![' | ']]>') Char)

Pop-up of finished entities.

Parse up to the end of the conditional section But disable SAX event generating DTD building in the meantime

xmlParseMarkupDecl: @ctxt: an XML parser context parse Markup declarations [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment [ VC: Proper Declaration/PE Nesting ] Parameter-entity replacement text must be properly nested with markup declarations. That is to say, if either the first character or the last character of a markup declaration (markupdecl above) is contained in the replacement text for a parameter-entity reference, both must be contained in the same replacement text. [ WFC: PEs in Internal Subset ] In the internal DTD subset, parameter-entity references can occur only where markup declarations can occur, not within markup declarations. (This does not apply to references that occur in external parameter entities or to the external subset.)

there is an error but it will be detected later

This is only for internal subset. On external entities, the replacement is done before parsing stage

Conditional sections are allowed from entities included by PE References in the internal subset.

xmlParseTextDecl: @ctxt: an XML parser context parse an XML declaration header for external entities [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'

We know that '<?xml' is here.

We may have the VersionInfo here.

We must have the encoding declaration

The XML REC instructs us to stop parsing right here

Deprecated old WD ...

xmlParseExternalSubset: @ctxt: an XML parser context @ExternalID: the external identifier @SystemID: the system identifier (or URL) parse Markup declarations from an external subset [30] extSubset ::= textDecl? extSubsetDecl [31] extSubsetDecl ::= (markupdecl | conditionalSect | PEReference | S)

The XML REC instructs us to stop parsing right here

Pop-up of finished entities.

xmlParseReference: @ctxt: an XML parser context parse and handle entity references in content, depending on the SAX interface, this may end-up in a call to character() if this is a CharRef, a predefined entity, if there is no reference() callback. or if the parser was asked to switch to that mode. [67] Reference ::= EntityRef | CharRef

Simple case of a CharRef

So we are using non-UTF-8 buffers Check that the char fit on 8bits, if not generate a CharRef.

Just encode the value in UTF-8

We are seeing an entity reference

special case of predefined entities

inline the entity.

The first reference to the entity trigger a parsing phase where the ent->children is filled with the result from the parsing.

This is a bit hackish but this seems the best way to make sure both SAX and DOM entity support behaves okay.

Check that this entity is well formed 4.3.2: An internal general parsed entity is well-formed if its replacement text matches the production labeled content.

Store the number of entities needing parsing for this entity content and do checkings

Prune it directly in the generated document except for single text nodes.

LIBXML_LEGACY_ENABLED

Now that the entity content has been gathered provide it to the application, this can take different forms based on the parsing modes.

Probably running in SAX mode and the callbacks don't build the entity content. So unless we already went though parsing for first checking go though the entity content to generate callbacks associated to the entity

This is a bit hackish but this seems the best way to make sure both SAX and DOM entity support behaves okay.

Entity reference callback comes second, it's somewhat superfluous but a compatibility to historical behaviour

If we didn't get any children for the entity being built

Create a node.

There is a problem on the handling of _private for entities (bug 155816): Should we copy the content of the field from the entity (possibly overwriting some value set by the user when a copy is created), should we leave it alone, or should we try to take care of different situations? The problem is exacerbated by the usage of this field by the xmlReader. To fix this bug, we look at _private on the created node and, if it's NULL, we copy in whatever was in the entity. If it's not NULL we leave it alone. This is somewhat of a hack - maybe we should have further tests to determine what to do.

Seems we are generating the DOM content, do a simple tree copy for all references except the first In the first occurrence list contains the replacement. progressive == 2 means we are operating on the Reader and since nodes are discarded we must copy all the time.

when operating on a reader, the entities definitions are always owning the entities subtree. if (ctxt->parseMode == XML_PARSE_READER) ent->owner = 1;

needed to detect some strange empty node cases in the reader tests

LIBXML_LEGACY_ENABLED

Copy the entity child list and make it the new entity child list. The goal is to make sure any ID or REF referenced will be the one from the document content and not the entity copy.

LIBXML_LEGACY_ENABLED

the name change is to avoid coalescing of the node with a possible previous text one which would make ent->children a dangling pointer

This is to avoid a nasty side effect, see characters() in SAX.c

xmlParseEntityRef: @ctxt: an XML parser context parse ENTITY references declarations [68] EntityRef ::= '&' Name ';' [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot. The declaration of a parameter entity must precede any reference to it. Similarly, the declaration of a general entity must precede any reference to it which appears in a default value in an attribute-list declaration. Note that if entities are declared in the external subset or in external parameter entities, a non-validating processor is not obligated to read and process their declarations; for such documents, the rule that an entity must be declared is a well-formedness constraint only if standalone='yes'. [ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity Returns the xmlEntityPtr if found, or NULL otherwise.

Predefined entites override any extra definition

Increate the number of entity references parsed

Ask first SAX for entity resolution, otherwise try the entities which may have stored in the parser context.

[ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot. The declaration of a parameter entity must precede any reference to it. Similarly, the declaration of a general entity must precede any reference to it which appears in a default value in an attribute-list declaration. Note that if entities are declared in the external subset or in external parameter entities, a non-validating processor is not obligated to read and process their declarations; for such documents, the rule that an entity must be declared is a well-formedness constraint only if standalone='yes'.

[ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity

[ WFC: No External Entity References ] Attribute values cannot contain direct or indirect entity references to external entities.

[ WFC: No < in Attribute Values ] The replacement text of any entity referred to directly or indirectly in an attribute value (other than "&lt;") must not contain a <.

Internal check, no parameter entities here ...

[ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly. Done somewhere else

xmlParseStringEntityRef: @ctxt: an XML parser context @str: a pointer to an index in the string parse ENTITY references declarations, but this version parses it from a string value. [68] EntityRef ::= '&' Name ';' [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot. The declaration of a parameter entity must precede any reference to it. Similarly, the declaration of a general entity must precede any reference to it which appears in a default value in an attribute-list declaration. Note that if entities are declared in the external subset or in external parameter entities, a non-validating processor is not obligated to read and process their declarations; for such documents, the rule that an entity must be declared is a well-formedness constraint only if standalone='yes'. [ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity Returns the xmlEntityPtr if found, or NULL otherwise. The str pointer is updated to the current location in the string.

Predefined entites override any extra definition

Increate the number of entity references parsed

Ask first SAX for entity resolution, otherwise try the entities which may have stored in the parser context.

[ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot. The declaration of a parameter entity must precede any reference to it. Similarly, the declaration of a general entity must precede any reference to it which appears in a default value in an attribute-list declaration. Note that if entities are declared in the external subset or in external parameter entities, a non-validating processor is not obligated to read and process their declarations; for such documents, the rule that an entity must be declared is a well-formedness constraint only if standalone='yes'.

TODO ? check regressions ctxt->valid = 0;

[ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity

[ WFC: No External Entity References ] Attribute values cannot contain direct or indirect entity references to external entities.

[ WFC: No < in Attribute Values ] The replacement text of any entity referred to directly or indirectly in an attribute value (other than "&lt;") must not contain a <.

Internal check, no parameter entities here ...

[ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly. Done somewhere else

xmlParsePEReference: @ctxt: an XML parser context parse PEReference declarations The entity content is handled directly by pushing it's content as a new input stream. [69] PEReference ::= '%' Name ';' [ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly. [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it... [ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it... [ WFC: In DTD ] Parameter-entity references may only appear in the DTD. NOTE: misleading but this is handled.

Increate the number of entity references parsed

Request the entity from SAX

[ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it...

[ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it...

Internal checking in case the entity quest barfed

TODO !!! handle the extra spaces added before and after c.f. http://www.w3.org/TR/REC-xml#as-PE

The XML REC instructs us to stop parsing right here

xmlLoadEntityContent: @ctxt: an XML parser context @entity: an unloaded system entity Load the original content of the given system entity from the ExternalID/SystemID given. This is to be used for Included in Literal http://www.w3.org/TR/REC-xml/#inliteral processing of entities references Returns 0 in case of success and -1 in case of failure

Push the entity as the current input, read char by char saving to the buffer until the end of the entity or an error

xmlParseStringPEReference: @ctxt: an XML parser context @str: a pointer to an index in the string parse PEReference declarations [69] PEReference ::= '%' Name ';' [ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly. [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it... [ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it... [ WFC: In DTD ] Parameter-entity references may only appear in the DTD. NOTE: misleading but this is handled. Returns the string of the entity content. str is updated to the current value of the index

Increate the number of entity references parsed

Request the entity from SAX

[ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "standalone='yes'", ... ... The declaration of a parameter entity must precede any reference to it...

[ VC: Entity Declared ] In a document with an external subset or external parameter entities with "standalone='no'", ... ... The declaration of a parameter entity must precede any reference to it...

Internal checking in case the entity quest barfed

xmlParseDocTypeDecl: @ctxt: an XML parser context parse a DOCTYPE declaration [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | PEReference | S) ']' S?)? '>' [ VC: Root Element Type ] The Name in the document type declaration must match the element type of the root element.

We know that '<!DOCTYPE' has been detected.

Parse the DOCTYPE name.

Check for SystemID and ExternalID

Create and update the internal subset.

Is there any internal subset declarations ? they are handled separately in xmlParseInternalSubset()

We should be at the end of the DOCTYPE declaration.

xmlParseInternalSubset: @ctxt: an XML parser context parse the internal subset declaration [28 end] ('[' (markupdecl | PEReference | S) ']' S?)? '>'

Is there any DTD definition ?

Parse the succession of Markup declarations and PEReferences. Subsequence (markupdecl | PEReference | S)

Pop-up of finished entities.

We should be at the end of the DOCTYPE declaration.

xmlParseAttribute: @ctxt: an XML parser context @value: a xmlChar used to store the value of the attribute parse an attribute [41] Attribute ::= Name Eq AttValue [ WFC: No External Entity References ] Attribute values cannot contain direct or indirect entity references to external entities. [ WFC: No < in Attribute Values ] The replacement text of any entity referred to directly or indirectly in an attribute value (other than "&lt;") must not contain a <. [ VC: Attribute Value Type ] The attribute must have been declared; the value must be of the type declared for it. [25] Eq ::= S? '=' S? With namespace: [NS 11] Attribute ::= QName Eq AttValue Also the case QName == xmlns:??? is handled independently as a namespace definition. Returns the attribute name, and the value in value.

read the value

Check that xml:lang conforms to the specification No more registered as an error, just generate a warning now since this was deprecated in XML second edition

Check that xml:space conforms to the specification

xmlParseStartTag: @ctxt: an XML parser context parse a start of tag either for rule element or EmptyElement. In both case we don't parse the tag closing chars. [40] STag ::= '<' Name (S Attribute) S? '>' [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag. [44] EmptyElemTag ::= '<' Name (S Attribute) S? '/>' [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag. With namespace: [NS 8] STag ::= '<' QName (S Attribute) S? '>' [NS 10] EmptyElement ::= '<' QName (S Attribute) S? '/>' Returns the element name parsed

Now parse the attributes, it ends up with the ending (S Attribute) S?

[ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag.

Add the pair to atts

allow for 10 attrs by default

SAX: Start of Element !

Free only the content strings

xmlParseEndTag1: @ctxt: an XML parser context @line: line of the start tag @nsNr: number of namespaces on the start tag parse an end of tag [42] ETag ::= '</' Name S? '>' With namespace [NS 9] ETag ::= '</' QName S? '>'

We should definitely be at the ending "S? '>'" part

[ WFC: Element Type Match ] The Name in an element's end-tag must match the element type in the start-tag.

SAX: End of Tag

xmlParseEndTag: @ctxt: an XML parser context parse an end of tag [42] ETag ::= '</' Name S? '>' With namespace [NS 9] ETag ::= '</' QName S? '>'

LIBXML_SAX1_ENABLED

SAX 2 specific operations

xmlGetNamespace: @ctxt: an XML parser context @prefix: the prefix to lookup Lookup the namespace name for the @prefix (which ca be NULL) The prefix must come from the @ctxt->dict dictionnary Returns the namespace name or NULL if not bound

xmlParseQName: @ctxt: an XML parser context @prefix: pointer to store the prefix part parse an XML Namespace QName [6] QName ::= (Prefix ':')? LocalPart [7] Prefix ::= NCName [8] LocalPart ::= NCName Returns the Name parsed or NULL

xmlParseQNameAndCompare: @ctxt: an XML parser context @name: the localname @prefix: the prefix, if any. parse an XML name and compares for match (specialized for endtag parsing) Returns NULL for an illegal name, (xmlChar) 1 for success and the name for mismatch

success

all strings coms from the dictionary, equality can be done directly

xmlParseAttValueInternal: @ctxt: an XML parser context @len: attribute len result @alloc: whether the attribute was reallocated as a new string @normalize: if 1 then further non-CDATA normalization must be done parse a value for an attribute. NOTE: if no normalization is needed, the routine will return pointers directly from the data buffer. 3.3.3 Attribute-Value Normalization: Before the value of an attribute is passed to the application or checked for validity, the XML processor must normalize it as follows: - a character reference is processed by appending the referenced character to the attribute value - an entity reference is processed by recursively processing the replacement text of the entity - a whitespace character (#x20, #xD, #xA, #x9) is processed by appending #x20 to the normalized value, except that only a single #x20 is appended for a "#xD#xA" sequence that is part of an external parsed entity or the literal entity value of an internal parsed entity - other characters are processed by appending them to the normalized value If the declared value is not CDATA, then the XML processor must further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character. All attributes for which no declaration has been read should be treated by a non-validating parser as if declared CDATA. Returns the AttValue parsed or NULL. The value has to be freed by the caller if it was copied, this can be detected by val[len] == 0.

try to handle in this routine the most common case where no allocation of a new string is required and where content is pure ASCII.

Skip any leading spaces

skip the trailing blanks

xmlParseAttribute2: @ctxt: an XML parser context @pref: the element prefix @elem: the element name @prefix: a xmlChar used to store the value of the attribute prefix @value: a xmlChar used to store the value of the attribute @len: an int to save the length of the attribute @alloc: an int to indicate if the attribute was allocated parse an attribute in the new SAX2 framework. Returns the attribute name, and the value in value, .

get the type if needed

read the value

Sometimes a second normalisation pass for spaces is needed but that only happens if charrefs or entities refernces have been used in the attribute value, i.e. the attribute value have been extracted in an allocated string already.

Check that xml:lang conforms to the specification No more registered as an error, just generate a warning now since this was deprecated in XML second edition

Check that xml:space conforms to the specification

xmlParseStartTag2: @ctxt: an XML parser context parse a start of tag either for rule element or EmptyElement. In both case we don't parse the tag closing chars. This routine is called when running SAX2 parsing [40] STag ::= '<' Name (S Attribute) S? '>' [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag. [44] EmptyElemTag ::= '<' Name (S Attribute) S? '/>' [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag. With namespace: [NS 8] STag ::= '<' QName (S Attribute) S? '>' [NS 10] EmptyElement ::= '<' QName (S Attribute) S? '/>' Returns the element name parsed

NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that point since the attribute values may be stored as pointers to the buffer and calling SHRINK would destroy them ! The Shrinking is only possible once the full set of attribute callbacks have been done.

Forget any namespaces added during an earlier parse of this element.

Now parse the attributes, it ends up with the ending (S Attribute) S?

check that it's not a defined namespace

Do not keep a namespace definition node

check that it's not a defined namespace

Add the pair to atts

the URI will be fetched later

tag if some deallocation is needed

The attributes defaulting

special work for namespaces defaulted defs

check that it's not a defined namespace

check that it's not a defined namespace

check that it's not a defined attribute

The attributes checkings

The default namespace does not apply to attribute names.

[ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag. As extended by the Namespace in XML REC.

SAX: Start of Element !

Free up attribute allocated strings if needed

the attribute strings are valid iif the base didn't changed

xmlParseEndTag2: @ctxt: an XML parser context @line: line of the start tag @nsNr: number of namespaces on the start tag parse an end of tag [42] ETag ::= '</' Name S? '>' With namespace [NS 9] ETag ::= '</' QName S? '>'

We should definitely be at the ending "S? '>'" part

[ WFC: Element Type Match ] The Name in an element's end-tag must match the element type in the start-tag.

SAX: End of Tag

xmlParseCDSect: @ctxt: an XML parser context Parse escaped pure raw content. [18] CDSect ::= CDStart CData CDEnd [19] CDStart ::= '<![CDATA[' [20] Data ::= (Char - (Char ']]>' Char)) [21] CDEnd ::= ']]>'

Check 2.6.0 was NXT(0) not RAW

OK the buffer is to be consumed as cdata.

xmlParseContent: @ctxt: an XML parser context Parse a content: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)

First case : a Processing Instruction.

Second case : a CDSection

2.6.0 test was cur not RAW

Third case : a comment

Fourth case : a sub-element.

Fifth case : a reference. If if has not been resolved, parsing returns it's Name, create the node

Last case, text. Note that References are handled directly.

Pop-up of finished entities.

xmlParseElement: @ctxt: an XML parser context parse an XML element, this is highly recursive [39] element ::= EmptyElemTag | STag content ETag [ WFC: Element Type Match ] The Name in an element's end-tag must match the element type in the start-tag.

Capture start position

LIBXML_SAX1_ENABLED

LIBXML_SAX1_ENABLED

[ VC: Root Element Type ] The Name in the document type declaration must match the element type of the root element.

LIBXML_VALID_ENABLED

Check for an Empty Element.

LIBXML_SAX1_ENABLED

end of parsing of this node.

Capture end position and add node

Parse the content of the element:

end of parsing of this node.

parse the end of tag: '</' should be here.

LIBXML_SAX1_ENABLED

Capture end position and add node

xmlParseVersionNum: @ctxt: an XML parser context parse the XML version value. [26] VersionNum ::= '1.' [0-9]+ In practice allow [0-9].[0-9]+ at that level Returns the string giving the XML version number, or NULL

xmlParseVersionInfo: @ctxt: an XML parser context parse the XML version. [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ") [25] Eq ::= S? '=' S? Returns the version string, e.g. "1.0"

xmlParseEncName: @ctxt: an XML parser context parse the XML encoding name [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-') Returns the encoding name value or NULL

xmlParseEncodingDecl: @ctxt: an XML parser context parse the XML encoding declaration [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'") this setups the conversion filters. Returns the encoding value or NULL

UTF-16 encoding stwich has already taken place at this stage, more over the little-endian/big-endian selection is already done

If no encoding was passed to the parser, that we are using UTF-16 and no decoder is present i.e. the document is apparently UTF-8 compatible, then raise an encoding mismatch fatal error

UTF-8 encoding is handled natively

xmlParseSDDecl: @ctxt: an XML parser context parse the XML standalone declaration [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no')'"')) [ VC: Standalone Document Declaration ] TODO The standalone document declaration must have the value "no" if any external markup declarations contain declarations of: - attributes with default values, if elements to which these attributes apply appear in the document without specifications of values for these attributes, or - entities (other than amp, lt, gt, apos, quot), if references to those entities appear in the document, or - attributes with values subject to normalization, where the attribute appears in the document with a value which will change as a result of normalization, or - element types with element content, if white space occurs directly within any instance of those types. Returns: 1 if standalone="yes" 0 if standalone="no" -2 if standalone attribute is missing or invalid (A standalone value of -2 means that the XML declaration was found, but no value was specified for the standalone attribute).

xmlParseXMLDecl: @ctxt: an XML parser context parse an XML declaration header [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'

This value for standalone indicates that the document has an XML declaration but it does not have a standalone attribute. It will be overwritten later if a standalone attribute is found.

We know that '<?xml' is here.

We must have the VersionInfo here.

Changed here for XML-1.0 5th edition

We may have the encoding declaration

The XML REC instructs us to stop parsing right here

We may have the standalone status.

We can grow the input buffer freely at that point

Deprecated old WD ...

xmlParseMisc: @ctxt: an XML parser context parse an XML Misc optional field. [27] Misc ::= Comment | PI | S

xmlParseDocument: @ctxt: an XML parser context parse an XML document (and build a tree if using the standard SAX interface). [1] document ::= prolog element Misc [22] prolog ::= XMLDecl? Misc (doctypedecl Misc)? Returns 0, -1 in case of error. the parser context is augmented as a result of the parsing.

SAX: detecting the level.

SAX: beginning of the document processing.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

Check for the XMLDecl in the Prolog. do not GROW here to avoid the detected encoder to decode more than just the first line

Note that we will switch encoding on the fly.

The XML REC instructs us to stop parsing right here

The Misc part of the Prolog

Then possibly doc type declaration(s) and more Misc (doctypedecl Misc)?

Create and update the external subset.

Time to start parsing the tree itself

The Misc part at the end

SAX: end of the document processing.

Remove locally kept entity definitions if the tree was not built

xmlParseExtParsedEnt: @ctxt: an XML parser context parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content Returns 0, -1 in case of error. the parser context is augmented as a result of the parsing.

SAX: beginning of the document processing.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

Check for the XMLDecl in the Prolog.

Note that we will switch encoding on the fly.

The XML REC instructs us to stop parsing right here

Doing validity checking on chunk doesn't make sense

SAX: end of the document processing.

Progressive parsing interfaces

xmlParseLookupSequence: @ctxt: an XML parser context @first: the first char to lookup @next: the next char to lookup or zero @third: the next char to lookup or zero Try to find if a sequence (first, next, third) or just (first next) or (first) is available in the input stream. This function has a side effect of (possibly) incrementing ctxt->checkIndex to avoid rescanning sequences of bytes, it DOES change the state of the parser, do not use liberally. Returns the index to the current parsing point if the full sequence is available, -1 otherwise.

take into account the sequence length

xmlParseGetLasts: @ctxt: an XML parser context @lastlt: pointer to store the last '<' from the input @lastgt: pointer to store the last '>' from the input Lookup the last < and > in the current chunk

xmlCheckCdataPush: @cur: pointer to the bock of characters @len: length of the block in bytes Check that the block of characters is okay as SCdata content [20] Returns the number of bytes to pass if okay, a negative index where an UTF-8 error occured otherwise

string is 0-terminated

1-byte code, starts with 10

2-byte code, starts with 110

3-byte code, starts with 1110

4-byte code, starts with 11110

unknown encoding

xmlParseTryOrFinish: @ctxt: an XML parser context @terminate: last chunk indicator Try to progress on parsing Returns zero if no parsing was possible

Pop-up of finished entities.

If we are operating on converted input, try to flush remainng chars to avoid them stalling in the non-converted buffer.

Document parsing is done !

Very first chars read from the document flow.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines, else xmlSwitchEncoding will set to (default) UTF8.

PI or XML decl

The XML REC instructs us to stop parsing right here

> can be found unescaped in attribute values

LIBXML_SAX1_ENABLED

LIBXML_SAX1_ENABLED

[ VC: Root Element Type ] The Name in the document type declaration must match the element type of the root element.

LIBXML_VALID_ENABLED

Check for an Empty Element.

LIBXML_SAX1_ENABLED

LIBXML_SAX1_ENABLED

TODO Avoid the extra copy, handle directly !!!

Goal of the following test is: - minimize calls to the SAX 'character' callback when they are mergeable - handle an problem for isBlank when we only parse a sequence of blank chars and the next one is not available to check against '<' presence. - tries to homogenize the differences in SAX callbacks between the push and pull versions of the parser.

Pop-up of finished entities.

> can be found unescaped in attribute values

LIBXML_SAX1_ENABLED

The Push mode need to have the SAX callback for cdataBlock merge back contiguous callbacks.

Special case to provide identical behaviour between pull and push parsers on enpty CDATA sections

Create and update the external subset.

Sorry but progressive parsing of the internal subset is not expected to be supported. We first check that the full content of the internal subset is available and the parsing is launched only at that point. Internal subset ends up with "']' S? '>'" in an unescaped section and not in a ']]>' sequence which are conditional sections (whoever argued to keep that crap in XML deserve a place in hell !).

special handling of comments

for

conditional crap, skip both ']' !

for

We didn't found the end of the Internal subset

xmlParseChunk: @ctxt: an XML parser context @chunk: an char array @size: the size in byte of the chunk @terminate: last chunk indicator Parse a Chunk of memory Returns zero if no error, the xmlParserErrors otherwise.

Specific handling if we autodetected an encoding, we should not push more than the first line ... which depend on the encoding And only push the rest once the final encoding was detected

TODO 2.6.0

Check for termination

I/O front end functions to the parser

xmlCreatePushParserCtxt: @sax: a SAX handler @user_data: The user data returned on SAX callbacks @chunk: a pointer to an array of chars @size: number of chars in the array @filename: an optional file name or URI Create a parser context for using the XML parser in push mode. If @buffer and @size are non-NULL, the data is used to detect the encoding. The remaining characters will be parsed so they don't need to be fed in again through xmlParseChunk. To allow content encoding detection, @size should be >= 4 The value of @filename is used for fetching external entities and error/warning reports. Returns the new parser context or NULL

plug some encoding conversion routines

LIBXML_SAX1_ENABLED

If the caller didn't provide an initial 'chunk' for determining the encoding, we set the context to XML_CHAR_ENCODING_NONE so that it can be automatically determined later

LIBXML_PUSH_ENABLED

xmlStopParser: @ctxt: an XML parser context Blocks further parser processing

xmlCreateIOParserCtxt: @sax: a SAX handler @user_data: The user data returned on SAX callbacks @ioread: an I/O read function @ioclose: an I/O close function @ioctx: an I/O handler @enc: the charset encoding if known Create a parser context for using the XML parser with an existing I/O stream Returns the new parser context or NULL

LIBXML_SAX1_ENABLED

Front ends when parsing a DTD

xmlIOParseDTD: @sax: the SAX handler block or NULL @input: an Input Buffer @enc: the charset encoding if known Load and parse a DTD Returns the resulting xmlDtdPtr or NULL in case of error. @input will be freed by the function in any case.

Set-up the SAX context

generate a parser input from the I/O handler

plug some encoding conversion routines here.

let's parse that entity knowing it's an external subset.

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

xmlSAXParseDTD: @sax: the SAX handler block @ExternalID: a NAME containing the External ID of the DTD @SystemID: a NAME containing the URL to the DTD Load and parse an external subset. Returns the resulting xmlDtdPtr or NULL in case of error.

Set-up the SAX context

Canonicalise the system ID

Ask the Entity resolver to load the damn thing

plug some encoding conversion routines here.

let's parse that entity knowing it's an external subset.

xmlParseDTD: @ExternalID: a NAME containing the External ID of the DTD @SystemID: a NAME containing the URL to the DTD Load and parse an external subset. Returns the resulting xmlDtdPtr or NULL in case of error.

LIBXML_VALID_ENABLED

Front ends when parsing an Entity

xmlParseCtxtExternalEntity: @ctx: the existing parsing context @URL: the URL for the entity to load @ID: the System ID for the entity to load @lst: the return value for the set of parsed nodes Parse an external general entity within an existing parsing context An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content Returns 0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise

@@ relax but check for dereferences

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

Parse a possible text declaration first

An XML-1.0 document can't reference an entity not XML-1.0

Doing validity checking on chunk doesn't make sense

Return the newly created nodeset after unlinking it from they pseudo parent.

xmlParseExternalEntityPrivate: @doc: the document the chunk pertains to @oldctxt: the previous parser context if available @sax: the SAX handler bloc (possibly NULL) @user_data: The user data returned on SAX callbacks (possibly NULL) @depth: Used for loop detection, use 0 @URL: the URL for the entity to load @ID: the System ID for the entity to load @list: the return value for the set of parsed nodes Private version of xmlParseExternalEntity() Returns 0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise

Doing validity checking on chunk without context doesn't make sense

Get the 4 first bytes and decode the charset if enc != XML_CHAR_ENCODING_NONE plug some encoding conversion routines.

Parse a possible text declaration first

Return the newly created nodeset after unlinking it from they pseudo parent.

Record in the parent context the number of entities replacement done when parsing that reference.

Also record the size of the entity parsed

And record the last error if any

xmlParseExternalEntity: @doc: the document the chunk pertains to @sax: the SAX handler bloc (possibly NULL) @user_data: The user data returned on SAX callbacks (possibly NULL) @depth: Used for loop detection, use 0 @URL: the URL for the entity to load @ID: the System ID for the entity to load @lst: the return value for the set of parsed nodes Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content Returns 0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise

xmlParseBalancedChunkMemory: @doc: the document the chunk pertains to @sax: the SAX handler bloc (possibly NULL) @user_data: The user data returned on SAX callbacks (possibly NULL) @depth: Used for loop detection, use 0 @string: the input string in UTF8 or ISO-Latin (zero terminated) @lst: the return value for the set of parsed nodes Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment) Returns 0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise

LIBXML_SAX1_ENABLED

xmlParseBalancedChunkMemoryInternal: @oldctxt: the existing parsing context @string: the input string in UTF8 or ISO-Latin (zero terminated) @user_data: the user data field for the parser context @lst: the return value for the set of parsed nodes Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment) Returns XML_ERR_OK if the chunk is well balanced, and the parser error code otherwise In case recover is set to 1, the nodelist will not be empty even if the parsed chunk is not well balanced.

propagate namespaces down the entity

ID/IDREF registration will be done in xmlValidateElement below

Return the newly created nodeset after unlinking it from they pseudo parent.

LIBXML_VALID_ENABLED

Record in the parent context the number of entities replacement done when parsing that reference.

Also record the last error if any

xmlParseInNodeContext: @node: the context node @data: the input string @datalen: the input string length in bytes @options: a combination of xmlParserOption @lst: the return value for the set of parsed nodes Parse a well-balanced chunk of an XML document within the context (DTD, namespaces, etc ...) of the given node. The allowed sequence for the data is a Well Balanced Chunk defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment) Returns XML_ERR_OK if the chunk is well balanced, and the parser error code otherwise

check all input parameters, grab the document

allocate a context and set-up everything not related to the node position in the tree

Use input doc's dict if present, else assure XML_PARSE_NODICT is set. We need a dictionary for xmlDetectSAX2, so if there's no doc dict we must wait until the last moment to free the original one.

initialize the SAX2 namespaces stack

ID/IDREF registration will be done in xmlValidateElement below

Return the newly created nodeset after unlinking it from the pseudo sibling.

!SAX2

xmlParseBalancedChunkMemoryRecover: @doc: the document the chunk pertains to @sax: the SAX handler bloc (possibly NULL) @user_data: The user data returned on SAX callbacks (possibly NULL) @depth: Used for loop detection, use 0 @string: the input string in UTF8 or ISO-Latin (zero terminated) @lst: the return value for the set of parsed nodes @recover: return nodes even if the data is broken (use 0) Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment) Returns 0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise In case recover is set to 1, the nodelist will not be empty even if the parsed chunk is not well balanced, assuming the parsing succeeded to some extent.

Ensure that doc has XML spec namespace

Doing validity checking on chunk doesn't make sense

Return the newly created nodeset after unlinking it from they pseudo parent.

xmlSAXParseEntity: @sax: the SAX handler block @filename: the filename parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. [78] extParsedEnt ::= TextDecl? content This correspond to a "Well Balanced" chunk Returns the resulting document tree

xmlParseEntity: @filename: the filename parse an XML external entity out of context and build a tree. [78] extParsedEnt ::= TextDecl? content This correspond to a "Well Balanced" chunk Returns the resulting document tree

LIBXML_SAX1_ENABLED

xmlCreateEntityParserCtxtInternal: @URL: the entity URL @ID: the entity PUBLIC ID @base: a possible base for the target URI @pctx: parser context used to set options on new context Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the new parser context or NULL

xmlCreateEntityParserCtxt: @URL: the entity URL @ID: the entity PUBLIC ID @base: a possible base for the target URI Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the new parser context or NULL

Front ends when parsing from a file

xmlCreateURLParserCtxt: @filename: the filename or URL @options: a combination of xmlParserOption Create a parser context for a file or URL content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time and for file accesses Returns the new parser context or NULL

xmlCreateFileParserCtxt: @filename: the filename Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the new parser context or NULL

xmlSAXParseFileWithData: @sax: the SAX handler block @filename: the filename @recovery: work in recovery mode, i.e. tries to read no Well Formed documents @data: the userdata parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void ) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml Returns the resulting document tree

xmlSAXParseFile: @sax: the SAX handler block @filename: the filename @recovery: work in recovery mode, i.e. tries to read no Well Formed documents parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. Returns the resulting document tree

xmlRecoverDoc: @cur: a pointer to an array of xmlChar parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a attempt to build a tree is tried anyway Returns the resulting document tree or NULL in case of failure

xmlParseFile: @filename: the filename parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Returns the resulting document tree if the file was wellformed, NULL otherwise.

xmlRecoverFile: @filename: the filename parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, it attempts to build a tree anyway Returns the resulting document tree or NULL in case of failure

xmlSetupParserForBuffer: @ctxt: an XML parser context @buffer: a xmlChar buffer @filename: a file name Setup the parser context to parse a new buffer; Clears any prior contents from the parser context. The buffer parameter must not be NULL, but the filename parameter can be

xmlSAXUserParseFile: @sax: a SAX handler @user_data: The user data returned on SAX callbacks @filename: a file name parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided Returns 0 in case of success or a error number otherwise

LIBXML_SAX1_ENABLED

Front ends when parsing from memory

xmlCreateMemoryParserCtxt: @buffer: a pointer to a char array @size: the size of the array Create a parser context for an XML in-memory document. Returns the new parser context or NULL

TODO: xmlParserInputBufferCreateStatic, requires some serious changes

xmlSAXParseMemoryWithData: @sax: the SAX handler block @buffer: an pointer to a char array @size: the size of the array @recovery: work in recovery mode, i.e. tries to read no Well Formed documents @data: the userdata parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void ) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml Returns the resulting document tree

xmlSAXParseMemory: @sax: the SAX handler block @buffer: an pointer to a char array @size: the size of the array @recovery: work in recovery mode, i.e. tries to read not Well Formed documents parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. Returns the resulting document tree

xmlParseMemory: @buffer: an pointer to a char array @size: the size of the array parse an XML in-memory block and build a tree. Returns the resulting document tree

xmlRecoverMemory: @buffer: an pointer to a char array @size: the size of the array parse an XML in-memory block and build a tree. In the case the document is not Well Formed, an attempt to build a tree is tried anyway Returns the resulting document tree or NULL in case of error

xmlSAXUserParseMemory: @sax: a SAX handler @user_data: The user data returned on SAX callbacks @buffer: an in-memory XML document input @size: the length of the XML document in bytes A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines. Returns 0 in case of success or a error number otherwise

LIBXML_SAX1_ENABLED

xmlCreateDocParserCtxt: @cur: a pointer to an array of xmlChar Creates a parser context for an XML in-memory document. Returns the new parser context or NULL

xmlSAXParseDoc: @sax: the SAX handler block @cur: a pointer to an array of xmlChar @recovery: work in recovery mode, i.e. tries to read no Well Formed documents parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. Returns the resulting document tree

xmlParseDoc: @cur: a pointer to an array of xmlChar parse an XML in-memory document and build a tree. Returns the resulting document tree

LIBXML_SAX1_ENABLED

Specific function to keep track of entities references and used by the XSLT debugger

xmlAddEntityReference: @ent : A valid entity @firstNode : A valid first node for children of entity @lastNode : A valid last node of children entity Notify of a reference to an entity of type XML_EXTERNAL_GENERAL_PARSED_ENTITY

xmlSetEntityReferenceFunc: @func: A valid function Set the function to call call back when a xml reference has been made

LIBXML_LEGACY_ENABLED

Miscellaneous

xmlInitParser: Initialization function for the XML parser. This is not reentrant. Call once before processing in case of use in multithreaded programs.

LIBXML_OUTPUT_ENABLED

xmlCleanupParser: This function name is somewhat misleading. It does not clean up parser state, it cleans up memory allocated by the library itself. It is a cleanup function for the XML library. It tries to reclaim all related global memory allocated for the library processing. It doesn't deallocate any document related memory. One should call xmlCleanupParser() only when the process has finished using the library and all XML/HTML documents built with it. See also xmlInitParser() which has the opposite function of preparing the library for operations. WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It's sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !

must be last if called not from the main thread

New set (2.6.0) of simpler and more flexible APIs

DICT_FREE: @str: a string Free a string if it is not owned by the "dict" dictionnary in the current scope

xmlCtxtReset: @ctxt: an XML parser context Reset a parser context

Non consuming

xmlCtxtResetPush: @ctxt: an XML parser context @chunk: a pointer to an array of chars @size: number of chars in the array @filename: an optional file name or URI @encoding: the document encoding, or NULL Reset a push parser context Returns 0 in case of success and 1 in case of error

xmlCtxtUseOptionsInternal: @ctxt: an XML parser context @options: a combination of xmlParserOption @encoding: the user provided encoding to use Applies the options to the parser context Returns 0 in case of success, the set of unknown or unimplemented options in case of error.

ctxt->loadsubset |= XML_DETECT_IDS;

LIBXML_SAX1_ENABLED

xmlCtxtUseOptions: @ctxt: an XML parser context @options: a combination of xmlParserOption Applies the options to the parser context Returns 0 in case of success, the set of unknown or unimplemented options in case of error.

xmlDoRead: @ctxt: an XML parser context @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption @reuse: keep the context for reuse Common front-end for the xmlRead functions Returns the resulting document tree or NULL

xmlReadDoc: @cur: a pointer to a zero terminated string @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML in-memory document and build a tree. Returns the resulting document tree

xmlReadFile: @filename: a file or URL @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML file from the filesystem or the network. Returns the resulting document tree

xmlReadMemory: @buffer: a pointer to a char array @size: the size of the array @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML in-memory document and build a tree. Returns the resulting document tree

xmlReadFd: @fd: an open file descriptor @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML from a file descriptor and build a tree. NOTE that the file descriptor will not be closed when the reader is closed or reset. Returns the resulting document tree

xmlReadIO: @ioread: an I/O read function @ioclose: an I/O close function @ioctx: an I/O handler @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML document from I/O functions and source and build a tree. Returns the resulting document tree

xmlCtxtReadDoc: @ctxt: an XML parser context @cur: a pointer to a zero terminated string @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

xmlCtxtReadFile: @ctxt: an XML parser context @filename: a file or URL @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML file from the filesystem or the network. This reuses the existing @ctxt parser context Returns the resulting document tree

xmlCtxtReadMemory: @ctxt: an XML parser context @buffer: a pointer to a char array @size: the size of the array @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

xmlCtxtReadFd: @ctxt: an XML parser context @fd: an open file descriptor @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML from a file descriptor and build a tree. This reuses the existing @ctxt parser context NOTE that the file descriptor will not be closed when the reader is closed or reset. Returns the resulting document tree

xmlCtxtReadIO: @ctxt: an XML parser context @ioread: an I/O read function @ioclose: an I/O close function @ioctx: an I/O handler @URL: the base URL to use for the document @encoding: the document encoding, or NULL @options: a combination of xmlParserOption parse an XML document from I/O functions and source and build a tree. This reuses the existing @ctxt parser context Returns the resulting document tree

www.w3.org/TR/REC-xml

www.w3.org/TR/1998/REC-xml-19980210

www.w3.org/TR/2000/WD-xml-2e-20000814

www.w3.org/TR/REC-xml#entproc

www.w3.org/TR/REC-xml#as-PE

www.w3.org/TR/WD-xml-names *

www.w3.org/TR/REC-xml *

example.com/catalog.xml"?>

www.w3.org/TR/REC-xml#as-PE

www.w3.org/TR/REC-xml/#inliteral processing of entities references

www.w3.org/2000/xmlns/"))) {

www.w3.org/2000/xmlns/"))) {

libxml.h

\\

/

SAX compatibility mode document

xml-stylesheet

Attribute %s redefined\n

Attribute %s:%s redefined\n

CharRef: invalid hexadecimal value\n

CharRef: invalid decimal value\n

CharRef: invalid value\n

internal error

PEReference at end of document\n

PEReference in prolog\n

PEReference in epilog\n

PEReference: no name\n

PEReference: expecting ';'\n

Detected an entity reference loop\n

EntityValue: \" or ' expected\n

PEReferences forbidden in internal subset\n

EntityValue: \" or ' expected\n

AttValue: \" or ' expected\n

Unescaped '<' not allowed in attributes values\n

SystemLiteral \" or ' expected\n

Unfinished System or Public ID \" or ' expected\n

Sequence ']]>' not allowed in content\n

SYSTEM or PUBLIC, the URI is missing\n

PUBLIC, the Public Identifier is missing\n

Comment must not contain '--' (double-hyphen)\n

xmlParsePI : no target name\n

Invalid PI name\n

NOTATION: Name expected here\n

'>' required to close NOTATION declaration\n

Entity value required\n

Fragment not allowed

'(' required to start ATTLIST enumeration\n

NmToken expected in ATTLIST enumeration\n

')' required to finish ATTLIST enumeration\n

MixedContentDecl : '|' or ')*' expected\n

MixedContentDecl : '#PCDATA' expected\n

ContentDecl : Name or '(' expected\n

ContentDecl : ',' '|' or ')' expected\n

PEReference: forbidden within markup decl in internal subset\n

expected '>'\n

XML conditional section '[' expected\n

Content error in the external subset\n

conditional section INCLUDE or IGNORE keyword expected\n

XML conditional section not closed\n

Text declaration '<?xml' required\n

parsing XML declaration: '?>' expected\n

external parsed entities cannot be standalone\n

EntityRef: expecting ';'\n

DOCTYPE improperly terminated\n

EndTag: '</' not found\n

expected '='\n

String not closed expecting \" or '\n

String not started expecting ' or \"\n

Invalid XML encoding name\n

standalone accepts only 'yes' or 'no'\n

Document is empty\n

Extra content at the end of the document\n

chunk is not well balanced\n

extra content at the end of well balanced chunk\n

Malformed declaration expecting version\n

\n

Unregistered error message\n

%s

xml

xmlns

t need * to preserve dst (and it doesn

external

-

i

I

-

x

X

-

i

-

I

-

A

Z

a

z

x

-

X

-

A

Z

a

z

A

Z

a

z

A

Z

a

z

-

A

Z

a

z

A

Z

a

z

Pbm popping %d NS\n

Excessive depth in document: %d use XML_PARSE_HUGE option\n

th next xmlChar. Same as CUR is should be used only * to compare on ASCII based substring. * SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined * strings without newlines within the parser. * NEXT1(l) Skip 1 xmlChar, and must also be used only to skip 1 non-newline ASCII * defined char within the parser. * Clean macros, not dependent of an ASCII context, expect UTF-8 encoding * * NEXT Skip to the next character, this does the proper decoding * in UTF-8 mode. It also pop-up unfinished entities on the fly. * NEXTL(l) Skip the current unicode character of l xmlChars long. * CUR_CHAR(l) returns the current unicode character (int), set l * to the number of xmlChars used for the encoding [0-5]. * CUR_SCHAR same but operate on a string instead of the context * COPY_BUF copy the current unicode char to the target buffer, increment * the index * GROW, SHRINK handling of input buffers */ #define RAW (*ctxt->input->cur) #define CUR (*ctxt->input->cur) #define NXT(val) ctxt->input->cur[(val)] #define CUR_PTR ctxt->input->cur #define CMP4( s, c1, c2, c3, c4 ) \ ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \ ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 ) #define CMP5( s, c1, c2, c3, c4, c5 ) \ ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 ) #define CMP6( s, c1, c2, c3, c4, c5, c6 ) \ ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 ) #define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \ ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 ) #define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \ ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 ) #define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \ ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \ ((unsigned char *) s)[ 8 ] == c9 ) #define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \ ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \ ((unsigned char *) s)[ 9 ] == c10 ) #define SKIP(val) do { \ ctxt->nbChars += (val),ctxt->input->cur += (val),ctxt->input->col+=(val); \ if (*ctxt->input->cur ==

) xmlParserHandlePEReference(ctxt); \ if ((*ctxt->input->cur == 0) && \ (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) \ xmlPopInput(ctxt); \ } while (0) #define SKIPL(val) do { \ int skipl; \ for(skipl=0; skipl<val; skipl++) { \ if (*(ctxt->input->cur) ==

) { \ ctxt->input->line++; ctxt->input->col = 1; \ } else ctxt->input->col++; \ ctxt->nbChars++; \ ctxt->input->cur++; \ } \ if (*ctxt->input->cur ==

) xmlParserHandlePEReference(ctxt); \ if ((*ctxt->input->cur == 0) && \ (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) \ xmlPopInput(ctxt); \ } while (0) #define SHRINK if ((ctxt->progressive == 0) && \ (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \ (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \ xmlSHRINK (ctxt); static void xmlSHRINK (xmlParserCtxtPtr ctxt) { xmlParserInputShrink(ctxt->input); if ((*ctxt->input->cur == 0) && (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) xmlPopInput(ctxt); } #define GROW if ((ctxt->progressive == 0) && \ (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)) \ xmlGROW (ctxt); static void xmlGROW (xmlParserCtxtPtr ctxt) { xmlParserInputGrow(ctxt->input, INPUT_CHUNK); if ((*ctxt->input->cur == 0) && (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) xmlPopInput(ctxt); } #define SKIP_BLANKS xmlSkipBlankChars(ctxt) #define NEXT xmlNextChar(ctxt) #define NEXT1 { \ ctxt->input->col++; \ ctxt->input->cur++; \ ctxt->nbChars++; \ if (*ctxt->input->cur == 0) \ xmlParserInputGrow(ctxt->input, INPUT_CHUNK); \ } #define NEXTL(l) do { \ if (*(ctxt->input->cur) ==

) { \ ctxt->input->line++; ctxt->input->col = 1; \ } else ctxt->input->col++; \ ctxt->input->cur += l; \ if (*ctxt->input->cur ==

) xmlParserHandlePEReference(ctxt); \ } while (0) #define CUR_CHAR(l) xmlCurrentChar(ctxt, &l) #define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l) #define COPY_BUF(l,b,i,v) \ if (l == 1) b[i++] = (xmlChar) v; \ else i += xmlCopyCharMultiByte(&b[i],v) /** * xmlSkipBlankChars: * @ctxt: the XML parser context * * skip all blanks character found at that point in the input streams. * It pops up finished entities in the process if allowable at that point. * * Returns the number of space chars skipped */ int xmlSkipBlankChars(xmlParserCtxtPtr ctxt) { int res = 0; /* * It

\n

%

Popping input %d\n

%s(%d):

Pushing input %d : %.30s\n

&#

;

&#x

;

&

#

x

;

0

9

0

a

f

a

A

F

A

;

&

#

;

0

9

0

;

xmlParseCharRef: invalid xmlChar value %d\n

&#

;

&#x

;

&

#

x

;

0

9

0

a

f

a

A

F

A

;

&

#

;

0

9

0

;

xmlParseStringCharRef: invalid xmlChar value %d\n

xmlNewBlanksWrapperInputStream entity\n

new blanks wrapper for entity: %s\n



%

;



%

;

standalone='yes'

standalone='no'

%

t do the * substitution here since we need the literal * entity value to be able to save the internal * subset of the document. * This will be handled by xmlStringDecodeEntities */ return; case XML_PARSER_DTD: /* * [WFC: Well-Formedness Constraint: PEs in Internal Subset] * In the internal DTD subset, parameter-entity references * can occur only where markup declarations can occur, not * within markup declarations. * In that case this is handled in xmlParseMarkupDecl */ if ((ctxt->external == 0) && (ctxt->inputNr == 1)) return; if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0) return; break; case XML_PARSER_IGNORE: return; } NEXT; name = xmlParseName(ctxt); if (xmlParserDebugEntities) xmlGenericError(xmlGenericErrorContext, "PEReference: %s\n", name); if (name == NULL) { xmlFatalErr(ctxt, XML_ERR_PEREF_NO_NAME, NULL); } else { if (RAW ==

) { NEXT; if ((ctxt->sax != NULL) && (ctxt->sax->getParameterEntity != NULL)) entity = ctxt->sax->getParameterEntity(ctxt->userData, name); if (entity == NULL) { /* * [ WFC: Entity Declared ] * In a document without any DTD, a document with only an * internal DTD subset which contains no parameter entity * references, or a document with "standalone=

", ... * ... The declaration of a parameter entity must precede * any reference to it... */ if ((ctxt->standalone == 1) || ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY, "PEReference: %%%s; not found\n", name); } else { /* * [ VC: Entity Declared ] * In a document with an external subset or external * parameter entities with "standalone=

", ... * ... The declaration of a parameter entity must precede * any reference to it... */ if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) { xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY, "PEReference: %%%s; not found\n", name, NULL); } else xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY, "PEReference: %%%s; not found\n", name, NULL); ctxt->valid = 0; } } else if (ctxt->input->free != deallocblankswrapper) { input = xmlNewBlanksWrapperInputStream(ctxt, entity); if (xmlPushInput(ctxt, input) < 0) return; } else { if ((entity->etype == XML_INTERNAL_PARAMETER_ENTITY) || (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY)) { xmlChar start[4]; xmlCharEncoding enc; /* * handle the extra spaces added before and after * c.f. http://www.w3.org/TR/REC-xml#as-PE * this is done independently. */ input = xmlNewEntityInputStream(ctxt, entity); if (xmlPushInput(ctxt, input) < 0) return; /* * Get the 4 first bytes and decode the charset * if enc != XML_CHAR_ENCODING_NONE * plug some encoding conversion routines. * Note that, since we may have some non-UTF8 * encoding (like UTF16, bug 135229), the

* is not known, but we can calculate based upon * the amount of data in the buffer. */ GROW if ((ctxt->input->end - ctxt->input->cur)>=4) { start[0] = RAW; start[1] = NXT(1); start[2] = NXT(2); start[3] = NXT(3); enc = xmlDetectCharEncoding(start, 4); if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } } if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) && (CMP5(CUR_PTR,

,

,

,

,

)) && (IS_BLANK_CH(NXT(5)))) { xmlParseTextDecl(ctxt); } } else { xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER, "PEReference: %s is not a parameter entity\n", name); } } } else { xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL); } } } /* * Macro used to grow the current buffer. */ #define growBuffer(buffer, n) { \ xmlChar *tmp; \ buffer##_size *= 2; \ buffer##_size += n; \ tmp = (xmlChar *) \ xmlRealloc(buffer, buffer##_size * sizeof(xmlChar)); \ if (tmp == NULL) goto mem_error; \ buffer = tmp; \ } /** * xmlStringLenDecodeEntities: * @ctxt: the parser context * @str: the input string * @len: the string length * @what: combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF * @end: an end marker xmlChar, 0 if none * @end2: an end marker xmlChar, 0 if none * @end3: an end marker xmlChar, 0 if none * * Takes a entity string content and process to do the adequate substitutions. * * [67] Reference ::= EntityRef | CharRef * * [69] PEReference ::=

Name

* * Returns A newly allocated string with the substitution done. The caller * must deallocate it ! */ xmlChar * xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len, int what, xmlChar end, xmlChar end2, xmlChar end3) { xmlChar *buffer = NULL; int buffer_size = 0; xmlChar *current = NULL; xmlChar *rep = NULL; const xmlChar *last; xmlEntityPtr ent; int c,l; int nbchars = 0; if ((ctxt == NULL) || (str == NULL) || (len < 0)) return(NULL); last = str + len; if (((ctxt->depth > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) || (ctxt->depth > 1024)) { xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL); return(NULL); } /* * allocate a translation buffer. */ buffer_size = XML_PARSER_BIG_BUFFER_SIZE; buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar)); if (buffer == NULL) goto mem_error; /* * OK loop until we reach one of the ending char or a size limit. * we are operating on already parsed values. */ if (str < last) c = CUR_SCHAR(str, l); else c = 0; while ((c != 0) && (c != end) && /* non input consuming loop */ (c != end2) && (c != end3)) { if (c == 0) break; if ((c ==

) && (str[1] ==

)) { int val = xmlParseStringCharRef(ctxt, &str); if (val != 0) { COPY_BUF(0,buffer,nbchars,val); } if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) { growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } } else if ((c ==

) && (what & XML_SUBSTITUTE_REF)) { if (xmlParserDebugEntities) xmlGenericError(xmlGenericErrorContext, "String decoding Entity Reference: %.30s\n", str); ent = xmlParseStringEntityRef(ctxt, &str); if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) || (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR)) goto int_error; if (ent != NULL) ctxt->nbentities += ent->checked; if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) { if (ent->content != NULL) { COPY_BUF(0,buffer,nbchars,ent->content[0]); if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) { growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } } else { xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR, "predefined entity has no content\n"); } } else if ((ent != NULL) && (ent->content != NULL)) { ctxt->depth++; rep = xmlStringDecodeEntities(ctxt, ent->content, what, 0, 0, 0); ctxt->depth--; if (rep != NULL) { current = rep; while (*current != 0) { /* non input consuming loop */ buffer[nbchars++] = *current++; if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) { if (xmlParserEntityCheck(ctxt, nbchars, ent)) goto int_error; growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } } xmlFree(rep); rep = NULL; } } else if (ent != NULL) { int i = xmlStrlen(ent->name); const xmlChar *cur = ent->name; buffer[nbchars++] =

; if (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) { growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } for (;i > 0;i--) buffer[nbchars++] = *cur++; buffer[nbchars++] =

; } } else if (c ==

&& (what & XML_SUBSTITUTE_PEREF)) { if (xmlParserDebugEntities) xmlGenericError(xmlGenericErrorContext, "String decoding PE Reference: %.30s\n", str); ent = xmlParseStringPEReference(ctxt, &str); if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP) goto int_error; if (ent != NULL) ctxt->nbentities += ent->checked; if (ent != NULL) { if (ent->content == NULL) { xmlLoadEntityContent(ctxt, ent); } ctxt->depth++; rep = xmlStringDecodeEntities(ctxt, ent->content, what, 0, 0, 0); ctxt->depth--; if (rep != NULL) { current = rep; while (*current != 0) { /* non input consuming loop */ buffer[nbchars++] = *current++; if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) { if (xmlParserEntityCheck(ctxt, nbchars, ent)) goto int_error; growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } } xmlFree(rep); rep = NULL; } } } else { COPY_BUF(l,buffer,nbchars,c); str += l; if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) { growBuffer(buffer, XML_PARSER_BUFFER_SIZE); } } if (str < last) c = CUR_SCHAR(str, l); else c = 0; } buffer[nbchars] = 0; return(buffer); mem_error: xmlErrMemory(ctxt, NULL); int_error: if (rep != NULL) xmlFree(rep); if (buffer != NULL) xmlFree(buffer); return(NULL); } /** * xmlStringDecodeEntities: * @ctxt: the parser context * @str: the input string * @what: combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF * @end: an end marker xmlChar, 0 if none * @end2: an end marker xmlChar, 0 if none * @end3: an end marker xmlChar, 0 if none * * Takes a entity string content and process to do the adequate substitutions. * * [67] Reference ::= EntityRef | CharRef * * [69] PEReference ::=

Name

* * Returns A newly allocated string with the substitution done. The caller * must deallocate it ! */ xmlChar * xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what, xmlChar end, xmlChar end2, xmlChar end3) { if ((ctxt == NULL) || (str == NULL)) return(NULL); return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what, end, end2, end3)); } /************************************************************************ * * * Commodity functions, cleanup needed ? * * * ************************************************************************/ /** * areBlanks: * @ctxt: an XML parser context * @str: a xmlChar * * @len: the size of @str * @blank_chars: we know the chars are blanks * * Is this a sequence of blank chars that one can ignore ? * * Returns 1 if ignorable 0 otherwise. */ static int areBlanks(xmlParserCtxtPtr ctxt, const xmlChar *str, int len, int blank_chars) { int i, ret; xmlNodePtr lastChild; /* * Don

<

<

/

:

x

m

l

:

:

:

s ready to pay * for the processing speed. */ max = len * 2; buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar)); if (buffer == NULL) { xmlErrMemory(ctxt, NULL); return(NULL); } memcpy(buffer, buf, len); while ((c != 0) && (c !=

)) { /* tested bigname.xml */ if (len + 10 > max) { xmlChar *tmp; max *= 2; tmp = (xmlChar *) xmlRealloc(buffer, max * sizeof(xmlChar)); if (tmp == NULL) { xmlFree(buffer); xmlErrMemory(ctxt, NULL); return(NULL); } buffer = tmp; } buffer[len++] = c; c = *cur++; } buffer[len] = 0; } if ((c ==

) && (*cur == 0)) { if (buffer != NULL) xmlFree(buffer); *prefix = NULL; return(xmlStrdup(name)); } if (buffer == NULL) ret = xmlStrndup(buf, len); else { ret = buffer; buffer = NULL; max = XML_MAX_NAMELEN; } if (c ==

) { c = *cur; *prefix = ret; if (c == 0) { return(xmlStrndup(BAD_CAST "", 0)); } len = 0; /* * Check that the first character is proper to start * a new name */ if (!(((c >= 0x61) && (c <= 0x7A)) || ((c >= 0x41) && (c <= 0x5A)) || (c ==

) || (c ==

))) { int l; int first = CUR_SCHAR(cur, l); if (!IS_LETTER(first) && (first !=

)) { xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME, "Name %s is not XML Namespace compliant\n", name); } } cur++; while ((c != 0) && (len < max)) { /* tested bigname2.xml */ buf[len++] = c; c = *cur++; } if (len >= max) { /* * Okay someone managed to make a huge name, so he



>

/

a

z

A

Z

_

:

_

:



>

/

a

z

A

Z

0

9

_

:

-

.

.

-

_

:



>

/

a

z

A

Z

_

:



>

/

a

z

A

Z

0

9

_

:

-

.



>

/

_

:



>

/

.

-

_

:

\n

\r

.

-

_

:

_

:

_

:

_

-

:

.



>

/

:



>

/

:

.

-

_

_

_

_

-

.

>

.

-

_

:

_

:

s ready to pay * for the processing speed. */ xmlChar *buffer; int max = len * 2; buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar)); if (buffer == NULL) { xmlErrMemory(ctxt, NULL); return(NULL); } memcpy(buffer, buf, len); while (xmlIsNameChar(ctxt, c)) { if (len + 10 > max) { xmlChar *tmp; max *= 2; tmp = (xmlChar *) xmlRealloc(buffer, max * sizeof(xmlChar)); if (tmp == NULL) { xmlErrMemory(ctxt, NULL); xmlFree(buffer); return(NULL); } buffer = tmp; } COPY_BUF(l,buffer,len,c); cur += l; c = CUR_SCHAR(cur, l); } buffer[len] = 0; *str = cur; return(buffer); } } *str = cur; return(xmlStrndup(buf, len)); } /** * xmlParseNmtoken: * @ctxt: an XML parser context * * parse an XML Nmtoken. * * [7] Nmtoken ::= (NameChar)+ * * [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)* * * Returns the Nmtoken parsed or NULL */ xmlChar * xmlParseNmtoken(xmlParserCtxtPtr ctxt) { xmlChar buf[XML_MAX_NAMELEN + 5]; int len = 0, l; int c; int count = 0; #ifdef DEBUG nbParseNmToken++; #endif GROW; c = CUR_CHAR(l); while (xmlIsNameChar(ctxt, c)) { if (count++ > 100) { count = 0; GROW; } COPY_BUF(l,buf,len,c); NEXTL(l); c = CUR_CHAR(l); if (len >= XML_MAX_NAMELEN) { /* * Okay someone managed to make a huge token, so he

"

] | PEReference | Reference)* '

| * "

([^%&'] | PEReference | Reference)*

" * * Returns the EntityValue parsed with reference substituted or NULL */ xmlChar * xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) { xmlChar *buf = NULL; int len = 0; int size = XML_PARSER_BUFFER_SIZE; int c, l; xmlChar stop; xmlChar *ret = NULL; const xmlChar *cur = NULL; xmlParserInputPtr input; if (RAW ==

') stop = '

; else if (RAW ==



\'

&

%

%

&

#

;

EntityValue: '%c' forbidden except for entities references\n

%

"

"

\'

\'

<

&

#

&

&

&

#

3

8

;

&

&

#

3

8

;

&

;

<

invalid character in attribute value\n

AttValue: ' expected\n

t do substitution of entities here, this * will be handled later in xmlStringGetNodeList * * [10] AttValue ::=

' ([^<&

"

'

] | Reference)* "

* * 3.3.3 Attribute-Value Normalization: * Before the value of an attribute is passed to the application or * checked for validity, the XML processor must normalize it as follows: * - a character reference is processed by appending the referenced * character to the attribute value * - an entity reference is processed by recursively processing the * replacement text of the entity * - a whitespace character (#x20, #xD, #xA, #x9) is processed by * appending #x20 to the normalized value, except that only a single * #x20 is appended for a

sequence that is part of an external * parsed entity or the literal entity value of an internal parsed entity * - other characters are processed by appending them to the normalized value * If the declared value is not CDATA, then the XML processor must further * process the normalized attribute value by discarding any leading and * trailing space (#x20) characters, and by replacing sequences of space * (#x20) characters by a single space (#x20) character. * All attributes for which no declaration has been read should be treated * by a non-validating parser as if declared CDATA. * * Returns the AttValue parsed or NULL. The value has to be freed by the caller. */ xmlChar * xmlParseAttValue(xmlParserCtxtPtr ctxt) { if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL); return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0)); } /** * xmlParseSystemLiteral: * @ctxt: an XML parser context * * parse an XML Literal * * [11] SystemLiteral ::= ('

[^"]*

') | (

" [^

'

"

"

\'

\'

"

"

'

'

'

"

"

\'

\'

]]>

&gt;

&gt;

]]>

]]>

t need to be * modified before passing it to the handler. */ if (!cdata) { in = ctxt->input->cur; do { get_more_space: while (*in == 0x20) { in++; ctxt->input->col++; } if (*in == 0xA) { do { ctxt->input->line++; ctxt->input->col = 1; in++; } while (*in == 0xA); goto get_more_space; } if (*in ==

) { nbchar = in - ctxt->input->cur; if (nbchar > 0) { const xmlChar *tmp = ctxt->input->cur; ctxt->input->cur = in; if ((ctxt->sax != NULL) && (ctxt->sax->ignorableWhitespace != ctxt->sax->characters)) { if (areBlanks(ctxt, tmp, nbchar, 1)) { if (ctxt->sax->ignorableWhitespace != NULL) ctxt->sax->ignorableWhitespace(ctxt->userData, tmp, nbchar); } else { if (ctxt->sax->characters != NULL) ctxt->sax->characters(ctxt->userData, tmp, nbchar); if (*ctxt->space == -1) *ctxt->space = -2; } } else if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL)) { ctxt->sax->characters(ctxt->userData, tmp, nbchar); } } return; } get_more: ccol = ctxt->input->col; while (test_char_data[*in]) { in++; ccol++; } ctxt->input->col = ccol; if (*in == 0xA) { do { ctxt->input->line++; ctxt->input->col = 1; in++; } while (*in == 0xA); goto get_more; } if (*in ==

) { if ((in[1] ==

) && (in[2] ==

)) { xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL); ctxt->input->cur = in; return; } in++; ctxt->input->col++; goto get_more; } nbchar = in - ctxt->input->cur; if (nbchar > 0) { if ((ctxt->sax != NULL) && (ctxt->sax->ignorableWhitespace != ctxt->sax->characters) && (IS_BLANK_CH(*ctxt->input->cur))) { const xmlChar *tmp = ctxt->input->cur; ctxt->input->cur = in; if (areBlanks(ctxt, tmp, nbchar, 0)) { if (ctxt->sax->ignorableWhitespace != NULL) ctxt->sax->ignorableWhitespace(ctxt->userData, tmp, nbchar); } else { if (ctxt->sax->characters != NULL) ctxt->sax->characters(ctxt->userData, tmp, nbchar); if (*ctxt->space == -1) *ctxt->space = -2; } line = ctxt->input->line; col = ctxt->input->col; } else if (ctxt->sax != NULL) { if (ctxt->sax->characters != NULL) ctxt->sax->characters(ctxt->userData, ctxt->input->cur, nbchar); line = ctxt->input->line; col = ctxt->input->col; } /* something really bad happened in the SAX callback */ if (ctxt->instate != XML_PARSER_CONTENT) return; } ctxt->input->cur = in; if (*in == 0xD) { in++; if (*in == 0xA) { ctxt->input->cur = in; in++; ctxt->input->line++; ctxt->input->col = 1; continue; /* while */ } in--; } if (*in ==

) { return; } if (*in ==

) { return; } SHRINK; GROW; in = ctxt->input->cur; } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09)); nbchar = 0; } ctxt->input->line = line; ctxt->input->col = col; xmlParseCharDataComplex(ctxt, cdata); } /** * xmlParseCharDataComplex: * @ctxt: an XML parser context * @cdata: int indicating whether we are within a CDATA section * * parse a CharData section.this is the fallback function * of xmlParseCharData() when the parsing requires handling * of non-ASCII characters. */ static void xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) { xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5]; int nbchar = 0; int cur, l; int count = 0; SHRINK; GROW; cur = CUR_CHAR(l); while ((cur !=

) && /* checked */ (cur !=

) && (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ { if ((cur ==

) && (NXT(1) ==

) && (NXT(2) ==

)) { if (cdata) break; else { xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL); } } COPY_BUF(l,buf,nbchar,cur); if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) { buf[nbchar] = 0; /* * OK the segment is to be consumed as chars. */ if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) { if (areBlanks(ctxt, buf, nbchar, 0)) { if (ctxt->sax->ignorableWhitespace != NULL) ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar); } else { if (ctxt->sax->characters != NULL) ctxt->sax->characters(ctxt->userData, buf, nbchar); if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) && (*ctxt->space == -1)) *ctxt->space = -2; } } nbchar = 0; /* something really bad happened in the SAX callback */ if (ctxt->instate != XML_PARSER_CONTENT) return; } count++; if (count > 50) { GROW; count = 0; } NEXTL(l); cur = CUR_CHAR(l); } if (nbchar != 0) { buf[nbchar] = 0; /* * OK the segment is to be consumed as chars. */ if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) { if (areBlanks(ctxt, buf, nbchar, 0)) { if (ctxt->sax->ignorableWhitespace != NULL) ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar); } else { if (ctxt->sax->characters != NULL) ctxt->sax->characters(ctxt->userData, buf, nbchar); if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) && (*ctxt->space == -1)) *ctxt->space = -2; } } } if ((cur != 0) && (!IS_CHAR(cur))) { /* Generate the error and skip the offending character */ xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR, "PCDATA invalid Char value %d\n", cur); NEXTL(l); } } /** * xmlParseExternalID: * @ctxt: an XML parser context * @publicID: a xmlChar** receiving PubidLiteral * @strict: indicate whether we should restrict parsing to only * production [75], see NOTE below * * Parse an External ID or a Public ID * * NOTE: Productions [75] and [83] interact badly since [75] can generate *

S PubidLiteral S SystemLiteral * * [75] ExternalID ::=

S SystemLiteral * |

S PubidLiteral S SystemLiteral * * [83] PublicID ::=

S PubidLiteral * * Returns the function returns SystemLiteral and in the second * case publicID receives PubidLiteral, is strict is off * it is possible to return NULL and have publicID set. */ xmlChar * xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) { xmlChar *URI = NULL; SHRINK; *publicID = NULL; if (CMP6(CUR_PTR,

,

,

,

,

,

)) { SKIP(6); if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after

\n"); } SKIP_BLANKS; URI = xmlParseSystemLiteral(ctxt); if (URI == NULL) { xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL); } } else if (CMP6(CUR_PTR,

,

,

,

,

,

)) { SKIP(6); if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after

\n"); } SKIP_BLANKS; *publicID = xmlParsePubidLiteral(ctxt); if (*publicID == NULL) { xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL); } if (strict) { /* * We don

S SystemLiteral

Space required after the Public Identifier\n

S SystemLiteral

s a nice mess. */ const xmlChar *ptr; GROW; ptr = CUR_PTR; if (!IS_BLANK_CH(*ptr)) return(NULL); while (IS_BLANK_CH(*ptr)) ptr++; /* TODO: dangerous, fix ! */ if ((*ptr !=



"

For compatibility, the string

(double-hyphen) * must not occur within comments.

t work * * [15] Comment ::=

((Char -

) | (

(Char -

)))*

*/ static void xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf, int len, int size) { int q, ql; int r, rl; int cur, l; int count = 0; int inputid; inputid = ctxt->input->id; if (buf == NULL) { len = 0; size = XML_PARSER_BUFFER_SIZE; buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar)); if (buf == NULL) { xmlErrMemory(ctxt, NULL); return; } } GROW; /* Assure there

xmlParseComment: invalid xmlChar value %d\n

xmlParseComment: invalid xmlChar value %d\n

>

-

-

-

-

Comment not terminated \n<!--%.50s\n

xmlParseComment: invalid xmlChar value %d\n

Comment doesn't start and stop in the same entity\n

Comment not terminated\n

For compatibility, the string

(double-hyphen) * must not occur within comments.

<!--

-

-

-

-->

<

!

-

-

t need to be * modified before passing it to the handler. */ in = ctxt->input->cur; do { if (*in == 0xA) { do { ctxt->input->line++; ctxt->input->col = 1; in++; } while (*in == 0xA); } get_more: ccol = ctxt->input->col; while (((*in >

) && (*in <= 0x7F)) || ((*in >= 0x20) && (*in <

)) || (*in == 0x09)) { in++; ccol++; } ctxt->input->col = ccol; if (*in == 0xA) { do { ctxt->input->line++; ctxt->input->col = 1; in++; } while (*in == 0xA); goto get_more; } nbchar = in - ctxt->input->cur; /* * save current set of data */ if (nbchar > 0) { if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL)) { if (buf == NULL) { if ((*in ==

) && (in[1] ==

)) size = nbchar + 1; else size = XML_PARSER_BUFFER_SIZE + nbchar; buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar)); if (buf == NULL) { xmlErrMemory(ctxt, NULL); ctxt->instate = state; return; } len = 0; } else if (len + nbchar + 1 >= size) { xmlChar *new_buf; size += len + nbchar + XML_PARSER_BUFFER_SIZE; new_buf = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar)); if (new_buf == NULL) { xmlFree (buf); xmlErrMemory(ctxt, NULL); ctxt->instate = state; return; } buf = new_buf; } memcpy(&buf[len], ctxt->input->cur, nbchar); len += nbchar; buf[len] = 0; } } ctxt->input->cur = in; if (*in == 0xA) { in++; ctxt->input->line++; ctxt->input->col = 1; } if (*in == 0xD) { in++; if (*in == 0xA) { ctxt->input->cur = in; in++; ctxt->input->line++; ctxt->input->col = 1; continue; /* while */ } in--; } SHRINK; GROW; in = ctxt->input->cur; if (*in ==

) { if (in[1] ==

) { if (in[2] ==

) { if (ctxt->input->id != inputid) { xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, "comment doesn

); } SKIP(3); if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) && (!ctxt->disableSAX)) { if (buf != NULL) ctxt->sax->comment(ctxt->userData, buf); else ctxt->sax->comment(ctxt->userData, BAD_CAST

); } if (buf != NULL) xmlFree(buf); ctxt->instate = state; return; } if (buf != NULL) xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

, buf); else xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

, NULL); in++; ctxt->input->col++; } in++; ctxt->input->col++; goto get_more; } } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09)); xmlParseCommentComplex(ctxt, buf, len, size); ctxt->instate = state; return; } /** * xmlParsePITarget: * @ctxt: an XML parser context * * parse the name of a PI * * [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l')) * * Returns the PITarget name or NULL */ const xmlChar * xmlParsePITarget(xmlParserCtxtPtr ctxt) { const xmlChar *name; name = xmlParseName(ctxt); if ((name != NULL) && ((name[0] == 'x') || (name[0] == 'X')) && ((name[1] == 'm') || (name[1] == 'M')) && ((name[2] == 'l') || (name[2] == 'L'))) { int i; if ((name[0] == 'x') && (name[1] == 'm') && (name[2] == 'l') && (name[3] == 0)) { xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

); return(name); } else if (name[3] == 0) { xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL); return(name); } for (i = 0;;i++) { if (xmlW3CPIs[i] == NULL) break; if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i])) return(name); } xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

xml

, NULL, NULL); } if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) { xmlNsErr(ctxt, XML_NS_ERR_COLON,

%s

, name, NULL, NULL); } return(name); } #ifdef LIBXML_CATALOG_ENABLED /** * xmlParseCatalogPI: * @ctxt: an XML parser context * @catalog: the PI value string * * parse an XML Catalog Processing Instruction. * * <?oasis-xml-catalog catalog=

?> * * Occurs only if allowed by the user and if happening in the Misc * part of the document before any doctype informations * This will add the given catalog to the parsing context in order * to be used if there is a resolution need further down in the document */ static void xmlParseCatalogPI(xmlParserCtxtPtr ctxt, const xmlChar *catalog) { xmlChar *URL = NULL; const xmlChar *tmp, *base; xmlChar marker; tmp = catalog; while (IS_BLANK_CH(*tmp)) tmp++; if (xmlStrncmp(tmp, BAD_CAST

, 7)) goto error; tmp += 7; while (IS_BLANK_CH(*tmp)) tmp++; if (*tmp != '=') { return; } tmp++; while (IS_BLANK_CH(*tmp)) tmp++; marker = *tmp; if ((marker != '\'') && (marker != '

)) goto error; tmp++; base = tmp; while ((*tmp != 0) && (*tmp != marker)) tmp++; if (*tmp == 0) goto error; URL = xmlStrndup(base, tmp - base); tmp++; while (IS_BLANK_CH(*tmp)) tmp++; if (*tmp != 0) goto error; if (URL != NULL) { ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL); xmlFree(URL); } return; error: xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI, "Catalog PI syntax error: %s\n", catalog, NULL); if (URL != NULL) xmlFree(URL); } #endif /** * xmlParsePI: * @ctxt: an XML parser context * * parse an XML Processing Instruction. * * [16] PI ::=

PITarget (S (Char* - (Char*

Char*)))?

* * The processing is transfered to SAX once parsed. */ void xmlParsePI(xmlParserCtxtPtr ctxt) { xmlChar *buf = NULL; int len = 0; int size = XML_PARSER_BUFFER_SIZE; int cur, l; const xmlChar *target; xmlParserInputState state; int count = 0; if ((RAW ==

) && (NXT(1) ==

)) { xmlParserInputPtr input = ctxt->input; state = ctxt->instate; ctxt->instate = XML_PARSER_PI; /* * this is a Processing Instruction. */ SKIP(2); SHRINK; /* * Parse the target name and check for special support like * namespace. */ target = xmlParsePITarget(ctxt); if (target != NULL) { if ((RAW ==

) && (NXT(1) ==

)) { if (input != ctxt->input) { xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, "PI declaration doesn

); } SKIP(2); /* * SAX: PI detected. */ if ((ctxt->sax) && (!ctxt->disableSAX) && (ctxt->sax->processingInstruction != NULL)) ctxt->sax->processingInstruction(ctxt->userData, target, NULL); ctxt->instate = state; return; } buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar)); if (buf == NULL) { xmlErrMemory(ctxt, NULL); ctxt->instate = state; return; } cur = CUR; if (!IS_BLANK(cur)) { xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,

, target); } SKIP_BLANKS; cur = CUR_CHAR(l); while (IS_CHAR(cur) && /* checked */ ((cur != '?') || (NXT(1) != '>'))) { if (len + 5 >= size) { xmlChar *tmp; size *= 2; tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar)); if (tmp == NULL) { xmlErrMemory(ctxt, NULL); xmlFree(buf); ctxt->instate = state; return; } buf = tmp; } count++; if (count > 50) { GROW; count = 0; } COPY_BUF(l,buf,len,cur); NEXTL(l); cur = CUR_CHAR(l); if (cur == 0) { SHRINK; GROW; cur = CUR_CHAR(l); } } buf[len] = 0; if (cur != '?') { xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

, target); } else { if (input != ctxt->input) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

t start and stop in the same entity\n"); } SKIP(2); #ifdef LIBXML_CATALOG_ENABLED if (((state == XML_PARSER_MISC) || (state == XML_PARSER_START)) && (xmlStrEqual(target, XML_CATALOG_PI))) { xmlCatalogAllow allow = xmlCatalogGetDefaults(); if ((allow == XML_CATA_ALLOW_DOCUMENT) || (allow == XML_CATA_ALLOW_ALL)) xmlParseCatalogPI(ctxt, buf); } #endif /* * SAX: PI detected. */ if ((ctxt->sax) && (!ctxt->disableSAX) && (ctxt->sax->processingInstruction != NULL)) ctxt->sax->processingInstruction(ctxt->userData, target, buf); } xmlFree(buf); } else { xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL); } ctxt->instate = state; } } /** * xmlParseNotationDecl: * @ctxt: an XML parser context * * parse a notation declaration * * [82] NotationDecl ::=

S Name S (ExternalID | PublicID) S?

* * Hence there is actually 3 choices: *

S PubidLiteral *

S PubidLiteral S SystemLiteral * and

S SystemLiteral * * See the NOTE on xmlParseExternalID(). */ void xmlParseNotationDecl(xmlParserCtxtPtr ctxt) { const xmlChar *name; xmlChar *Pubid; xmlChar *Systemid; if (CMP10(CUR_PTR,

,

,

,

,

,

,

,

,

,

)) { xmlParserInputPtr input = ctxt->input; SHRINK; SKIP(10); if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after

\n"); return; } SKIP_BLANKS; name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL); return; } if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after the NOTATION name

); return; } if (xmlStrchr(name, ':') != NULL) { xmlNsErr(ctxt, XML_NS_ERR_COLON,

%s

, name, NULL, NULL); } SKIP_BLANKS; /* * Parse the IDs. */ Systemid = xmlParseExternalID(ctxt, &Pubid, 0); SKIP_BLANKS; if (RAW == '>') { if (input != ctxt->input) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

t start and stop in the same entity\n"); } NEXT; if ((ctxt->sax != NULL) && (!ctxt->disableSAX) && (ctxt->sax->notationDecl != NULL)) ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid); } else { xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL); } if (Systemid != NULL) xmlFree(Systemid); if (Pubid != NULL) xmlFree(Pubid); } } /** * xmlParseEntityDecl: * @ctxt: an XML parser context * * parse <!ENTITY declarations * * [70] EntityDecl ::= GEDecl | PEDecl * * [71] GEDecl ::=

S Name S EntityDef S?

* * [72] PEDecl ::=

S

S Name S PEDef S?

* * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?) * * [74] PEDef ::= EntityValue | ExternalID * * [76] NDataDecl ::= S

S Name * * [ VC: Notation Declared ] * The Name must match the declared name of a notation. */ void xmlParseEntityDecl(xmlParserCtxtPtr ctxt) { const xmlChar *name = NULL; xmlChar *value = NULL; xmlChar *URI = NULL, *literal = NULL; const xmlChar *ndata = NULL; int isParameter = 0; xmlChar *orig = NULL; int skipped; /* GROW; done in the caller */ if (CMP8(CUR_PTR,

,

,

,

,

,

,

,

)) { xmlParserInputPtr input = ctxt->input; SHRINK; SKIP(8); skipped = SKIP_BLANKS; if (skipped == 0) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after

\n"); } if (RAW ==

) { NEXT; skipped = SKIP_BLANKS; if (skipped == 0) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after

\n"); } isParameter = 1; } name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "xmlParseEntityDecl: no name\n"); return; } if (xmlStrchr(name,

) != NULL) { xmlNsErr(ctxt, XML_NS_ERR_COLON, "colon are forbidden from entities names

\n", name, NULL, NULL); } skipped = SKIP_BLANKS; if (skipped == 0) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Space required after the entity name\n"); } ctxt->instate = XML_PARSER_ENTITY_DECL; /* * handle the various case of definitions... */ if (isParameter) { if ((RAW ==

') || (RAW == '\'')) { value = xmlParseEntityValue(ctxt, &orig); if (value) { if ((ctxt->sax != NULL) && (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL)) ctxt->sax->entityDecl(ctxt->userData, name, XML_INTERNAL_PARAMETER_ENTITY, NULL, NULL, value); } } else { URI = xmlParseExternalID(ctxt, &literal, 1); if ((URI == NULL) && (literal == NULL)) { xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL); } if (URI) { xmlURIPtr uri; uri = xmlParseURI((const char *) URI); if (uri == NULL) { xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,

, URI); /* * This really ought to be a well formedness error * but the XML Core WG decided otherwise c.f. issue * E26 of the XML erratas. */ } else { if (uri->fragment != NULL) { /* * Okay this is foolish to block those but not * invalid URIs. */ xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL); } else { if ((ctxt->sax != NULL) && (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL)) ctxt->sax->entityDecl(ctxt->userData, name, XML_EXTERNAL_PARAMETER_ENTITY, literal, URI, NULL); } xmlFreeURI(uri); } } } } else { if ((RAW == '

) || (RAW ==



New Doc failed

fake

Invalid URI: %s\n

>

Space required before 'NDATA'\n

N

D

A

T

A

Space required after 'NDATA'\n

New Doc failed

fake

>

xmlParseEntityDecl: entity %s not terminated\n

Entity declaration doesn't start and stop in the same entity\n

#REQUIRED

#IMPLIED

#FIXED

#

R

E

Q

U

I

R

E

D

#

I

M

P

L

I

E

D

#

F

I

X

E

D

Space required after '#FIXED'\n

Attribute default value declaration error\n

NOTATION

NOTATION

(

|

)

(

Name expected in NOTATION declaration\n

standalone: attribute notation value token %s duplicated\n

|

)

(

|

)

(

standalone: attribute enumeration value token %s duplicated\n

|

)

NOTATION

(

|

)

N

O

T

A

T

I

O

N

Space required after 'NOTATION'\n

CDATA

ID

IDREF

IDREFS

ENTITY

ENTITIES

NMTOKEN

NMTOKENS

C

D

A

T

A

I

D

R

E

F

S

I

D

R

E

F

I

D

E

N

T

I

T

Y

E

N

T

I

T

I

E

S

N

M

T

O

K

E

N

S

N

M

T

O

K

E

N

<!ATTLIST

>

<

!

A

T

T

L

I

S

T

Space required after '<!ATTLIST'\n

ATTLIST: no name for Element\n

>

ATTLIST: no name for Attribute\n

Space required after the attribute name\n

Space required after the attribute type\n

>

Space required after the attribute default value\n

in xmlParseAttributeListDecl\n

>

Attribute list declaration doesn't start and stop in the same entity\n

(

(

#PCDATA

|

)*

(

#PCDATA

)

#

P

C

D

A

T

A

)

Element content declaration doesn't start and stop in the same entity\n

*

(

|

|

xmlParseElementMixedContentDecl : Name expected\n

)

*

Element content declaration doesn't start and stop in the same entity\n

(

?

*

+

?

*

+

(

|

)

(

,

)

xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n

(

?

*

+

)

,

Name | Name , Name

xmlParseElementChildrenContentDecl : '%c' expected\n

|

Name , Name | Name

xmlParseElementChildrenContentDecl : '%c' expected\n

(

?

*

+

Element content declaration doesn't start and stop in the same entity\n

?

*

+

(

?

*

+

?

*

+

(

|

)

(

,

)

EMPTY

ANY

(

xmlParseElementContentDecl : %s '(' expected\n

#

P

C

D

A

T

A

<!ELEMENT

>

<

!

E

L

E

M

E

N

T

Space required after 'ELEMENT'\n

xmlParseElementDecl: no name for Element\n

Space required after the element name\n

E

M

P

T

Y

A

N

Y

(

%

PEReference: forbidden within markup decl in internal subset\n

xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n

>

Element declaration doesn't start and stop in the same entity\n

<![

INCLUDE

[

]]>

<![

IGNORE

[

]]>

<![

]]>

<![

]]>

I

N

C

L

U

D

E

[

All markup of the conditional section is not in the same entity\n

%s(%d):

Entering INCLUDE Conditional Section\n

]

]

>

<

!

[

%

%s(%d):

Leaving INCLUDE Conditional Section\n

I

G

N

O

R

E

[

All markup of the conditional section is not in the same entity\n

%s(%d):

Entering IGNORE Conditional Section\n

<

!

[

]

]

>

%s(%d):

Leaving IGNORE Conditional Section\n

All markup of the conditional section is not in the same entity\n

<

!

E

L

N

A

N

-

?

<

!

[

<?xml

?>

<?xml

<

?

x

m

l

Space needed after '<?xml'\n

Space needed here\n

Missing encoding in text declaration\n

?

>

>

<

?

x

m

l

1.0

New Doc failed

<

?

<

!

%

<

!

[

%

&

#

x

X

#x%X

#%d

invalid entity type found\n

Entity '%s' failed to parse\n

t * build the entity content. So unless we already went * though parsing for first checking go though the entity * content to generate callbacks associated to the entity */ if (was_checked != 0) { void *user_data; /* * This is a bit hackish but this seems the best * way to make sure both SAX and DOM entity support * behaves okay. */ if (ctxt->userData == ctxt) user_data = NULL; else user_data = ctxt->userData; if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) { ctxt->depth++; ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content, user_data, NULL); ctxt->depth--; } else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) { ctxt->depth++; ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax, user_data, ctxt->depth, ent->URI, ent->ExternalID, NULL); ctxt->depth--; } else { ret = XML_ERR_ENTITY_PE_INTERNAL; xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR, "invalid entity type found\n", NULL); } if (ret == XML_ERR_ENTITY_LOOP) { xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL); return; } } if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) && (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) { /* * Entity reference callback comes second, it

t get any children for the entity being built */ if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) && (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) { /* * Create a node. */ ctxt->sax->reference(ctxt->userData, ent->name); return; } if ((ctxt->replaceEntities) || (ent->children == NULL)) { /* * There is a problem on the handling of _private for entities * (bug 155816): Should we copy the content of the field from * the entity (possibly overwriting some value set by the user * when a copy is created), should we leave it alone, or should * we try to take care of different situations? The problem * is exacerbated by the usage of this field by the xmlReader. * To fix this bug, we look at _private on the created node * and, if it

s not NULL we leave it alone. This is somewhat of a * hack - maybe we should have further tests to determine * what to do. */ if ((ctxt->node != NULL) && (ent->children != NULL)) { /* * Seems we are generating the DOM content, do * a simple tree copy for all references except the first * In the first occurrence list contains the replacement. * progressive == 2 means we are operating on the Reader * and since nodes are discarded we must copy all the time. */ if (((list == NULL) && (ent->owner == 0)) || (ctxt->parseMode == XML_PARSE_READER)) { xmlNodePtr nw = NULL, cur, firstChild = NULL; /* * when operating on a reader, the entities definitions * are always owning the entities subtree. if (ctxt->parseMode == XML_PARSE_READER) ent->owner = 1; */ cur = ent->children; while (cur != NULL) { nw = xmlDocCopyNode(cur, ctxt->myDoc, 1); if (nw != NULL) { if (nw->_private == NULL) nw->_private = cur->_private; if (firstChild == NULL){ firstChild = nw; } nw = xmlAddChild(ctxt->node, nw); } if (cur == ent->last) { /* * needed to detect some strange empty * node cases in the reader tests */ if ((ctxt->parseMode == XML_PARSE_READER) && (nw != NULL) && (nw->type == XML_ELEMENT_NODE) && (nw->children == NULL)) nw->extra = 1; break; } cur = cur->next; } #ifdef LIBXML_LEGACY_ENABLED if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) xmlAddEntityReference(ent, firstChild, nw); #endif /* LIBXML_LEGACY_ENABLED */ } else if (list == NULL) { xmlNodePtr nw = NULL, cur, next, last, firstChild = NULL; /* * Copy the entity child list and make it the new * entity child list. The goal is to make sure any * ID or REF referenced will be the one from the * document content and not the entity copy. */ cur = ent->children; ent->children = NULL; last = ent->last; ent->last = NULL; while (cur != NULL) { next = cur->next; cur->next = NULL; cur->parent = NULL; nw = xmlDocCopyNode(cur, ctxt->myDoc, 1); if (nw != NULL) { if (nw->_private == NULL) nw->_private = cur->_private; if (firstChild == NULL){ firstChild = cur; } xmlAddChild((xmlNodePtr) ent, nw); xmlAddChild(ctxt->node, cur); } if (cur == last) break; cur = next; } if (ent->owner == 0) ent->owner = 1; #ifdef LIBXML_LEGACY_ENABLED if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) xmlAddEntityReference(ent, firstChild, nw); #endif /* LIBXML_LEGACY_ENABLED */ } else { const xmlChar *nbktext; /* * the name change is to avoid coalescing of the * node with a possible previous text one which * would make ent->children a dangling pointer */ nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext", -1); if (ent->children->type == XML_TEXT_NODE) ent->children->name = nbktext; if ((ent->last != ent->children) && (ent->last->type == XML_TEXT_NODE)) ent->last->name = nbktext; xmlAddChildList(ctxt->node, ent->children); } /* * This is to avoid a nasty side effect, see * characters() in SAX.c */ ctxt->nodemem = 0; ctxt->nodelen = 0; return; } } } /** * xmlParseEntityRef: * @ctxt: an XML parser context * * parse ENTITY references declarations * * [68] EntityRef ::=

Name

* * [ WFC: Entity Declared ] * In a document without any DTD, a document with only an internal DTD * subset which contains no parameter entity references, or a document * with "standalone=

", the Name given in the entity reference * must match that in an entity declaration, except that well-formed * documents need not declare any of the following entities: amp, lt, * gt, apos, quot. The declaration of a parameter entity must precede * any reference to it. Similarly, the declaration of a general entity * must precede any reference to it which appears in a default value in an * attribute-list declaration. Note that if entities are declared in the * external subset or in external parameter entities, a non-validating * processor is not obligated to read and process their declarations; * for such documents, the rule that an entity must be declared is a * well-formedness constraint only if standalone=

. * * [ WFC: Parsed Entity ] * An entity reference must not contain the name of an unparsed entity * * Returns the xmlEntityPtr if found, or NULL otherwise. */ xmlEntityPtr xmlParseEntityRef(xmlParserCtxtPtr ctxt) { const xmlChar *name; xmlEntityPtr ent = NULL; GROW; if (RAW !=

) return(NULL); NEXT; name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "xmlParseEntityRef: no name\n"); return(NULL); } if (RAW !=

) { xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL); return(NULL); } NEXT; /* * Predefined entites override any extra definition */ if ((ctxt->options & XML_PARSE_OLDSAX) == 0) { ent = xmlGetPredefinedEntity(name); if (ent != NULL) return(ent); } /* * Increate the number of entity references parsed */ ctxt->nbentities++; /* * Ask first SAX for entity resolution, otherwise try the * entities which may have stored in the parser context. */ if (ctxt->sax != NULL) { if (ctxt->sax->getEntity != NULL) ent = ctxt->sax->getEntity(ctxt->userData, name); if ((ctxt->wellFormed == 1 ) && (ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX)) ent = xmlGetPredefinedEntity(name); if ((ctxt->wellFormed == 1 ) && (ent == NULL) && (ctxt->userData==ctxt)) { ent = xmlSAX2GetEntity(ctxt, name); } } /* * [ WFC: Entity Declared ] * In a document without any DTD, a document with only an * internal DTD subset which contains no parameter entity * references, or a document with "standalone=

", the * Name given in the entity reference must match that in an * entity declaration, except that well-formed documents * need not declare any of the following entities: amp, lt, * gt, apos, quot. * The declaration of a parameter entity must precede any * reference to it. * Similarly, the declaration of a general entity must * precede any reference to it which appears in a default * value in an attribute-list declaration. Note that if * entities are declared in the external subset or in * external parameter entities, a non-validating processor * is not obligated to read and process their declarations; * for such documents, the rule that an entity must be * declared is a well-formedness constraint only if * standalone=

. */ if (ent == NULL) { if ((ctxt->standalone == 1) || ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY, "Entity

not defined\n", name); } else { xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY, "Entity

not defined\n", name); if ((ctxt->inSubset == 0) && (ctxt->sax != NULL) && (ctxt->sax->reference != NULL)) { ctxt->sax->reference(ctxt->userData, name); } } ctxt->valid = 0; } /* * [ WFC: Parsed Entity ] * An entity reference must not contain the name of an * unparsed entity */ else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY, "Entity reference to unparsed entity %s\n", name); } /* * [ WFC: No External Entity References ] * Attribute values cannot contain direct or indirect * entity references to external entities. */ else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) && (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) { xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL, "Attribute references external entity

\n", name); } /* * [ WFC: No < in Attribute Values ] * The replacement text of any entity referred to directly or * indirectly in an attribute value (other than "&lt;") must * not contain a <. */ else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) && (ent != NULL) && (ent->content != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (xmlStrchr(ent->content,

))) { xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, "

in entity

is not allowed in attributes values\n", name); } /* * Internal check, no parameter entities here ... */ else { switch (ent->etype) { case XML_INTERNAL_PARAMETER_ENTITY: case XML_EXTERNAL_PARAMETER_ENTITY: xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER, "Attempt to reference the parameter entity

\n", name); break; default: break; } } /* * [ WFC: No Recursion ] * A parsed entity must not contain a recursive reference * to itself, either directly or indirectly. * Done somewhere else */ return(ent); } /** * xmlParseStringEntityRef: * @ctxt: an XML parser context * @str: a pointer to an index in the string * * parse ENTITY references declarations, but this version parses it from * a string value. * * [68] EntityRef ::=

Name

* * [ WFC: Entity Declared ] * In a document without any DTD, a document with only an internal DTD * subset which contains no parameter entity references, or a document * with "standalone=

", the Name given in the entity reference * must match that in an entity declaration, except that well-formed * documents need not declare any of the following entities: amp, lt, * gt, apos, quot. The declaration of a parameter entity must precede * any reference to it. Similarly, the declaration of a general entity * must precede any reference to it which appears in a default value in an * attribute-list declaration. Note that if entities are declared in the * external subset or in external parameter entities, a non-validating * processor is not obligated to read and process their declarations; * for such documents, the rule that an entity must be declared is a * well-formedness constraint only if standalone=

. * * [ WFC: Parsed Entity ] * An entity reference must not contain the name of an unparsed entity * * Returns the xmlEntityPtr if found, or NULL otherwise. The str pointer * is updated to the current location in the string. */ static xmlEntityPtr xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) { xmlChar *name; const xmlChar *ptr; xmlChar cur; xmlEntityPtr ent = NULL; if ((str == NULL) || (*str == NULL)) return(NULL); ptr = *str; cur = *ptr; if (cur !=

) return(NULL); ptr++; name = xmlParseStringName(ctxt, &ptr); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "xmlParseStringEntityRef: no name\n"); *str = ptr; return(NULL); } if (*ptr !=

) { xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL); xmlFree(name); *str = ptr; return(NULL); } ptr++; /* * Predefined entites override any extra definition */ if ((ctxt->options & XML_PARSE_OLDSAX) == 0) { ent = xmlGetPredefinedEntity(name); if (ent != NULL) { xmlFree(name); *str = ptr; return(ent); } } /* * Increate the number of entity references parsed */ ctxt->nbentities++; /* * Ask first SAX for entity resolution, otherwise try the * entities which may have stored in the parser context. */ if (ctxt->sax != NULL) { if (ctxt->sax->getEntity != NULL) ent = ctxt->sax->getEntity(ctxt->userData, name); if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX)) ent = xmlGetPredefinedEntity(name); if ((ent == NULL) && (ctxt->userData==ctxt)) { ent = xmlSAX2GetEntity(ctxt, name); } } /* * [ WFC: Entity Declared ] * In a document without any DTD, a document with only an * internal DTD subset which contains no parameter entity * references, or a document with "standalone=

", the * Name given in the entity reference must match that in an * entity declaration, except that well-formed documents * need not declare any of the following entities: amp, lt, * gt, apos, quot. * The declaration of a parameter entity must precede any * reference to it. * Similarly, the declaration of a general entity must * precede any reference to it which appears in a default * value in an attribute-list declaration. Note that if * entities are declared in the external subset or in * external parameter entities, a non-validating processor * is not obligated to read and process their declarations; * for such documents, the rule that an entity must be * declared is a well-formedness constraint only if * standalone=

. */ if (ent == NULL) { if ((ctxt->standalone == 1) || ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY, "Entity

not defined\n", name); } else { xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY, "Entity

not defined\n", name); } /* TODO ? check regressions ctxt->valid = 0; */ } /* * [ WFC: Parsed Entity ] * An entity reference must not contain the name of an * unparsed entity */ else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY, "Entity reference to unparsed entity %s\n", name); } /* * [ WFC: No External Entity References ] * Attribute values cannot contain direct or indirect * entity references to external entities. */ else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) && (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) { xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL, "Attribute references external entity

\n", name); } /* * [ WFC: No < in Attribute Values ] * The replacement text of any entity referred to directly or * indirectly in an attribute value (other than "&lt;") must * not contain a <. */ else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) && (ent != NULL) && (ent->content != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (xmlStrchr(ent->content,

))) { xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, "

in entity

is not allowed in attributes values\n", name); } /* * Internal check, no parameter entities here ... */ else { switch (ent->etype) { case XML_INTERNAL_PARAMETER_ENTITY: case XML_EXTERNAL_PARAMETER_ENTITY: xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER, "Attempt to reference the parameter entity

\n", name); break; default: break; } } /* * [ WFC: No Recursion ] * A parsed entity must not contain a recursive reference * to itself, either directly or indirectly. * Done somewhere else */ xmlFree(name); *str = ptr; return(ent); } /** * xmlParsePEReference: * @ctxt: an XML parser context * * parse PEReference declarations * The entity content is handled directly by pushing it

%

;

standalone='yes'

standalone='no'

%

xmlParsePEReference: no name\n

;

standalone='yes'

PEReference: %%%s; not found\n

standalone='no'

PEReference: %%%s; not found\n

Internal: %%%s; is not a parameter entity\n

<

?

x

m

l

xmlLoadEntityContent parameter error

Reading %s entity content input\n

xmlLoadEntityContent parameter error

xmlLoadEntityContent input error

xmlLoadEntityContent: invalid char value %d\n

%

;

standalone='yes'

standalone='no'

%

xmlParseStringPEReference: no name\n

;

standalone='yes'

PEReference: %%%s; not found\n

standalone='no'

PEReference: %%%s; not found\n

%%%s; is not a parameter entity\n

<!DOCTYPE

[

]

>

<!DOCTYPE

xmlParseDocTypeDecl : no DOCTYPE name !\n

[

>

[

]

>

[

]

xmlParseInternalSubset: error detected in Markup declaration\n

]

>

&lt;

=

error parsing attribute name\n

=

Specification mandate value for attribute %s\n

xml:lang

Malformed value for xml:lang : %s\n

xml:space

default

preserve

Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n

t parse the tag closing chars. * * [40] STag ::=

Name (S Attribute)* S?

* * [ WFC: Unique Att Spec ] * No attribute name may appear more than once in the same start-tag or * empty-element tag. * * [44] EmptyElemTag ::=

Name (S Attribute)* S?

* * [ WFC: Unique Att Spec ] * No attribute name may appear more than once in the same start-tag or * empty-element tag. * * With namespace: * * [NS 8] STag ::=

QName (S Attribute)* S?

* * [NS 10] EmptyElement ::=

QName (S Attribute)* S?

* * Returns the element name parsed */ const xmlChar * xmlParseStartTag(xmlParserCtxtPtr ctxt) { const xmlChar *name; const xmlChar *attname; xmlChar *attvalue; const xmlChar **atts = ctxt->atts; int nbatts = 0; int maxatts = ctxt->maxatts; int i; if (RAW !=

) return(NULL); NEXT1; name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "xmlParseStartTag: invalid element name\n"); return(NULL); } /* * Now parse the attributes, it ends up with the ending * * (S Attribute)* S? */ SKIP_BLANKS; GROW; while ((RAW !=

) && ((RAW !=

) || (NXT(1) !=

)) && (IS_BYTE_CHAR(RAW))) { const xmlChar *q = CUR_PTR; unsigned int cons = ctxt->input->consumed; attname = xmlParseAttribute(ctxt, &attvalue); if ((attname != NULL) && (attvalue != NULL)) { /* * [ WFC: Unique Att Spec ] * No attribute name may appear more than once in the same * start-tag or empty-element tag. */ for (i = 0; i < nbatts;i += 2) { if (xmlStrEqual(atts[i], attname)) { xmlErrAttributeDup(ctxt, NULL, attname); xmlFree(attvalue); goto failed; } } /* * Add the pair to atts */ if (atts == NULL) { maxatts = 22; /* allow for 10 attrs by default */ atts = (const xmlChar **) xmlMalloc(maxatts * sizeof(xmlChar *)); if (atts == NULL) { xmlErrMemory(ctxt, NULL); if (attvalue != NULL) xmlFree(attvalue); goto failed; } ctxt->atts = atts; ctxt->maxatts = maxatts; } else if (nbatts + 4 > maxatts) { const xmlChar **n; maxatts *= 2; n = (const xmlChar **) xmlRealloc((void *) atts, maxatts * sizeof(const xmlChar *)); if (n == NULL) { xmlErrMemory(ctxt, NULL); if (attvalue != NULL) xmlFree(attvalue); goto failed; } atts = n; ctxt->atts = atts; ctxt->maxatts = maxatts; } atts[nbatts++] = attname; atts[nbatts++] = attvalue; atts[nbatts] = NULL; atts[nbatts + 1] = NULL; } else { if (attvalue != NULL) xmlFree(attvalue); } failed: GROW if ((RAW ==

) || (((RAW ==

) && (NXT(1) ==

)))) break; if (!IS_BLANK_CH(RAW)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "attributes construct error\n"); } SKIP_BLANKS; if ((cons == ctxt->input->consumed) && (q == CUR_PTR) && (attname == NULL) && (attvalue == NULL)) { xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR, "xmlParseStartTag: problem parsing attributes\n"); break; } SHRINK; GROW; } /* * SAX: Start of Element ! */ if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) && (!ctxt->disableSAX)) { if (nbatts > 0) ctxt->sax->startElement(ctxt->userData, name, atts); else ctxt->sax->startElement(ctxt->userData, name, NULL); } if (atts != NULL) { /* Free only the content strings */ for (i = 1;i < nbatts;i+=2) if (atts[i] != NULL) xmlFree((xmlChar *) atts[i]); } return(name); } /** * xmlParseEndTag1: * @ctxt: an XML parser context * @line: line of the start tag * @nsNr: number of namespaces on the start tag * * parse an end of tag * * [42] ETag ::=

Name S?

* * With namespace * * [NS 9] ETag ::=

QName S?

*/ static void xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) { const xmlChar *name; GROW; if ((RAW !=

) || (NXT(1) !=

)) { xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED, "xmlParseEndTag:

not found\n"); return; } SKIP(2); name = xmlParseNameAndCompare(ctxt,ctxt->name); /* * We should definitely be at the ending "S?

" part */ GROW; SKIP_BLANKS; if ((!IS_BYTE_CHAR(RAW)) || (RAW !=

)) { xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL); } else NEXT1; /* * [ WFC: Element Type Match ] * The Name in an element

unparseable

Opening and ending tag mismatch: %s line %d and %s\n

</

>

</

>

:

:

Failed to parse QName '%s'\n

:

Failed to parse QName '%s:'\n



:

Failed to parse QName '%s:%s:'\n



:

>

#xD#xA

"

\'

&

<

&

<

error parsing attribute name\n

=

Specification mandate value for attribute %s\n

lang

Malformed value for xml:lang : %s\n

space

default

preserve

Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n

t parse the tag closing chars. * This routine is called when running SAX2 parsing * * [40] STag ::=

Name (S Attribute)* S?

* * [ WFC: Unique Att Spec ] * No attribute name may appear more than once in the same start-tag or * empty-element tag. * * [44] EmptyElemTag ::=

Name (S Attribute)* S?

* * [ WFC: Unique Att Spec ] * No attribute name may appear more than once in the same start-tag or * empty-element tag. * * With namespace: * * [NS 8] STag ::=

QName (S Attribute)* S?

* * [NS 10] EmptyElement ::=

QName (S Attribute)* S?

* * Returns the element name parsed */ static const xmlChar * xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref, const xmlChar **URI, int *tlen) { const xmlChar *localname; const xmlChar *prefix; const xmlChar *attname; const xmlChar *aprefix; const xmlChar *nsname; xmlChar *attvalue; const xmlChar **atts = ctxt->atts; int maxatts = ctxt->maxatts; int nratts, nbatts, nbdef; int i, j, nbNs, attval, oldline, oldcol; const xmlChar *base; unsigned long cur; int nsNr = ctxt->nsNr; if (RAW !=

) return(NULL); NEXT1; /* * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that * point since the attribute values may be stored as pointers to * the buffer and calling SHRINK would destroy them ! * The Shrinking is only possible once the full set of attribute * callbacks have been done. */ reparse: SHRINK; base = ctxt->input->base; cur = ctxt->input->cur - ctxt->input->base; oldline = ctxt->input->line; oldcol = ctxt->input->col; nbatts = 0; nratts = 0; nbdef = 0; nbNs = 0; attval = 0; /* Forget any namespaces added during an earlier parse of this element. */ ctxt->nsNr = nsNr; localname = xmlParseQName(ctxt, &prefix); if (localname == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, "StartTag: invalid element name\n"); return(NULL); } *tlen = ctxt->input->cur - ctxt->input->base - cur; /* * Now parse the attributes, it ends up with the ending * * (S Attribute)* S? */ SKIP_BLANKS; GROW; if (ctxt->input->base != base) goto base_changed; while ((RAW !=

) && ((RAW !=

) || (NXT(1) !=

)) && (IS_BYTE_CHAR(RAW))) { const xmlChar *q = CUR_PTR; unsigned int cons = ctxt->input->consumed; int len = -1, alloc = 0; attname = xmlParseAttribute2(ctxt, prefix, localname, &aprefix, &attvalue, &len, &alloc); if (ctxt->input->base != base) { if ((attvalue != NULL) && (alloc != 0)) xmlFree(attvalue); attvalue = NULL; goto base_changed; } if ((attname != NULL) && (attvalue != NULL)) { if (len < 0) len = xmlStrlen(attvalue); if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); xmlURIPtr uri; if (*URL != 0) { uri = xmlParseURI((const char *) URL); if (uri == NULL) { xmlNsErr(ctxt, XML_WAR_NS_URI, "xmlns:

is not a valid URI\n", URL, NULL, NULL); } else { if (uri->scheme == NULL) { xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, "xmlns: URI %s is not absolute\n", URL, NULL, NULL); } xmlFreeURI(uri); } if (URL == ctxt->str_xml_ns) { if (attname != ctxt->str_xml) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, "xml namespace URI cannot be the default namespace\n", NULL, NULL, NULL); } goto skip_default_ns; } if ((len == 29) && (xmlStrEqual(URL, BAD_CAST "http://www.w3.org/2000/xmlns/"))) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, "reuse of the xmlns namespace name is forbidden\n", NULL, NULL, NULL); goto skip_default_ns; } } /* * check that it

xml namespace prefix mapped to wrong URI\n

xml namespace URI mapped to wrong prefix\n

redefinition of the xmlns prefix is forbidden\n

http://www.w3.org/2000/xmlns/

reuse of the xmlns namespace name is forbidden\n

xmlns:%s: Empty XML namespace is not allowed\n

xmlns:%s: '%s' is not a valid URI\n

xmlns:%s: URI %s is not absolute\n

s not a defined namespace */ for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) break; if (j <= nbNs) xmlErrAttributeDup(ctxt, aprefix, attname); else if (nsPush(ctxt, attname, URL) > 0) nbNs++; skip_ns: if (alloc != 0) xmlFree(attvalue); SKIP_BLANKS; if (ctxt->input->base != base) goto base_changed; continue; } /* * Add the pair to atts */ if ((atts == NULL) || (nbatts + 5 > maxatts)) { if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { if (attvalue[len] == 0) xmlFree(attvalue); goto failed; } maxatts = ctxt->maxatts; atts = ctxt->atts; } ctxt->attallocs[nratts++] = alloc; atts[nbatts++] = attname; atts[nbatts++] = aprefix; atts[nbatts++] = NULL; /* the URI will be fetched later */ atts[nbatts++] = attvalue; attvalue += len; atts[nbatts++] = attvalue; /* * tag if some deallocation is needed */ if (alloc != 0) attval = 1; } else { if ((attvalue != NULL) && (attvalue[len] == 0)) xmlFree(attvalue); } failed: GROW if (ctxt->input->base != base) goto base_changed; if ((RAW ==

) || (((RAW ==

) && (NXT(1) ==

)))) break; if (!IS_BLANK_CH(RAW)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "attributes construct error\n"); break; } SKIP_BLANKS; if ((cons == ctxt->input->consumed) && (q == CUR_PTR) && (attname == NULL) && (attvalue == NULL)) { xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "xmlParseStartTag: problem parsing attributes\n"); break; } GROW; if (ctxt->input->base != base) goto base_changed; } /* * The attributes defaulting */ if (ctxt->attsDefault != NULL) { xmlDefAttrsPtr defaults; defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix); if (defaults != NULL) { for (i = 0;i < defaults->nbAttrs;i++) { attname = defaults->values[5 * i]; aprefix = defaults->values[5 * i + 1]; /* * special work for namespaces defaulted defs */ if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { /* * check that it

s not a defined namespace */ for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) break; if (j <= nbNs) continue; nsname = xmlGetNamespace(ctxt, attname); if (nsname != defaults->values[2]) { if (nsPush(ctxt, attname, defaults->values[5 * i + 2]) > 0) nbNs++; } } else { /* * check that it

standalone: attribute %s on %s defaulted from external subset\n

Namespace prefix %s for %s on %s is not defined\n

Namespaced Attribute %s in '%s' redefined\n

Namespace prefix %s on %s is not defined\n

t changed */ if (attval != 0) { for (i = 3,j = 0; j < nratts;i += 5,j++) if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) xmlFree((xmlChar *) atts[i]); } ctxt->input->cur = ctxt->input->base + cur; ctxt->input->line = oldline; ctxt->input->col = oldcol; if (ctxt->wellFormed == 1) { goto reparse; } return(NULL); } /** * xmlParseEndTag2: * @ctxt: an XML parser context * @line: line of the start tag * @nsNr: number of namespaces on the start tag * * parse an end of tag * * [42] ETag ::=

Name S?

* * With namespace * * [NS 9] ETag ::=

QName S?

*/ static void xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URI, int line, int nsNr, int tlen) { const xmlChar *name; GROW; if ((RAW !=

) || (NXT(1) !=

)) { xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL); return; } SKIP(2); if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) { if (ctxt->input->cur[tlen] ==

) { ctxt->input->cur += tlen + 1; goto done; } ctxt->input->cur += tlen; name = (xmlChar*)1; } else { if (prefix == NULL) name = xmlParseNameAndCompare(ctxt, ctxt->name); else name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix); } /* * We should definitely be at the ending "S?

" part */ GROW; SKIP_BLANKS; if ((!IS_BYTE_CHAR(RAW)) || (RAW !=

)) { xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL); } else NEXT1; /* * [ WFC: Element Type Match ] * The Name in an element

unparseable

Opening and ending tag mismatch: %s line %d and %s\n

<![CDATA[

]]>

]]>

<

!

[

C

D

A

T

A

[

]

]

>

>

CData section not finished\n%.50s\n

<

/

<

?

<

!

[

C

D

A

T

A

[

<

!

-

-

<

s Name, create the node */ else if (*cur ==

) { xmlParseReference(ctxt); } /* * Last case, text. Note that References are handled directly. */ else { xmlParseCharData(ctxt, 0); } GROW; /* * Pop-up of finished entities. */ while ((RAW == 0) && (ctxt->inputNr > 1)) xmlPopInput(ctxt); SHRINK; if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) { xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "detected an error in element content\n"); ctxt->instate = XML_PARSER_EOF; break; } } } /** * xmlParseElement: * @ctxt: an XML parser context * * parse an XML element, this is highly recursive * * [39] element ::= EmptyElemTag | STag content ETag * * [ WFC: Element Type Match ] * The Name in an element

Excessive depth in document: %d use XML_PARSE_HUGE option\n

/

>

>

Couldn't find end of Start Tag %s line %d\n

Premature end of data in tag %s line %d\n

</

1.

0

9

.

0

9

version

VersionNum

VersionNum

=

1.0

v

e

r

s

i

o

n

=

"

"

\'

\'

-

a

z

A

Z

a

z

A

Z

0

9

.

_

-

encoding

"

"

'

'

e

n

c

o

d

i

n

g

=

"

"

\'

\'

UTF-16

UTF16

Document labelled UTF-16 but has UTF-8 content\n

UTF-8

UTF8

Unsupported encoding %s\n

standalone

'

yes

no

'

"

yes

no

"

no

yes

no

s

t

a

n

d

a

l

o

n

e

=

\'

n

o

y

e

s

\'

"

n

o

y

e

s

"

<?xml

?>

<?xml

Blank needed after '<?xml'\n

Unsupported version '%s'\n

1

.

Unsupported version '%s'\n

Unsupported version '%s'\n

?

>

Blank needed here\n

?

>

Blank needed here\n

?

>

>

<

?

<

!

-

-

<

?

<

?

x

m

l

<

!

D

O

C

T

Y

P

E

[

<

Start tag expected, '<' not found\n

<

?

x

m

l

t make sense */ ctxt->instate = XML_PARSER_CONTENT; ctxt->validate = 0; ctxt->loadsubset = 0; ctxt->depth = 0; xmlParseContent(ctxt); if ((RAW ==

) && (NXT(1) ==

)) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } else if (RAW != 0) { xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL); } /* * SAX: end of the document processing. */ if ((ctxt->sax) && (ctxt->sax->endDocument != NULL)) ctxt->sax->endDocument(ctxt->userData); if (! ctxt->wellFormed) return(-1); return(0); } #ifdef LIBXML_PUSH_ENABLED /************************************************************************ * * * Progressive parsing interfaces * * * ************************************************************************/ /** * xmlParseLookupSequence: * @ctxt: an XML parser context * @first: the first char to lookup * @next: the next char to lookup or zero * @third: the next char to lookup or zero * * Try to find if a sequence (first, next, third) or just (first next) or * (first) is available in the input stream. * This function has a side effect of (possibly) incrementing ctxt->checkIndex * to avoid rescanning sequences of bytes, it DOES change the state of the * parser, do not use liberally. * * Returns the index to the current parsing point if the full sequence * is available, -1 otherwise. */ static int xmlParseLookupSequence(xmlParserCtxtPtr ctxt, xmlChar first, xmlChar next, xmlChar third) { int base, len; xmlParserInputPtr in; const xmlChar *buf; in = ctxt->input; if (in == NULL) return(-1); base = in->cur - in->base; if (base < 0) return(-1); if (ctxt->checkIndex > base) base = ctxt->checkIndex; if (in->buf == NULL) { buf = in->base; len = in->length; } else { buf = in->buf->buffer->content; len = in->buf->buffer->use; } /* take into account the sequence length */ if (third) len -= 2; else if (next) len --; for (;base < len;base++) { if (buf[base] == first) { if (third != 0) { if ((buf[base + 1] != next) || (buf[base + 2] != third)) continue; } else if (next != 0) { if (buf[base + 1] != next) continue; } ctxt->checkIndex = 0; #ifdef DEBUG_PUSH if (next == 0) xmlGenericError(xmlGenericErrorContext, "PP: lookup

found at %d\n", first, base); else if (third == 0) xmlGenericError(xmlGenericErrorContext, "PP: lookup

found at %d\n", first, next, base); else xmlGenericError(xmlGenericErrorContext, "PP: lookup

found at %d\n", first, next, third, base); #endif return(base - (in->cur - in->base)); } } ctxt->checkIndex = base; #ifdef DEBUG_PUSH if (next == 0) xmlGenericError(xmlGenericErrorContext, "PP: lookup

failed\n", first); else if (third == 0) xmlGenericError(xmlGenericErrorContext, "PP: lookup

failed\n", first, next); else xmlGenericError(xmlGenericErrorContext, "PP: lookup

failed\n", first, next, third); #endif return(-1); } /** * xmlParseGetLasts: * @ctxt: an XML parser context * @lastlt: pointer to store the last

from the input * @lastgt: pointer to store the last

from the input * * Lookup the last < and > in the current chunk */ static void xmlParseGetLasts(xmlParserCtxtPtr ctxt, const xmlChar **lastlt, const xmlChar **lastgt) { const xmlChar *tmp; if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) { xmlGenericError(xmlGenericErrorContext, "Internal error: xmlParseGetLasts\n"); return; } if ((ctxt->progressive != 0) && (ctxt->inputNr == 1)) { tmp = ctxt->input->end; tmp--; while ((tmp >= ctxt->input->base) && (*tmp !=

)) tmp--; if (tmp < ctxt->input->base) { *lastlt = NULL; *lastgt = NULL; } else { *lastlt = tmp; tmp++; while ((tmp < ctxt->input->end) && (*tmp !=

)) { if (*tmp ==



\'

"

"

>

PP: try EOF\n

PP: try START\n

PP: try MISC\n

PP: try COMMENT\n

PP: try PROLOG\n

PP: try START_TAG\n

PP: try CONTENT\n

PP: try CDATA_SECTION\n

PP: try END_TAG\n

PP: try ENTITY_DECL\n

PP: try ENTITY_VALUE\n

PP: try ATTRIBUTE_VALUE\n

PP: try DTD\n

PP: try EPILOG\n

PP: try PI\n

PP: try IGNORE\n



PP: entering EOF\n

<

?

?

>

x

m

l

PP: Parsing XML Decl\n

PP: entering MISC\n

PP: entering MISC\n

PP: entering MISC\n

<

>

/

>

>

Couldn't find end of Start Tag %s\n

<

/

<

?

?

>

<

!

<

!

-

-

-

-

>

<

!

[

C

D

A

T

A

[

<

!

&

;

character

<

<

detected an error in element content\n

>

]

]

>

<![CDATA[



PP: entering CONTENT\n

<

?

?

>

PP: Parsing PI\n

<

!

-

-

-

-

>

PP: Parsing Comment\n

<

!

D

O

C

T

Y

P

E

>

PP: Parsing internal subset\n

[

PP: entering DTD\n

PP: entering PROLOG\n

<

!

PP: entering START_TAG\n

<

?

?

>

PP: Parsing PI\n

<

!

-

-

-

-

>

PP: Parsing Comment\n

<

!

PP: entering START_TAG\n

<

?

?

>

PP: Parsing PI\n

<

!

-

-

-

-

>

PP: Parsing Comment\n

<

!

PP: entering EOF\n

']' S? '>'

]]>

<

!

-

-

-

-

>

unfinished comment\n

"

"

\'

\'

]

%c%c%c%c:

]

]

>

found\n

not found\n

end of stream\n

t found the end of the Internal subset */ #ifdef DEBUG_PUSH if (next == 0) xmlGenericError(xmlGenericErrorContext, "PP: lookup of int subset end filed\n"); #endif goto done; found_end_int_subset: xmlParseInternalSubset(ctxt); ctxt->inSubset = 2; if ((ctxt->sax != NULL) && (!ctxt->disableSAX) && (ctxt->sax->externalSubset != NULL)) ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName, ctxt->extSubSystem, ctxt->extSubURI); ctxt->inSubset = 0; xmlCleanSpecialAttr(ctxt); ctxt->instate = XML_PARSER_PROLOG; ctxt->checkIndex = 0; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering PROLOG\n"); #endif break; } case XML_PARSER_COMMENT: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == COMMENT\n"); ctxt->instate = XML_PARSER_CONTENT; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering CONTENT\n"); #endif break; case XML_PARSER_IGNORE: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == IGNORE"); ctxt->instate = XML_PARSER_DTD; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering DTD\n"); #endif break; case XML_PARSER_PI: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == PI\n"); ctxt->instate = XML_PARSER_CONTENT; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering CONTENT\n"); #endif break; case XML_PARSER_ENTITY_DECL: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ENTITY_DECL\n"); ctxt->instate = XML_PARSER_DTD; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering DTD\n"); #endif break; case XML_PARSER_ENTITY_VALUE: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ENTITY_VALUE\n"); ctxt->instate = XML_PARSER_CONTENT; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering DTD\n"); #endif break; case XML_PARSER_ATTRIBUTE_VALUE: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ATTRIBUTE_VALUE\n"); ctxt->instate = XML_PARSER_START_TAG; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering START_TAG\n"); #endif break; case XML_PARSER_SYSTEM_LITERAL: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == SYSTEM_LITERAL\n"); ctxt->instate = XML_PARSER_START_TAG; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering START_TAG\n"); #endif break; case XML_PARSER_PUBLIC_LITERAL: xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == PUBLIC_LITERAL\n"); ctxt->instate = XML_PARSER_START_TAG; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: entering START_TAG\n"); #endif break; } } done: #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret); #endif return(ret); encoding_error: { char buffer[150]; snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", ctxt->input->cur[0], ctxt->input->cur[1], ctxt->input->cur[2], ctxt->input->cur[3]); __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR, "Input is not proper UTF-8, indicate encoding !\n%s", BAD_CAST buffer, NULL); } return(0); } /** * xmlParseChunk: * @ctxt: an XML parser context * @chunk: an char array * @size: the size in byte of the chunk * @terminate: last chunk indicator * * Parse a Chunk of memory * * Returns zero if no error, the xmlParserErrors otherwise. */ int xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate) { int end_in_lf = 0; int remain = 0; if (ctxt == NULL) return(XML_ERR_INTERNAL_ERROR); if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1)) return(ctxt->errNo); if (ctxt->instate == XML_PARSER_START) xmlDetectSAX2(ctxt); if ((size > 0) && (chunk != NULL) && (!terminate) && (chunk[size - 1] ==

)) { end_in_lf = 1; size--; } xmldecl_done: if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) && (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF)) { int base = ctxt->input->base - ctxt->input->buf->buffer->content; int cur = ctxt->input->cur - ctxt->input->base; int res; /* * Specific handling if we autodetected an encoding, we should not * push more than the first line ... which depend on the encoding * And only push the rest once the final encoding was detected */ if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) && (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) { int len = 45; if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name, BAD_CAST "UTF-16")) || (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name, BAD_CAST "UTF16"))) len = 90; else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name, BAD_CAST "UCS-4")) || (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name, BAD_CAST "UCS4"))) len = 180; if (ctxt->input->buf->rawconsumed < len) len -= ctxt->input->buf->rawconsumed; remain = size - len; size = len; } res =xmlParserInputBufferPush(ctxt->input->buf, size, chunk); if (res < 0) { ctxt->errNo = XML_PARSER_EOF; ctxt->disableSAX = 1; return (XML_PARSER_EOF); } ctxt->input->base = ctxt->input->buf->buffer->content + base; ctxt->input->cur = ctxt->input->base + cur; ctxt->input->end = &ctxt->input->buf->buffer->content[ctxt->input->buf->buffer->use]; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size); #endif } else if (ctxt->instate != XML_PARSER_EOF) { if ((ctxt->input != NULL) && ctxt->input->buf != NULL) { xmlParserInputBufferPtr in = ctxt->input->buf; if ((in->encoder != NULL) && (in->buffer != NULL) && (in->raw != NULL)) { int nbchars; nbchars = xmlCharEncInFunc(in->encoder, in->buffer, in->raw); if (nbchars < 0) { /* TODO 2.6.0 */ xmlGenericError(xmlGenericErrorContext, "xmlParseChunk: encoder error\n"); return(XML_ERR_INVALID_ENCODING); } } } } if (remain != 0) xmlParseTryOrFinish(ctxt, 0); else xmlParseTryOrFinish(ctxt, terminate); if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1)) return(ctxt->errNo); if (remain != 0) { chunk += size; size = remain; remain = 0; goto xmldecl_done; } if ((end_in_lf == 1) && (ctxt->input != NULL) && (ctxt->input->buf != NULL)) { xmlParserInputBufferPush(ctxt->input->buf, 1, "\r"); } if (terminate) { /* * Check for termination */ int avail = 0; if (ctxt->input != NULL) { if (ctxt->input->buf == NULL) avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base); else avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base); } if ((ctxt->instate != XML_PARSER_EOF) && (ctxt->instate != XML_PARSER_EPILOG)) { xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL); } if ((ctxt->instate == XML_PARSER_EPILOG) && (avail > 0)) { xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL); } if (ctxt->instate != XML_PARSER_EOF) { if ((ctxt->sax) && (ctxt->sax->endDocument != NULL)) ctxt->sax->endDocument(ctxt->userData); } ctxt->instate = XML_PARSER_EOF; } return((xmlParserErrors) ctxt->errNo); } /************************************************************************ * * * I/O front end functions to the parser * * * ************************************************************************/ /** * xmlCreatePushParserCtxt: * @sax: a SAX handler * @user_data: The user data returned on SAX callbacks * @chunk: a pointer to an array of chars * @size: number of chars in the array * @filename: an optional file name or URI * * Create a parser context for using the XML parser in push mode. * If @buffer and @size are non-NULL, the data is used to detect * the encoding. The remaining characters will be parsed so they * don

creating parser: out of memory\n

t provide an initial

for determining * the encoding, we set the context to XML_CHAR_ENCODING_NONE so * that it can be automatically determined later */ if ((size == 0) || (chunk == NULL)) { ctxt->charset = XML_CHAR_ENCODING_NONE; } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) { int base = ctxt->input->base - ctxt->input->buf->buffer->content; int cur = ctxt->input->cur - ctxt->input->base; xmlParserInputBufferPush(ctxt->input->buf, size, chunk); ctxt->input->base = ctxt->input->buf->buffer->content + base; ctxt->input->cur = ctxt->input->base + cur; ctxt->input->end = &ctxt->input->buf->buffer->content[ctxt->input->buf->buffer->use]; #ifdef DEBUG_PUSH xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size); #endif } if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } return(ctxt); } #endif /* LIBXML_PUSH_ENABLED */ /** * xmlStopParser: * @ctxt: an XML parser context * * Blocks further parser processing */ void xmlStopParser(xmlParserCtxtPtr ctxt) { if (ctxt == NULL) return; ctxt->instate = XML_PARSER_EOF; ctxt->disableSAX = 1; if (ctxt->input != NULL) { ctxt->input->cur = BAD_CAST""; ctxt->input->base = ctxt->input->cur; } } /** * xmlCreateIOParserCtxt: * @sax: a SAX handler * @user_data: The user data returned on SAX callbacks * @ioread: an I/O read function * @ioclose: an I/O close function * @ioctx: an I/O handler * @enc: the charset encoding if known * * Create a parser context for using the XML parser with an existing * I/O stream * * Returns the new parser context or NULL */ xmlParserCtxtPtr xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, xmlCharEncoding enc) { xmlParserCtxtPtr ctxt; xmlParserInputPtr inputStream; xmlParserInputBufferPtr buf; if (ioread == NULL) return(NULL); buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc); if (buf == NULL) return(NULL); ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { xmlFreeParserInputBuffer(buf); return(NULL); } if (sax != NULL) { #ifdef LIBXML_SAX1_ENABLED if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler) #endif /* LIBXML_SAX1_ENABLED */ xmlFree(ctxt->sax); ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler)); if (ctxt->sax == NULL) { xmlErrMemory(ctxt, NULL); xmlFreeParserCtxt(ctxt); return(NULL); } memset(ctxt->sax, 0, sizeof(xmlSAXHandler)); if (sax->initialized == XML_SAX2_MAGIC) memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler)); else memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1)); if (user_data != NULL) ctxt->userData = user_data; } inputStream = xmlNewIOInputStream(ctxt, buf, enc); if (inputStream == NULL) { xmlFreeParserCtxt(ctxt); return(NULL); } inputPush(ctxt, inputStream); return(ctxt); } #ifdef LIBXML_VALID_ENABLED /************************************************************************ * * * Front ends when parsing a DTD * * * ************************************************************************/ /** * xmlIOParseDTD: * @sax: the SAX handler block or NULL * @input: an Input Buffer * @enc: the charset encoding if known * * Load and parse a DTD * * Returns the resulting xmlDtdPtr or NULL in case of error. * @input will be freed by the function in any case. */ xmlDtdPtr xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input, xmlCharEncoding enc) { xmlDtdPtr ret = NULL; xmlParserCtxtPtr ctxt; xmlParserInputPtr pinput = NULL; xmlChar start[4]; if (input == NULL) return(NULL); ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { xmlFreeParserInputBuffer(input); return(NULL); } /* * Set-up the SAX context */ if (sax != NULL) { if (ctxt->sax != NULL) xmlFree(ctxt->sax); ctxt->sax = sax; ctxt->userData = ctxt; } xmlDetectSAX2(ctxt); /* * generate a parser input from the I/O handler */ pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE); if (pinput == NULL) { if (sax != NULL) ctxt->sax = NULL; xmlFreeParserInputBuffer(input); xmlFreeParserCtxt(ctxt); return(NULL); } /* * plug some encoding conversion routines here. */ if (xmlPushInput(ctxt, pinput) < 0) { if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(NULL); } if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } pinput->filename = NULL; pinput->line = 1; pinput->col = 1; pinput->base = ctxt->input->cur; pinput->cur = ctxt->input->cur; pinput->free = NULL; /* * let

s an external subset. */ ctxt->inSubset = 2; ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0"); if (ctxt->myDoc == NULL) { xmlErrMemory(ctxt, "New Doc failed"); return(NULL); } ctxt->myDoc->properties = XML_DOC_INTERNAL; ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none", BAD_CAST "none", BAD_CAST "none"); if ((enc == XML_CHAR_ENCODING_NONE) && ((ctxt->input->end - ctxt->input->cur) >= 4)) { /* * Get the 4 first bytes and decode the charset * if enc != XML_CHAR_ENCODING_NONE * plug some encoding conversion routines. */ start[0] = RAW; start[1] = NXT(1); start[2] = NXT(2); start[3] = NXT(3); enc = xmlDetectCharEncoding(start, 4); if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } } xmlParseExternalSubset(ctxt, BAD_CAST "none", BAD_CAST "none"); if (ctxt->myDoc != NULL) { if (ctxt->wellFormed) { ret = ctxt->myDoc->extSubset; ctxt->myDoc->extSubset = NULL; if (ret != NULL) { xmlNodePtr tmp; ret->doc = NULL; tmp = ret->children; while (tmp != NULL) { tmp->doc = NULL; tmp = tmp->next; } } } else { ret = NULL; } xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(ret); } /** * xmlSAXParseDTD: * @sax: the SAX handler block * @ExternalID: a NAME* containing the External ID of the DTD * @SystemID: a NAME* containing the URL to the DTD * * Load and parse an external subset. * * Returns the resulting xmlDtdPtr or NULL in case of error. */ xmlDtdPtr xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID, const xmlChar *SystemID) { xmlDtdPtr ret = NULL; xmlParserCtxtPtr ctxt; xmlParserInputPtr input = NULL; xmlCharEncoding enc; xmlChar* systemIdCanonic; if ((ExternalID == NULL) && (SystemID == NULL)) return(NULL); ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { return(NULL); } /* * Set-up the SAX context */ if (sax != NULL) { if (ctxt->sax != NULL) xmlFree(ctxt->sax); ctxt->sax = sax; ctxt->userData = ctxt; } /* * Canonicalise the system ID */ systemIdCanonic = xmlCanonicPath(SystemID); if ((SystemID != NULL) && (systemIdCanonic == NULL)) { xmlFreeParserCtxt(ctxt); return(NULL); } /* * Ask the Entity resolver to load the damn thing */ if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL)) input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID, systemIdCanonic); if (input == NULL) { if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); if (systemIdCanonic != NULL) xmlFree(systemIdCanonic); return(NULL); } /* * plug some encoding conversion routines here. */ if (xmlPushInput(ctxt, input) < 0) { if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); if (systemIdCanonic != NULL) xmlFree(systemIdCanonic); return(NULL); } if ((ctxt->input->end - ctxt->input->cur) >= 4) { enc = xmlDetectCharEncoding(ctxt->input->cur, 4); xmlSwitchEncoding(ctxt, enc); } if (input->filename == NULL) input->filename = (char *) systemIdCanonic; else xmlFree(systemIdCanonic); input->line = 1; input->col = 1; input->base = ctxt->input->cur; input->cur = ctxt->input->cur; input->free = NULL; /* * let

s an external subset. */ ctxt->inSubset = 2; ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0"); if (ctxt->myDoc == NULL) { xmlErrMemory(ctxt, "New Doc failed"); if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(NULL); } ctxt->myDoc->properties = XML_DOC_INTERNAL; ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none", ExternalID, SystemID); xmlParseExternalSubset(ctxt, ExternalID, SystemID); if (ctxt->myDoc != NULL) { if (ctxt->wellFormed) { ret = ctxt->myDoc->extSubset; ctxt->myDoc->extSubset = NULL; if (ret != NULL) { xmlNodePtr tmp; ret->doc = NULL; tmp = ret->children; while (tmp != NULL) { tmp->doc = NULL; tmp = tmp->next; } } } else { ret = NULL; } xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(ret); } /** * xmlParseDTD: * @ExternalID: a NAME* containing the External ID of the DTD * @SystemID: a NAME* containing the URL to the DTD * * Load and parse an external subset. * * Returns the resulting xmlDtdPtr or NULL in case of error. */ xmlDtdPtr xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) { return(xmlSAXParseDTD(NULL, ExternalID, SystemID)); } #endif /* LIBXML_VALID_ENABLED */ /************************************************************************ * * * Front ends when parsing an Entity * * * ************************************************************************/ /** * xmlParseCtxtExternalEntity: * @ctx: the existing parsing context * @URL: the URL for the entity to load * @ID: the System ID for the entity to load * @lst: the return value for the set of parsed nodes * * Parse an external general entity within an existing parsing context * An external general parsed entity is well-formed if it matches the * production labeled extParsedEnt. * * [78] extParsedEnt ::= TextDecl? content * * Returns 0 if the entity is well formed, -1 in case of args problem and * the parser error code otherwise */ int xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) { xmlParserCtxtPtr ctxt; xmlDocPtr newDoc; xmlNodePtr newRoot; xmlSAXHandlerPtr oldsax = NULL; int ret = 0; xmlChar start[4]; xmlCharEncoding enc; if (ctx == NULL) return(-1); if (((ctx->depth > 40) && ((ctx->options & XML_PARSE_HUGE) == 0)) || (ctx->depth > 1024)) { return(XML_ERR_ENTITY_LOOP); } if (lst != NULL) *lst = NULL; if ((URL == NULL) && (ID == NULL)) return(-1); if (ctx->myDoc == NULL) /* @@ relax but check for dereferences */ return(-1); ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx); if (ctxt == NULL) { return(-1); } oldsax = ctxt->sax; ctxt->sax = ctx->sax; xmlDetectSAX2(ctxt); newDoc = xmlNewDoc(BAD_CAST "1.0"); if (newDoc == NULL) { xmlFreeParserCtxt(ctxt); return(-1); } newDoc->properties = XML_DOC_INTERNAL; if (ctx->myDoc->dict) { newDoc->dict = ctx->myDoc->dict; xmlDictReference(newDoc->dict); } if (ctx->myDoc != NULL) { newDoc->intSubset = ctx->myDoc->intSubset; newDoc->extSubset = ctx->myDoc->extSubset; } if (ctx->myDoc->URL != NULL) { newDoc->URL = xmlStrdup(ctx->myDoc->URL); } newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL); if (newRoot == NULL) { ctxt->sax = oldsax; xmlFreeParserCtxt(ctxt); newDoc->intSubset = NULL; newDoc->extSubset = NULL; xmlFreeDoc(newDoc); return(-1); } xmlAddChild((xmlNodePtr) newDoc, newRoot); nodePush(ctxt, newDoc->children); if (ctx->myDoc == NULL) { ctxt->myDoc = newDoc; } else { ctxt->myDoc = ctx->myDoc; newDoc->children->doc = ctx->myDoc; } /* * Get the 4 first bytes and decode the charset * if enc != XML_CHAR_ENCODING_NONE * plug some encoding conversion routines. */ GROW if ((ctxt->input->end - ctxt->input->cur) >= 4) { start[0] = RAW; start[1] = NXT(1); start[2] = NXT(2); start[3] = NXT(3); enc = xmlDetectCharEncoding(start, 4); if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } } /* * Parse a possible text declaration first */ if ((CMP5(CUR_PTR,

,

,

,

,

)) && (IS_BLANK_CH(NXT(5)))) { xmlParseTextDecl(ctxt); /* * An XML-1.0 document can

1.0

1.0

Version mismatch between document and entity\n

t make sense */ ctxt->instate = XML_PARSER_CONTENT; ctxt->validate = ctx->validate; ctxt->valid = ctx->valid; ctxt->loadsubset = ctx->loadsubset; ctxt->depth = ctx->depth + 1; ctxt->replaceEntities = ctx->replaceEntities; if (ctxt->validate) { ctxt->vctxt.error = ctx->vctxt.error; ctxt->vctxt.warning = ctx->vctxt.warning; } else { ctxt->vctxt.error = NULL; ctxt->vctxt.warning = NULL; } ctxt->vctxt.nodeTab = NULL; ctxt->vctxt.nodeNr = 0; ctxt->vctxt.nodeMax = 0; ctxt->vctxt.node = NULL; if (ctxt->dict != NULL) xmlDictFree(ctxt->dict); ctxt->dict = ctx->dict; ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3); ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5); ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36); ctxt->dictNames = ctx->dictNames; ctxt->attsDefault = ctx->attsDefault; ctxt->attsSpecial = ctx->attsSpecial; ctxt->linenumbers = ctx->linenumbers; xmlParseContent(ctxt); ctx->validate = ctxt->validate; ctx->valid = ctxt->valid; if ((RAW ==

) && (NXT(1) ==

)) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } else if (RAW != 0) { xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL); } if (ctxt->node != newDoc->children) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } if (!ctxt->wellFormed) { if (ctxt->errNo == 0) ret = 1; else ret = ctxt->errNo; } else { if (lst != NULL) { xmlNodePtr cur; /* * Return the newly created nodeset after unlinking it from * they pseudo parent. */ cur = newDoc->children->children; *lst = cur; while (cur != NULL) { cur->parent = NULL; cur = cur->next; } newDoc->children->children = NULL; } ret = 0; } ctxt->sax = oldsax; ctxt->dict = NULL; ctxt->attsDefault = NULL; ctxt->attsSpecial = NULL; xmlFreeParserCtxt(ctxt); newDoc->intSubset = NULL; newDoc->extSubset = NULL; xmlFreeDoc(newDoc); return(ret); } /** * xmlParseExternalEntityPrivate: * @doc: the document the chunk pertains to * @oldctxt: the previous parser context if available * @sax: the SAX handler bloc (possibly NULL) * @user_data: The user data returned on SAX callbacks (possibly NULL) * @depth: Used for loop detection, use 0 * @URL: the URL for the entity to load * @ID: the System ID for the entity to load * @list: the return value for the set of parsed nodes * * Private version of xmlParseExternalEntity() * * Returns 0 if the entity is well formed, -1 in case of args problem and * the parser error code otherwise */ static xmlParserErrors xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *list) { xmlParserCtxtPtr ctxt; xmlDocPtr newDoc; xmlNodePtr newRoot; xmlSAXHandlerPtr oldsax = NULL; xmlParserErrors ret = XML_ERR_OK; xmlChar start[4]; xmlCharEncoding enc; if (((depth > 40) && ((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) || (depth > 1024)) { return(XML_ERR_ENTITY_LOOP); } if (list != NULL) *list = NULL; if ((URL == NULL) && (ID == NULL)) return(XML_ERR_INTERNAL_ERROR); if (doc == NULL) return(XML_ERR_INTERNAL_ERROR); ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt); if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY); ctxt->userData = ctxt; if (oldctxt != NULL) { ctxt->_private = oldctxt->_private; ctxt->loadsubset = oldctxt->loadsubset; ctxt->validate = oldctxt->validate; ctxt->external = oldctxt->external; ctxt->record_info = oldctxt->record_info; ctxt->node_seq.maximum = oldctxt->node_seq.maximum; ctxt->node_seq.length = oldctxt->node_seq.length; ctxt->node_seq.buffer = oldctxt->node_seq.buffer; } else { /* * Doing validity checking on chunk without context * doesn

1.0

pseudoroot

<

?

x

m

l

<

/

xml

xmlns

1.0

pseudoroot

<

/

s dict if present, else assure XML_PARSE_NODICT is set. * We need a dictionary for xmlDetectSAX2, so if there

<

/

1.0

xml

xmlns

pseudoroot

t make sense */ ctxt->validate = 0; ctxt->loadsubset = 0; xmlDetectSAX2(ctxt); if ( doc != NULL ){ content = doc->children; doc->children = NULL; xmlParseContent(ctxt); doc->children = content; } else { xmlParseContent(ctxt); } if ((RAW ==

) && (NXT(1) ==

)) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } else if (RAW != 0) { xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL); } if (ctxt->node != newDoc->children) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } if (!ctxt->wellFormed) { if (ctxt->errNo == 0) ret = 1; else ret = ctxt->errNo; } else { ret = 0; } if ((lst != NULL) && ((ret == 0) || (recover == 1))) { xmlNodePtr cur; /* * Return the newly created nodeset after unlinking it from * they pseudo parent. */ cur = newDoc->children->children; *lst = cur; while (cur != NULL) { xmlSetTreeDoc(cur, doc); cur->parent = NULL; cur = cur->next; } newDoc->children->children = NULL; } if (sax != NULL) ctxt->sax = oldsax; xmlFreeParserCtxt(ctxt); newDoc->intSubset = NULL; newDoc->extSubset = NULL; newDoc->oldNs = NULL; xmlFreeDoc(newDoc); return(ret); } /** * xmlSAXParseEntity: * @sax: the SAX handler block * @filename: the filename * * parse an XML external entity out of context and build a tree. * It use the given SAX function block to handle the parsing callback. * If sax is NULL, fallback to the default DOM tree building routines. * * [78] extParsedEnt ::= TextDecl? content * * This correspond to a "Well Balanced" chunk * * Returns the resulting document tree */ xmlDocPtr xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename) { xmlDocPtr ret; xmlParserCtxtPtr ctxt; ctxt = xmlCreateFileParserCtxt(filename); if (ctxt == NULL) { return(NULL); } if (sax != NULL) { if (ctxt->sax != NULL) xmlFree(ctxt->sax); ctxt->sax = sax; ctxt->userData = NULL; } xmlParseExtParsedEnt(ctxt); if (ctxt->wellFormed) ret = ctxt->myDoc; else { ret = NULL; xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(ret); } /** * xmlParseEntity: * @filename: the filename * * parse an XML external entity out of context and build a tree. * * [78] extParsedEnt ::= TextDecl? content * * This correspond to a "Well Balanced" chunk * * Returns the resulting document tree */ xmlDocPtr xmlParseEntity(const char *filename) { return(xmlSAXParseEntity(NULL, filename)); } #endif /* LIBXML_SAX1_ENABLED */ /** * xmlCreateEntityParserCtxtInternal: * @URL: the entity URL * @ID: the entity PUBLIC ID * @base: a possible base for the target URI * @pctx: parser context used to set options on new context * * Create a parser context for an external entity * Automatic support for ZLIB/Compress compressed document is provided * by default if found at compile-time. * * Returns the new parser context or NULL */ static xmlParserCtxtPtr xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID, const xmlChar *base, xmlParserCtxtPtr pctx) { xmlParserCtxtPtr ctxt; xmlParserInputPtr inputStream; char *directory = NULL; xmlChar *uri; ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { return(NULL); } if (pctx != NULL) { ctxt->options = pctx->options; ctxt->_private = pctx->_private; } uri = xmlBuildURI(URL, base); if (uri == NULL) { inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt); if (inputStream == NULL) { xmlFreeParserCtxt(ctxt); return(NULL); } inputPush(ctxt, inputStream); if ((ctxt->directory == NULL) && (directory == NULL)) directory = xmlParserGetDirectory((char *)URL); if ((ctxt->directory == NULL) && (directory != NULL)) ctxt->directory = directory; } else { inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt); if (inputStream == NULL) { xmlFree(uri); xmlFreeParserCtxt(ctxt); return(NULL); } inputPush(ctxt, inputStream); if ((ctxt->directory == NULL) && (directory == NULL)) directory = xmlParserGetDirectory((char *)uri); if ((ctxt->directory == NULL) && (directory != NULL)) ctxt->directory = directory; xmlFree(uri); } return(ctxt); } /** * xmlCreateEntityParserCtxt: * @URL: the entity URL * @ID: the entity PUBLIC ID * @base: a possible base for the target URI * * Create a parser context for an external entity * Automatic support for ZLIB/Compress compressed document is provided * by default if found at compile-time. * * Returns the new parser context or NULL */ xmlParserCtxtPtr xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID, const xmlChar *base) { return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL); } /************************************************************************ * * * Front ends when parsing from a file * * * ************************************************************************/ /** * xmlCreateURLParserCtxt: * @filename: the filename or URL * @options: a combination of xmlParserOption * * Create a parser context for a file or URL content. * Automatic support for ZLIB/Compress compressed document is provided * by default if found at compile-time and for file accesses * * Returns the new parser context or NULL */ xmlParserCtxtPtr xmlCreateURLParserCtxt(const char *filename, int options) { xmlParserCtxtPtr ctxt; xmlParserInputPtr inputStream; char *directory = NULL; ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { xmlErrMemory(NULL, "cannot allocate parser context"); return(NULL); } if (options) xmlCtxtUseOptionsInternal(ctxt, options, NULL); ctxt->linenumbers = 1; inputStream = xmlLoadExternalEntity(filename, NULL, ctxt); if (inputStream == NULL) { xmlFreeParserCtxt(ctxt); return(NULL); } inputPush(ctxt, inputStream); if ((ctxt->directory == NULL) && (directory == NULL)) directory = xmlParserGetDirectory(filename); if ((ctxt->directory == NULL) && (directory != NULL)) ctxt->directory = directory; return(ctxt); } /** * xmlCreateFileParserCtxt: * @filename: the filename * * Create a parser context for a file content. * Automatic support for ZLIB/Compress compressed document is provided * by default if found at compile-time. * * Returns the new parser context or NULL */ xmlParserCtxtPtr xmlCreateFileParserCtxt(const char *filename) { return(xmlCreateURLParserCtxt(filename, 0)); } #ifdef LIBXML_SAX1_ENABLED /** * xmlSAXParseFileWithData: * @sax: the SAX handler block * @filename: the filename * @recovery: work in recovery mode, i.e. tries to read no Well Formed * documents * @data: the userdata * * parse an XML file and build a tree. Automatic support for ZLIB/Compress * compressed document is provided by default if found at compile-time. * It use the given SAX function block to handle the parsing callback. * If sax is NULL, fallback to the default DOM tree building routines. * * User data (void *) is stored within the parser context in the * context

parsing new buffer: out of memory\n

s _private member, so it is available nearly everywhere in libxml * * Returns the resulting document tree */ xmlDocPtr xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery, void *data) { xmlDocPtr ret; xmlParserCtxtPtr ctxt; xmlInitParser(); ctxt = xmlCreateMemoryParserCtxt(buffer, size); if (ctxt == NULL) return(NULL); if (sax != NULL) { if (ctxt->sax != NULL) xmlFree(ctxt->sax); ctxt->sax = sax; } xmlDetectSAX2(ctxt); if (data!=NULL) { ctxt->_private=data; } ctxt->recovery = recovery; xmlParseDocument(ctxt); if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc; else { ret = NULL; xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } if (sax != NULL) ctxt->sax = NULL; xmlFreeParserCtxt(ctxt); return(ret); } /** * xmlSAXParseMemory: * @sax: the SAX handler block * @buffer: an pointer to a char array * @size: the size of the array * @recovery: work in recovery mode, i.e. tries to read not Well Formed * documents * * parse an XML in-memory block and use the given SAX function block * to handle the parsing callback. If sax is NULL, fallback to the default * DOM tree building routines. * * Returns the resulting document tree */ xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery) { return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, NULL); } /** * xmlParseMemory: * @buffer: an pointer to a char array * @size: the size of the array * * parse an XML in-memory block and build a tree. * * Returns the resulting document tree */ xmlDocPtr xmlParseMemory(const char *buffer, int size) { return(xmlSAXParseMemory(NULL, buffer, size, 0)); } /** * xmlRecoverMemory: * @buffer: an pointer to a char array * @size: the size of the array * * parse an XML in-memory block and build a tree. * In the case the document is not Well Formed, an attempt to * build a tree is tried anyway * * Returns the resulting document tree or NULL in case of error */ xmlDocPtr xmlRecoverMemory(const char *buffer, int size) { return(xmlSAXParseMemory(NULL, buffer, size, 1)); } /** * xmlSAXUserParseMemory: * @sax: a SAX handler * @user_data: The user data returned on SAX callbacks * @buffer: an in-memory XML document input * @size: the length of the XML document in bytes * * A better SAX parsing routine. * parse an XML in-memory buffer and call the given SAX handler routines. * * Returns 0 in case of success or a error number otherwise */ int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data, const char *buffer, int size) { int ret = 0; xmlParserCtxtPtr ctxt; xmlInitParser(); ctxt = xmlCreateMemoryParserCtxt(buffer, size); if (ctxt == NULL) return -1; if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler) xmlFree(ctxt->sax); ctxt->sax = sax; xmlDetectSAX2(ctxt); if (user_data != NULL) ctxt->userData = user_data; xmlParseDocument(ctxt); if (ctxt->wellFormed) ret = 0; else { if (ctxt->errNo != 0) ret = ctxt->errNo; else ret = -1; } if (sax != NULL) ctxt->sax = NULL; if (ctxt->myDoc != NULL) { xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } xmlFreeParserCtxt(ctxt); return ret; } #endif /* LIBXML_SAX1_ENABLED */ /** * xmlCreateDocParserCtxt: * @cur: a pointer to an array of xmlChar * * Creates a parser context for an XML in-memory document. * * Returns the new parser context or NULL */ xmlParserCtxtPtr xmlCreateDocParserCtxt(const xmlChar *cur) { int len; if (cur == NULL) return(NULL); len = xmlStrlen(cur); return(xmlCreateMemoryParserCtxt((const char *)cur, len)); } #ifdef LIBXML_SAX1_ENABLED /** * xmlSAXParseDoc: * @sax: the SAX handler block * @cur: a pointer to an array of xmlChar * @recovery: work in recovery mode, i.e. tries to read no Well Formed * documents * * parse an XML in-memory document and build a tree. * It use the given SAX function block to handle the parsing callback. * If sax is NULL, fallback to the default DOM tree building routines. * * Returns the resulting document tree */ xmlDocPtr xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery) { xmlDocPtr ret; xmlParserCtxtPtr ctxt; xmlSAXHandlerPtr oldsax = NULL; if (cur == NULL) return(NULL); ctxt = xmlCreateDocParserCtxt(cur); if (ctxt == NULL) return(NULL); if (sax != NULL) { oldsax = ctxt->sax; ctxt->sax = sax; ctxt->userData = NULL; } xmlDetectSAX2(ctxt); xmlParseDocument(ctxt); if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc; else { ret = NULL; xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } if (sax != NULL) ctxt->sax = oldsax; xmlFreeParserCtxt(ctxt); return(ret); } /** * xmlParseDoc: * @cur: a pointer to an array of xmlChar * * parse an XML in-memory document and build a tree. * * Returns the resulting document tree */ xmlDocPtr xmlParseDoc(const xmlChar *cur) { return(xmlSAXParseDoc(NULL, cur, 0)); } #endif /* LIBXML_SAX1_ENABLED */ #ifdef LIBXML_LEGACY_ENABLED /************************************************************************ * * * Specific function to keep track of entities references * * and used by the XSLT debugger * * * ************************************************************************/ static xmlEntityReferenceFunc xmlEntityRefFunc = NULL; /** * xmlAddEntityReference: * @ent : A valid entity * @firstNode : A valid first node for children of entity * @lastNode : A valid last node of children entity * * Notify of a reference to an entity of type XML_EXTERNAL_GENERAL_PARSED_ENTITY */ static void xmlAddEntityReference(xmlEntityPtr ent, xmlNodePtr firstNode, xmlNodePtr lastNode) { if (xmlEntityRefFunc != NULL) { (*xmlEntityRefFunc) (ent, firstNode, lastNode); } } /** * xmlSetEntityReferenceFunc: * @func: A valid function * * Set the function to call call back when a xml reference has been made */ void xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func) { xmlEntityRefFunc = func; } #endif /* LIBXML_LEGACY_ENABLED */ /************************************************************************ * * * Miscellaneous * * * ************************************************************************/ #ifdef LIBXML_XPATH_ENABLED #include <libxml/xpath.h> #endif extern void XMLCDECL xmlGenericErrorDefaultFunc(void *ctx, const char *msg, ...); static int xmlParserInitialized = 0; /** * xmlInitParser: * * Initialization function for the XML parser. * This is not reentrant. Call once before processing in case of * use in multithreaded programs. */ void xmlInitParser(void) { if (xmlParserInitialized != 0) return; #ifdef LIBXML_THREAD_ENABLED __xmlGlobalInitMutexLock(); if (xmlParserInitialized == 0) { #endif xmlInitGlobals(); xmlInitThreads(); if ((xmlGenericError == xmlGenericErrorDefaultFunc) || (xmlGenericError == NULL)) initGenericErrorDefaultFunc(NULL); xmlInitMemory(); xmlInitCharEncodingHandlers(); xmlDefaultSAXHandlerInit(); xmlRegisterDefaultInputCallbacks(); #ifdef LIBXML_OUTPUT_ENABLED xmlRegisterDefaultOutputCallbacks(); #endif /* LIBXML_OUTPUT_ENABLED */ #ifdef LIBXML_HTML_ENABLED htmlInitAutoClose(); htmlDefaultSAXHandlerInit(); #endif #ifdef LIBXML_XPATH_ENABLED xmlXPathInit(); #endif xmlParserInitialized = 1; #ifdef LIBXML_THREAD_ENABLED } __xmlGlobalInitMutexUnlock(); #endif } /** * xmlCleanupParser: * * This function name is somewhat misleading. It does not clean up * parser state, it cleans up memory allocated by the library itself. * It is a cleanup function for the XML library. It tries to reclaim all * related global memory allocated for the library processing. * It doesn

dict

PP: pushed %d\n

Unsupported encoding %s\n

elfgcchack.h

0x20)

0x20)

0x20)

0x20;

0x20)

0x20)

0x20)

0x10FFFF)

0x10FFFF)

0x10FFFF)

0x10FFFF)

0xD))

0x61)

0x7A))

0x41)

0x5A))

0xC0)

0xD6))

0xD8)

0xF6))

0xF8)

0x2FF))

0x370)

0x37D))

0x37F)

0x1FFF))

0x200C)

0x200D))

0x2070)

0x218F))

0x2C00)

0x2FEF))

0x3001)

0xD7FF))

0xF900)

0xFDCF))

0xFDF0)

0xFFFD))

0x10000)

0xEFFFF))))

0xB7)

0xC0)

0xD6))

0xD8)

0xF6))

0xF8)

0x2FF))

0x300)

0x36F))

0x370)

0x37D))

0x37F)

0x1FFF))

0x200C)

0x200D))

0x203F)

0x2040))

0x2070)

0x218F))

0x2C00)

0x2FEF))

0x3001)

0xD7FF))

0xF900)

0xFDCF))

0xFDF0)

0xFFFD))

0x10000)

0xEFFFF))))

0xC0)

0xD6))

0xD8)

0xF6))

0xF8)

0x2FF))

0x370)

0x37D))

0x37F)

0x1FFF))

0x200C)

0x200D))

0x2070)

0x218F))

0x2C00)

0x2FEF))

0x3001)

0xD7FF))

0xF900)

0xFDCF))

0xFDF0)

0xFFFD))

0x10000)

0xEFFFF)))))

0xB7)

0xC0)

0xD6))

0xD8)

0xF6))

0xF8)

0x2FF))

0x300)

0x36F))

0x370)

0x37D))

0x37F)

0x1FFF))

0x200C)

0x200D))

0x203F)

0x2040))

0x2070)

0x218F))

0x2C00)

0x2FEF))

0x3001)

0xD7FF))

0xF900)

0xFDCF))

0xFDF0)

0xFFFD))

0x10000)

0xEFFFF))

0x61)

0x7A))

0x41)

0x5A))

0x61)

0x7A))

0x41)

0x5A))

0x30)

0x39))

0x80))

0x61)

0x7A))

0x41)

0x5A))

0x61)

0x7A))

0x41)

0x5A))

0x30)

0x39))

0x80))

0xD)

0xA)

0x9))

0x20;

0x20)

0xD)

0xA)

0x9))

0x20);

0x20)

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x09,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x9,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x20,

0x21,

0x22,

0x23,

0x24,

0x25,

0x00,

0x27,

0x28,

0x29,

0x2A,

0x2B,

0x2C,

0x2D,

0x2E,

0x2F,

0x30,

0x31,

0x32,

0x33,

0x34,

0x35,

0x36,

0x37,

0x38,

0x39,

0x3A,

0x3B,

0x00,

0x3D,

0x3E,

0x3F,

0x40,

0x41,

0x42,

0x43,

0x44,

0x45,

0x46,

0x47,

0x48,

0x49,

0x4A,

0x4B,

0x4C,

0x4D,

0x4E,

0x4F,

0x50,

0x51,

0x52,

0x53,

0x54,

0x55,

0x56,

0x57,

0x58,

0x59,

0x5A,

0x5B,

0x5C,

0x00,

0x5E,

0x5F,

0x60,

0x61,

0x62,

0x63,

0x64,

0x65,

0x66,

0x67,

0x68,

0x69,

0x6A,

0x6B,

0x6C,

0x6D,

0x6E,

0x6F,

0x70,

0x71,

0x72,

0x73,

0x74,

0x75,

0x76,

0x77,

0x78,

0x79,

0x7A,

0x7B,

0x7C,

0x7D,

0x7E,

0x7F,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x20)

0xA)

0xA);

0xA)

0xA);

0xD)

0xA)

0x20)

0x7F))

0x09));

0xA)

0xA);

0x7F))

0x20)

0x09))

0xA)

0xA);

0xA)

0xD)

0xA)

0x20)

0x7F))

0x09));

0xFF)

0x20)

0x9)

0xA)

0xD)))

0x20)

0x7f)

0x20)

0x20))

0x20)

0x20)

0x9)

0xA)

0xD)))

0x20)

0x7f)

0x80)

0x00)

0x20)

0xA)

0xD)

0x9))

0xe0)

0xc0)

0xc0

0x80)

0x1f)

0x3f;

0xf0)

0xe0)

0xc0)

0x80)

0xc0)

0x80))

0xf)

0x3f)

0x3f;

0xf8)

0xf0)

0xc0)

0x80)

0xc0)

0x80)

0xc0)

0x80))

0x7)

0x3f)

0x3f)

0x3f;

0x%02X

0x%02X

0x%02X

0x%02X\n",

Summary: the core parser module Description: Interfaces, constants and types related to the XML parser Copy: See Copyright for the status of this software. Author: Daniel Veillard

XML_DEFAULT_VERSION: The default version of XML used: 1.0

xmlParserInput: An xmlParserInput is an input flow for the XML processor. Each entity parsed is associated an xmlParserInput (except the few predefined ones). This is the case both for internal entities - in which case the flow is already completely in memory - or external entities - in which case we use the buf structure for progressive reading and I18N conversions to the internal UTF-8 format.

xmlParserInputDeallocate: @str: the string to deallocate Callback for freeing some parser input allocations.

Input buffer

UTF-8 encoded buffer

The file analyzed, if any

the directory/base of the file

Base of the array to parse

Current char being parsed

end of the array to parse

length if known

Current line

Current column

NOTE: consumed is only tested for equality in the parser code, so even if there is an overflow this should not give troubles for parsing very large instances.

How many xmlChars already consumed

function to deallocate the base

the encoding string for entity

the version string for entity

Was that entity marked standalone

an unique identifier for the entity

xmlParserNodeInfo: The parser can be asked to collect Node informations, i.e. at what place in the file they were detected. NOTE: This is off by default and not very well tested.

Position & line # that text that created the node begins & ends on

xmlParserInputState: The parser is now working also as a state based parser. The recursive one use the state info for entities processing.

nothing is to be parsed

nothing has been parsed

Misc before int subset

Within a processing instruction

within some DTD content

Misc after internal subset

within a comment

within a start tag

within the content

within a CDATA section

within a closing tag

within an entity declaration

within an entity value in a decl

within an attribute value

within a SYSTEM value

the Misc after the last end tag

within an IGNORED section

within a PUBLIC value

XML_DETECT_IDS: Bit in the loadsubset context field to tell to do ID/REFs lookups. Use it to initialize xmlLoadExtDtdDefaultValue.

XML_COMPLETE_ATTRS: Bit in the loadsubset context field to tell to do complete the elements attributes lists with the ones defaulted from the DTDs. Use it to initialize xmlLoadExtDtdDefaultValue.

XML_SKIP_IDS: Bit in the loadsubset context field to tell to not do ID/REFs registration. Used to initialize xmlLoadExtDtdDefaultValue in some special cases.

xmlParserMode: A parser can operate in various modes

xmlParserCtxt: The parser context. NOTE This doesn't completely define the parser state, the (current ?) design of the parser uses recursive function calls since this allow and easy mapping from the production rules of the specification to the actual code. The drawback is that the actual function call also reflect the parser state. However most of the parsing routines takes as the only argument the parser context pointer, so migrating to a state based parser for progressive parsing shouldn't be too hard.

The SAX handler

For SAX interface only, used by DOM build

the document being built

is the document well formed

shall we replace entities ?

the XML version string

the declared encoding, if any

standalone document

an HTML(1)/Docbook(2) document 3 is HTML after <head> 10 is HTML after <body>

Input stream stack

Current input stream

Number of current input streams

Max number of input streams

stack of inputs

Node analysis stack only used for DOM building

Current parsed Node

Depth of the parsing stack

Max depth of the parsing stack

array of nodes

Whether node info should be kept

info about each node parsed

error code

reference and external subset

the internal subset has PE refs

are we parsing an external entity

is the document valid

shall we try to validate ?

The validity context

current type of input

next char look-ahead

the data directory

Node name stack

Current parsed Node

Depth of the parsing stack

Max depth of the parsing stack

array of nodes

number of xmlChar processed

used by progressive parsing lookup

ugly but ...

SAX callbacks are disabled

Parsing is in int 1/ext 2 subset

name of subset

URI of external subset

SYSTEM ID of external subset

xml:space values

Should the parser preserve spaces

Depth of the parsing stack

Max depth of the parsing stack

array of space infos

to prevent entity substitution loops

used to check entities boundaries

encoding of the in-memory content actually an xmlCharEncoding

Those two fields are there to

Speed up large node parsing

signal pedantic warnings

For user data, libxml won't touch it

should the external subset be loaded

set line number in element content

document's own catalog

run in recovery mode

is this a progressive parsing

dictionnary for the parser

array for the attributes callbacks

the size of the array

use strings from dict to build tree

pre-interned strings

Everything below is used only by the new SAX mode

operating in the new SAX mode

the number of inherited namespaces

the size of the arrays

the array of prefix/namespace name

which attribute were allocated

array of data for push

defaulted attributes if any

non-CDATA attributes if any

is the document XML Nanespace okay

Extra options

Those fields are needed only for treaming parsing so far

Use dictionary names for the tree

number of freed element nodes

List of freed element nodes

number of freed attributes nodes

List of freed attributes nodes

the complete error informations for the last error.

the parser mode

number of entities references

size of parsed entities

xmlSAXLocator: A SAX Locator.

xmlSAXHandler: A SAX handler is bunch of callbacks called by the parser when processing of the input generate data or structure informations.

resolveEntitySAXFunc: @ctx: the user data (XML parser context) @publicId: The public ID of the entity @systemId: The system ID of the entity Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it's own entity resolution routine Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

internalSubsetSAXFunc: @ctx: the user data (XML parser context) @name: the root element name @ExternalID: the external ID @SystemID: the SYSTEM ID (e.g. filename or URL) Callback on internal subset declaration.

externalSubsetSAXFunc: @ctx: the user data (XML parser context) @name: the root element name @ExternalID: the external ID @SystemID: the SYSTEM ID (e.g. filename or URL) Callback on external subset declaration.

getEntitySAXFunc: @ctx: the user data (XML parser context) @name: The entity name Get an entity by name. Returns the xmlEntityPtr if found.

getParameterEntitySAXFunc: @ctx: the user data (XML parser context) @name: The entity name Get a parameter entity by name. Returns the xmlEntityPtr if found.

entityDeclSAXFunc: @ctx: the user data (XML parser context) @name: the entity name @type: the entity type @publicId: The public ID of the entity @systemId: The system ID of the entity @content: the entity value (without processing). An entity definition has been parsed.

notationDeclSAXFunc: @ctx: the user data (XML parser context) @name: The name of the notation @publicId: The public ID of the entity @systemId: The system ID of the entity What to do when a notation declaration has been parsed.

attributeDeclSAXFunc: @ctx: the user data (XML parser context) @elem: the name of the element @fullname: the attribute name @type: the attribute type @def: the type of default value @defaultValue: the attribute default value @tree: the tree of enumerated value set An attribute definition has been parsed.

elementDeclSAXFunc: @ctx: the user data (XML parser context) @name: the element name @type: the element type @content: the element value tree An element definition has been parsed.

unparsedEntityDeclSAXFunc: @ctx: the user data (XML parser context) @name: The name of the entity @publicId: The public ID of the entity @systemId: The system ID of the entity @notationName: the name of the notation What to do when an unparsed entity declaration is parsed.

setDocumentLocatorSAXFunc: @ctx: the user data (XML parser context) @loc: A SAX Locator Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.

startDocumentSAXFunc: @ctx: the user data (XML parser context) Called when the document start being processed.

endDocumentSAXFunc: @ctx: the user data (XML parser context) Called when the document end has been detected.

startElementSAXFunc: @ctx: the user data (XML parser context) @name: The element name, including namespace prefix @atts: An array of name/value attributes pairs, NULL terminated Called when an opening tag has been processed.

endElementSAXFunc: @ctx: the user data (XML parser context) @name: The element name Called when the end of an element has been detected.

attributeSAXFunc: @ctx: the user data (XML parser context) @name: The attribute name, including namespace prefix @value: The attribute value Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.

referenceSAXFunc: @ctx: the user data (XML parser context) @name: The entity name Called when an entity reference is detected.

charactersSAXFunc: @ctx: the user data (XML parser context) @ch: a xmlChar string @len: the number of xmlChar Receiving some chars from the parser.

ignorableWhitespaceSAXFunc: @ctx: the user data (XML parser context) @ch: a xmlChar string @len: the number of xmlChar Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.

processingInstructionSAXFunc: @ctx: the user data (XML parser context) @target: the target name @data: the PI data's A processing instruction has been parsed.

commentSAXFunc: @ctx: the user data (XML parser context) @value: the comment content A comment has been parsed.

cdataBlockSAXFunc: @ctx: the user data (XML parser context) @value: The pcdata content @len: the block length Called when a pcdata block has been parsed.

warningSAXFunc: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a warning messages, callback.

errorSAXFunc: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format an error messages, callback.

fatalErrorSAXFunc: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format fatal error messages, callback. Note: so far fatalError() SAX callbacks are not used, error() get all the callbacks for errors.

isStandaloneSAXFunc: @ctx: the user data (XML parser context) Is this document tagged standalone? Returns 1 if true

hasInternalSubsetSAXFunc: @ctx: the user data (XML parser context) Does this document has an internal subset. Returns 1 if true

hasExternalSubsetSAXFunc: @ctx: the user data (XML parser context) Does this document has an external subset? Returns 1 if true

The SAX version 2 API extensions

XML_SAX2_MAGIC: Special constant found in SAX2 blocks initialized fields

startElementNsSAX2Func: @ctx: the user data (XML parser context) @localname: the local name of the element @prefix: the element namespace prefix if available @URI: the element namespace name if available @nb_namespaces: number of namespace definitions on that node @namespaces: pointer to the array of prefix/URI pairs namespace definitions @nb_attributes: the number of attributes on that node @nb_defaulted: the number of defaulted attributes. The defaulted ones are at the end of the array @attributes: pointer to the array of (localname/prefix/URI/value/end) attribute values. SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.

endElementNsSAX2Func: @ctx: the user data (XML parser context) @localname: the local name of the element @prefix: the element namespace prefix if available @URI: the element namespace name if available SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.

unused error() get all the errors

The following fields are extensions available only on version 2

SAX Version 1

unused error() get all the errors

xmlExternalEntityLoader: @URL: The System ID of the resource requested @ID: The Public ID of the resource requested @context: the XML parser context External entity loaders types. Returns the entity input parser.

Init/Cleanup

Input functions

Basic parsing Interfaces

LIBXML_SAX1_ENABLED

Recovery mode

LIBXML_SAX1_ENABLED

Less common routines and SAX interfaces

LIBXML_SAX1_ENABLED

LIBXML_VALID_ENABLE

LIBXML_SAX1_ENABLED

LIBXML_SAX1_ENABLED

Parser contexts handling.

LIBXML_SAX1_ENABLED

Reading/setting optional parsing features.

LIBXML_LEGACY_ENABLED

Interfaces for the Push mode.

LIBXML_PUSH_ENABLED

Special I/O mode.

Node infos.

External entities handling actually implemented in xmlIO.

Index lookup, actually implemented in the encoding module

New set of simpler/more flexible APIs

xmlParserOption: This is the set of XML parser options that can be passed down to the xmlReadDoc() and similar calls.

recover on errors

substitute entities

load the external subset

default DTD attributes

validate with the DTD

suppress error reports

suppress warning reports

pedantic error reporting

remove blank nodes

use the SAX1 interface internally

Implement XInclude substitition

Forbid network access

Do not reuse the context dictionnary

remove redundant namespaces declarations

merge CDATA as text nodes

do not generate XINCLUDE START/END nodes

compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)

parse using XML-1.0 before update 5

do not fixup XINCLUDE xml:base uris

relax any hardcoded limit from the parser

parse using SAX2 interface from before 2.7.0

Library wide options

xmlFeature: Used to examine the existance of features that can be enabled or disabled at compile-time. They used to be called XML_FEATURE_xxx but this clashed with Expat

just to be sure of allocation size

__XML_PARSER_H__

C

1.0

t completely define the parser state, the (current ?) * design of the parser uses recursive function calls since this allow * and easy mapping from the production rules of the specification * to the actual code. The drawback is that the actual function call * also reflect the parser state. However most of the parsing routines * takes as the only argument the parser context pointer, so migrating * to a state based parser for progressive parsing shouldn

t touch it */ int loadsubset; /* should the external subset be loaded */ int linenumbers; /* set line number in element content */ void *catalogs; /* document

s own entity resolution routine * * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour. */ typedef xmlParserInputPtr (*resolveEntitySAXFunc) (void *ctx, const xmlChar *publicId, const xmlChar *systemId); /** * internalSubsetSAXFunc: * @ctx: the user data (XML parser context) * @name: the root element name * @ExternalID: the external ID * @SystemID: the SYSTEM ID (e.g. filename or URL) * * Callback on internal subset declaration. */ typedef void (*internalSubsetSAXFunc) (void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID); /** * externalSubsetSAXFunc: * @ctx: the user data (XML parser context) * @name: the root element name * @ExternalID: the external ID * @SystemID: the SYSTEM ID (e.g. filename or URL) * * Callback on external subset declaration. */ typedef void (*externalSubsetSAXFunc) (void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID); /** * getEntitySAXFunc: * @ctx: the user data (XML parser context) * @name: The entity name * * Get an entity by name. * * Returns the xmlEntityPtr if found. */ typedef xmlEntityPtr (*getEntitySAXFunc) (void *ctx, const xmlChar *name); /** * getParameterEntitySAXFunc: * @ctx: the user data (XML parser context) * @name: The entity name * * Get a parameter entity by name. * * Returns the xmlEntityPtr if found. */ typedef xmlEntityPtr (*getParameterEntitySAXFunc) (void *ctx, const xmlChar *name); /** * entityDeclSAXFunc: * @ctx: the user data (XML parser context) * @name: the entity name * @type: the entity type * @publicId: The public ID of the entity * @systemId: The system ID of the entity * @content: the entity value (without processing). * * An entity definition has been parsed. */ typedef void (*entityDeclSAXFunc) (void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content); /** * notationDeclSAXFunc: * @ctx: the user data (XML parser context) * @name: The name of the notation * @publicId: The public ID of the entity * @systemId: The system ID of the entity * * What to do when a notation declaration has been parsed. */ typedef void (*notationDeclSAXFunc)(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId); /** * attributeDeclSAXFunc: * @ctx: the user data (XML parser context) * @elem: the name of the element * @fullname: the attribute name * @type: the attribute type * @def: the type of default value * @defaultValue: the attribute default value * @tree: the tree of enumerated value set * * An attribute definition has been parsed. */ typedef void (*attributeDeclSAXFunc)(void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree); /** * elementDeclSAXFunc: * @ctx: the user data (XML parser context) * @name: the element name * @type: the element type * @content: the element value tree * * An element definition has been parsed. */ typedef void (*elementDeclSAXFunc)(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content); /** * unparsedEntityDeclSAXFunc: * @ctx: the user data (XML parser context) * @name: The name of the entity * @publicId: The public ID of the entity * @systemId: The system ID of the entity * @notationName: the name of the notation * * What to do when an unparsed entity declaration is parsed. */ typedef void (*unparsedEntityDeclSAXFunc)(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName); /** * setDocumentLocatorSAXFunc: * @ctx: the user data (XML parser context) * @loc: A SAX Locator * * Receive the document locator at startup, actually xmlDefaultSAXLocator. * Everything is available on the context, so this is useless in our case. */ typedef void (*setDocumentLocatorSAXFunc) (void *ctx, xmlSAXLocatorPtr loc); /** * startDocumentSAXFunc: * @ctx: the user data (XML parser context) * * Called when the document start being processed. */ typedef void (*startDocumentSAXFunc) (void *ctx); /** * endDocumentSAXFunc: * @ctx: the user data (XML parser context) * * Called when the document end has been detected. */ typedef void (*endDocumentSAXFunc) (void *ctx); /** * startElementSAXFunc: * @ctx: the user data (XML parser context) * @name: The element name, including namespace prefix * @atts: An array of name/value attributes pairs, NULL terminated * * Called when an opening tag has been processed. */ typedef void (*startElementSAXFunc) (void *ctx, const xmlChar *name, const xmlChar **atts); /** * endElementSAXFunc: * @ctx: the user data (XML parser context) * @name: The element name * * Called when the end of an element has been detected. */ typedef void (*endElementSAXFunc) (void *ctx, const xmlChar *name); /** * attributeSAXFunc: * @ctx: the user data (XML parser context) * @name: The attribute name, including namespace prefix * @value: The attribute value * * Handle an attribute that has been read by the parser. * The default handling is to convert the attribute into an * DOM subtree and past it in a new xmlAttr element added to * the element. */ typedef void (*attributeSAXFunc) (void *ctx, const xmlChar *name, const xmlChar *value); /** * referenceSAXFunc: * @ctx: the user data (XML parser context) * @name: The entity name * * Called when an entity reference is detected. */ typedef void (*referenceSAXFunc) (void *ctx, const xmlChar *name); /** * charactersSAXFunc: * @ctx: the user data (XML parser context) * @ch: a xmlChar string * @len: the number of xmlChar * * Receiving some chars from the parser. */ typedef void (*charactersSAXFunc) (void *ctx, const xmlChar *ch, int len); /** * ignorableWhitespaceSAXFunc: * @ctx: the user data (XML parser context) * @ch: a xmlChar string * @len: the number of xmlChar * * Receiving some ignorable whitespaces from the parser. * UNUSED: by default the DOM building will use characters. */ typedef void (*ignorableWhitespaceSAXFunc) (void *ctx, const xmlChar *ch, int len); /** * processingInstructionSAXFunc: * @ctx: the user data (XML parser context) * @target: the target name * @data: the PI data

C

0xDEEDBEAF

