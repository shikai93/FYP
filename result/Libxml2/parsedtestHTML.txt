testHTML.c : a small tester program for HTML input. See Copyright for the status of this software. daniel@veillard.com

LIBXML_PUSH_ENABLED

internalSubset

isStandalone

hasInternalSubset

hasExternalSubset

resolveEntity

getEntity

entityDecl

notationDecl

attributeDecl

elementDecl

unparsedEntityDecl

setDocumentLocator

startDocument

endDocument

startElement

endElement

reference

characters

ignorableWhitespace

processingInstruction

comment

xmlParserWarning

xmlParserError

xmlParserError

getParameterEntity

cdataBlock

externalSubset

initialized

private

startElementNsSAX2Func

endElementNsSAX2Func

xmlStructuredErrorFunc

Debug Handlers

isStandaloneDebug: @ctxt: An XML parser context Is this document tagged standalone ? Returns 1 if true

hasInternalSubsetDebug: @ctxt: An XML parser context Does this document has an internal subset Returns 1 if true

hasExternalSubsetDebug: @ctxt: An XML parser context Does this document has an external subset Returns 1 if true

hasInternalSubsetDebug: @ctxt: An XML parser context Does this document has an internal subset

resolveEntityDebug: @ctxt: An XML parser context @publicId: The public ID of the entity @systemId: The system ID of the entity Special entity resolver, better left to the parser, it has more context than the application layer. The default behaviour is to NOT resolve the entities, in that case the ENTITY_REF nodes are built in the structure (and the parameter values). Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;

if (systemId != NULL) { return(xmlNewInputFromFile(ctxt, (char ) systemId)); }

getEntityDebug: @ctxt: An XML parser context @name: The entity name Get an entity by name Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

getParameterEntityDebug: @ctxt: An XML parser context @name: The entity name Get a parameter entity by name Returns the xmlParserInputPtr

entityDeclDebug: @ctxt: An XML parser context @name: the entity name @type: the entity type @publicId: The public ID of the entity @systemId: The system ID of the entity @content: the entity value (without processing). An entity definition has been parsed

attributeDeclDebug: @ctxt: An XML parser context @name: the attribute name @type: the attribute type An attribute definition has been parsed

elementDeclDebug: @ctxt: An XML parser context @name: the element name @type: the element type @content: the element value (without processing). An element definition has been parsed

notationDeclDebug: @ctxt: An XML parser context @name: The name of the notation @publicId: The public ID of the entity @systemId: The system ID of the entity What to do when a notation declaration has been parsed.

unparsedEntityDeclDebug: @ctxt: An XML parser context @name: The name of the entity @publicId: The public ID of the entity @systemId: The system ID of the entity @notationName: the name of the notation What to do when an unparsed entity declaration is parsed

setDocumentLocatorDebug: @ctxt: An XML parser context @loc: A SAX Locator Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.

startDocumentDebug: @ctxt: An XML parser context called when the document start being processed.

endDocumentDebug: @ctxt: An XML parser context called when the document end has been detected.

startElementDebug: @ctxt: An XML parser context @name: The element name called when an opening tag has been processed.

endElementDebug: @ctxt: An XML parser context @name: The element name called when the end of an element has been detected.

charactersDebug: @ctxt: An XML parser context @ch: a xmlChar string @len: the number of xmlChar receiving some chars from the parser. Question: how much at a time ???

cdataDebug: @ctxt: An XML parser context @ch: a xmlChar string @len: the number of xmlChar receiving some cdata chars from the parser. Question: how much at a time ???

referenceDebug: @ctxt: An XML parser context @name: The entity name called when an entity reference is detected.

ignorableWhitespaceDebug: @ctxt: An XML parser context @ch: a xmlChar string @start: the first char in the string @len: the number of xmlChar receiving some ignorable whitespaces from the parser. Question: how much at a time ???

processingInstructionDebug: @ctxt: An XML parser context @target: the target name @data: the PI data's @len: the number of xmlChar A processing instruction has been parsed.

commentDebug: @ctxt: An XML parser context @value: the comment content A comment has been parsed.

warningDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a warning messages, gives file, line, position and extra parameters.

errorDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a error messages, gives file, line, position and extra parameters.

fatalErrorDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a fatalError messages, gives file, line, position and extra parameters.

Debug

Empty callbacks for checking

if (repeat)

if (repeat)

LIBXML_PUSH_ENABLED

Debug callback

LIBXML_PUSH_ENABLED

build an HTML tree from a string;

if (repeat)

test intermediate copy if needed.

print it.

LIBXML_OUTPUT_ENABLED

free it.

LIBXML_PUSH_ENABLED

LIBXML_PUSH_ENABLED

!LIBXML_HTML_ENABLED

libxml.h

SAX.isStandalone()\n

SAX.hasInternalSubset()\n

SAX.hasExternalSubset()\n

SAX.internalSubset(%s,

,

%s,

)\n

%s)\n

SAX.resolveEntity(

%s



, %s)\n

, )\n

SAX.getEntity(%s)\n

SAX.getParameterEntity(%s)\n

SAX.entityDecl(%s, %d, %s, %s, %s)\n

SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\n

SAX.elementDecl(%s, %d, ...)\n

SAX.notationDecl(%s, %s, %s)\n

SAX.unparsedEntityDecl(%s, %s, %s, %s)\n

SAX.setDocumentLocator()\n

SAX.startDocument()\n

SAX.endDocument()\n

SAX.startElement(%s

, %s

='

\'

%s

'

)\n

SAX.endElement(%s)\n

SAX.characters(%s, %d)\n

SAX.cdata(%s, %d)\n

SAX.reference(%s)\n

SAX.ignorableWhitespace(%s, %d)\n

s * @len: the number of xmlChar * * A processing instruction has been parsed. */ static void processingInstructionDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *target, const xmlChar *data) { fprintf(stdout, "SAX.processingInstruction(%s, %s)\n", (char *) target, (char *) data); } /** * commentDebug: * @ctxt: An XML parser context * @value: the comment content * * A comment has been parsed. */ static void commentDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *value) { fprintf(stdout, "SAX.comment(%s)\n", value); } /** * warningDebug: * @ctxt: An XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a warning messages, gives file, line, position and * extra parameters. */ static void XMLCDECL warningDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) { va_list args; va_start(args, msg); fprintf(stdout, "SAX.warning: "); vfprintf(stdout, msg, args); va_end(args); } /** * errorDebug: * @ctxt: An XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a error messages, gives file, line, position and * extra parameters. */ static void XMLCDECL errorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) { va_list args; va_start(args, msg); fprintf(stdout, "SAX.error: "); vfprintf(stdout, msg, args); va_end(args); } /** * fatalErrorDebug: * @ctxt: An XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a fatalError messages, gives file, line, position and * extra parameters. */ static void XMLCDECL fatalErrorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) { va_list args; va_start(args, msg); fprintf(stdout, "SAX.fatalError: "); vfprintf(stdout, msg, args); va_end(args); } static xmlSAXHandler debugSAXHandlerStruct = { internalSubsetDebug, isStandaloneDebug, hasInternalSubsetDebug, hasExternalSubsetDebug, resolveEntityDebug, getEntityDebug, entityDeclDebug, notationDeclDebug, attributeDeclDebug, elementDeclDebug, unparsedEntityDeclDebug, setDocumentLocatorDebug, startDocumentDebug, endDocumentDebug, startElementDebug, endElementDebug, referenceDebug, charactersDebug, ignorableWhitespaceDebug, processingInstructionDebug, commentDebug, warningDebug, errorDebug, fatalErrorDebug, getParameterEntityDebug, cdataDebug, NULL, 1, NULL, NULL, NULL, NULL }; xmlSAXHandlerPtr debugSAXHandler = &debugSAXHandlerStruct; /************************************************************************ * * * Debug * * * ************************************************************************/ static void parseSAXFile(char *filename) { htmlDocPtr doc = NULL; /* * Empty callbacks for checking */ #ifdef LIBXML_PUSH_ENABLED if (push) { FILE *f; #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif if (f != NULL) { int res, size = 3; char chars[4096]; htmlParserCtxtPtr ctxt; /* if (repeat) */ size = 4096; res = fread(chars, 1, 4, f); if (res > 0) { ctxt = htmlCreatePushParserCtxt(emptySAXHandler, NULL, chars, res, filename, XML_CHAR_ENCODING_NONE); while ((res = fread(chars, 1, size, f)) > 0) { htmlParseChunk(ctxt, chars, res, 0); } htmlParseChunk(ctxt, chars, 0, 1); doc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); } if (doc != NULL) { fprintf(stdout, "htmlSAXParseFile returned non-NULL\n"); xmlFreeDoc(doc); } fclose(f); } if (!noout) { #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif if (f != NULL) { int res, size = 3; char chars[4096]; htmlParserCtxtPtr ctxt; /* if (repeat) */ size = 4096; res = fread(chars, 1, 4, f); if (res > 0) { ctxt = htmlCreatePushParserCtxt(debugSAXHandler, NULL, chars, res, filename, XML_CHAR_ENCODING_NONE); while ((res = fread(chars, 1, size, f)) > 0) { htmlParseChunk(ctxt, chars, res, 0); } htmlParseChunk(ctxt, chars, 0, 1); doc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); } if (doc != NULL) { fprintf(stdout, "htmlSAXParseFile returned non-NULL\n"); xmlFreeDoc(doc); } fclose(f); } } } else { #endif /* LIBXML_PUSH_ENABLED */ doc = htmlSAXParseFile(filename, NULL, emptySAXHandler, NULL); if (doc != NULL) { fprintf(stdout, "htmlSAXParseFile returned non-NULL\n"); xmlFreeDoc(doc); } if (!noout) { /* * Debug callback */ doc = htmlSAXParseFile(filename, NULL, debugSAXHandler, NULL); if (doc != NULL) { fprintf(stdout, "htmlSAXParseFile returned non-NULL\n"); xmlFreeDoc(doc); } } #ifdef LIBXML_PUSH_ENABLED } #endif /* LIBXML_PUSH_ENABLED */ } static void parseAndPrintFile(char *filename) { htmlDocPtr doc = NULL; /* * build an HTML tree from a string; */ #ifdef LIBXML_PUSH_ENABLED if (push) { FILE *f; #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif if (f != NULL) { int res, size = 3; char chars[4096]; htmlParserCtxtPtr ctxt; /* if (repeat) */ size = 4096; res = fread(chars, 1, 4, f); if (res > 0) { ctxt = htmlCreatePushParserCtxt(NULL, NULL, chars, res, filename, XML_CHAR_ENCODING_NONE); while ((res = fread(chars, 1, size, f)) > 0) { htmlParseChunk(ctxt, chars, res, 0); } htmlParseChunk(ctxt, chars, 0, 1); doc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); } fclose(f); } } else { doc = htmlReadFile(filename, NULL, options); } #else doc = htmlReadFile(filename,NULL,options); #endif if (doc == NULL) { xmlGenericError(xmlGenericErrorContext, "Could not parse %s\n", filename); } #ifdef LIBXML_TREE_ENABLED /* * test intermediate copy if needed. */ if (copy) { htmlDocPtr tmp; tmp = doc; doc = xmlCopyDoc(doc, 1); xmlFreeDoc(tmp); } #endif #ifdef LIBXML_OUTPUT_ENABLED /* * print it. */ if (!noout) { #ifdef LIBXML_DEBUG_ENABLED if (!debug) { if (encoding) htmlSaveFileEnc("-", doc, encoding); else htmlDocDump(stdout, doc); } else xmlDebugDumpDocument(stdout, doc); #else if (encoding) htmlSaveFileEnc("-", doc, encoding); else htmlDocDump(stdout, doc); #endif } #endif /* LIBXML_OUTPUT_ENABLED */ /* * free it. */ xmlFreeDoc(doc); } int main(int argc, char **argv) { int i, count; int files = 0; for (i = 1; i < argc ; i++) { #ifdef LIBXML_DEBUG_ENABLED if ((!strcmp(argv[i], "-debug")) || (!strcmp(argv[i], "--debug"))) debug++; else #endif if ((!strcmp(argv[i], "-copy")) || (!strcmp(argv[i], "--copy"))) copy++; #ifdef LIBXML_PUSH_ENABLED else if ((!strcmp(argv[i], "-push")) || (!strcmp(argv[i], "--push"))) push++; #endif /* LIBXML_PUSH_ENABLED */ else if ((!strcmp(argv[i], "-sax")) || (!strcmp(argv[i], "--sax"))) sax++; else if ((!strcmp(argv[i], "-noout")) || (!strcmp(argv[i], "--noout"))) noout++; else if ((!strcmp(argv[i], "-repeat")) || (!strcmp(argv[i], "--repeat"))) repeat++; else if ((!strcmp(argv[i], "-encode")) || (!strcmp(argv[i], "--encode"))) { i++; encoding = argv[i]; } } for (i = 1; i < argc ; i++) { if ((!strcmp(argv[i], "-encode")) || (!strcmp(argv[i], "--encode"))) { i++; continue; } if (argv[i][0] !=

Usage : %s [--debug] [--copy] [--copy] HTMLfiles ...\n

\tParse the HTML files and output the result of the parsing\n

\t--debug : dump a debug tree of the in-memory document\n

\t--copy : used to test the internal copy implementation\n

\t--sax : debug the sequence of SAX callbacks\n

\t--repeat : parse the file 100 times, for timing\n

\t--noout : do not print the result\n

\t--push : use the push mode parser\n

\t--encode encoding : output in the given encoding\n

%s : HTML support not compiled in\n

