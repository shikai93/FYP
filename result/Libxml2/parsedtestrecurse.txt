testrecurse.c: C program to run libxml2 regression tests checking entities recursions To compile on Unixes: cc -o testrecurse `xml2-config --cflags` testrecurse.c `xml2-config --libs` -lpthread See Copyright for the status of this software. daniel@veillard.com

O_BINARY is just for Windows compatibility - if it isn't defined on this system, avoid any compilation error

descripton of the test

function implementing the test

glob to path for input files

output directory

suffix for output files

suffix for error output files

parser options for the test

Count of paths matched so far

List of matched pathnames.

Slots to reserve in 'gl_pathv'.

Huge document generator

hugeMatch: @URI: an URI to test Check for an huge: query Returns 1 if yes and 0 if another Input module should be used

hugeOpen: @URI: an URI to test Return a pointer to the huge: query handler, in this example simply the current pointer... Returns an Input context or NULL in case or error

hugeClose: @context: the read context Close the huge: query handler Returns 0 or -1 in case of error

hugeRead: @context: the read context @buffer: where to store data @len: number of bytes to read Implement an huge: query read. Returns the number of bytes read or -1 in case of error

Libxml2 specific routines

We need to trap calls to the resolver to not account memory for the catalog which is shared to the current running test. We also don't want to have network downloads modifying tests.

Trapping the error messages at the generic level to grab the equivalent of stderr messages on CLI tools.

buffer is full

xmlParserPrintFileContext: @input: an xmlParserInputPtr input Displays current context within the input content for error tracking

GCC warns if signed, because compared with sizeof()

space for 80 chars + line terminator

skip backwards over any end-of-lines

search backwards for beginning-of-line (to max buff size)

calculate the error position in terms of the current position

search forward for end-of-line (to max buff size)

copy selected text to our buffer

print out the selected text

create blank line with problem pointer

(leave buffer space for pointer + line terminator)

Maintain the compatibility with the legacy error handling

register the new I/O handlers

File name and path utilities

if ((filename[0] == 't') && (filename[1] == 'e') && (filename[2] == 's') && (filename[3] == 't') && (filename[4] == '/')) filename = &filename[5];

Test to detect or not recursive entities

recursiveDetectTest: @filename: the file to parse @result: the file with expected result @err: the file with error messages: unused Parse a file loading DTD and replacing entities check it fails for lol cases Returns 0 in case of success, an error code otherwise

base of the test, parse with the old API

notRecursiveDetectTest: @filename: the file to parse @result: the file with expected result @err: the file with error messages: unused Parse a file loading DTD and replacing entities check it works for good cases Returns 0 in case of success, an error code otherwise

base of the test, parse with the old API

notRecursiveHugeTest: @filename: the file to parse @result: the file with expected result @err: the file with error messages: unused Parse a memory generated file good cases Returns 0 in case of success, an error code otherwise

Tests Descriptions

The main code driving the tests

libxml.h

t defined * on this system, avoid any compilation error */ #ifdef O_BINARY #define RD_FLAGS O_RDONLY | O_BINARY #else #define RD_FLAGS O_RDONLY #endif typedef int (*functest) (const char *filename, const char *result, const char *error, int options); typedef struct testDesc testDesc; typedef testDesc *testDescPtr; struct testDesc { const char *desc; /* descripton of the test */ functest func; /* function implementing the test */ const char *in; /* glob to path for input files */ const char *out; /* output directory */ const char *suffix;/* suffix for output files */ const char *err; /* suffix for error output files */ int options; /* parser options for the test */ }; static int checkTestFile(const char *filename); #if defined(_WIN32) && !defined(__CYGWIN__) #include <windows.h> #include <io.h> typedef struct { size_t gl_pathc; /* Count of paths matched so far */ char **gl_pathv; /* List of matched pathnames. */ size_t gl_offs; /* Slots to reserve in

. */ } glob_t; #define GLOB_DOOFFS 0 static int glob(const char *pattern, int flags, int errfunc(const char *epath, int eerrno), glob_t *pglob) { glob_t *ret; WIN32_FIND_DATA FindFileData; HANDLE hFind; unsigned int nb_paths = 0; char directory[500]; int len; if ((pattern == NULL) || (pglob == NULL)) return(-1); strncpy(directory, pattern, 499); for (len = strlen(directory);len >= 0;len--) { if (directory[len] ==

) { len++; directory[len] = 0; break; } } if (len <= 0) len = 0; ret = pglob; memset(ret, 0, sizeof(glob_t)); hFind = FindFirstFileA(pattern, &FindFileData); if (hFind == INVALID_HANDLE_VALUE) return(0); nb_paths = 20; ret->gl_pathv = (char **) malloc(nb_paths * sizeof(char *)); if (ret->gl_pathv == NULL) { FindClose(hFind); return(-1); } strncpy(directory + len, FindFileData.cFileName, 499 - len); ret->gl_pathv[ret->gl_pathc] = strdup(directory); if (ret->gl_pathv[ret->gl_pathc] == NULL) goto done; ret->gl_pathc++; while(FindNextFileA(hFind, &FindFileData)) { if (FindFileData.cFileName[0] ==

) continue; if (ret->gl_pathc + 2 > nb_paths) { char **tmp = realloc(ret->gl_pathv, nb_paths * 2 * sizeof(char *)); if (tmp == NULL) break; ret->gl_pathv = tmp; nb_paths *= 2; } strncpy(directory + len, FindFileData.cFileName, 499 - len); ret->gl_pathv[ret->gl_pathc] = strdup(directory); if (ret->gl_pathv[ret->gl_pathc] == NULL) break; ret->gl_pathc++; } ret->gl_pathv[ret->gl_pathc] = NULL; done: FindClose(hFind); return(0); } static void globfree(glob_t *pglob) { unsigned int i; if (pglob == NULL) return; for (i = 0;i < pglob->gl_pathc;i++) { if (pglob->gl_pathv[i] != NULL) free(pglob->gl_pathv[i]); } } #define vsnprintf _vsnprintf #define snprintf _snprintf #else #include <glob.h> #endif /************************************************************************ * * * Huge document generator * * * ************************************************************************/ #include <libxml/xmlIO.h> static const char *start = "<!DOCTYPE foo [\ <!ENTITY f

> \ <!ENTITY e

> \ <!ENTITY d

> \ ]> \ <foo>"; static const char *segment = " <bar>&e; &f; &d;</bar>\n"; static const char *finish = "</foo>"; static int curseg = 0; static const char *current; static int rlen; /** * hugeMatch: * @URI: an URI to test * * Check for an huge: query * * Returns 1 if yes and 0 if another Input module should be used */ static int hugeMatch(const char * URI) { if ((URI != NULL) && (!strncmp(URI, "huge:", 4))) return(1); return(0); } /** * hugeOpen: * @URI: an URI to test * * Return a pointer to the huge: query handler, in this example simply * the current pointer... * * Returns an Input context or NULL in case or error */ static void * hugeOpen(const char * URI) { if ((URI == NULL) || (strncmp(URI, "huge:", 4))) return(NULL); rlen = strlen(start); current = start; return((void *) current); } /** * hugeClose: * @context: the read context * * Close the huge: query handler * * Returns 0 or -1 in case of error */ static int hugeClose(void * context) { if (context == NULL) return(-1); return(0); } #define MAX_NODES 1000000 /** * hugeRead: * @context: the read context * @buffer: where to store data * @len: number of bytes to read * * Implement an huge: query read. * * Returns the number of bytes read or -1 in case of error */ static int hugeRead(void *context, char *buffer, int len) { if ((context == NULL) || (buffer == NULL) || (len < 0)) return (-1); if (len >= rlen) { if (curseg >= MAX_NODES + 1) { rlen = 0; return(0); } len = rlen; rlen = 0; memcpy(buffer, current, len); curseg ++; if (curseg == MAX_NODES) { fprintf(stderr, "\n"); rlen = strlen(finish); current = finish; } else { if (curseg % (MAX_NODES / 10) == 0) fprintf(stderr, "."); rlen = strlen(segment); current = segment; } } else { memcpy(buffer, current, len); rlen -= len; current += len; } return (len); } /************************************************************************ * * * Libxml2 specific routines * * * ************************************************************************/ static int nb_tests = 0; static int nb_errors = 0; static int nb_leaks = 0; static int extraMemoryFromResolver = 0; static int fatalError(void) { fprintf(stderr, "Exitting tests on fatal error\n"); exit(1); } /* * We need to trap calls to the resolver to not account memory for the catalog * which is shared to the current running test. We also don

\n

\r

\n

\r

\n

\r

\n

\r

%s\n

\t



^

%s\n

%s:%d:

Entity: line %d:

%s:%d:

Entity: line %d:

element %s:

parser

namespace

validity

HTML parser

memory

output

I/O

XInclude

XPath

parser

regexp

module

Schemas validity

Schemas parser

Relax-NG parser

Relax-NG validity

Catalog

C14N

XSLT

:

warning :

error :

error :

\n

%s\n

%s

%s\n

out of memory error

%s:%d: \n

Entity: line %d: \n

%s\n



^

%s\n

failed to register Huge handler\n

/

/

t

e

s

t

/

.tmp



.

.

_

%s%s%s

Failed to detect recursion in %s\n

Failed to parse correct file %s\n

huge:test

Failed to open huge:test\n

Failed to parser huge:test with entities\n

Parsing recursive test cases

./test/recurse/lol*.xml

Parsing non-recursive test cases

./test/recurse/good*.xml

Parsing non-recursive huge case

Out of memory !\n

Out of memory !\n

Missing result file %s\n

Missing error file %s\n

File %s generated an error\n

File %s leaked %d bytes\n

## %s\n

Ran %d tests, no errors\n

Ran %d tests, %d errors, %d leaks\n

-v

-quiet

Total %d tests, no errors\n

Total %d tests, %d errors, %d leaks\n

