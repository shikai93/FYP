threads.c: set of generic threading related routines See Copyright for the status of this software. Gary Pennington <Gary.Pennington@uk.sun.com> daniel@veillard.com

#define DEBUG_THREADS

linux

__GNUC__

HAVE_PTHREAD_H

TODO: this module still uses malloc/free and not xmlMalloc/xmlFree to avoid some crazyness since xmlMalloc/xmlFree may actually be hosted on allocated blocks needing them for the allocation ...

xmlMutex are a simple mutual exception locks

xmlRMutex are reentrant mutual exception locks

This module still has some internal static data. - xmlLibraryLock a global lock - globalkey used for per-thread data

HAVE_COMPILER_TLS

HAVE_COMPILER_TLS

endif HAVE_WIN32_THREADS

xmlNewMutex: xmlNewMutex() is used to allocate a libxml2 token struct for use in synchronizing access to data. Returns a new simple mutex pointer or NULL in case of error

xmlFreeMutex: @tok: the simple mutex xmlFreeMutex() is used to reclaim resources associated with a libxml2 token struct.

xmlMutexLock: @tok: the simple mutex xmlMutexLock() is used to lock a libxml2 token.

xmlMutexUnlock: @tok: the simple mutex xmlMutexUnlock() is used to unlock a libxml2 token.

xmlNewRMutex: xmlRNewMutex() is used to allocate a reentrant mutex for use in synchronizing access to data. token_r is a re-entrant lock and thus useful for synchronizing access to data structures that may be manipulated in a recursive fashion. Returns the new reentrant mutex pointer or NULL in case of error

xmlFreeRMutex: @tok: the reentrant mutex xmlRFreeMutex() is used to reclaim resources associated with a reentrant mutex.

xmlRMutexLock: @tok: the reentrant mutex xmlRMutexLock() is used to lock a libxml2 token_r.

xmlRMutexUnlock: @tok: the reentrant mutex xmlRMutexUnlock() is used to unlock a libxml2 token_r.

xmlGlobalInitMutexLock Makes sure that the global initialization mutex is initialized and locks it.

Make sure the global init lock is initialized and then lock it.

The mutex is statically initialized, so we just lock it.

Create a new critical section

Swap it into the global_init_lock

Use older void version

InterlockedCompareExchangePointer

If another thread successfully recorded its critical section in the global_init_lock then discard the one allocated by this thread.

Lock the chosen critical section

Allocate a new semaphore

If another thread successfully recorded its critical section in the global_init_lock then discard the one allocated by this thread.

Acquire the chosen semaphore

xmlGlobalInitMutexDestroy Makes sure that the global initialization mutex is destroyed before application termination.

Per thread global state handling

xmlFreeGlobalState: @state: a thread global state xmlFreeGlobalState() is called when a thread terminates with a non-NULL global state. It is is used here to reclaim memory resources.

free any memory allocated in the thread's xmlLastError

xmlNewGlobalState: xmlNewGlobalState() allocates a global state. This structure is used to hold all data for use by a thread when supporting backwards compatibility of libxml2 to pre-thread-safe behaviour. Returns the newly allocated xmlGlobalStatePtr or NULL in case of error

LIBXML_THREAD_ENABLED

LIBXML_STATIC && !LIBXML_STATIC_FOR_DLL

LIBXMLSTATIC && !LIBXML_STATIC_FOR_DLL

HAVE_COMPILER_TLS

HAVE_WIN32_THREADS

xmlGlobalStateCleanup: @data: unused parameter Used for Beos only

xmlGetGlobalState: xmlGetGlobalState() is called to retrieve the global state for a thread. Returns the thread global state or NULL in case of error

HAVE_COMPILER_TLS

HAVE_COMPILER_TLS

Library wide thread interfaces

xmlGetThreadId: xmlGetThreadId() find the current thread ID number Note that this is likely to be broken on some platforms using pthreads as the specification doesn't mandate pthread_t to be an integer type Returns the current thread ID number

horrible but preserves compat, see warning above

xmlIsMainThread: xmlIsMainThread() check whether the current thread is the main thread. Returns 1 if the current thread is the main thread, 0 otherwise

xmlLockLibrary: xmlLockLibrary() is used to take out a re-entrant lock on the libxml2 library.

xmlUnlockLibrary: xmlUnlockLibrary() is used to release a re-entrant lock on the libxml2 library.

xmlInitThreads: xmlInitThreads() is used to to initialize all the thread related data of the libxml2 library.

fprintf(stderr, "Running multithreaded\n");

fprintf(stderr, "Running without multithread\n");

xmlCleanupThreads: xmlCleanupThreads() is used to to cleanup all the thread related data of the libxml2 library once processing has ended. WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It's sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !

xmlOnceInit xmlOnceInit() is used to initialize the value of mainthread for use in other routines. This function should only be called using pthread_once() in association with the once_control variable to ensure that the function is only called once. See man pthread_once for more details.

Another thread is working; give up our slice and wait until they're done.

DllMain: @hinstDLL: handle to DLL instance @fdwReason: Reason code for entry @lpvReserved: generic pointer (depends upon reason code) Entry point for Windows library. It is being used to free thread-specific storage. Returns TRUE always

libxml.h

xmlMutex

xmlMutexLock():BeOS:Couldn't aquire semaphore\n

xmlGlobalInitMutexLock: out of memory\n

xmlGlobalinitMutex

xmlGlobalInitMutexLock():BeOS:Couldn't acquire semaphore\n

s xmlLastError */ xmlResetError(&(gs->xmlLastError)); free(state); } /** * xmlNewGlobalState: * * xmlNewGlobalState() allocates a global state. This structure is used to * hold all data for use by a thread when supporting backwards compatibility * of libxml2 to pre-thread-safe behaviour. * * Returns the newly allocated xmlGlobalStatePtr or NULL in case of error */ static xmlGlobalStatePtr xmlNewGlobalState(void) { xmlGlobalState *gs; gs = malloc(sizeof(xmlGlobalState)); if (gs == NULL) { xmlGenericError(xmlGenericErrorContext, "xmlGetGlobalState: out of memory\n"); return (NULL); } memset(gs, 0, sizeof(xmlGlobalState)); xmlInitializeGlobalState(gs); return (gs); } #endif /* LIBXML_THREAD_ENABLED */ #ifdef HAVE_PTHREAD_H #elif HAVE_WIN32_THREADS #if !defined(HAVE_COMPILER_TLS) #if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL) typedef struct _xmlGlobalStateCleanupHelperParams { HANDLE thread; void *memory; } xmlGlobalStateCleanupHelperParams; static void XMLCDECL xmlGlobalStateCleanupHelper(void *p) { xmlGlobalStateCleanupHelperParams *params = (xmlGlobalStateCleanupHelperParams *) p; WaitForSingleObject(params->thread, INFINITE); CloseHandle(params->thread); xmlFreeGlobalState(params->memory); free(params); _endthread(); } #else /* LIBXML_STATIC && !LIBXML_STATIC_FOR_DLL */ typedef struct _xmlGlobalStateCleanupHelperParams { void *memory; struct _xmlGlobalStateCleanupHelperParams *prev; struct _xmlGlobalStateCleanupHelperParams *next; } xmlGlobalStateCleanupHelperParams; static xmlGlobalStateCleanupHelperParams *cleanup_helpers_head = NULL; static CRITICAL_SECTION cleanup_helpers_cs; #endif /* LIBXMLSTATIC && !LIBXML_STATIC_FOR_DLL */ #endif /* HAVE_COMPILER_TLS */ #endif /* HAVE_WIN32_THREADS */ #if defined HAVE_BEOS_THREADS /** * xmlGlobalStateCleanup: * @data: unused parameter * * Used for Beos only */ void xmlGlobalStateCleanup(void *data) { void *globalval = tls_get(globalkey); if (globalval != NULL) xmlFreeGlobalState(globalval); } #endif /** * xmlGetGlobalState: * * xmlGetGlobalState() is called to retrieve the global state for a thread. * * Returns the thread global state or NULL in case of error */ xmlGlobalStatePtr xmlGetGlobalState(void) { #ifdef HAVE_PTHREAD_H xmlGlobalState *globalval; if (libxml_is_threaded == 0) return (NULL); pthread_once(&once_control, xmlOnceInit); if ((globalval = (xmlGlobalState *) pthread_getspecific(globalkey)) == NULL) { xmlGlobalState *tsd = xmlNewGlobalState(); if (tsd == NULL) return(NULL); pthread_setspecific(globalkey, tsd); return (tsd); } return (globalval); #elif defined HAVE_WIN32_THREADS #if defined(HAVE_COMPILER_TLS) if (!tlstate_inited) { tlstate_inited = 1; xmlInitializeGlobalState(&tlstate); } return &tlstate; #else /* HAVE_COMPILER_TLS */ xmlGlobalState *globalval; xmlGlobalStateCleanupHelperParams *p; xmlOnceInit(); #if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL) globalval = (xmlGlobalState *) TlsGetValue(globalkey); #else p = (xmlGlobalStateCleanupHelperParams *) TlsGetValue(globalkey); globalval = (xmlGlobalState *) (p ? p->memory : NULL); #endif if (globalval == NULL) { xmlGlobalState *tsd = xmlNewGlobalState(); if (tsd == NULL) return(NULL); p = (xmlGlobalStateCleanupHelperParams *) malloc(sizeof(xmlGlobalStateCleanupHelperParams)); if (p == NULL) { xmlGenericError(xmlGenericErrorContext, "xmlGetGlobalState: out of memory\n"); xmlFreeGlobalState(tsd); return(NULL); } p->memory = tsd; #if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL) DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &p->thread, 0, TRUE, DUPLICATE_SAME_ACCESS); TlsSetValue(globalkey, tsd); _beginthread(xmlGlobalStateCleanupHelper, 0, p); #else EnterCriticalSection(&cleanup_helpers_cs); if (cleanup_helpers_head != NULL) { cleanup_helpers_head->prev = p; } p->next = cleanup_helpers_head; p->prev = NULL; cleanup_helpers_head = p; TlsSetValue(globalkey, p); LeaveCriticalSection(&cleanup_helpers_cs); #endif return (tsd); } return (globalval); #endif /* HAVE_COMPILER_TLS */ #elif defined HAVE_BEOS_THREADS xmlGlobalState *globalval; xmlOnceInit(); if ((globalval = (xmlGlobalState *) tls_get(globalkey)) == NULL) { xmlGlobalState *tsd = xmlNewGlobalState(); if (tsd == NULL) return (NULL); tls_set(globalkey, tsd); on_exit_thread(xmlGlobalStateCleanup, NULL); return (tsd); } return (globalval); #else return (NULL); #endif } /************************************************************************ * * * Library wide thread interfaces * * * ************************************************************************/ /** * xmlGetThreadId: * * xmlGetThreadId() find the current thread ID number * Note that this is likely to be broken on some platforms using pthreads * as the specification doesn

xmlIsMainThread()\n

xmlLockLibrary()\n

xmlUnlockLibrary()\n

Running multithreaded\n

Running without multithread\n

s sometimes very hard to * guess if libxml2 is in use in the application, some libraries * or plugins may use it without notice. In case of doubt abstain * from calling this function or do it just before calling exit() * to avoid leak reports from valgrind ! */ void xmlCleanupThreads(void) { #ifdef DEBUG_THREADS xmlGenericError(xmlGenericErrorContext, "xmlCleanupThreads()\n"); #endif #ifdef HAVE_PTHREAD_H if ((libxml_is_threaded) && (pthread_key_delete != NULL)) pthread_key_delete(globalkey); #elif defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL)) if (globalkey != TLS_OUT_OF_INDEXES) { xmlGlobalStateCleanupHelperParams *p; EnterCriticalSection(&cleanup_helpers_cs); p = cleanup_helpers_head; while (p != NULL) { xmlGlobalStateCleanupHelperParams *temp = p; p = p->next; xmlFreeGlobalState(temp->memory); free(temp); } cleanup_helpers_head = 0; LeaveCriticalSection(&cleanup_helpers_cs); TlsFree(globalkey); globalkey = TLS_OUT_OF_INDEXES; } DeleteCriticalSection(&cleanup_helpers_cs); #endif } #ifdef LIBXML_THREAD_ENABLED /** * xmlOnceInit * * xmlOnceInit() is used to initialize the value of mainthread for use * in other routines. This function should only be called using * pthread_once() in association with the once_control variable to ensure * that the function is only called once. See man pthread_once for more * details. */ static void xmlOnceInit(void) { #ifdef HAVE_PTHREAD_H (void) pthread_key_create(&globalkey, xmlFreeGlobalState); mainthread = pthread_self(); #elif defined(HAVE_WIN32_THREADS) if (!run_once.done) { if (InterlockedIncrement(&run_once.control) == 1) { #if !defined(HAVE_COMPILER_TLS) globalkey = TlsAlloc(); #endif mainthread = GetCurrentThreadId(); run_once.done = 1; } else { /* Another thread is working; give up our slice and * wait until they

elfgcchack.h

Summary: interfaces for thread handling Description: set of generic threading related routines should work with pthreads, Windows native or TLS threads Copy: See Copyright for the status of this software. Author: Daniel Veillard

xmlMutex are a simple mutual exception locks.

xmlRMutex are reentrant mutual exception locks.

Library wide APIs.

__XML_THREADS_H__

C

C

