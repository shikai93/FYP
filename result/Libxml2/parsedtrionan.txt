$Id$ Copyright (C) 2001 Bjorn Reese <breese@users.sourceforge.net> Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER. Functions to handle special quantities in floating-point numbers (that is, NaNs and infinity). They provide the capability to detect and fabricate special quantities. Although written to be as portable as possible, it can never be guaranteed to work on all platforms, as not all hardware supports special quantities. The approach used here (approximately) is to: 1. Use C99 functionality when available. 2. Use IEEE 754 bit-patterns if possible. 3. Use platform-specific techniques.

TODO: o Put all the magic into trio_fpclassify_and_signbit(), and use this from trio_isnan() etc.

Include files

@addtogroup SpecialQuantities @{

Definitions

We must enable IEEE floating-point on Alpha

__alpha && ! _IEEE_FP

In ANSI/IEEE 754-1985 64-bits double format numbers have the following properties (amoungst others) o FLT_RADIX == 2: binary encoding o DBL_MAX_EXP == 1024: 11 bits exponent, where one bit is used to indicate special numbers (e.g. NaN and Infinity), so the maximum exponent is 10 bits wide (2^10 == 1024). o DBL_MANT_DIG == 53: The mantissa is 52 bits wide, but because numbers are normalized the initial binary 1 is represented implicitly (the so-called "hidden bit"), which leaves us with the ability to represent 53 bits wide mantissa.

Constants

Endian-agnostic indexing macro. The value of internalEndianMagic, when converted into a 64-bit integer, becomes 0x0706050403020100 (we could have used a 64-bit integer value instead of a double, but not all platforms supports that type). The value is automatically encoded with the correct endianess by the compiler, which means that we can support any kind of endianess. The individual bytes are then used as an index for the IEEE 754 bit-patterns and masks.

Mask for the exponent

Mask for the mantissa

Mask for the sign bit

Bit-pattern for negative zero

Bit-pattern for infinity

Bit-pattern for quiet NaN

Functions

trio_make_double

trio_is_special_quantity

trio_is_negative

USE_IEEE_754

Generate negative zero. @return Floating-point representation of negative zero.

Generate positive infinity. @return Floating-point representation of positive infinity.

Cache the result

If HUGE_VAL is different from DBL_MAX, then HUGE_VAL is used as infinity. Otherwise we have to resort to an overflow operation to generate infinity.

Force overflow

Generate negative infinity. @return Floating-point value of negative infinity.

Negative infinity is calculated by negating positive infinity, which can be done because it is legal to do calculations on infinity (for example, 1 / infinity == 0).

Generate NaN. @return Floating-point representation of NaN.

Cache the result

There are several ways to generate NaN. The one used here is to divide infinity by infinity. I would have preferred to add negative infinity to positive infinity, but that yields wrong result (infinity) on FreeBSD. This may fail if the hardware does not support NaN, or if the Invalid Operation floating-point exception is unmasked.

Check for NaN. @param number An arbitrary floating-point number. @return Boolean value indicating whether or not the number is a NaN.

C99 defines isnan() as a macro. UNIX95 defines isnan() as a function. This function was already present in XPG4, but this is a bit tricky to detect with compiler defines, so we choose the conservative approach and only use it for UNIX95.

Microsoft Visual C++ and Borland C++ Builder have an _isnan() function.

Examine IEEE 754 bit-pattern. A NaN must have a special exponent pattern, and a non-empty mantissa.

Fallback solution

NaN is the only number which does not compare to itself

Fallback solution if NaN compares to NaN

Check for infinity. @param number An arbitrary floating-point number. @return 1 if positive infinity, -1 if negative infinity, 0 otherwise.

DECC has an isinf() macro, but it works differently than that of C99, so we use the fp_class() function instead.

C99 defines isinf() as a macro.

Microsoft Visual C++ and Borland C++ Builder have an _fpclass() function that can be used to detect infinity.

Examine IEEE 754 bit-pattern. Infinity must have a special exponent pattern, and an empty mantissa.

Fallback solution.

Temporary fix - this routine is not used anywhere

Check for finity. @param number An arbitrary floating-point number. @return Boolean value indicating whether or not the number is a finite.

C99 defines isfinite() as a macro.

Microsoft Visual C++ and Borland C++ Builder use _finite().

Examine IEEE 754 bit-pattern. For finity we do not care about the mantissa.

Fallback solution.

The sign of NaN is always false

C99 defines fpclassify() and signbit() as a macros

DECC has an fp_class() function.

Microsoft Visual C++ and Borland C++ Builder have an _fpclass() function.

HP-UX 9.x and 10.x have an fpclassify() function, that is different from the C99 fpclassify() macro supported on HP-UX 11.x. AIX has class() for C, and _class() for C++, which returns the same values as the HP-UX fpclassify() function.

NaN has no sign

Just in case...

Fallback solution.

In IEEE 754 the sign of zero is ignored in comparisons, so we have to handle this as a special case by examining the sign bit directly.

FIXME

Examine the sign of a number. @param number An arbitrary floating-point number. @return Boolean value indicating whether or not the number has the sign bit set (i.e. is negative).

Temporary fix - this routine is not used in libxml

Examine the class of a number. @param number An arbitrary floating-point number. @return Enumerable value indicating the class of @p number

@} SpecialQuantities

For test purposes. Add the following compiler option to include this test code. Unix : -DSTANDALONE VMS : /DEFINE=(STANDALONE)



triodef.h

trionan.h

doc/doc_nan.h

Must be compiled with option /IEEE_MODE=UNDERFLOW_TO_ZERO/FLOAT=IEEE

Must be compiled with option -ieee

Must be compiled with option -mieee

hidden bit

@(#)$Id$



FP_INFINITE

FP_NAN

FP_NORMAL

FP_SUBNORMAL

FP_ZERO

FP_UNKNOWN

%-6s: %s %-15s %g\n

-

+

Nan

PInf

NInf

PZero

NZero

PNorm

NNorm

PSub

NSub

NaN : %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

PInf: %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

NInf: %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

NaN : %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

PInf: %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

NInf: %4g 0x%02x%02x%02x%02x%02x%02x%02x%02x (%2d, %2d)\n

0x0706050403020100

0x0590)

0x7F,

0xF0,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x00,

0x0F,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x7F,

0xF0,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x7F,

0xF8,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x%02x%02x%02x%02x%02x%02x%02x%02x

0x%02x%02x%02x%02x%02x%02x%02x%02x

0x%02x%02x%02x%02x%02x%02x%02x%02x

0x%02x%02x%02x%02x%02x%02x%02x%02x

0x%02x%02x%02x%02x%02x%02x%02x%02x

0x%02x%02x%02x%02x%02x%02x%02x%02x

$Id$ Copyright (C) 2001 Bjorn Reese <breese@users.sourceforge.net> Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.

Return NaN (Not-a-Number).

Return positive infinity.

Return negative infinity.

Return negative zero.

If number is a NaN return non-zero, otherwise return zero.

If number is positive infinity return 1, if number is negative infinity return -1, otherwise return 0.

If number is finite return non-zero, otherwise return zero.

Temporary fix - these 2 routines not used in libxml

TRIO_NAN_H



triodef.h

C

