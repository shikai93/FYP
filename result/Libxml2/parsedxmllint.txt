xmllint.c : a small tester program for XML input. See Copyright for the status of this software. daniel@veillard.com

_MSC_VER

_WIN32

seems needed for Solaris

No error

Unclassified

Error in DTD

Validation error

CtxtReadFile error

Schema compilation

Error writing output

Error in schema pattern

Error in Reader registration

Out of memory error

LIBXML_TREE_ENABLED

LIBXML_OUTPUT_ENABLED

LIBXML_PUSH_ENABLED

LIBXML_READER_ENABLED

LIBXML_SAX1_ENABLED

Entity loading control and customization.

Memory allocation consumption debugging

Internal timing routines to remove the necessity to have unix-specific function calls.

HAVE_FTIME

HAVE_SYS_TIME_H

HAVE_SYS_TIMEB_H

!HAVE_GETTIMEOFDAY

startTimer: call where you want to start timing

endTimer: call where you want to stop timing and to print out a message about the timing performed; format is a printf type argument

No gettimeofday function, so we have to make do with calling clock. This is obviously less accurate, but there's little we can do about that.

We don't have a gettimeofday or time.h, so we just don't do timing

Do nothing

We cannot do anything because we don't have a timing function

We don't have gettimeofday, time or stdarg.h, what crazy world is this ?!

HTML ouput

xmlHTMLPrintFileInfo: @input: an xmlParserInputPtr input Displays the associated file and line informations for the current input

xmlHTMLPrintFileContext: @input: an xmlParserInputPtr input Displays current context within the input content for error tracking

xmlHTMLError: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format an error messages, gives file, line, position and extra parameters.

xmlHTMLWarning: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a warning messages, gives file, line, position and extra parameters.

xmlHTMLValidityError: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format an validity error messages, gives file, line, position and extra parameters.

xmlHTMLValidityWarning: @ctx: an XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a validity warning messages, gives file, line, position and extra parameters.

Shell Interface

xmlShellReadline: @prompt: the prompt value Read a string Returns a pointer to it or NULL on EOF the caller is expected to free the returned string.

Get a line from the user.

If the line has any text in it, save it on the history.

LIBXML_XPATH_ENABLED

LIBXML_DEBUG_ENABLED

I/O Interfaces

SAX based tests

empty SAX block

internalSubset

isStandalone

hasInternalSubset

hasExternalSubset

resolveEntity

getEntity

entityDecl

notationDecl

attributeDecl

elementDecl

unparsedEntityDecl

setDocumentLocator

startDocument

endDocument

startElement

endElement

reference

characters

ignorableWhitespace

processingInstruction

comment

xmlParserWarning

xmlParserError

xmlParserError

getParameterEntity

cdataBlock;

externalSubset;

startElementNs

endElementNs

xmlStructuredErrorFunc

isStandaloneDebug: @ctxt: An XML parser context Is this document tagged standalone ? Returns 1 if true

hasInternalSubsetDebug: @ctxt: An XML parser context Does this document has an internal subset Returns 1 if true

hasExternalSubsetDebug: @ctxt: An XML parser context Does this document has an external subset Returns 1 if true

internalSubsetDebug: @ctxt: An XML parser context Does this document has an internal subset

externalSubsetDebug: @ctxt: An XML parser context Does this document has an external subset

resolveEntityDebug: @ctxt: An XML parser context @publicId: The public ID of the entity @systemId: The system ID of the entity Special entity resolver, better left to the parser, it has more context than the application layer. The default behaviour is to NOT resolve the entities, in that case the ENTITY_REF nodes are built in the structure (and the parameter values). Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;

getEntityDebug: @ctxt: An XML parser context @name: The entity name Get an entity by name Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.

getParameterEntityDebug: @ctxt: An XML parser context @name: The entity name Get a parameter entity by name Returns the xmlParserInputPtr

entityDeclDebug: @ctxt: An XML parser context @name: the entity name @type: the entity type @publicId: The public ID of the entity @systemId: The system ID of the entity @content: the entity value (without processing). An entity definition has been parsed

not all libraries handle printing null pointers nicely

attributeDeclDebug: @ctxt: An XML parser context @name: the attribute name @type: the attribute type An attribute definition has been parsed

elementDeclDebug: @ctxt: An XML parser context @name: the element name @type: the element type @content: the element value (without processing). An element definition has been parsed

notationDeclDebug: @ctxt: An XML parser context @name: The name of the notation @publicId: The public ID of the entity @systemId: The system ID of the entity What to do when a notation declaration has been parsed.

unparsedEntityDeclDebug: @ctxt: An XML parser context @name: The name of the entity @publicId: The public ID of the entity @systemId: The system ID of the entity @notationName: the name of the notation What to do when an unparsed entity declaration is parsed

setDocumentLocatorDebug: @ctxt: An XML parser context @loc: A SAX Locator Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.

startDocumentDebug: @ctxt: An XML parser context called when the document start being processed.

endDocumentDebug: @ctxt: An XML parser context called when the document end has been detected.

startElementDebug: @ctxt: An XML parser context @name: The element name called when an opening tag has been processed.

endElementDebug: @ctxt: An XML parser context @name: The element name called when the end of an element has been detected.

charactersDebug: @ctxt: An XML parser context @ch: a xmlChar string @len: the number of xmlChar receiving some chars from the parser. Question: how much at a time ???

referenceDebug: @ctxt: An XML parser context @name: The entity name called when an entity reference is detected.

ignorableWhitespaceDebug: @ctxt: An XML parser context @ch: a xmlChar string @start: the first char in the string @len: the number of xmlChar receiving some ignorable whitespaces from the parser. Question: how much at a time ???

processingInstructionDebug: @ctxt: An XML parser context @target: the target name @data: the PI data's @len: the number of xmlChar A processing instruction has been parsed.

cdataBlockDebug: @ctx: the user data (XML parser context) @value: The pcdata content @len: the block length called when a pcdata block has been parsed

commentDebug: @ctxt: An XML parser context @value: the comment content A comment has been parsed.

warningDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a warning messages, gives file, line, position and extra parameters.

errorDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a error messages, gives file, line, position and extra parameters.

fatalErrorDebug: @ctxt: An XML parser context @msg: the message to display/transmit @...: extra parameters for the message display Display and format a fatalError messages, gives file, line, position and extra parameters.

SAX2 specific callbacks

startElementNsDebug: @ctxt: An XML parser context @name: The element name called when an opening tag has been processed.

endElementDebug: @ctxt: An XML parser context @name: The element name called when the end of an element has been detected.

mostly for debugging

it's not the simplest code but the most generic in term of I/O

Create the parser context amd hook the input

do the parsing

Stream Test processing

do the check only on element start

LIBXML_VALID_ENABLED

Process all nodes in sequence

LIBXML_VALID_ENABLED

Done, cleanup and status

LIBXML_PATTERN_ENABLED

LIBXML_READER_ENABLED

Tree Test processing

LIBXML_TREE_ENABLED

LIBXML_TREE_ENABLED

if (repeat)

LIBXML_PUSH_ENABLED

LIBXML_HTML_ENABLED

build an XML tree from a string;

'-' Usually means stdin -<sven@zen.org>

if (repeat) size = 1024;

LIBXML_PUSH_ENABLED

LIBXML_VALID_ENABLED

LIBXML_SAX1_ENABLED

If we don't have a document we might as well give up. Do we want an error message here? <sven@zen.org>

Remove DOCTYPE nodes

shell interaction

test intermediate copy if needed.

LIBXML_TREE_ENABLED

LIBXML_VALID_ENABLED

LIBXML_READER_ENABLED

print it.

HAVE_SYS_MMAN_H

LIBXML_OUTPUT_ENABLED

A posteriori validation test

LIBXML_VALID_ENABLED

free it.

Usage and Main

LIBXML_OUTPUT_ENABLED

LIBXML_READER_ENABLED

LIBXML_TREE_ENABLED

LIBXML_VALID_ENABLED

LIBXML_OUTPUT_ENABLED

LIBXML_PUSH_ENABLED

LIBXML_OUTPUT_ENABLED

LIBXML_C14N_ENABLED

LIBXML_READER_ENABLED

LIBXML_TREE_ENABLED

LIBXML_OUTPUT_ENABLED

LIBXML_HTML_ENABLED

LIBXML_VALID_ENABLED

LIBXML_PUSH_ENABLED

LIBXML_OUTPUT_ENABLED

OK it's for testing purposes

LIBXML_OUTPUT_ENABLED

LIBXML_READER_ENABLED

LIBXML_SAX1_ENABLED

LIBXML_SAX1_ENABLED

LIBXML_VALID_ENABLED

LIBXML_READER_ENABLED

forces loading the DTDs

LIBXML_READER_ENABLED

forces loading the DTDs

LIBXML_SCHEMAS_ENABLED

LIBXML_PATTERN_ENABLED

LIBXML_VALID_ENABLED

Remember file names. "-" means stdin. <sven@zen.org>

LIBXML_READER_ENABLED

LIBXML_READER_ENABLED

LIBXML_READER_ENABLED

/etc/xml/catalog"

xmlsoft.org/\n");

xmlsoft.org/bugs.html\n");

W3C//DTD HTML 4.0 Transitional//EN\"\n");

www.w3.org/TR/REC-html40/loose.dtd\">\n");

libxml.h

ws2_32.lib

file:///etc/xml/catalog

;

:

MAX_PATHS reached: too many paths\n





/

Loaded URL=\"%s\" ID=\"%s\"\n

(null)

(null)

/

Loaded URL=\"%s\" ID=\"%s\"\n

(null)

failed to load external entity \"%s\"\n

failed to load external entity \"%s\"\n

Ran out of memory needs > %d bytes\n

endTimer required stdarg functions

took %ld ms\n

s little we can do about * that. */ #ifndef CLOCKS_PER_SEC #define CLOCKS_PER_SEC 100 #endif static clock_t begin, end; static void startTimer(void) { begin = clock(); } static void XMLCDECL endTimer(const char *fmt, ...) { long msec; va_list ap; end = clock(); msec = ((end - begin) * 1000) / CLOCKS_PER_SEC; #ifndef HAVE_STDARG_H #error "endTimer required stdarg functions" #endif va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap); fprintf(stderr, " took %ld ms\n", msec); } #else /* * We don

t do timing */ static void startTimer(void) { /* * Do nothing */ } static void XMLCDECL endTimer(char *format, ...) { /* * We cannot do anything because we don

was not timed\n

t have gettimeofday, time or stdarg.h, what crazy world is * this ?! */ #endif } #endif /************************************************************************ * * * HTML ouput * * * ************************************************************************/ static char buffer[50000]; static void xmlHTMLEncodeSend(void) { char *result; result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer); if (result) { xmlGenericError(xmlGenericErrorContext, "%s", result); xmlFree(result); } buffer[0] = 0; } /** * xmlHTMLPrintFileInfo: * @input: an xmlParserInputPtr input * * Displays the associated file and line informations for the current input */ static void xmlHTMLPrintFileInfo(xmlParserInputPtr input) { int len; xmlGenericError(xmlGenericErrorContext, "<p>"); len = strlen(buffer); if (input != NULL) { if (input->filename) { snprintf(&buffer[len], sizeof(buffer) - len, "%s:%d: ", input->filename, input->line); } else { snprintf(&buffer[len], sizeof(buffer) - len, "Entity: line %d: ", input->line); } } xmlHTMLEncodeSend(); } /** * xmlHTMLPrintFileContext: * @input: an xmlParserInputPtr input * * Displays current context within the input content for error tracking */ static void xmlHTMLPrintFileContext(xmlParserInputPtr input) { const xmlChar *cur, *base; int len; int n; if (input == NULL) return; xmlGenericError(xmlGenericErrorContext, "<pre>\n"); cur = input->cur; base = input->base; while ((cur > base) && ((*cur ==

) || (*cur ==

))) { cur--; } n = 0; while ((n++ < 80) && (cur > base) && (*cur !=

) && (*cur !=

)) cur--; if ((*cur ==

) || (*cur ==

)) cur++; base = cur; n = 0; while ((*cur != 0) && (*cur !=

) && (*cur !=

) && (n < 79)) { len = strlen(buffer); snprintf(&buffer[len], sizeof(buffer) - len, "%c", (unsigned char) *cur++); n++; } len = strlen(buffer); snprintf(&buffer[len], sizeof(buffer) - len, "\n"); cur = input->cur; while ((*cur ==

) || (*cur ==

)) cur--; n = 0; while ((cur != base) && (n++ < 80)) { len = strlen(buffer); snprintf(&buffer[len], sizeof(buffer) - len, " "); base++; } len = strlen(buffer); snprintf(&buffer[len], sizeof(buffer) - len, "^\n"); xmlHTMLEncodeSend(); xmlGenericError(xmlGenericErrorContext, "</pre>"); } /** * xmlHTMLError: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format an error messages, gives file, line, position and * extra parameters. */ static void XMLCDECL xmlHTMLError(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input; va_list args; int len; buffer[0] = 0; input = ctxt->input; if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) { input = ctxt->inputTab[ctxt->inputNr - 2]; } xmlHTMLPrintFileInfo(input); xmlGenericError(xmlGenericErrorContext, "<b>error</b>: "); va_start(args, msg); len = strlen(buffer); vsnprintf(&buffer[len], sizeof(buffer) - len, msg, args); va_end(args); xmlHTMLEncodeSend(); xmlGenericError(xmlGenericErrorContext, "</p>\n"); xmlHTMLPrintFileContext(input); xmlHTMLEncodeSend(); } /** * xmlHTMLWarning: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a warning messages, gives file, line, position and * extra parameters. */ static void XMLCDECL xmlHTMLWarning(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input; va_list args; int len; buffer[0] = 0; input = ctxt->input; if ((input != NULL) && (input->filename == NULL) && (ctxt->inputNr > 1)) { input = ctxt->inputTab[ctxt->inputNr - 2]; } xmlHTMLPrintFileInfo(input); xmlGenericError(xmlGenericErrorContext, "<b>warning</b>: "); va_start(args, msg); len = strlen(buffer); vsnprintf(&buffer[len], sizeof(buffer) - len, msg, args); va_end(args); xmlHTMLEncodeSend(); xmlGenericError(xmlGenericErrorContext, "</p>\n"); xmlHTMLPrintFileContext(input); xmlHTMLEncodeSend(); } /** * xmlHTMLValidityError: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format an validity error messages, gives file, * line, position and extra parameters. */ static void XMLCDECL xmlHTMLValidityError(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input; va_list args; int len; buffer[0] = 0; input = ctxt->input; if ((input->filename == NULL) && (ctxt->inputNr > 1)) input = ctxt->inputTab[ctxt->inputNr - 2]; xmlHTMLPrintFileInfo(input); xmlGenericError(xmlGenericErrorContext, "<b>validity error</b>: "); len = strlen(buffer); va_start(args, msg); vsnprintf(&buffer[len], sizeof(buffer) - len, msg, args); va_end(args); xmlHTMLEncodeSend(); xmlGenericError(xmlGenericErrorContext, "</p>\n"); xmlHTMLPrintFileContext(input); xmlHTMLEncodeSend(); progresult = XMLLINT_ERR_VALID; } /** * xmlHTMLValidityWarning: * @ctx: an XML parser context * @msg: the message to display/transmit * @...: extra parameters for the message display * * Display and format a validity warning messages, gives file, line, * position and extra parameters. */ static void XMLCDECL xmlHTMLValidityWarning(void *ctx, const char *msg, ...) { xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; xmlParserInputPtr input; va_list args; int len; buffer[0] = 0; input = ctxt->input; if ((input->filename == NULL) && (ctxt->inputNr > 1)) input = ctxt->inputTab[ctxt->inputNr - 2]; xmlHTMLPrintFileInfo(input); xmlGenericError(xmlGenericErrorContext, "<b>validity warning</b>: "); va_start(args, msg); len = strlen(buffer); vsnprintf(&buffer[len], sizeof(buffer) - len, msg, args); va_end(args); xmlHTMLEncodeSend(); xmlGenericError(xmlGenericErrorContext, "</p>\n"); xmlHTMLPrintFileContext(input); xmlHTMLEncodeSend(); } /************************************************************************ * * * Shell Interface * * * ************************************************************************/ #ifdef LIBXML_DEBUG_ENABLED #ifdef LIBXML_XPATH_ENABLED /** * xmlShellReadline: * @prompt: the prompt value * * Read a string * * Returns a pointer to it or NULL on EOF the caller is expected to * free the returned string. */ static char * xmlShellReadline(char *prompt) { #ifdef HAVE_LIBREADLINE char *line_read; /* Get a line from the user. */ line_read = readline (prompt); /* If the line has any text in it, save it on the history. */ if (line_read && *line_read) add_history (line_read); return (line_read); #else char line_read[501]; char *ret; int len; if (prompt != NULL) fprintf(stdout, "%s", prompt); if (!fgets(line_read, 500, stdin)) return(NULL); line_read[500] = 0; len = strlen(line_read); ret = (char *) malloc(len + 1); if (ret != NULL) { memcpy (ret, line_read, len + 1); } return(ret); #endif } #endif /* LIBXML_XPATH_ENABLED */ #endif /* LIBXML_DEBUG_ENABLED */ /************************************************************************ * * * I/O Interfaces * * * ************************************************************************/ static int myRead(FILE *f, char * buf, int len) { return(fread(buf, 1, len, f)); } static void myClose(FILE *f) { if (f != stdin) { fclose(f); } } /************************************************************************ * * * SAX based tests * * * ************************************************************************/ /* * empty SAX block */ static xmlSAXHandler emptySAXHandlerStruct = { NULL, /* internalSubset */ NULL, /* isStandalone */ NULL, /* hasInternalSubset */ NULL, /* hasExternalSubset */ NULL, /* resolveEntity */ NULL, /* getEntity */ NULL, /* entityDecl */ NULL, /* notationDecl */ NULL, /* attributeDecl */ NULL, /* elementDecl */ NULL, /* unparsedEntityDecl */ NULL, /* setDocumentLocator */ NULL, /* startDocument */ NULL, /* endDocument */ NULL, /* startElement */ NULL, /* endElement */ NULL, /* reference */ NULL, /* characters */ NULL, /* ignorableWhitespace */ NULL, /* processingInstruction */ NULL, /* comment */ NULL, /* xmlParserWarning */ NULL, /* xmlParserError */ NULL, /* xmlParserError */ NULL, /* getParameterEntity */ NULL, /* cdataBlock; */ NULL, /* externalSubset; */ XML_SAX2_MAGIC, NULL, NULL, /* startElementNs */ NULL, /* endElementNs */ NULL /* xmlStructuredErrorFunc */ }; static xmlSAXHandlerPtr emptySAXHandler = &emptySAXHandlerStruct; extern xmlSAXHandlerPtr debugSAXHandler; static int callbacks; /** * isStandaloneDebug: * @ctxt: An XML parser context * * Is this document tagged standalone ? * * Returns 1 if true */ static int isStandaloneDebug(void *ctx ATTRIBUTE_UNUSED) { callbacks++; if (noout) return(0); fprintf(stdout, "SAX.isStandalone()\n"); return(0); } /** * hasInternalSubsetDebug: * @ctxt: An XML parser context * * Does this document has an internal subset * * Returns 1 if true */ static int hasInternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED) { callbacks++; if (noout) return(0); fprintf(stdout, "SAX.hasInternalSubset()\n"); return(0); } /** * hasExternalSubsetDebug: * @ctxt: An XML parser context * * Does this document has an external subset * * Returns 1 if true */ static int hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED) { callbacks++; if (noout) return(0); fprintf(stdout, "SAX.hasExternalSubset()\n"); return(0); } /** * internalSubsetDebug: * @ctxt: An XML parser context * * Does this document has an internal subset */ static void internalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID) { callbacks++; if (noout) return; fprintf(stdout, "SAX.internalSubset(%s,", name); if (ExternalID == NULL) fprintf(stdout, " ,"); else fprintf(stdout, " %s,", ExternalID); if (SystemID == NULL) fprintf(stdout, " )\n"); else fprintf(stdout, " %s)\n", SystemID); } /** * externalSubsetDebug: * @ctxt: An XML parser context * * Does this document has an external subset */ static void externalSubsetDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID) { callbacks++; if (noout) return; fprintf(stdout, "SAX.externalSubset(%s,", name); if (ExternalID == NULL) fprintf(stdout, " ,"); else fprintf(stdout, " %s,", ExternalID); if (SystemID == NULL) fprintf(stdout, " )\n"); else fprintf(stdout, " %s)\n", SystemID); } /** * resolveEntityDebug: * @ctxt: An XML parser context * @publicId: The public ID of the entity * @systemId: The system ID of the entity * * Special entity resolver, better left to the parser, it has * more context than the application layer. * The default behaviour is to NOT resolve the entities, in that case * the ENTITY_REF nodes are built in the structure (and the parameter * values). * * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour. */ static xmlParserInputPtr resolveEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *publicId, const xmlChar *systemId) { callbacks++; if (noout) return(NULL); /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */ fprintf(stdout, "SAX.resolveEntity("); if (publicId != NULL) fprintf(stdout, "%s", (char *)publicId); else fprintf(stdout, " "); if (systemId != NULL) fprintf(stdout, ", %s)\n", (char *)systemId); else fprintf(stdout, ", )\n"); return(NULL); } /** * getEntityDebug: * @ctxt: An XML parser context * @name: The entity name * * Get an entity by name * * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour. */ static xmlEntityPtr getEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name) { callbacks++; if (noout) return(NULL); fprintf(stdout, "SAX.getEntity(%s)\n", name); return(NULL); } /** * getParameterEntityDebug: * @ctxt: An XML parser context * @name: The entity name * * Get a parameter entity by name * * Returns the xmlParserInputPtr */ static xmlEntityPtr getParameterEntityDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name) { callbacks++; if (noout) return(NULL); fprintf(stdout, "SAX.getParameterEntity(%s)\n", name); return(NULL); } /** * entityDeclDebug: * @ctxt: An XML parser context * @name: the entity name * @type: the entity type * @publicId: The public ID of the entity * @systemId: The system ID of the entity * @content: the entity value (without processing). * * An entity definition has been parsed */ static void entityDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content) { const xmlChar *nullstr = BAD_CAST "(null)"; /* not all libraries handle printing null pointers nicely */ if (publicId == NULL) publicId = nullstr; if (systemId == NULL) systemId = nullstr; if (content == NULL) content = (xmlChar *)nullstr; callbacks++; if (noout) return; fprintf(stdout, "SAX.entityDecl(%s, %d, %s, %s, %s)\n", name, type, publicId, systemId, content); } /** * attributeDeclDebug: * @ctxt: An XML parser context * @name: the attribute name * @type: the attribute type * * An attribute definition has been parsed */ static void attributeDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar * elem, const xmlChar * name, int type, int def, const xmlChar * defaultValue, xmlEnumerationPtr tree) { callbacks++; if (noout) return; if (defaultValue == NULL) fprintf(stdout, "SAX.attributeDecl(%s, %s, %d, %d, NULL, ...)\n", elem, name, type, def); else fprintf(stdout, "SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\n", elem, name, type, def, defaultValue); xmlFreeEnumeration(tree); } /** * elementDeclDebug: * @ctxt: An XML parser context * @name: the element name * @type: the element type * @content: the element value (without processing). * * An element definition has been parsed */ static void elementDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, int type, xmlElementContentPtr content ATTRIBUTE_UNUSED) { callbacks++; if (noout) return; fprintf(stdout, "SAX.elementDecl(%s, %d, ...)\n", name, type); } /** * notationDeclDebug: * @ctxt: An XML parser context * @name: The name of the notation * @publicId: The public ID of the entity * @systemId: The system ID of the entity * * What to do when a notation declaration has been parsed. */ static void notationDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId) { callbacks++; if (noout) return; fprintf(stdout, "SAX.notationDecl(%s, %s, %s)\n", (char *) name, (char *) publicId, (char *) systemId); } /** * unparsedEntityDeclDebug: * @ctxt: An XML parser context * @name: The name of the entity * @publicId: The public ID of the entity * @systemId: The system ID of the entity * @notationName: the name of the notation * * What to do when an unparsed entity declaration is parsed */ static void unparsedEntityDeclDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName) { const xmlChar *nullstr = BAD_CAST "(null)"; if (publicId == NULL) publicId = nullstr; if (systemId == NULL) systemId = nullstr; if (notationName == NULL) notationName = nullstr; callbacks++; if (noout) return; fprintf(stdout, "SAX.unparsedEntityDecl(%s, %s, %s, %s)\n", (char *) name, (char *) publicId, (char *) systemId, (char *) notationName); } /** * setDocumentLocatorDebug: * @ctxt: An XML parser context * @loc: A SAX Locator * * Receive the document locator at startup, actually xmlDefaultSAXLocator * Everything is available on the context, so this is useless in our case. */ static void setDocumentLocatorDebug(void *ctx ATTRIBUTE_UNUSED, xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED) { callbacks++; if (noout) return; fprintf(stdout, "SAX.setDocumentLocator()\n"); } /** * startDocumentDebug: * @ctxt: An XML parser context * * called when the document start being processed. */ static void startDocumentDebug(void *ctx ATTRIBUTE_UNUSED) { callbacks++; if (noout) return; fprintf(stdout, "SAX.startDocument()\n"); } /** * endDocumentDebug: * @ctxt: An XML parser context * * called when the document end has been detected. */ static void endDocumentDebug(void *ctx ATTRIBUTE_UNUSED) { callbacks++; if (noout) return; fprintf(stdout, "SAX.endDocument()\n"); } /** * startElementDebug: * @ctxt: An XML parser context * @name: The element name * * called when an opening tag has been processed. */ static void startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts) { int i; callbacks++; if (noout) return; fprintf(stdout, "SAX.startElement(%s", (char *) name); if (atts != NULL) { for (i = 0;(atts[i] != NULL);i++) { fprintf(stdout, ", %s=

, atts[i++]); if (atts[i] != NULL) fprintf(stdout,

", atts[i]); } } fprintf(stdout, ")\n"); } /** * endElementDebug: * @ctxt: An XML parser context * @name: The element name * * called when the end of an element has been detected. */ static void endElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name) { callbacks++; if (noout) return; fprintf(stdout, "SAX.endElement(%s)\n", (char *) name); } /** * charactersDebug: * @ctxt: An XML parser context * @ch: a xmlChar string * @len: the number of xmlChar * * receiving some chars from the parser. * Question: how much at a time ??? */ static void charactersDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len) { char out[40]; int i; callbacks++; if (noout) return; for (i = 0;(i<len) && (i < 30);i++) out[i] = ch[i]; out[i] = 0; fprintf(stdout, "SAX.characters(%s, %d)\n", out, len); } /** * referenceDebug: * @ctxt: An XML parser context * @name: The entity name * * called when an entity reference is detected. */ static void referenceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name) { callbacks++; if (noout) return; fprintf(stdout, "SAX.reference(%s)\n", name); } /** * ignorableWhitespaceDebug: * @ctxt: An XML parser context * @ch: a xmlChar string * @start: the first char in the string * @len: the number of xmlChar * * receiving some ignorable whitespaces from the parser. * Question: how much at a time ??? */ static void ignorableWhitespaceDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len) { char out[40]; int i; callbacks++; if (noout) return; for (i = 0;(i<len) && (i < 30);i++) out[i] = ch[i]; out[i] = 0; fprintf(stdout, "SAX.ignorableWhitespace(%s, %d)\n", out, len); } /** * processingInstructionDebug: * @ctxt: An XML parser context * @target: the target name * @data: the PI data

SAX.processingInstruction(%s, %s)\n

SAX.processingInstruction(%s, NULL)\n

SAX.pcdata(%.20s, %d)\n

SAX.comment(%s)\n

SAX.warning:

SAX.error:

SAX.fatalError:

SAX.startElementNs(%s

, NULL

, %s

, NULL

, '%s'

, %d

, xmlns

:%s

='%s'

, %d, %d

, %s:%s='

, %s='

%.4s...', %d

)\n

SAX.endElementNs(%s

, NULL

, %s

, NULL)\n

, '%s')\n

user_data

s not the simplest code but the most generic in term of I/O */ buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE); if (buf == NULL) { goto error; } #ifdef LIBXML_SCHEMAS_ENABLED if (wxschemas != NULL) { int ret; xmlSchemaValidCtxtPtr vctxt; vctxt = xmlSchemaNewValidCtxt(wxschemas); xmlSchemaSetValidErrors(vctxt, (xmlSchemaValidityErrorFunc) fprintf, (xmlSchemaValidityWarningFunc) fprintf, stderr); ret = xmlSchemaValidateStream(vctxt, buf, 0, handler, (void *)user_data); if (repeat == 0) { if (ret == 0) { fprintf(stderr, "%s validates\n", filename); } else if (ret > 0) { fprintf(stderr, "%s fails to validate\n", filename); progresult = XMLLINT_ERR_VALID; } else { fprintf(stderr, "%s validation generated an internal error\n", filename); progresult = XMLLINT_ERR_VALID; } } xmlSchemaFreeValidCtxt(vctxt); } else #endif { /* * Create the parser context amd hook the input */ ctxt = xmlNewParserCtxt(); if (ctxt == NULL) { xmlFreeParserInputBuffer(buf); goto error; } old_sax = ctxt->sax; ctxt->sax = handler; ctxt->userData = (void *) user_data; inputStream = xmlNewIOInputStream(ctxt, buf, XML_CHAR_ENCODING_NONE); if (inputStream == NULL) { xmlFreeParserInputBuffer(buf); goto error; } inputPush(ctxt, inputStream); /* do the parsing */ xmlParseDocument(ctxt); if (ctxt->myDoc != NULL) { fprintf(stderr, "SAX generated a doc !\n"); xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL; } } error: if (ctxt != NULL) { ctxt->sax = old_sax; xmlFreeParserCtxt(ctxt); } } /************************************************************************ * * * Stream Test processing * * * ************************************************************************/ #ifdef LIBXML_READER_ENABLED static void processNode(xmlTextReaderPtr reader) { const xmlChar *name, *value; int type, empty; type = xmlTextReaderNodeType(reader); empty = xmlTextReaderIsEmptyElement(reader); if (debug) { name = xmlTextReaderConstName(reader); if (name == NULL) name = BAD_CAST "--"; value = xmlTextReaderConstValue(reader); printf("%d %d %s %d %d", xmlTextReaderDepth(reader), type, name, empty, xmlTextReaderHasValue(reader)); if (value == NULL) printf("\n"); else { printf(" %s\n", value); } } #ifdef LIBXML_PATTERN_ENABLED if (patternc) { xmlChar *path = NULL; int match = -1; if (type == XML_READER_TYPE_ELEMENT) { /* do the check only on element start */ match = xmlPatternMatch(patternc, xmlTextReaderCurrentNode(reader)); if (match) { #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) path = xmlGetNodePath(xmlTextReaderCurrentNode(reader)); printf("Node %s matches pattern %s\n", path, pattern); #else printf("Node %s matches pattern %s\n", xmlTextReaderConstName(reader), pattern); #endif } } if (patstream != NULL) { int ret; if (type == XML_READER_TYPE_ELEMENT) { ret = xmlStreamPush(patstream, xmlTextReaderConstLocalName(reader), xmlTextReaderConstNamespaceUri(reader)); if (ret < 0) { fprintf(stderr, "xmlStreamPush() failure\n"); xmlFreeStreamCtxt(patstream); patstream = NULL; } else if (ret != match) { #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) if (path == NULL) { path = xmlGetNodePath( xmlTextReaderCurrentNode(reader)); } #endif fprintf(stderr, "xmlPatternMatch and xmlStreamPush disagree\n"); if (path != NULL) fprintf(stderr, " pattern %s node %s\n", pattern, path); else fprintf(stderr, " pattern %s node %s\n", pattern, xmlTextReaderConstName(reader)); } } if ((type == XML_READER_TYPE_END_ELEMENT) || ((type == XML_READER_TYPE_ELEMENT) && (empty))) { ret = xmlStreamPop(patstream); if (ret < 0) { fprintf(stderr, "xmlStreamPop() failure\n"); xmlFreeStreamCtxt(patstream); patstream = NULL; } } } if (path != NULL) xmlFree(path); } #endif } static void streamFile(char *filename) { xmlTextReaderPtr reader; int ret; #ifdef HAVE_SYS_MMAN_H int fd = -1; struct stat info; const char *base = NULL; xmlParserInputBufferPtr input = NULL; if (memory) { if (stat(filename, &info) < 0) return; if ((fd = open(filename, O_RDONLY)) < 0) return; base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ; if (base == (void *) MAP_FAILED) return; reader = xmlReaderForMemory(base, info.st_size, filename, NULL, options); } else #endif reader = xmlReaderForFile(filename, NULL, options); #ifdef LIBXML_PATTERN_ENABLED if (pattern != NULL) { patternc = xmlPatterncompile((const xmlChar *) pattern, NULL, 0, NULL); if (patternc == NULL) { xmlGenericError(xmlGenericErrorContext, "Pattern %s failed to compile\n", pattern); progresult = XMLLINT_ERR_SCHEMAPAT; pattern = NULL; } } if (patternc != NULL) { patstream = xmlPatternGetStreamCtxt(patternc); if (patstream != NULL) { ret = xmlStreamPush(patstream, NULL, NULL); if (ret < 0) { fprintf(stderr, "xmlStreamPush() failure\n"); xmlFreeStreamCtxt(patstream); patstream = NULL; } } } #endif if (reader != NULL) { #ifdef LIBXML_VALID_ENABLED if (valid) xmlTextReaderSetParserProp(reader, XML_PARSER_VALIDATE, 1); else #endif /* LIBXML_VALID_ENABLED */ xmlTextReaderSetParserProp(reader, XML_PARSER_LOADDTD, 1); #ifdef LIBXML_SCHEMAS_ENABLED if (relaxng != NULL) { if ((timing) && (!repeat)) { startTimer(); } ret = xmlTextReaderRelaxNGValidate(reader, relaxng); if (ret < 0) { xmlGenericError(xmlGenericErrorContext, "Relax-NG schema %s failed to compile\n", relaxng); progresult = XMLLINT_ERR_SCHEMACOMP; relaxng = NULL; } if ((timing) && (!repeat)) { endTimer("Compiling the schemas"); } } if (schema != NULL) { if ((timing) && (!repeat)) { startTimer(); } ret = xmlTextReaderSchemaValidate(reader, schema); if (ret < 0) { xmlGenericError(xmlGenericErrorContext, "XSD schema %s failed to compile\n", schema); progresult = XMLLINT_ERR_SCHEMACOMP; schema = NULL; } if ((timing) && (!repeat)) { endTimer("Compiling the schemas"); } } #endif /* * Process all nodes in sequence */ if ((timing) && (!repeat)) { startTimer(); } ret = xmlTextReaderRead(reader); while (ret == 1) { if ((debug) #ifdef LIBXML_PATTERN_ENABLED || (patternc) #endif ) processNode(reader); ret = xmlTextReaderRead(reader); } if ((timing) && (!repeat)) { #ifdef LIBXML_SCHEMAS_ENABLED if (relaxng != NULL) endTimer("Parsing and validating"); else #endif #ifdef LIBXML_VALID_ENABLED if (valid) endTimer("Parsing and validating"); else #endif endTimer("Parsing"); } #ifdef LIBXML_VALID_ENABLED if (valid) { if (xmlTextReaderIsValid(reader) != 1) { xmlGenericError(xmlGenericErrorContext, "Document %s does not validate\n", filename); progresult = XMLLINT_ERR_VALID; } } #endif /* LIBXML_VALID_ENABLED */ #ifdef LIBXML_SCHEMAS_ENABLED if ((relaxng != NULL) || (schema != NULL)) { if (xmlTextReaderIsValid(reader) != 1) { fprintf(stderr, "%s fails to validate\n", filename); progresult = XMLLINT_ERR_VALID; } else { fprintf(stderr, "%s validates\n", filename); } } #endif /* * Done, cleanup and status */ xmlFreeTextReader(reader); if (ret != 0) { fprintf(stderr, "%s : failed to parse\n", filename); progresult = XMLLINT_ERR_UNCLASS; } } else { fprintf(stderr, "Unable to open %s\n", filename); progresult = XMLLINT_ERR_UNCLASS; } #ifdef LIBXML_PATTERN_ENABLED if (patstream != NULL) { xmlFreeStreamCtxt(patstream); patstream = NULL; } #endif #ifdef HAVE_SYS_MMAN_H if (memory) { xmlFreeParserInputBuffer(input); munmap((char *) base, info.st_size); close(fd); } #endif } static void walkDoc(xmlDocPtr doc) { xmlTextReaderPtr reader; int ret; #ifdef LIBXML_PATTERN_ENABLED xmlNodePtr root; const xmlChar *namespaces[22]; int i; xmlNsPtr ns; root = xmlDocGetRootElement(doc); for (ns = root->nsDef, i = 0;ns != NULL && i < 20;ns=ns->next) { namespaces[i++] = ns->href; namespaces[i++] = ns->prefix; } namespaces[i++] = NULL; namespaces[i] = NULL; if (pattern != NULL) { patternc = xmlPatterncompile((const xmlChar *) pattern, doc->dict, 0, &namespaces[0]); if (patternc == NULL) { xmlGenericError(xmlGenericErrorContext, "Pattern %s failed to compile\n", pattern); progresult = XMLLINT_ERR_SCHEMAPAT; pattern = NULL; } } if (patternc != NULL) { patstream = xmlPatternGetStreamCtxt(patternc); if (patstream != NULL) { ret = xmlStreamPush(patstream, NULL, NULL); if (ret < 0) { fprintf(stderr, "xmlStreamPush() failure\n"); xmlFreeStreamCtxt(patstream); patstream = NULL; } } } #endif /* LIBXML_PATTERN_ENABLED */ reader = xmlReaderWalker(doc); if (reader != NULL) { if ((timing) && (!repeat)) { startTimer(); } ret = xmlTextReaderRead(reader); while (ret == 1) { if ((debug) #ifdef LIBXML_PATTERN_ENABLED || (patternc) #endif ) processNode(reader); ret = xmlTextReaderRead(reader); } if ((timing) && (!repeat)) { endTimer("walking through the doc"); } xmlFreeTextReader(reader); if (ret != 0) { fprintf(stderr, "failed to walk through the doc\n"); progresult = XMLLINT_ERR_UNCLASS; } } else { fprintf(stderr, "Failed to crate a reader from the document\n"); progresult = XMLLINT_ERR_UNCLASS; } #ifdef LIBXML_PATTERN_ENABLED if (patstream != NULL) { xmlFreeStreamCtxt(patstream); patstream = NULL; } #endif } #endif /* LIBXML_READER_ENABLED */ /************************************************************************ * * * Tree Test processing * * * ************************************************************************/ static void parseAndPrintFile(char *filename, xmlParserCtxtPtr rectxt) { xmlDocPtr doc = NULL; #ifdef LIBXML_TREE_ENABLED xmlDocPtr tmp; #endif /* LIBXML_TREE_ENABLED */ if ((timing) && (!repeat)) startTimer(); #ifdef LIBXML_TREE_ENABLED if (filename == NULL) { if (generate) { xmlNodePtr n; doc = xmlNewDoc(BAD_CAST "1.0"); n = xmlNewDocNode(doc, NULL, BAD_CAST "info", NULL); xmlNodeSetContent(n, BAD_CAST "abc"); xmlDocSetRootElement(doc, n); } } #endif /* LIBXML_TREE_ENABLED */ #ifdef LIBXML_HTML_ENABLED #ifdef LIBXML_PUSH_ENABLED else if ((html) && (push)) { FILE *f; #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif if (f != NULL) { int res, size = 3; char chars[4096]; htmlParserCtxtPtr ctxt; /* if (repeat) */ size = 4096; res = fread(chars, 1, 4, f); if (res > 0) { ctxt = htmlCreatePushParserCtxt(NULL, NULL, chars, res, filename, XML_CHAR_ENCODING_NONE); while ((res = fread(chars, 1, size, f)) > 0) { htmlParseChunk(ctxt, chars, res, 0); } htmlParseChunk(ctxt, chars, 0, 1); doc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); } fclose(f); } } #endif /* LIBXML_PUSH_ENABLED */ #ifdef HAVE_SYS_MMAN_H else if ((html) && (memory)) { int fd; struct stat info; const char *base; if (stat(filename, &info) < 0) return; if ((fd = open(filename, O_RDONLY)) < 0) return; base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ; if (base == (void *) MAP_FAILED) return; doc = htmlReadMemory((char *) base, info.st_size, filename, NULL, options); munmap((char *) base, info.st_size); close(fd); } #endif else if (html) { doc = htmlReadFile(filename, NULL, options); } #endif /* LIBXML_HTML_ENABLED */ else { #ifdef LIBXML_PUSH_ENABLED /* * build an XML tree from a string; */ if (push) { FILE *f; /*

Usually means stdin -<sven@zen.org> */ if ((filename[0] ==

) && (filename[1] == 0)) { f = stdin; } else { #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif } if (f != NULL) { int ret; int res, size = 1024; char chars[1024]; xmlParserCtxtPtr ctxt; /* if (repeat) size = 1024; */ res = fread(chars, 1, 4, f); if (res > 0) { ctxt = xmlCreatePushParserCtxt(NULL, NULL, chars, res, filename); xmlCtxtUseOptions(ctxt, options); while ((res = fread(chars, 1, size, f)) > 0) { xmlParseChunk(ctxt, chars, res, 0); } xmlParseChunk(ctxt, chars, 0, 1); doc = ctxt->myDoc; ret = ctxt->wellFormed; xmlFreeParserCtxt(ctxt); if (!ret) { xmlFreeDoc(doc); doc = NULL; } } } } else #endif /* LIBXML_PUSH_ENABLED */ if (testIO) { if ((filename[0] ==

) && (filename[1] == 0)) { doc = xmlReadFd(0, NULL, NULL, options); } else { FILE *f; #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__) f = fopen(filename, "rb"); #else f = fopen(filename, "r"); #endif if (f != NULL) { if (rectxt == NULL) doc = xmlReadIO((xmlInputReadCallback) myRead, (xmlInputCloseCallback) myClose, f, filename, NULL, options); else doc = xmlCtxtReadIO(rectxt, (xmlInputReadCallback) myRead, (xmlInputCloseCallback) myClose, f, filename, NULL, options); } else doc = NULL; } } else if (htmlout) { xmlParserCtxtPtr ctxt; if (rectxt == NULL) ctxt = xmlNewParserCtxt(); else ctxt = rectxt; if (ctxt == NULL) { doc = NULL; } else { ctxt->sax->error = xmlHTMLError; ctxt->sax->warning = xmlHTMLWarning; ctxt->vctxt.error = xmlHTMLValidityError; ctxt->vctxt.warning = xmlHTMLValidityWarning; doc = xmlCtxtReadFile(ctxt, filename, NULL, options); if (rectxt == NULL) xmlFreeParserCtxt(ctxt); } #ifdef HAVE_SYS_MMAN_H } else if (memory) { int fd; struct stat info; const char *base; if (stat(filename, &info) < 0) return; if ((fd = open(filename, O_RDONLY)) < 0) return; base = mmap(NULL, info.st_size, PROT_READ, MAP_SHARED, fd, 0) ; if (base == (void *) MAP_FAILED) return; if (rectxt == NULL) doc = xmlReadMemory((char *) base, info.st_size, filename, NULL, options); else doc = xmlCtxtReadMemory(rectxt, (char *) base, info.st_size, filename, NULL, options); munmap((char *) base, info.st_size); close(fd); #endif #ifdef LIBXML_VALID_ENABLED } else if (valid) { xmlParserCtxtPtr ctxt = NULL; if (rectxt == NULL) ctxt = xmlNewParserCtxt(); else ctxt = rectxt; if (ctxt == NULL) { doc = NULL; } else { doc = xmlCtxtReadFile(ctxt, filename, NULL, options); if (ctxt->valid == 0) progresult = XMLLINT_ERR_RDFILE; if (rectxt == NULL) xmlFreeParserCtxt(ctxt); } #endif /* LIBXML_VALID_ENABLED */ } else { if (rectxt != NULL) doc = xmlCtxtReadFile(rectxt, filename, NULL, options); else { #ifdef LIBXML_SAX1_ENABLED if (sax1) doc = xmlParseFile(filename); else #endif /* LIBXML_SAX1_ENABLED */ doc = xmlReadFile(filename, NULL, options); } } } /* * If we don

Parsing

Xinclude processing

Copying

Freeing original

could not get valid list of elements\n

No element can be inserted under root\n

%d element types can be inserted under root:\n

%s\n

-

-

-

-

wb

failed to open %s\n

Saving

Failed to canonicalize\n

Failed to canonicalize\n

Failed to canonicalize\n

Failed to save\n

-

-

-

failed save to %s\n

-

-

failed save to %s\n

-

wb

failed to open %s\n

failed save to %s\n

-

Saving

wb

failed to open %s\n

Parsing DTD

Could not parse DTD %s\n

Could not parse DTD %s\n

Couldn't allocate validation context\n

Document %s does not validate against %s\n

Document %s does not validate against %s\n

Validating against DTD

Couldn't allocate validation context\n

Document %s does not validate\n

Validating

%s validates\n

%s fails to validate\n

%s validation generated an internal error\n

Validating

%s validates\n

%s fails to validate\n

%s validation generated an internal error\n

Validating

%s validates\n

%s fails to validate\n

%s validation generated an internal error\n

Validating

Freeing

%s: using libxml version %s\n

compiled with:

Threads

Tree

Output

Push

Reader

Patterns

Writer

SAXv1

FTP

HTTP

DTDValid

HTML

Legacy

C14N

Catalog

XPath

XPointer

XInclude

Iconv

ISO8859X

Unicode

Regexps

Automata

Expr

Schemas

Schematron

Modules

Debug

MemDebug

RunDebug

Zlib

\n

Usage : %s [options] XMLfiles ...\n

\tParse the XML files and output the result of the parsing\n

\tParse the XML files\n

\t--version : display the version of the XML library used\n

\t--debug : dump a debug tree of the in-memory document\n

\t--shell : run a navigating shell\n

\t--debugent : debug the entities defined in the document\n

\t--debug : dump the nodes content when using --stream\n

\t--copy : used to test the internal copy implementation\n

\t--recover : output what was parsable on broken XML documents\n

\t--huge : remove any internal arbitrary parser limits\n

\t--noent : substitute entity references by their value\n

\t--noout : don't output the result tree\n

\t--path 'paths': provide a set of paths for resources\n

\t--load-trace : print trace of all external entites loaded\n

\t--nonet : refuse to fetch DTDs or entities over network\n

\t--nocompact : do not generate compact text nodes\n

\t--htmlout : output results as HTML\n

\t--nowrap : do not put HTML doc wrapper\n

\t--valid : validate the document in addition to std well-formed check\n

\t--postvalid : do a posteriori validation, i.e after parsing\n

\t--dtdvalid URL : do a posteriori validation against a given DTD\n

\t--dtdvalidfpi FPI : same but name the DTD with a Public Identifier\n

\t--timing : print some timings\n

\t--output file or -o file: save to a given file\n

\t--repeat : repeat 100 times, for timing or profiling\n

\t--insert : ad-hoc test for valid insertions\n

\t--compress : turn on gzip compression of output\n

\t--html : use the HTML parser\n

\t--xmlout : force to use the XML serializer when using --html\n

\t--push : use the push mode of the parser\n

\t--memory : parse from memory\n

\t--maxmem nbbytes : limits memory allocation to nbbytes bytes\n

\t--nowarning : do not emit warnings from parser/validator\n

\t--noblanks : drop (ignorable?) blanks spaces\n

\t--nocdata : replace cdata section with text nodes\n

\t--format : reformat/reindent the input\n

\t--encode encoding : output in the given encoding\n

\t--dropdtd : remove the DOCTYPE of the input docs\n

\t--c14n : save in W3C canonical format v1.0 (with comments)\n

\t--c14n11 : save in W3C canonical format v1.1 (with comments)\n

\t--exc-c14n : save in W3C exclusive canonical format (with comments)\n

\t--nsclean : remove redundant namespace declarations\n

\t--testIO : test user I/O support\n

\t--catalogs : use SGML catalogs from $SGML_CATALOG_FILES\n

\t otherwise XML Catalogs starting from \n

\t %s are activated by default\n

\t--nocatalogs: deactivate all catalogs\n

\t--auto : generate a small doc on the fly\n

\t--xinclude : do XInclude processing\n

\t--noxincludenode : same but do not generate XInclude nodes\n

\t--nofixup-base-uris : do not fixup xml:base uris\n

\t--loaddtd : fetch external DTD\n

\t--dtdattr : loaddtd + populate the tree with inherited attributes \n

\t--stream : use the streaming interface to process very large files\n

\t--walker : create a reader and walk though the resulting doc\n

\t--pattern pattern_value : test the pattern support\n

\t--chkregister : verify the node registration code\n

\t--relaxng schema : do RelaxNG validation against the schema\n

\t--schema schema : do validation against the WXS schema\n

\t--schematron schema : do validation against a schematron\n

\t--sax1: use the old SAX1 interfaces for processing\n

\t--sax: do not build a tree but work just at the SAX level\n

\t--oldxml10: use XML-1.0 parsing rules before the 5th edition\n

\nLibxml project home page: http://xmlsoft.org/\n

To report bugs or get some help check: http://xmlsoft.org/bugs.html\n

-

-

-debug

--debug

-shell

--shell

-copy

--copy

-recover

--recover

-huge

--huge

-noent

--noent

-nsclean

--nsclean

-nocdata

--nocdata

-nodict

--nodict

-version

--version

-noout

--noout

-o

-output

--output

-htmlout

--htmlout

-nowrap

--nowrap

-html

--html

-xmlout

--xmlout

-loaddtd

--loaddtd

-dtdattr

--dtdattr

-valid

--valid

-postvalid

--postvalid

-dtdvalid

--dtdvalid

-dtdvalidfpi

--dtdvalidfpi

-dropdtd

--dropdtd

-insert

--insert

-timing

--timing

-auto

--auto

-repeat

--repeat

-push

--push

-memory

--memory

-testIO

--testIO

-xinclude

--xinclude

-noxincludenode

--noxincludenode

-nofixup-base-uris

--nofixup-base-uris

-compress

--compress

-nowarning

--nowarning

-pedantic

--pedantic

-debugent

--debugent

-c14n

--c14n

-c14n11

--c14n11

-exc-c14n

--exc-c14n

-catalogs

--catalogs

-nocatalogs

--nocatalogs

-encode

--encode

s for testing purposes */ xmlAddEncodingAlias("UTF-8", "DVEnc"); } else if ((!strcmp(argv[i], "-noblanks")) || (!strcmp(argv[i], "--noblanks"))) { noblanks++; xmlKeepBlanksDefault(0); } else if ((!strcmp(argv[i], "-maxmem")) || (!strcmp(argv[i], "--maxmem"))) { i++; if (sscanf(argv[i], "%d", &maxmem) == 1) { xmlMemSetup(myFreeFunc, myMallocFunc, myReallocFunc, myStrdupFunc); } else { maxmem = 0; } } else if ((!strcmp(argv[i], "-format")) || (!strcmp(argv[i], "--format"))) { noblanks++; #ifdef LIBXML_OUTPUT_ENABLED format++; #endif /* LIBXML_OUTPUT_ENABLED */ xmlKeepBlanksDefault(0); } #ifdef LIBXML_READER_ENABLED else if ((!strcmp(argv[i], "-stream")) || (!strcmp(argv[i], "--stream"))) { stream++; } else if ((!strcmp(argv[i], "-walker")) || (!strcmp(argv[i], "--walker"))) { walker++; noout++; } #endif /* LIBXML_READER_ENABLED */ #ifdef LIBXML_SAX1_ENABLED else if ((!strcmp(argv[i], "-sax1")) || (!strcmp(argv[i], "--sax1"))) { sax1++; options |= XML_PARSE_SAX1; } #endif /* LIBXML_SAX1_ENABLED */ else if ((!strcmp(argv[i], "-sax")) || (!strcmp(argv[i], "--sax"))) { sax++; } else if ((!strcmp(argv[i], "-chkregister")) || (!strcmp(argv[i], "--chkregister"))) { chkregister++; #ifdef LIBXML_SCHEMAS_ENABLED } else if ((!strcmp(argv[i], "-relaxng")) || (!strcmp(argv[i], "--relaxng"))) { i++; relaxng = argv[i]; noent++; options |= XML_PARSE_NOENT; } else if ((!strcmp(argv[i], "-schema")) || (!strcmp(argv[i], "--schema"))) { i++; schema = argv[i]; noent++; #endif #ifdef LIBXML_SCHEMATRON_ENABLED } else if ((!strcmp(argv[i], "-schematron")) || (!strcmp(argv[i], "--schematron"))) { i++; schematron = argv[i]; noent++; #endif } else if ((!strcmp(argv[i], "-nonet")) || (!strcmp(argv[i], "--nonet"))) { options |= XML_PARSE_NONET; xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader); } else if ((!strcmp(argv[i], "-nocompact")) || (!strcmp(argv[i], "--nocompact"))) { options &= ~XML_PARSE_COMPACT; } else if ((!strcmp(argv[i], "-load-trace")) || (!strcmp(argv[i], "--load-trace"))) { load_trace++; } else if ((!strcmp(argv[i], "-path")) || (!strcmp(argv[i], "--path"))) { i++; parsePath(BAD_CAST argv[i]); #ifdef LIBXML_PATTERN_ENABLED } else if ((!strcmp(argv[i], "-pattern")) || (!strcmp(argv[i], "--pattern"))) { i++; pattern = argv[i]; #endif } else if ((!strcmp(argv[i], "-oldxml10")) || (!strcmp(argv[i], "--oldxml10"))) { oldxml10++; options |= XML_PARSE_OLD10; } else { fprintf(stderr, "Unknown option %s\n", argv[i]); usage(argv[0]); return(1); } } #ifdef LIBXML_CATALOG_ENABLED if (nocatalogs == 0) { if (catalogs) { const char *catal; catal = getenv("SGML_CATALOG_FILES"); if (catal != NULL) { xmlLoadCatalogs(catal); } else { fprintf(stderr, "Variable $SGML_CATALOG_FILES not set\n"); } } } #endif #ifdef LIBXML_SAX1_ENABLED if (sax1) xmlSAXDefaultVersion(1); else xmlSAXDefaultVersion(2); #endif /* LIBXML_SAX1_ENABLED */ if (chkregister) { xmlRegisterNodeDefault(registerNode); xmlDeregisterNodeDefault(deregisterNode); } indent = getenv("XMLLINT_INDENT"); if(indent != NULL) { xmlTreeIndentString = indent; } defaultEntityLoader = xmlGetExternalEntityLoader(); xmlSetExternalEntityLoader(xmllintExternalEntityLoader); xmlLineNumbersDefault(1); if (loaddtd != 0) xmlLoadExtDtdDefaultValue |= XML_DETECT_IDS; if (dtdattrs) xmlLoadExtDtdDefaultValue |= XML_COMPLETE_ATTRS; if (noent != 0) xmlSubstituteEntitiesDefault(1); #ifdef LIBXML_VALID_ENABLED if (valid != 0) xmlDoValidityCheckingDefaultValue = 1; #endif /* LIBXML_VALID_ENABLED */ if ((htmlout) && (!nowrap)) { xmlGenericError(xmlGenericErrorContext, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\n"); xmlGenericError(xmlGenericErrorContext, "\t\"http://www.w3.org/TR/REC-html40/loose.dtd\">\n"); xmlGenericError(xmlGenericErrorContext, "<html><head><title>%s output</title></head>\n", argv[0]); xmlGenericError(xmlGenericErrorContext, "<body bgcolor=\"#ffffff\"><h1 align=\"center\">%s output</h1>\n", argv[0]); } #ifdef LIBXML_SCHEMATRON_ENABLED if ((schematron != NULL) && (sax == 0) #ifdef LIBXML_READER_ENABLED && (stream == 0) #endif /* LIBXML_READER_ENABLED */ ) { xmlSchematronParserCtxtPtr ctxt; /* forces loading the DTDs */ xmlLoadExtDtdDefaultValue |= 1; options |= XML_PARSE_DTDLOAD; if (timing) { startTimer(); } ctxt = xmlSchematronNewParserCtxt(schematron); #if 0 xmlSchematronSetParserErrors(ctxt, (xmlSchematronValidityErrorFunc) fprintf, (xmlSchematronValidityWarningFunc) fprintf, stderr); #endif wxschematron = xmlSchematronParse(ctxt); if (wxschematron == NULL) { xmlGenericError(xmlGenericErrorContext, "Schematron schema %s failed to compile\n", schematron); progresult = XMLLINT_ERR_SCHEMACOMP; schematron = NULL; } xmlSchematronFreeParserCtxt(ctxt); if (timing) { endTimer("Compiling the schemas"); } } #endif #ifdef LIBXML_SCHEMAS_ENABLED if ((relaxng != NULL) && (sax == 0) #ifdef LIBXML_READER_ENABLED && (stream == 0) #endif /* LIBXML_READER_ENABLED */ ) { xmlRelaxNGParserCtxtPtr ctxt; /* forces loading the DTDs */ xmlLoadExtDtdDefaultValue |= 1; options |= XML_PARSE_DTDLOAD; if (timing) { startTimer(); } ctxt = xmlRelaxNGNewParserCtxt(relaxng); xmlRelaxNGSetParserErrors(ctxt, (xmlRelaxNGValidityErrorFunc) fprintf, (xmlRelaxNGValidityWarningFunc) fprintf, stderr); relaxngschemas = xmlRelaxNGParse(ctxt); if (relaxngschemas == NULL) { xmlGenericError(xmlGenericErrorContext, "Relax-NG schema %s failed to compile\n", relaxng); progresult = XMLLINT_ERR_SCHEMACOMP; relaxng = NULL; } xmlRelaxNGFreeParserCtxt(ctxt); if (timing) { endTimer("Compiling the schemas"); } } else if ((schema != NULL) #ifdef LIBXML_READER_ENABLED && (stream == 0) #endif ) { xmlSchemaParserCtxtPtr ctxt; if (timing) { startTimer(); } ctxt = xmlSchemaNewParserCtxt(schema); xmlSchemaSetParserErrors(ctxt, (xmlSchemaValidityErrorFunc) fprintf, (xmlSchemaValidityWarningFunc) fprintf, stderr); wxschemas = xmlSchemaParse(ctxt); if (wxschemas == NULL) { xmlGenericError(xmlGenericErrorContext, "WXS schema %s failed to compile\n", schema); progresult = XMLLINT_ERR_SCHEMACOMP; schema = NULL; } xmlSchemaFreeParserCtxt(ctxt); if (timing) { endTimer("Compiling the schemas"); } } #endif /* LIBXML_SCHEMAS_ENABLED */ #ifdef LIBXML_PATTERN_ENABLED if ((pattern != NULL) #ifdef LIBXML_READER_ENABLED && (walker == 0) #endif ) { patternc = xmlPatterncompile((const xmlChar *) pattern, NULL, 0, NULL); if (patternc == NULL) { xmlGenericError(xmlGenericErrorContext, "Pattern %s failed to compile\n", pattern); progresult = XMLLINT_ERR_SCHEMAPAT; pattern = NULL; } } #endif /* LIBXML_PATTERN_ENABLED */ for (i = 1; i < argc ; i++) { if ((!strcmp(argv[i], "-encode")) || (!strcmp(argv[i], "--encode"))) { i++; continue; } else if ((!strcmp(argv[i], "-o")) || (!strcmp(argv[i], "-output")) || (!strcmp(argv[i], "--output"))) { i++; continue; } #ifdef LIBXML_VALID_ENABLED if ((!strcmp(argv[i], "-dtdvalid")) || (!strcmp(argv[i], "--dtdvalid"))) { i++; continue; } if ((!strcmp(argv[i], "-path")) || (!strcmp(argv[i], "--path"))) { i++; continue; } if ((!strcmp(argv[i], "-dtdvalidfpi")) || (!strcmp(argv[i], "--dtdvalidfpi"))) { i++; continue; } #endif /* LIBXML_VALID_ENABLED */ if ((!strcmp(argv[i], "-relaxng")) || (!strcmp(argv[i], "--relaxng"))) { i++; continue; } if ((!strcmp(argv[i], "-maxmem")) || (!strcmp(argv[i], "--maxmem"))) { i++; continue; } if ((!strcmp(argv[i], "-schema")) || (!strcmp(argv[i], "--schema"))) { i++; continue; } if ((!strcmp(argv[i], "-schematron")) || (!strcmp(argv[i], "--schematron"))) { i++; continue; } #ifdef LIBXML_PATTERN_ENABLED if ((!strcmp(argv[i], "-pattern")) || (!strcmp(argv[i], "--pattern"))) { i++; continue; } #endif if ((timing) && (repeat)) startTimer(); /* Remember file names. "-" means stdin. <sven@zen.org> */ if ((argv[i][0] !=

-

Registration count off: %d\n

%d iterations

</body></html>\n

0x81726354;

0x81726354);

