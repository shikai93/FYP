schemastypes.c : implementation of the XML Schema Datatypes definition and validity checking See Copyright for the status of this software. Daniel Veillard <veillard@redhat.com>

Date value

1 <= mon <= 12

1 <= day <= 31

0 <= hour <= 23

0 <= min <= 5

is tzo explicitely set?

-1440 <= tzo <= 1440; currently only -840 to +840 are needed

Duration value

mon stores years also

sec stores min and hour also

would use long long but not portable

Basic types

Derived types

Datatype error handlers

xmlSchemaTypeErrMemory: @extra: extra informations Handle an out of memory condition

Base types support

xmlSchemaNewValue: @type: the value type Allocate a new simple type value Returns a pointer to the new value or NULL in case of error

xmlSchemaInitBasicType: @name: the type name @type: the value type associated Initialize one primitive built-in type

Primitive types.

Set variety.

WARNING: Those type reside normally in xmlschemas.c but are redefined here locally in oder of being able to use them for xs:anyType- TODO: Remove those definition if we move the types to a header file. TODO: Always keep those structs up-to-date with the originals.

xmlSchemaInitTypes: Initialize the default XML Schemas type library

3.4.7 Built-in Complex Type Definition

Init the content type.

First particle.

Sequence model group.

Second particle.

The wildcard

Create the attribute wildcard.

primitive datatypes

derived datatypes

Derived list types.

ENTITIES

IDREFS

NMTOKENS

xmlSchemaCleanupTypes: Cleanup the default XML Schemas type library

Free xs:anyType.

Attribute wildcard.

Content type.

Wildcard.

Sequence model group.

xmlSchemaIsBuiltInTypeFacet: @type: the built-in type @facetType: the facet type Evaluates if a specific facet can be used in conjunction with a type. Returns 1 if the facet can be used with the given built-in type, 0 otherwise and -1 in case the type is not a built-in type.

xmlSchemaGetBuiltInType: @type: the type of the built in type Gives you the type struct for a built-in type by its type id. Returns the type if found, NULL otherwise.

xmlSchemaValueAppend: @prev: the value @cur: the value to be appended Appends a next sibling to a list of computed values. Returns 0 if succeeded and -1 on API errors.

xmlSchemaValueGetNext: @cur: the value Accessor for the next sibling of a list of computed values. Returns the next value or NULL if there was none, or on API errors.

xmlSchemaValueGetAsString: @val: the value Accessor for the string value of a computed value. Returns the string value or NULL if there was none, or on API errors.

xmlSchemaValueGetAsBoolean: @val: the value Accessor for the boolean value of a computed value. Returns 1 if true and 0 if false, or in case of an error. Hmm.

xmlSchemaNewStringValue: @type: the value type @value: the value Allocate a new simple type value. The type can be of XML_SCHEMAS_STRING. WARNING: This one is intended to be expanded for other string based types. We need this for anySimpleType as well. The given value is consumed and freed with the struct. Returns a pointer to the new value or NULL in case of error

xmlSchemaNewNOTATIONValue: @name: the notation name @ns: the notation namespace name or NULL Allocate a new NOTATION value. The given values are consumed and freed with the struct. Returns a pointer to the new value or NULL in case of error

xmlSchemaNewQNameValue: @namespaceName: the namespace name @localName: the local name Allocate a new QName value. The given values are consumed and freed with the struct. Returns a pointer to the new value or NULL in case of an error.

xmlSchemaFreeValue: @value: the value to free Cleanup the default XML Schemas type library

xmlSchemaGetPredefinedType: @name: the type name @ns: the URI of the namespace usually "http://www.w3.org/2001/XMLSchema" Lookup a type in the default XML Schemas type library Returns the type if found, NULL otherwise

xmlSchemaGetBuiltInListSimpleTypeItemType: @type: the built-in simple type. Lookup function Returns the item type of @type as defined by the built-in datatype hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.

Convenience macros and functions

VALID_DAY should only be used when month is unknown

_xmlSchemaParseGYear: @dt: pointer to a date structure @str: pointer to the string to analyze Parses a xs:gYear without time zone and fills in the appropriate field of the @dt structure. @str is updated to point just after the xs:gYear. It is supposed that @dt->year is big enough to contain the year. Returns 0 or the error code

year must be at least 4 digits (CCYY); over 4 digits cannot have a leading zero.

PARSE_2_DIGITS: @num: the integer to fill in @cur: an #xmlChar @invalid: an integer Parses a 2-digits integer and updates @num with the value. @cur is updated to point just after the integer. In case of error, @invalid is set to %TRUE, values of @num and @cur are undefined.

PARSE_FLOAT: @num: the double to fill in @cur: an #xmlChar @invalid: an integer Parses a float and updates @num with the value. @cur is updated to point just after the float. The float must have a 2-digits integer part and may or may not have a decimal part. In case of error, @invalid is set to %TRUE, values of @num and @cur are undefined.

_xmlSchemaParseGMonth: @dt: pointer to a date structure @str: pointer to the string to analyze Parses a xs:gMonth without time zone and fills in the appropriate field of the @dt structure. @str is updated to point just after the xs:gMonth. Returns 0 or the error code

_xmlSchemaParseGDay: @dt: pointer to a date structure @str: pointer to the string to analyze Parses a xs:gDay without time zone and fills in the appropriate field of the @dt structure. @str is updated to point just after the xs:gDay. Returns 0 or the error code

_xmlSchemaParseTime: @dt: pointer to a date structure @str: pointer to the string to analyze Parses a xs:time without time zone and fills in the appropriate fields of the @dt structure. @str is updated to point just after the xs:time. In case of error, values of @dt fields are undefined. Returns 0 or the error code

the ':' insures this string is xs:time

_xmlSchemaParseTimeZone: @dt: pointer to a date structure @str: pointer to the string to analyze Parses a time zone without time zone and fills in the appropriate field of the @dt structure. @str is updated to point just after the time zone. Returns 0 or the error code

_xmlSchemaBase64Decode: @ch: a character Converts a base64 encoded character to its base 64 value. Returns 0-63 (value), 64 (pad), or -1 (not recognized)

XML Schema Dates/Times Datatypes Handling

PARSE_DIGITS: @num: the integer to fill in @cur: an #xmlChar @num_type: an integer flag Parses a digits integer and updates @num with the value. @cur is updated to point just after the integer. In case of error, @num_type is set to -1, values of @num and @cur are undefined.

PARSE_NUM: @num: the double to fill in @cur: an #xmlChar @num_type: an integer flag Parses a float or integer and updates @num with the value. @cur is updated to point just after the number. If the number is a float, then it must have an integer part and a decimal part; @num_type will be set to 1. If there is no decimal part, @num_type is set to zero. In case of error, @num_type is set to -1, values of @num and @cur are undefined.

xmlSchemaValidateDates: @type: the expected type or XML_SCHEMAS_UNKNOWN @dateTime: string to analyze @val: the return computed value Check that @dateTime conforms to the lexical space of one of the date types. if true a value is computed and returned in @val. Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

It's an incomplete date (xs:gMonthDay, xs:gMonth or xs:gDay)

is it an xs:gDay?

it should be an xs:gMonthDay or xs:gMonth

a '-' char could indicate this type is xs:gMonthDay or a negative time zone offset. Check for xs:gMonthDay first. Also the first three char's of a negative tzo (-MM:SS) can appear to be a valid day; so even if the day portion of the xs:gMonthDay verifies, we must insure it was not a tzo.

we can use the VALID_MDAY macro to validate the month and day because the leap year test will flag year zero as a leap year (even though zero is an invalid year). FUTURE TODO: Zero will become valid in XML Schema 1.1 probably.

not xs:gMonthDay so rewind and check if just xs:gMonth with an optional time zone.

It's a right-truncated date or an xs:time. Try to parse an xs:time then fallback on right-truncated dates.

it's an xs:time

fallback on date parsing

is it an xs:gYear?

is it an xs:gYearMonth?

is it an xs:date?

it should be an xs:dateTime

insure the parsed type is equal to or less significant (right truncated) than the desired type.

time only matches time

xmlSchemaValidateDuration: @type: the predefined type @duration: string to analyze @val: the return computed value Check that @duration conforms to the lexical space of the duration type. if true a value is computed and returned in @val. Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

-1 = invalid, 0 = int, 1 = floating

duration must start with 'P' (after sign)

input string should be empty or invalid date/time item

T designator must be present for time items

parse the number portion of the item

update duration based on item type

verify numeric type; only seconds can be float

convert to seconds using multiplier

exit loop

no date designators found?

xmlSchemaStrip: @value: a value Removes the leading and ending spaces of a string Returns the new string or NULL if no change was required.

xmlSchemaWhiteSpaceReplace: @value: a value Replaces 0xd, 0x9 and 0xa with a space. Returns the new string or NULL if no change was required.

TODO FIXME: I guess gcc will bark at this.

xmlSchemaCollapseString: @value: a value Removes and normalize white spaces in the string Returns the new string or NULL if no change was required.

xmlSchemaValAtomicListNode: @type: the predefined atomic type for a token in the list @value: the list value to check @ret: the return computed value @node: the node containing the value Check that a value conforms to the lexical space of the predefined list type. if true a value is computed and returned in @ret. Returns the number of items if this validates, a negative error code number otherwise

Split the list

TODO what return value ? c.f. bug #158628 if (ret != NULL) { TODO }

xmlSchemaParseUInt: @str: pointer to the string R/W @llo: pointer to the low result @lmi: pointer to the mid result @lhi: pointer to the high result Parse an unsigned long into 3 fields. Returns the number of significant digits in the number or -1 if overflow of the capacity and -2 if it's not a number.

ignore leading zeroes

xmlSchemaValAtomicType: @type: the predefined type @value: the value to check @val: the return computed value @node: the node containing the value flags: flags to control the vlidation Check that a value conforms to the lexical space of the atomic type. if true a value is computed and returned in @val. This checks the value space for list types as well (IDREFS, NMTOKENS). Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

validating a non existant text node is similar to validating an empty one.

xs:decimal has a whitespace-facet value of 'collapse'.

First we handle an optional sign.

Disallow: "", "-", "- "

Next we "pre-parse" the number, in preparation for calling the common routine xmlSchemaParseUInt. We get rid of any leading zeroes (because we have reserved only 25 chars), and note the position of a decimal point.

Skip leading zeroes.

Disallow "." but allow "00."

error if any extraneous chars

Now evaluate the significant digits of the number

Get rid of trailing zeroes in the fractional part.

Terminate the (preparsed) string.

Set the total digits to 1 if a zero value.

Speedup for zero values.

TODO: sscanf seems not to give the correct value for extremely high/low values. E.g. "1E-149" results in zero.

TODO: sscanf seems not to give the correct value for extremely high/low values.

NOTE: the IDness might have already be declared in the DTD

Copy only the normalized piece. CRITICAL TODO: Check this.

number of octets

ISSUE: Ignore all stray characters? (yes, currently) Worry about long lines? (no, currently) rfc2045.txt: "The encoded output stream must be represented in lines of no more than 76 characters each. All line breaks or other characters not found in Table 1 must be ignored by decoding software. In base64 data, characters other than those in Table 1, line breaks, and other white space probably indicate a transmission error, about which a warning message or even a message rejection might be appropriate under some circumstances."

rfc2045.txt: "Special processing is performed if fewer than 24 bits are available at the end of the data being encoded. A full encoding quantum is always completed at the end of a body. When fewer than 24 input bits are available in an input group, zero bits are added (on the right) to form an integral number of 6-bit groups. Padding at the end of the data is performed using the "=" character. Since all base64 input is an integral number of octets, only the following cases can arise: (1) the final quantum of encoding input is an integral multiple of 24 bits; here, the final unit of encoded output will be an integral multiple ofindent: Standard input:701: Warning:old style assignment ambiguity in "=". Assuming "= " 4 characters with no "=" padding, (2) the final quantum of encoding input is exactly 8 bits; here, the final unit of encoded output will be two characters followed by two "=" padding characters, or (3) the final quantum of encoding input is exactly 16 bits; here, the final unit of encoded output will be three characters followed by one "=" padding character."

16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm0

00111100 -> 0x3c

8bits in 12bits means 4 pad bits: nnnnnn nn0000

00110000 -> 0x30

xmlSchemaValPredefTypeNode: @type: the predefined type @value: the value to check @val: the return computed value @node: the node containing the value Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val. Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

xmlSchemaValPredefTypeNodeNoNorm: @type: the predefined type @value: the value to check @val: the return computed value @node: the node containing the value Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val. This one does apply any normalization to the value. Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

xmlSchemaValidatePredefinedType: @type: the predefined type @value: the value to check @val: the return computed value Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val. Returns 0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.

xmlSchemaCompareDecimals: @x: a first decimal value @y: a second decimal value Compare 2 decimals Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error

First test: If x is -ve and not zero

Then if y is -ve and not zero reverse the compare

Otherwise (y >= 0) we have the answer

If x is not -ve and y is -ve we have the answer

If it's not simply determined by a difference in sign, then we need to compare the actual values of the two nums. To do this, we start by looking at the integral parts. If the number of integral digits differ, then we have our answer.

NOTE: We changed the "total" for values like "0.1" (or "-0.1" or ".1") to be 1, which was 2 previously. Therefore the special case, when such values are compared with 0, needs to be handled separately; otherwise a zero would be recognized incorrectly as greater than those values. This has the nice side effect that we gain an overall optimized comparison with zeroes. Note that a "0" has a "total" of 1 already.

If the number of integral digits is the same for both numbers, then things get a little more complicated. We need to "normalize" the numbers in order to properly compare them. To do this, we look at the total length of each number (length => number of significant digits), and divide the "shorter" by 10 (decreasing the length) until they are of equal length.

y has more digits than x

x has more digits than y

in effect, right shift by 108

xmlSchemaCompareDurations: @x: a first duration value @y: a second duration value Compare 2 durations Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

months

seconds

days

easy test

can this really happen ?

indeterminate

macros for adding date/times and durations

xmlSchemaDupVal: @v: the #xmlSchemaValPtr value to duplicate Makes a copy of @v. The calling program is responsible for freeing the returned value. returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error.

xmlSchemaCopyValue: @val: the precomputed value to be copied Copies the precomputed value. This duplicates any string within. Returns the copy or NULL if a copy for a data-type is not implemented.

Copy the string values.

_xmlSchemaDateAdd: @dt: an #xmlSchemaValPtr @dur: an #xmlSchemaValPtr of type #XS_DURATION Compute a new date/time from @dt and @dur. This function assumes @dt is either #XML_SCHEMAS_DATETIME, #XML_SCHEMAS_DATE, #XML_SCHEMAS_GYEARMONTH, or #XML_SCHEMAS_GYEAR. The returned #xmlSchemaVal is the same type as @dt. The calling program is responsible for freeing the returned value. Returns a pointer to a new #xmlSchemaVal or NULL if error.

make a copy so we don't alter the original value

normalization

normalize for time zone offset

normalization

month

year (may be modified later)

time zone

seconds

minute

hours

days Note we use tempdays because the temporary values may need more than 5 bits

Coverity detected an overrun in daysInMonth of size 12 at position 12 with index variable "((r)->mon - 1)"

adjust the date/time type to the date values

xmlSchemaDateNormalize: @dt: an #xmlSchemaValPtr of a date/time type value. @offset: number of seconds to adjust @dt by. Normalize @dt to GMT time. The @offset parameter is subtracted from the return value is a time-zone offset is present on @dt. Returns a normalized copy of @dt or NULL if error.

ret->value.date.tzo = 0;

_xmlSchemaDateCastYMToDays: @dt: an #xmlSchemaValPtr Convert mon and year of @dt to total number of days. Take the number of years since (or before) 1 AD and add the number of leap years. This is a function because negative years must be handled a little differently and there is no zero year. Returns number of days.

normalization

TIME_TO_NUMBER: @dt: an #xmlSchemaValPtr Calculates the number of seconds in the time portion of @dt. Returns seconds.

xmlSchemaCompareDates: @x: a first date/time value @y: a second date/time value Compare 2 date/times Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

normalize y + 14:00

normalize y - 14:00

indeterminate

normalize x - 14:00

normalize x + 14:00

indeterminate

if the same type then calculate the difference

mark type differences

mark field specification

year

indeterminate

month

indeterminate

day

indeterminate

time

indeterminate

xmlSchemaComparePreserveReplaceStrings: @x: a first string value @y: a second string value @invert: inverts the result if x < y or x > y. Compare 2 string for their normalized values. @x is a string with whitespace of "preserve", @y is a string with a whitespace of "replace". I.e. @x could be an "xsd:string" and @y an "xsd:normalizedString". Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in case of error

xmlSchemaComparePreserveCollapseStrings: @x: a first string value @y: a second string value Compare 2 string for their normalized values. @x is a string with whitespace of "preserve", @y is a string with a whitespace of "collapse". I.e. @x could be an "xsd:string" and @y an "xsd:normalizedString". Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in case of error

Skip leading blank chars of the collapsed string.

The yv character would have been replaced to 0x20.

Skip contiguous blank chars of the collapsed string.

Skip trailing blank chars of the collapsed string.

xmlSchemaComparePreserveCollapseStrings: @x: a first string value @y: a second string value Compare 2 string for their normalized values. @x is a string with whitespace of "preserve", @y is a string with a whitespace of "collapse". I.e. @x could be an "xsd:string" and @y an "xsd:normalizedString". Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in case of error

Skip leading blank chars of the collapsed string.

The yv character would have been replaced to 0x20.

Skip contiguous blank chars of the collapsed string.

The xv character would have been replaced to 0x20.

Skip trailing blank chars of the collapsed string.

xmlSchemaCompareReplacedStrings: @x: a first string value @y: a second string value Compare 2 string for their normalized values. Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in case of error

xmlSchemaCompareNormStrings: @x: a first string value @y: a second string value Compare 2 string for their normalized values. Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in case of error

xmlSchemaCompareFloats: @x: a first float or double value @y: a second float or double value Compare 2 values Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

Cast everything to doubles.

Check for special cases.

basic tests, the last one we should have equality, but portability is more important than speed and handling NaN or Inf in a portable way is always a challenge, so ...

xmlSchemaCompareValues: @x: a first value @xvalue: the first value as a string (optional) @xwtsp: the whitespace type @y: a second value @xvalue: the second value as a string (optional) @ywtsp: the whitespace type Compare 2 values Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, 3 if not comparable and -2 in case of error

Note that we will support comparison of string types against anySimpleType as well.

TODO: Compare those against QName.

TODO: What about x < y or x > y.

xmlSchemaCompareValues: @x: a first value @y: a second value Compare 2 values Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

xmlSchemaCompareValuesWhtsp: @x: a first value @xws: the whitespace value of x @y: a second value @yws: the whitespace value of y Compare 2 values Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

xmlSchemaCompareValuesWhtspExt: @x: a first value @xws: the whitespace value of x @y: a second value @yws: the whitespace value of y Compare 2 values Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in case of error

xmlSchemaNormLen: @value: a string Computes the UTF8 length of the normalized value of the string Returns the length or -1 in case of error.

xmlSchemaGetFacetValueAsULong: @facet: an schemas type facet Extract the value of a facet Returns the value as a long

TODO: Check if this is a decimal.

xmlSchemaValidateListSimpleTypeFacet: @facet: the facet to check @value: the lexical repr of the value to validate @actualLen: the number of list items @expectedLen: the resulting expected number of list items Checks the value of a list simple type against a facet. Returns 0 if the value is valid, a positive error code number otherwise and -1 in case of an internal error.

TODO: Check if this will work with large numbers. (compare value.decimal.mi and value.decimal.hi as well?).

NOTE: That we can pass NULL as xmlSchemaValPtr to xmlSchemaValidateFacet, since the remaining facet types are: XML_SCHEMA_FACET_PATTERN, XML_SCHEMA_FACET_ENUMERATION.

xmlSchemaValidateLengthFacet: @type: the built-in type @facet: the facet to check @value: the lexical repr. of the value to be validated @val: the precomputed value @ws: the whitespace type of the value @length: the actual length of the value Checka a value against a "length", "minLength" and "maxLength" facet; sets @length to the computed length of @value. Returns 0 if the value is valid, a positive error code otherwise and -1 in case of an internal or API error.

TODO: length, maxLength and minLength must be of type nonNegativeInteger only. Check if decimal is used somehow.

This is to ensure API compatibility with the old xmlSchemaValidateLengthFacet(). Anyway, this was and is not the correct handling. TODO: Get rid of this case somehow.

Should be OK for "preserve" as well.

FIXME: What exactly to do with anyURI?

For QName and NOTATION, those facets are deprecated and should be ignored.

TODO: Return the whole expected value, i.e. "lo", "mi" and "hi".

xmlSchemaValidateLengthFacet: @type: the built-in type @facet: the facet to check @value: the lexical repr. of the value to be validated @val: the precomputed value @length: the actual length of the value Checka a value against a "length", "minLength" and "maxLength" facet; sets @length to the computed length of @value. Returns 0 if the value is valid, a positive error code otherwise and -1 in case of an internal or API error.

xmlSchemaValidateLengthFacetWhtsp: @facet: the facet to check @valType: the built-in type @value: the lexical repr. of the value to be validated @val: the precomputed value @ws: the whitespace type of the value @length: the actual length of the value Checka a value against a "length", "minLength" and "maxLength" facet; sets @length to the computed length of @value. Returns 0 if the value is valid, a positive error code otherwise and -1 in case of an internal or API error.

xmlSchemaValidateFacetInternal: @facet: the facet to check @fws: the whitespace type of the facet's value @valType: the built-in type of the value @value: the lexical repr of the value to validate @val: the precomputed value @ws: the whitespace type of the value Check a value against a facet condition Returns 0 if the element is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.

NOTE that for patterns, the @value needs to be the normalized value, not the lexical initial value or the canonical value.

TODO whitespaces

NOTE: Whitespace should be handled to normalize the value to be validated against a the facets; not to normalize the value in-between.

This is to ensure API compatibility with the old xmlSchemaValidateFacet(). TODO: Get rid of this case.

SPEC (1.3) "if {primitive type definition} is QName or NOTATION, then any {value} is facet-valid."

No break on purpose.

TODO: length, maxLength and minLength must be of type nonNegativeInteger only. Check if decimal is used somehow.

This is to ensure API compatibility with the old xmlSchemaValidateFacet(). Anyway, this was and is not the correct handling. TODO: Get rid of this case somehow.

Should be OK for "preserve" as well.

xmlSchemaValidateFacet: @base: the base type @facet: the facet to check @value: the lexical repr of the value to validate @val: the precomputed value Check a value against a facet condition Returns 0 if the element is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.

This tries to ensure API compatibility regarding the old xmlSchemaValidateFacet() and the new xmlSchemaValidateFacetInternal() and xmlSchemaValidateFacetWhtsp().

xmlSchemaValidateFacetWhtsp: @facet: the facet to check @fws: the whitespace type of the facet's value @valType: the built-in type of the value @value: the lexical (or normalized for pattern) repr of the value to validate @val: the precomputed value @ws: the whitespace type of the value Check a value against a facet condition. This takes value normalization according to the specified whitespace types into account. Note that @value needs to be the normalized value if the facet is of type "pattern". Returns 0 if the element is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.

xmlXPathFormatNumber: @number: number to format @buffer: output buffer @buffersize: size of output buffer Convert the number into a string representation.

3 is sign, decimal point, and terminating zero

Result is in work, and after_fraction points just past the fractional part. Use scientific notation

Remove fractional trailing zeroes

Finally copy result back to caller

xmlSchemaGetCanonValue: @val: the precomputed value @retValue: the returned value Get a the cononical lexical representation of the value. The caller has to FREE the returned retValue. WARNING: Some value types are not supported yet, resulting in a @retValue of "???". TODO: XML Schema 1.0 does not define canonical representations for: duration, gYearMonth, gYear, gMonthDay, gMonth, gDay, anyURI, QName, NOTATION. This will be fixed in XML Schema 1.1. Returns 0 if the value could be built, 1 if the value type is not supported yet and -1 in case of API errors.

Unclear

Unclear

TODO: Unclear in XML Schema 1.0.

TODO: Lookout for a more simple implementation.

Add room for the decimal point as well.

Add room for leading/trailing zero.

Insert the decimal point.

Insert missing zeroes behind the decimal point.

Append decimal point and zero.

Add room for the decimal point as well.

TODO: Unclear in XML Schema 1.0

TODO: This results in a normalized output of the value - which is NOT conformant to the spec - since the exact values of each property are not recoverable. Think about extending the structure to provide a field for every property.

TODO: Unclear in XML Schema 1.0

TODO: What to do with the timezone?

TODO: Unclear in XML Schema 1.0

TODO: What to do with the timezone?

TODO: Unclear in XML Schema 1.0

TODO: What to do with the timezone?

TODO: Unclear in XML Schema 1.0

TODO: What to do with the timezone?

TODO: Unclear in XML Schema 1.0

TODO: What to do with the timezone?

TODO: Check if "%.14g" is portable.

TODO: Append the canonical value of the recoverable timezone and not "Z".

TODO: Check if "%.14g" is portable.

TODO: Is the following spec piece implemented?: SPEC: "Note: For some values the canonical form defined above does not conform to [RFC 2045], which requires breaking with linefeeds at appropriate intervals."

|m| < 16777216, -149 <= e <= 104. TODO: Handle, NaN, INF, -INF. The format is not yet conformant. The c type float does not cover the whole range.

|m| < 9007199254740992, -1075 <= e <= 970

TODO: Handle, NaN, INF, -INF. The format is not yet conformant. The c type float does not cover the whole range.

xmlSchemaGetCanonValueWhtsp: @val: the precomputed value @retValue: the returned value @ws: the whitespace type of the value Get a the cononical representation of the value. The caller has to free the returned @retValue. Returns 0 if the value could be built, 1 if the value type is not supported yet and -1 in case of API errors.

xmlSchemaGetValType: @val: a schemas value Accessor for the type of a value Returns the xmlSchemaValType of the value

LIBXML_SCHEMAS_ENABLED

www.w3.org/2001/XMLSchema"

www.w3.org/2001/XMLSchema"

libxml.h

Unimplemented block at %s:%d\n

http://www.w3.org/2001/XMLSchema

could not initialize basic types

allocating particle component

anyType

allocating model group component

allocating wildcard component

could not create an attribute

wildcard on anyType

anySimpleType

string

decimal

date

dateTime

time

gYear

gYearMonth

gMonth

gMonthDay

gDay

duration

float

double

boolean

anyURI

hexBinary

base64Binary

NOTATION

QName

integer

nonPositiveInteger

negativeInteger

long

int

short

byte

nonNegativeInteger

unsignedLong

unsignedInt

unsignedShort

unsignedByte

positiveInteger

normalizedString

token

language

Name

NMTOKEN

NCName

ID

IDREF

ENTITY

ENTITIES

IDREFS

NMTOKENS

http://www.w3.org/2001/XMLSchema

Z

+

-

type=%o %04ld-%02u-%02uT%02u:%02u:%03f

%+05d\n

Z\n

\n

0

9

-

+

-

0

9

0

0

0

9

0

9

0

0

.

0

9

0

9

0

:

:

:

Z

+

-

-

:

A

Z

A

a

z

a

0

9

0

+

/

=

0

9

0

9

0

.

0

9

0

9

0

-

0

9

-

-

s an incomplete date (xs:gMonthDay, xs:gMonth or * xs:gDay) */ cur += 2; /* is it an xs:gDay? */ if (*cur ==

) { if (type == XML_SCHEMAS_GMONTH) goto error; ++cur; ret = _xmlSchemaParseGDay(&(dt->value.date), &cur); if (ret != 0) goto error; RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY); goto error; } /* * it should be an xs:gMonthDay or xs:gMonth */ ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur); if (ret != 0) goto error; /* * a

char could indicate this type is xs:gMonthDay or * a negative time zone offset. Check for xs:gMonthDay first. * Also the first three char

-

:

s a right-truncated date or an xs:time. * Try to parse an xs:time then fallback on right-truncated dates. */ if ((*cur >=

) && (*cur <=

)) { ret = _xmlSchemaParseTime(&(dt->value.date), &cur); if (ret == 0) { /* it

-

-

T

Y

M

D

H

M

S

-

P

P

T







s not a number. */ static int xmlSchemaParseUInt(const xmlChar **str, unsigned long *llo, unsigned long *lmi, unsigned long *lhi) { unsigned long lo = 0, mi = 0, hi = 0; const xmlChar *tmp, *cur = *str; int ret = 0, i = 0; if (!((*cur >=

) && (*cur <=

))) return(-2); while (*cur ==

) { /* ignore leading zeroes */ cur++; } tmp = cur; while ((*tmp != 0) && (*tmp >=

) && (*tmp <=

)) { i++;tmp++;ret++; } if (i > 24) { *str = tmp; return(-1); } while (i > 16) { hi = hi * 10 + (*cur++ -

); i--; } while (i > 8) { mi = mi * 10 + (*cur++ -

); i--; } while (i > 0) { lo = lo * 10 + (*cur++ -

); i--; } *str = cur; *llo = lo; *lmi = mi; *lhi = hi; return(ret); } /** * xmlSchemaValAtomicType: * @type: the predefined type * @value: the value to check * @val: the return computed value * @node: the node containing the value * flags: flags to control the vlidation * * Check that a value conforms to the lexical space of the atomic type. * if true a value is computed and returned in @val. * This checks the value space for list types as well (IDREFS, NMTOKENS). * * Returns 0 if this validates, a positive error code number otherwise * and -1 in case of internal or API error. */ static int xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value, xmlSchemaValPtr * val, xmlNodePtr node, int flags, xmlSchemaWhitespaceValueType ws, int normOnTheFly, int applyNorm, int createStringValue) { xmlSchemaValPtr v; xmlChar *norm = NULL; int ret = 0; if (xmlSchemaTypesInitialized == 0) xmlSchemaInitTypes(); if (type == NULL) return (-1); /* * validating a non existant text node is similar to validating * an empty one. */ if (value == NULL) value = BAD_CAST ""; if (val != NULL) *val = NULL; if ((flags == 0) && (value != NULL)) { if ((type->builtInType != XML_SCHEMAS_STRING) && (type->builtInType != XML_SCHEMAS_ANYTYPE) && (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) { if (type->builtInType == XML_SCHEMAS_NORMSTRING) norm = xmlSchemaWhiteSpaceReplace(value); else norm = xmlSchemaCollapseString(value); if (norm != NULL) value = norm; } } switch (type->builtInType) { case XML_SCHEMAS_UNKNOWN: goto error; case XML_SCHEMAS_ANYTYPE: case XML_SCHEMAS_ANYSIMPLETYPE: if ((createStringValue) && (val != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; case XML_SCHEMAS_STRING: if (! normOnTheFly) { const xmlChar *cur = value; if (ws == XML_SCHEMA_WHITESPACE_REPLACE) { while (*cur != 0) { if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) { goto return1; } else { cur++; } } } else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) { while (*cur != 0) { if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) { goto return1; } else if IS_WSP_SPACE_CH(*cur) { cur++; if IS_WSP_SPACE_CH(*cur) goto return1; } else { cur++; } } } } if (createStringValue && (val != NULL)) { if (applyNorm) { if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) norm = xmlSchemaCollapseString(value); else if (ws == XML_SCHEMA_WHITESPACE_REPLACE) norm = xmlSchemaWhiteSpaceReplace(value); if (norm != NULL) value = norm; } v = xmlSchemaNewValue(XML_SCHEMAS_STRING); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; case XML_SCHEMAS_NORMSTRING:{ if (normOnTheFly) { if (applyNorm) { if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) norm = xmlSchemaCollapseString(value); else norm = xmlSchemaWhiteSpaceReplace(value); if (norm != NULL) value = norm; } } else { const xmlChar *cur = value; while (*cur != 0) { if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) { goto return1; } else { cur++; } } } if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; } case XML_SCHEMAS_DECIMAL:{ const xmlChar *cur = value; unsigned int len, neg, integ, hasLeadingZeroes; xmlChar cval[25]; xmlChar *cptr = cval; if ((cur == NULL) || (*cur == 0)) goto return1; /* * xs:decimal has a whitespace-facet value of

. */ if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; /* * First we handle an optional sign. */ neg = 0; if (*cur ==

) { neg = 1; cur++; } else if (*cur ==

) cur++; /* * Disallow: "", "-", "- " */ if (*cur == 0) goto return1; /* * Next we "pre-parse" the number, in preparation for calling * the common routine xmlSchemaParseUInt. We get rid of any * leading zeroes (because we have reserved only 25 chars), * and note the position of a decimal point. */ len = 0; integ = ~0u; hasLeadingZeroes = 0; /* * Skip leading zeroes. */ while (*cur ==

) { cur++; hasLeadingZeroes = 1; } if (*cur != 0) { do { if ((*cur >=

) && (*cur <=

)) { *cptr++ = *cur++; len++; } else if (*cur ==

) { cur++; integ = len; do { if ((*cur >=

) && (*cur <=

)) { *cptr++ = *cur++; len++; } else break; } while (len < 24); /* * Disallow "." but allow "00." */ if ((len == 0) && (!hasLeadingZeroes)) goto return1; break; } else break; } while (len < 24); } if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if (*cur != 0) goto return1; /* error if any extraneous chars */ if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL); if (v != NULL) { /* * Now evaluate the significant digits of the number */ if (len != 0) { if (integ != ~0u) { /* * Get rid of trailing zeroes in the * fractional part. */ while ((len != integ) && (*(cptr-1) ==

)) { cptr--; len--; } } /* * Terminate the (preparsed) string. */ if (len != 0) { *cptr = 0; cptr = cval; xmlSchemaParseUInt((const xmlChar **)&cptr, &v->value.decimal.lo, &v->value.decimal.mi, &v->value.decimal.hi); } } /* * Set the total digits to 1 if a zero value. */ v->value.decimal.sign = neg; if (len == 0) { /* Speedup for zero values. */ v->value.decimal.total = 1; } else { v->value.decimal.total = len; if (integ == ~0u) v->value.decimal.frac = 0; else v->value.decimal.frac = len - integ; } *val = v; } } goto return0; } case XML_SCHEMAS_TIME: case XML_SCHEMAS_GDAY: case XML_SCHEMAS_GMONTH: case XML_SCHEMAS_GMONTHDAY: case XML_SCHEMAS_GYEAR: case XML_SCHEMAS_GYEARMONTH: case XML_SCHEMAS_DATE: case XML_SCHEMAS_DATETIME: ret = xmlSchemaValidateDates(type->builtInType, value, val, normOnTheFly); break; case XML_SCHEMAS_DURATION: ret = xmlSchemaValidateDuration(type, value, val, normOnTheFly); break; case XML_SCHEMAS_FLOAT: case XML_SCHEMAS_DOUBLE:{ const xmlChar *cur = value; int neg = 0; if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if ((cur[0] ==

) && (cur[1] ==

) && (cur[2] ==

)) { cur += 3; if (*cur != 0) goto return1; if (val != NULL) { if (type == xmlSchemaTypeFloatDef) { v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT); if (v != NULL) { v->value.f = (float) xmlXPathNAN; } else { xmlSchemaFreeValue(v); goto error; } } else { v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE); if (v != NULL) { v->value.d = xmlXPathNAN; } else { xmlSchemaFreeValue(v); goto error; } } *val = v; } goto return0; } if (*cur ==

) { neg = 1; cur++; } if ((cur[0] ==

) && (cur[1] ==

) && (cur[2] ==

)) { cur += 3; if (*cur != 0) goto return1; if (val != NULL) { if (type == xmlSchemaTypeFloatDef) { v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT); if (v != NULL) { if (neg) v->value.f = (float) xmlXPathNINF; else v->value.f = (float) xmlXPathPINF; } else { xmlSchemaFreeValue(v); goto error; } } else { v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE); if (v != NULL) { if (neg) v->value.d = xmlXPathNINF; else v->value.d = xmlXPathPINF; } else { xmlSchemaFreeValue(v); goto error; } } *val = v; } goto return0; } if ((neg == 0) && (*cur ==

)) cur++; if ((cur[0] == 0) || (cur[0] ==

) || (cur[0] ==

)) goto return1; while ((*cur >=

) && (*cur <=

)) { cur++; } if (*cur ==

) { cur++; while ((*cur >=

) && (*cur <=

)) cur++; } if ((*cur ==

) || (*cur ==

)) { cur++; if ((*cur ==

) || (*cur ==

)) cur++; while ((*cur >=

) && (*cur <=

)) cur++; } if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if (*cur != 0) goto return1; if (val != NULL) { if (type == xmlSchemaTypeFloatDef) { v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT); if (v != NULL) { /* * TODO: sscanf seems not to give the correct * value for extremely high/low values. * E.g. "1E-149" results in zero. */ if (sscanf((const char *) value, "%f", &(v->value.f)) == 1) { *val = v; } else { xmlSchemaFreeValue(v); goto return1; } } else { goto error; } } else { v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE); if (v != NULL) { /* * TODO: sscanf seems not to give the correct * value for extremely high/low values. */ if (sscanf((const char *) value, "%lf", &(v->value.d)) == 1) { *val = v; } else { xmlSchemaFreeValue(v); goto return1; } } else { goto error; } } } goto return0; } case XML_SCHEMAS_BOOLEAN:{ const xmlChar *cur = value; if (normOnTheFly) { while IS_WSP_BLANK_CH(*cur) cur++; if (*cur ==

) { ret = 0; cur++; } else if (*cur ==

) { ret = 1; cur++; } else if (*cur ==

) { cur++; if ((*cur++ ==

) && (*cur++ ==

) && (*cur++ ==

)) { ret = 1; } else goto return1; } else if (*cur ==

) { cur++; if ((*cur++ ==

) && (*cur++ ==

) && (*cur++ ==

) && (*cur++ ==

)) { ret = 0; } else goto return1; } else goto return1; if (*cur != 0) { while IS_WSP_BLANK_CH(*cur) cur++; if (*cur != 0) goto return1; } } else { if ((cur[0] ==

) && (cur[1] == 0)) ret = 0; else if ((cur[0] ==

) && (cur[1] == 0)) ret = 1; else if ((cur[0] ==

) && (cur[1] ==

) && (cur[2] ==

) && (cur[3] ==

) && (cur[4] == 0)) ret = 1; else if ((cur[0] ==

) && (cur[1] ==

) && (cur[2] ==

) && (cur[3] ==

) && (cur[4] ==

) && (cur[5] == 0)) ret = 0; else goto return1; } if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN); if (v != NULL) { v->value.b = ret; *val = v; } else { goto error; } } goto return0; } case XML_SCHEMAS_TOKEN:{ const xmlChar *cur = value; if (! normOnTheFly) { while (*cur != 0) { if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) { goto return1; } else if (*cur ==

) { cur++; if (*cur == 0) goto return1; if (*cur ==

) goto return1; } else { cur++; } } } if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; } case XML_SCHEMAS_LANGUAGE: if (normOnTheFly) { norm = xmlSchemaCollapseString(value); if (norm != NULL) value = norm; } if (xmlCheckLanguageID(value) == 1) { if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; } goto return1; case XML_SCHEMAS_NMTOKEN: if (xmlValidateNMToken(value, 1) == 0) { if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto return0; } goto return1; case XML_SCHEMAS_NMTOKENS: ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef, value, val, node); if (ret > 0) ret = 0; else ret = 1; goto done; case XML_SCHEMAS_NAME: ret = xmlValidateName(value, 1); if ((ret == 0) && (val != NULL) && (value != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_NAME); if (v != NULL) { const xmlChar *start = value, *end; while (IS_BLANK_CH(*start)) start++; end = start; while ((*end != 0) && (!IS_BLANK_CH(*end))) end++; v->value.str = xmlStrndup(start, end - start); *val = v; } else { goto error; } } goto done; case XML_SCHEMAS_QNAME:{ const xmlChar *uri = NULL; xmlChar *local = NULL; ret = xmlValidateQName(value, 1); if (ret != 0) goto done; if (node != NULL) { xmlChar *prefix; xmlNsPtr ns; local = xmlSplitQName2(value, &prefix); ns = xmlSearchNs(node->doc, node, prefix); if ((ns == NULL) && (prefix != NULL)) { xmlFree(prefix); if (local != NULL) xmlFree(local); goto return1; } if (ns != NULL) uri = ns->href; if (prefix != NULL) xmlFree(prefix); } if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_QNAME); if (v == NULL) { if (local != NULL) xmlFree(local); goto error; } if (local != NULL) v->value.qname.name = local; else v->value.qname.name = xmlStrdup(value); if (uri != NULL) v->value.qname.uri = xmlStrdup(uri); *val = v; } else if (local != NULL) xmlFree(local); goto done; } case XML_SCHEMAS_NCNAME: ret = xmlValidateNCName(value, 1); if ((ret == 0) && (val != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } goto done; case XML_SCHEMAS_ID: ret = xmlValidateNCName(value, 1); if ((ret == 0) && (val != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_ID); if (v != NULL) { v->value.str = xmlStrdup(value); *val = v; } else { goto error; } } if ((ret == 0) && (node != NULL) && (node->type == XML_ATTRIBUTE_NODE)) { xmlAttrPtr attr = (xmlAttrPtr) node; /* * NOTE: the IDness might have already be declared in the DTD */ if (attr->atype != XML_ATTRIBUTE_ID) { xmlIDPtr res; xmlChar *strip; strip = xmlSchemaStrip(value); if (strip != NULL) { res = xmlAddID(NULL, node->doc, strip, attr); xmlFree(strip); } else res = xmlAddID(NULL, node->doc, value, attr); if (res == NULL) { ret = 2; } else { attr->atype = XML_ATTRIBUTE_ID; } } } goto done; case XML_SCHEMAS_IDREF: ret = xmlValidateNCName(value, 1); if ((ret == 0) && (val != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_IDREF); if (v == NULL) goto error; v->value.str = xmlStrdup(value); *val = v; } if ((ret == 0) && (node != NULL) && (node->type == XML_ATTRIBUTE_NODE)) { xmlAttrPtr attr = (xmlAttrPtr) node; xmlChar *strip; strip = xmlSchemaStrip(value); if (strip != NULL) { xmlAddRef(NULL, node->doc, strip, attr); xmlFree(strip); } else xmlAddRef(NULL, node->doc, value, attr); attr->atype = XML_ATTRIBUTE_IDREF; } goto done; case XML_SCHEMAS_IDREFS: ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef, value, val, node); if (ret < 0) ret = 2; else ret = 0; if ((ret == 0) && (node != NULL) && (node->type == XML_ATTRIBUTE_NODE)) { xmlAttrPtr attr = (xmlAttrPtr) node; attr->atype = XML_ATTRIBUTE_IDREFS; } goto done; case XML_SCHEMAS_ENTITY:{ xmlChar *strip; ret = xmlValidateNCName(value, 1); if ((node == NULL) || (node->doc == NULL)) ret = 3; if (ret == 0) { xmlEntityPtr ent; strip = xmlSchemaStrip(value); if (strip != NULL) { ent = xmlGetDocEntity(node->doc, strip); xmlFree(strip); } else { ent = xmlGetDocEntity(node->doc, value); } if ((ent == NULL) || (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)) ret = 4; } if ((ret == 0) && (val != NULL)) { TODO; } if ((ret == 0) && (node != NULL) && (node->type == XML_ATTRIBUTE_NODE)) { xmlAttrPtr attr = (xmlAttrPtr) node; attr->atype = XML_ATTRIBUTE_ENTITY; } goto done; } case XML_SCHEMAS_ENTITIES: if ((node == NULL) || (node->doc == NULL)) goto return3; ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef, value, val, node); if (ret <= 0) ret = 1; else ret = 0; if ((ret == 0) && (node != NULL) && (node->type == XML_ATTRIBUTE_NODE)) { xmlAttrPtr attr = (xmlAttrPtr) node; attr->atype = XML_ATTRIBUTE_ENTITIES; } goto done; case XML_SCHEMAS_NOTATION:{ xmlChar *uri = NULL; xmlChar *local = NULL; ret = xmlValidateQName(value, 1); if ((ret == 0) && (node != NULL)) { xmlChar *prefix; local = xmlSplitQName2(value, &prefix); if (prefix != NULL) { xmlNsPtr ns; ns = xmlSearchNs(node->doc, node, prefix); if (ns == NULL) ret = 1; else if (val != NULL) uri = xmlStrdup(ns->href); } if ((local != NULL) && ((val == NULL) || (ret != 0))) xmlFree(local); if (prefix != NULL) xmlFree(prefix); } if ((node == NULL) || (node->doc == NULL)) ret = 3; if (ret == 0) { ret = xmlValidateNotationUse(NULL, node->doc, value); if (ret == 1) ret = 0; else ret = 1; } if ((ret == 0) && (val != NULL)) { v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION); if (v != NULL) { if (local != NULL) v->value.qname.name = local; else v->value.qname.name = xmlStrdup(value); if (uri != NULL) v->value.qname.uri = uri; *val = v; } else { if (local != NULL) xmlFree(local); if (uri != NULL) xmlFree(uri); goto error; } } goto done; } case XML_SCHEMAS_ANYURI:{ if (*value != 0) { xmlURIPtr uri; xmlChar *tmpval, *cur; if (normOnTheFly) { norm = xmlSchemaCollapseString(value); if (norm != NULL) value = norm; } tmpval = xmlStrdup(value); for (cur = tmpval; *cur; ++cur) { if (*cur < 32 || *cur >= 127 || *cur ==

|| *cur ==

|| *cur ==

|| *cur ==

' || *cur == '{' || *cur == '}' || *cur == '|' || *cur == '\\' || *cur == '^' || *cur == '`' || *cur == '\'') *cur = '_'; } uri = xmlParseURI((const char *) tmpval); xmlFree(tmpval); if (uri == NULL) goto return1; xmlFreeURI(uri); } if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI); if (v == NULL) goto error; v->value.str = xmlStrdup(value); *val = v; } goto return0; } case XML_SCHEMAS_HEXBINARY:{ const xmlChar *cur = value, *start; xmlChar *base; int total, i = 0; if (cur == NULL) goto return1; if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; start = cur; while (((*cur >= '0') && (*cur <= '9')) || ((*cur >= 'A') && (*cur <= 'F')) || ((*cur >= 'a') && (*cur <= 'f'))) { i++; cur++; } if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if (*cur != 0) goto return1; if ((i % 2) != 0) goto return1; if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY); if (v == NULL) goto error; /* * Copy only the normalized piece. * CRITICAL TODO: Check this. */ cur = xmlStrndup(start, i); if (cur == NULL) { xmlSchemaTypeErrMemory(node,

); xmlFree(v); goto return1; } total = i / 2; /* number of octets */ base = (xmlChar *) cur; while (i-- > 0) { if (*base >= 'a') *base = *base - ('a' - 'A'); base++; } v->value.hex.str = (xmlChar *) cur; v->value.hex.total = total; *val = v; } goto return0; } case XML_SCHEMAS_BASE64BINARY:{ /* ISSUE: * * Ignore all stray characters? (yes, currently) * Worry about long lines? (no, currently) * * rfc2045.txt: * *

*/ const xmlChar *cur = value; xmlChar *base; int total, i = 0, pad = 0; if (cur == NULL) goto return1; for (; *cur; ++cur) { int decc; decc = _xmlSchemaBase64Decode(*cur); if (decc < 0) ; else if (decc < 64) i++; else break; } for (; *cur; ++cur) { int decc; decc = _xmlSchemaBase64Decode(*cur); if (decc < 0) ; else if (decc < 64) goto return1; if (decc == 64) pad++; } /* rfc2045.txt:

=

=*

= *

=

=

=

*/ total = 3 * (i / 4); if (pad == 0) { if (i % 4 != 0) goto return1; } else if (pad == 1) { int decc; if (i % 4 != 3) goto return1; for (decc = _xmlSchemaBase64Decode(*cur); (decc < 0) || (decc > 63); decc = _xmlSchemaBase64Decode(*cur)) --cur; /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/ /* 00111100 -> 0x3c */ if (decc & ~0x3c) goto return1; total += 2; } else if (pad == 2) { int decc; if (i % 4 != 2) goto return1; for (decc = _xmlSchemaBase64Decode(*cur); (decc < 0) || (decc > 63); decc = _xmlSchemaBase64Decode(*cur)) --cur; /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */ /* 00110000 -> 0x30 */ if (decc & ~0x30) goto return1; total += 1; } else goto return1; if (val != NULL) { v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY); if (v == NULL) goto error; base = (xmlChar *) xmlMallocAtomic((i + pad + 1) * sizeof(xmlChar)); if (base == NULL) { xmlSchemaTypeErrMemory(node,

); xmlFree(v); goto return1; } v->value.base64.str = base; for (cur = value; *cur; ++cur) if (_xmlSchemaBase64Decode(*cur) >= 0) { *base = *cur; ++base; } *base = 0; v->value.base64.total = total; *val = v; } goto return0; } case XML_SCHEMAS_INTEGER: case XML_SCHEMAS_PINTEGER: case XML_SCHEMAS_NPINTEGER: case XML_SCHEMAS_NINTEGER: case XML_SCHEMAS_NNINTEGER:{ const xmlChar *cur = value; unsigned long lo, mi, hi; int sign = 0; if (cur == NULL) goto return1; if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if (*cur == '-') { sign = 1; cur++; } else if (*cur == '+') cur++; ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi); if (ret < 0) goto return1; if (normOnTheFly) while IS_WSP_BLANK_CH(*cur) cur++; if (*cur != 0) goto return1; if (type->builtInType == XML_SCHEMAS_NPINTEGER) { if ((sign == 0) && ((hi != 0) || (mi != 0) || (lo != 0))) goto return1; } else if (type->builtInType == XML_SCHEMAS_PINTEGER) { if (sign == 1) goto return1; if ((hi == 0) && (mi == 0) && (lo == 0)) goto return1; } else if (type->builtInType == XML_SCHEMAS_NINTEGER) { if (sign == 0) goto return1; if ((hi == 0) && (mi == 0) && (lo == 0)) goto return1; } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) { if ((sign == 1) && ((hi != 0) || (mi != 0) || (lo != 0))) goto return1; } if (val != NULL) { v = xmlSchemaNewValue(type->builtInType); if (v != NULL) { if (ret == 0) ret++; v->value.decimal.lo = lo; v->value.decimal.mi = mi; v->value.decimal.hi = hi; v->value.decimal.sign = sign; v->value.decimal.frac = 0; v->value.decimal.total = ret; *val = v; } } goto return0; } case XML_SCHEMAS_LONG: case XML_SCHEMAS_BYTE: case XML_SCHEMAS_SHORT: case XML_SCHEMAS_INT:{ const xmlChar *cur = value; unsigned long lo, mi, hi; int sign = 0; if (cur == NULL) goto return1; if (*cur == '-') { sign = 1; cur++; } else if (*cur == '+') cur++; ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi); if (ret < 0) goto return1; if (*cur != 0) goto return1; if (type->builtInType == XML_SCHEMAS_LONG) { if (hi >= 922) { if (hi > 922) goto return1; if (mi >= 33720368) { if (mi > 33720368) goto return1; if ((sign == 0) && (lo > 54775807)) goto return1; if ((sign == 1) && (lo > 54775808)) goto return1; } } } else if (type->builtInType == XML_SCHEMAS_INT) { if (hi != 0) goto return1; if (mi >= 21) { if (mi > 21) goto return1; if ((sign == 0) && (lo > 47483647)) goto return1; if ((sign == 1) && (lo > 47483648)) goto return1; } } else if (type->builtInType == XML_SCHEMAS_SHORT) { if ((mi != 0) || (hi != 0)) goto return1; if ((sign == 1) && (lo > 32768)) goto return1; if ((sign == 0) && (lo > 32767)) goto return1; } else if (type->builtInType == XML_SCHEMAS_BYTE) { if ((mi != 0) || (hi != 0)) goto return1; if ((sign == 1) && (lo > 128)) goto return1; if ((sign == 0) && (lo > 127)) goto return1; } if (val != NULL) { v = xmlSchemaNewValue(type->builtInType); if (v != NULL) { v->value.decimal.lo = lo; v->value.decimal.mi = mi; v->value.decimal.hi = hi; v->value.decimal.sign = sign; v->value.decimal.frac = 0; v->value.decimal.total = ret; *val = v; } } goto return0; } case XML_SCHEMAS_UINT: case XML_SCHEMAS_ULONG: case XML_SCHEMAS_USHORT: case XML_SCHEMAS_UBYTE:{ const xmlChar *cur = value; unsigned long lo, mi, hi; if (cur == NULL) goto return1; ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi); if (ret < 0) goto return1; if (*cur != 0) goto return1; if (type->builtInType == XML_SCHEMAS_ULONG) { if (hi >= 1844) { if (hi > 1844) goto return1; if (mi >= 67440737) { if (mi > 67440737) goto return1; if (lo > 9551615) goto return1; } } } else if (type->builtInType == XML_SCHEMAS_UINT) { if (hi != 0) goto return1; if (mi >= 42) { if (mi > 42) goto return1; if (lo > 94967295) goto return1; } } else if (type->builtInType == XML_SCHEMAS_USHORT) { if ((mi != 0) || (hi != 0)) goto return1; if (lo > 65535) goto return1; } else if (type->builtInType == XML_SCHEMAS_UBYTE) { if ((mi != 0) || (hi != 0)) goto return1; if (lo > 255) goto return1; } if (val != NULL) { v = xmlSchemaNewValue(type->builtInType); if (v != NULL) { v->value.decimal.lo = lo; v->value.decimal.mi = mi; v->value.decimal.hi = hi; v->value.decimal.sign = 0; v->value.decimal.frac = 0; v->value.decimal.total = ret; *val = v; } } goto return0; } } done: if (norm != NULL) xmlFree(norm); return (ret); return3: if (norm != NULL) xmlFree(norm); return (3); return1: if (norm != NULL) xmlFree(norm); return (1); return0: if (norm != NULL) xmlFree(norm); return (0); error: if (norm != NULL) xmlFree(norm); return (-1); } /** * xmlSchemaValPredefTypeNode: * @type: the predefined type * @value: the value to check * @val: the return computed value * @node: the node containing the value * * Check that a value conforms to the lexical space of the predefined type. * if true a value is computed and returned in @val. * * Returns 0 if this validates, a positive error code number otherwise * and -1 in case of internal or API error. */ int xmlSchemaValPredefTypeNode(xmlSchemaTypePtr type, const xmlChar *value, xmlSchemaValPtr *val, xmlNodePtr node) { return(xmlSchemaValAtomicType(type, value, val, node, 0, XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0)); } /** * xmlSchemaValPredefTypeNodeNoNorm: * @type: the predefined type * @value: the value to check * @val: the return computed value * @node: the node containing the value * * Check that a value conforms to the lexical space of the predefined type. * if true a value is computed and returned in @val. * This one does apply any normalization to the value. * * Returns 0 if this validates, a positive error code number otherwise * and -1 in case of internal or API error. */ int xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, const xmlChar *value, xmlSchemaValPtr *val, xmlNodePtr node) { return(xmlSchemaValAtomicType(type, value, val, node, 1, XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1)); } /** * xmlSchemaValidatePredefinedType: * @type: the predefined type * @value: the value to check * @val: the return computed value * * Check that a value conforms to the lexical space of the predefined type. * if true a value is computed and returned in @val. * * Returns 0 if this validates, a positive error code number otherwise * and -1 in case of internal or API error. */ int xmlSchemaValidatePredefinedType(xmlSchemaTypePtr type, const xmlChar *value, xmlSchemaValPtr *val) { return(xmlSchemaValPredefTypeNode(type, value, val, NULL)); } /** * xmlSchemaCompareDecimals: * @x: a first decimal value * @y: a second decimal value * * Compare 2 decimals * * Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error */ static int xmlSchemaCompareDecimals(xmlSchemaValPtr x, xmlSchemaValPtr y) { xmlSchemaValPtr swp; int order = 1, integx, integy, dlen; unsigned long hi, mi, lo; /* * First test: If x is -ve and not zero */ if ((x->value.decimal.sign) && ((x->value.decimal.lo != 0) || (x->value.decimal.mi != 0) || (x->value.decimal.hi != 0))) { /* * Then if y is -ve and not zero reverse the compare */ if ((y->value.decimal.sign) && ((y->value.decimal.lo != 0) || (y->value.decimal.mi != 0) || (y->value.decimal.hi != 0))) order = -1; /* * Otherwise (y >= 0) we have the answer */ else return (-1); /* * If x is not -ve and y is -ve we have the answer */ } else if ((y->value.decimal.sign) && ((y->value.decimal.lo != 0) || (y->value.decimal.mi != 0) || (y->value.decimal.hi != 0))) { return (1); } /* * If it's not simply determined by a difference in sign, * then we need to compare the actual values of the two nums. * To do this, we start by looking at the integral parts. * If the number of integral digits differ, then we have our * answer. */ integx = x->value.decimal.total - x->value.decimal.frac; integy = y->value.decimal.total - y->value.decimal.frac; /* * NOTE: We changed the

for values like

* (or

or

) to be 1, which was 2 previously. * Therefore the special case, when such values are * compared with 0, needs to be handled separately; * otherwise a zero would be recognized incorrectly as * greater than those values. This has the nice side effect * that we gain an overall optimized comparison with zeroes. * Note that a

has a

of 1 already. */ if (integx == 1) { if (x->value.decimal.lo == 0) { if (integy != 1) return -order; else if (y->value.decimal.lo != 0) return -order; else return(0); } } if (integy == 1) { if (y->value.decimal.lo == 0) { if (integx != 1) return order; else if (x->value.decimal.lo != 0) return order; else return(0); } } if (integx > integy) return order; else if (integy > integx) return -order; /* * If the number of integral digits is the same for both numbers, * then things get a little more complicated. We need to

* the numbers in order to properly compare them. To do this, we * look at the total length of each number (length => number of * significant digits), and divide the

by 10 (decreasing * the length) until they are of equal length. */ dlen = x->value.decimal.total - y->value.decimal.total; if (dlen < 0) { /* y has more digits than x */ swp = x; hi = y->value.decimal.hi; mi = y->value.decimal.mi; lo = y->value.decimal.lo; dlen = -dlen; order = -order; } else { /* x has more digits than y */ swp = y; hi = x->value.decimal.hi; mi = x->value.decimal.mi; lo = x->value.decimal.lo; } while (dlen > 8) { /* in effect, right shift by 10**8 */ lo = mi; mi = hi; hi = 0; dlen -= 8; } while (dlen > 0) { unsigned long rem1, rem2; rem1 = (hi % 10) * 100000000L; hi = hi / 10; rem2 = (mi % 10) * 100000000L; mi = (mi + rem1) / 10; lo = (lo + rem2) / 10; dlen--; } if (hi > swp->value.decimal.hi) { return order; } else if (hi == swp->value.decimal.hi) { if (mi > swp->value.decimal.mi) { return order; } else if (mi == swp->value.decimal.mi) { if (lo > swp->value.decimal.lo) { return order; } else if (lo == swp->value.decimal.lo) { if (x->value.decimal.total == y->value.decimal.total) { return 0; } else { return order; } } } } return -order; } /** * xmlSchemaCompareDurations: * @x: a first duration value * @y: a second duration value * * Compare 2 durations * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ static int xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y) { long carry, mon, day; double sec; int invert = 1; long xmon, xday, myear, minday, maxday; static const long dayRange [2][12] = { { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, }, { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} }; if ((x == NULL) || (y == NULL)) return -2; /* months */ mon = x->value.dur.mon - y->value.dur.mon; /* seconds */ sec = x->value.dur.sec - y->value.dur.sec; carry = (long)sec / SECS_PER_DAY; sec -= (double)(carry * SECS_PER_DAY); /* days */ day = x->value.dur.day - y->value.dur.day + carry; /* easy test */ if (mon == 0) { if (day == 0) if (sec == 0.0) return 0; else if (sec < 0.0) return -1; else return 1; else if (day < 0) return -1; else return 1; } if (mon > 0) { if ((day >= 0) && (sec >= 0.0)) return 1; else { xmon = mon; xday = -day; } } else if ((day <= 0) && (sec <= 0.0)) { return -1; } else { invert = -1; xmon = -mon; xday = day; } myear = xmon / 12; if (myear == 0) { minday = 0; maxday = 0; } else { maxday = 366 * ((myear + 3) / 4) + 365 * ((myear - 1) % 4); minday = maxday - 1; } xmon = xmon % 12; minday += dayRange[0][xmon]; maxday += dayRange[1][xmon]; if ((maxday == minday) && (maxday == xday)) return(0); /* can this really happen ? */ if (maxday < xday) return(-invert); if (minday > xday) return(invert); /* indeterminate */ return 2; } /* * macros for adding date/times and durations */ #define FQUOTIENT(a,b) (floor(((double)a/(double)b))) #define MODULO(a,b) (a - FQUOTIENT(a,b) * b) #define FQUOTIENT_RANGE(a,low,high) (FQUOTIENT((a-low),(high-low))) #define MODULO_RANGE(a,low,high) ((MODULO((a-low),(high-low)))+low) /** * xmlSchemaDupVal: * @v: the #xmlSchemaValPtr value to duplicate * * Makes a copy of @v. The calling program is responsible for freeing * the returned value. * * returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error. */ static xmlSchemaValPtr xmlSchemaDupVal (xmlSchemaValPtr v) { xmlSchemaValPtr ret = xmlSchemaNewValue(v->type); if (ret == NULL) return NULL; memcpy(ret, v, sizeof(xmlSchemaVal)); ret->next = NULL; return ret; } /** * xmlSchemaCopyValue: * @val: the precomputed value to be copied * * Copies the precomputed value. This duplicates any string within. * * Returns the copy or NULL if a copy for a data-type is not implemented. */ xmlSchemaValPtr xmlSchemaCopyValue(xmlSchemaValPtr val) { xmlSchemaValPtr ret = NULL, prev = NULL, cur; /* * Copy the string values. */ while (val != NULL) { switch (val->type) { case XML_SCHEMAS_ANYTYPE: case XML_SCHEMAS_IDREFS: case XML_SCHEMAS_ENTITIES: case XML_SCHEMAS_NMTOKENS: xmlSchemaFreeValue(ret); return (NULL); case XML_SCHEMAS_ANYSIMPLETYPE: case XML_SCHEMAS_STRING: case XML_SCHEMAS_NORMSTRING: case XML_SCHEMAS_TOKEN: case XML_SCHEMAS_LANGUAGE: case XML_SCHEMAS_NAME: case XML_SCHEMAS_NCNAME: case XML_SCHEMAS_ID: case XML_SCHEMAS_IDREF: case XML_SCHEMAS_ENTITY: case XML_SCHEMAS_NMTOKEN: case XML_SCHEMAS_ANYURI: cur = xmlSchemaDupVal(val); if (val->value.str != NULL) cur->value.str = xmlStrdup(BAD_CAST val->value.str); break; case XML_SCHEMAS_QNAME: case XML_SCHEMAS_NOTATION: cur = xmlSchemaDupVal(val); if (val->value.qname.name != NULL) cur->value.qname.name = xmlStrdup(BAD_CAST val->value.qname.name); if (val->value.qname.uri != NULL) cur->value.qname.uri = xmlStrdup(BAD_CAST val->value.qname.uri); break; case XML_SCHEMAS_HEXBINARY: cur = xmlSchemaDupVal(val); if (val->value.hex.str != NULL) cur->value.hex.str = xmlStrdup(BAD_CAST val->value.hex.str); break; case XML_SCHEMAS_BASE64BINARY: cur = xmlSchemaDupVal(val); if (val->value.base64.str != NULL) cur->value.base64.str = xmlStrdup(BAD_CAST val->value.base64.str); break; default: cur = xmlSchemaDupVal(val); break; } if (ret == NULL) ret = cur; else prev->next = cur; prev = cur; val = val->next; } return (ret); } /** * _xmlSchemaDateAdd: * @dt: an #xmlSchemaValPtr * @dur: an #xmlSchemaValPtr of type #XS_DURATION * * Compute a new date/time from @dt and @dur. This function assumes @dt * is either #XML_SCHEMAS_DATETIME, #XML_SCHEMAS_DATE, #XML_SCHEMAS_GYEARMONTH, * or #XML_SCHEMAS_GYEAR. The returned #xmlSchemaVal is the same type as * @dt. The calling program is responsible for freeing the returned value. * * Returns a pointer to a new #xmlSchemaVal or NULL if error. */ static xmlSchemaValPtr _xmlSchemaDateAdd (xmlSchemaValPtr dt, xmlSchemaValPtr dur) { xmlSchemaValPtr ret, tmp; long carry, tempdays, temp; xmlSchemaValDatePtr r, d; xmlSchemaValDurationPtr u; if ((dt == NULL) || (dur == NULL)) return NULL; ret = xmlSchemaNewValue(dt->type); if (ret == NULL) return NULL; /* make a copy so we don't alter the original value */ tmp = xmlSchemaDupVal(dt); if (tmp == NULL) { xmlSchemaFreeValue(ret); return NULL; } r = &(ret->value.date); d = &(tmp->value.date); u = &(dur->value.dur); /* normalization */ if (d->mon == 0) d->mon = 1; /* normalize for time zone offset */ u->sec -= (d->tzo * 60); d->tzo = 0; /* normalization */ if (d->day == 0) d->day = 1; /* month */ carry = d->mon + u->mon; r->mon = (unsigned int) MODULO_RANGE(carry, 1, 13); carry = (long) FQUOTIENT_RANGE(carry, 1, 13); /* year (may be modified later) */ r->year = d->year + carry; if (r->year == 0) { if (d->year > 0) r->year--; else r->year++; } /* time zone */ r->tzo = d->tzo; r->tz_flag = d->tz_flag; /* seconds */ r->sec = d->sec + u->sec; carry = (long) FQUOTIENT((long)r->sec, 60); if (r->sec != 0.0) { r->sec = MODULO(r->sec, 60.0); } /* minute */ carry += d->min; r->min = (unsigned int) MODULO(carry, 60); carry = (long) FQUOTIENT(carry, 60); /* hours */ carry += d->hour; r->hour = (unsigned int) MODULO(carry, 24); carry = (long)FQUOTIENT(carry, 24); /* * days * Note we use tempdays because the temporary values may need more * than 5 bits */ if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) && (d->day > MAX_DAYINMONTH(r->year, r->mon))) tempdays = MAX_DAYINMONTH(r->year, r->mon); else if (d->day < 1) tempdays = 1; else tempdays = d->day; tempdays += u->day + carry; while (1) { if (tempdays < 1) { long tmon = (long) MODULO_RANGE((int)r->mon-1, 1, 13); long tyr = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13); if (tyr == 0) tyr--; /* * Coverity detected an overrun in daysInMonth * of size 12 at position 12 with index variable

*/ if (tmon < 0) tmon = 0; if (tmon > 12) tmon = 12; tempdays += MAX_DAYINMONTH(tyr, tmon); carry = -1; } else if (tempdays > (long) MAX_DAYINMONTH(r->year, r->mon)) { tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon); carry = 1; } else break; temp = r->mon + carry; r->mon = (unsigned int) MODULO_RANGE(temp, 1, 13); r->year = r->year + (unsigned int) FQUOTIENT_RANGE(temp, 1, 13); if (r->year == 0) { if (temp < 1) r->year--; else r->year++; } } r->day = tempdays; /* * adjust the date/time type to the date values */ if (ret->type != XML_SCHEMAS_DATETIME) { if ((r->hour) || (r->min) || (r->sec)) ret->type = XML_SCHEMAS_DATETIME; else if (ret->type != XML_SCHEMAS_DATE) { if ((r->mon != 1) && (r->day != 1)) ret->type = XML_SCHEMAS_DATE; else if ((ret->type != XML_SCHEMAS_GYEARMONTH) && (r->mon != 1)) ret->type = XML_SCHEMAS_GYEARMONTH; } } xmlSchemaFreeValue(tmp); return ret; } /** * xmlSchemaDateNormalize: * @dt: an #xmlSchemaValPtr of a date/time type value. * @offset: number of seconds to adjust @dt by. * * Normalize @dt to GMT time. The @offset parameter is subtracted from * the return value is a time-zone offset is present on @dt. * * Returns a normalized copy of @dt or NULL if error. */ static xmlSchemaValPtr xmlSchemaDateNormalize (xmlSchemaValPtr dt, double offset) { xmlSchemaValPtr dur, ret; if (dt == NULL) return NULL; if (((dt->type != XML_SCHEMAS_TIME) && (dt->type != XML_SCHEMAS_DATETIME) && (dt->type != XML_SCHEMAS_DATE)) || (dt->value.date.tzo == 0)) return xmlSchemaDupVal(dt); dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION); if (dur == NULL) return NULL; dur->value.date.sec -= offset; ret = _xmlSchemaDateAdd(dt, dur); if (ret == NULL) return NULL; xmlSchemaFreeValue(dur); /* ret->value.date.tzo = 0; */ return ret; } /** * _xmlSchemaDateCastYMToDays: * @dt: an #xmlSchemaValPtr * * Convert mon and year of @dt to total number of days. Take the * number of years since (or before) 1 AD and add the number of leap * years. This is a function because negative * years must be handled a little differently and there is no zero year. * * Returns number of days. */ static long _xmlSchemaDateCastYMToDays (const xmlSchemaValPtr dt) { long ret; int mon; mon = dt->value.date.mon; if (mon <= 0) mon = 1; /* normalization */ if (dt->value.date.year <= 0) ret = (dt->value.date.year * 365) + (((dt->value.date.year+1)/4)-((dt->value.date.year+1)/100)+ ((dt->value.date.year+1)/400)) + DAY_IN_YEAR(0, mon, dt->value.date.year); else ret = ((dt->value.date.year-1) * 365) + (((dt->value.date.year-1)/4)-((dt->value.date.year-1)/100)+ ((dt->value.date.year-1)/400)) + DAY_IN_YEAR(0, mon, dt->value.date.year); return ret; } /** * TIME_TO_NUMBER: * @dt: an #xmlSchemaValPtr * * Calculates the number of seconds in the time portion of @dt. * * Returns seconds. */ #define TIME_TO_NUMBER(dt) \ ((double)((dt->value.date.hour * SECS_PER_HOUR) + \ (dt->value.date.min * SECS_PER_MIN) + \ (dt->value.date.tzo * SECS_PER_MIN)) + \ dt->value.date.sec) /** * xmlSchemaCompareDates: * @x: a first date/time value * @y: a second date/time value * * Compare 2 date/times * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ static int xmlSchemaCompareDates (xmlSchemaValPtr x, xmlSchemaValPtr y) { unsigned char xmask, ymask, xor_mask, and_mask; xmlSchemaValPtr p1, p2, q1, q2; long p1d, p2d, q1d, q2d; if ((x == NULL) || (y == NULL)) return -2; if (x->value.date.tz_flag) { if (!y->value.date.tz_flag) { p1 = xmlSchemaDateNormalize(x, 0); p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day; /* normalize y + 14:00 */ q1 = xmlSchemaDateNormalize(y, (14 * SECS_PER_HOUR)); q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day; if (p1d < q1d) { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); return -1; } else if (p1d == q1d) { double sec; sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1); if (sec < 0.0) { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); return -1; } else { int ret = 0; /* normalize y - 14:00 */ q2 = xmlSchemaDateNormalize(y, -(14 * SECS_PER_HOUR)); q2d = _xmlSchemaDateCastYMToDays(q2) + q2->value.date.day; if (p1d > q2d) ret = 1; else if (p1d == q2d) { sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2); if (sec > 0.0) ret = 1; else ret = 2; /* indeterminate */ } xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); xmlSchemaFreeValue(q2); if (ret != 0) return(ret); } } else { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); } } } else if (y->value.date.tz_flag) { q1 = xmlSchemaDateNormalize(y, 0); q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day; /* normalize x - 14:00 */ p1 = xmlSchemaDateNormalize(x, -(14 * SECS_PER_HOUR)); p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day; if (p1d < q1d) { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); return -1; } else if (p1d == q1d) { double sec; sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1); if (sec < 0.0) { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); return -1; } else { int ret = 0; /* normalize x + 14:00 */ p2 = xmlSchemaDateNormalize(x, (14 * SECS_PER_HOUR)); p2d = _xmlSchemaDateCastYMToDays(p2) + p2->value.date.day; if (p2d > q1d) { ret = 1; } else if (p2d == q1d) { sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1); if (sec > 0.0) ret = 1; else ret = 2; /* indeterminate */ } xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); xmlSchemaFreeValue(p2); if (ret != 0) return(ret); } } else { xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); } } /* * if the same type then calculate the difference */ if (x->type == y->type) { int ret = 0; q1 = xmlSchemaDateNormalize(y, 0); q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day; p1 = xmlSchemaDateNormalize(x, 0); p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day; if (p1d < q1d) { ret = -1; } else if (p1d > q1d) { ret = 1; } else { double sec; sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1); if (sec < 0.0) ret = -1; else if (sec > 0.0) ret = 1; } xmlSchemaFreeValue(p1); xmlSchemaFreeValue(q1); return(ret); } switch (x->type) { case XML_SCHEMAS_DATETIME: xmask = 0xf; break; case XML_SCHEMAS_DATE: xmask = 0x7; break; case XML_SCHEMAS_GYEAR: xmask = 0x1; break; case XML_SCHEMAS_GMONTH: xmask = 0x2; break; case XML_SCHEMAS_GDAY: xmask = 0x3; break; case XML_SCHEMAS_GYEARMONTH: xmask = 0x3; break; case XML_SCHEMAS_GMONTHDAY: xmask = 0x6; break; case XML_SCHEMAS_TIME: xmask = 0x8; break; default: xmask = 0; break; } switch (y->type) { case XML_SCHEMAS_DATETIME: ymask = 0xf; break; case XML_SCHEMAS_DATE: ymask = 0x7; break; case XML_SCHEMAS_GYEAR: ymask = 0x1; break; case XML_SCHEMAS_GMONTH: ymask = 0x2; break; case XML_SCHEMAS_GDAY: ymask = 0x3; break; case XML_SCHEMAS_GYEARMONTH: ymask = 0x3; break; case XML_SCHEMAS_GMONTHDAY: ymask = 0x6; break; case XML_SCHEMAS_TIME: ymask = 0x8; break; default: ymask = 0; break; } xor_mask = xmask ^ ymask; /* mark type differences */ and_mask = xmask & ymask; /* mark field specification */ /* year */ if (xor_mask & 1) return 2; /* indeterminate */ else if (and_mask & 1) { if (x->value.date.year < y->value.date.year) return -1; else if (x->value.date.year > y->value.date.year) return 1; } /* month */ if (xor_mask & 2) return 2; /* indeterminate */ else if (and_mask & 2) { if (x->value.date.mon < y->value.date.mon) return -1; else if (x->value.date.mon > y->value.date.mon) return 1; } /* day */ if (xor_mask & 4) return 2; /* indeterminate */ else if (and_mask & 4) { if (x->value.date.day < y->value.date.day) return -1; else if (x->value.date.day > y->value.date.day) return 1; } /* time */ if (xor_mask & 8) return 2; /* indeterminate */ else if (and_mask & 8) { if (x->value.date.hour < y->value.date.hour) return -1; else if (x->value.date.hour > y->value.date.hour) return 1; else if (x->value.date.min < y->value.date.min) return -1; else if (x->value.date.min > y->value.date.min) return 1; else if (x->value.date.sec < y->value.date.sec) return -1; else if (x->value.date.sec > y->value.date.sec) return 1; } return 0; } /** * xmlSchemaComparePreserveReplaceStrings: * @x: a first string value * @y: a second string value * @invert: inverts the result if x < y or x > y. * * Compare 2 string for their normalized values. * @x is a string with whitespace of

, @y is * a string with a whitespace of

. I.e. @x could * be an

and @y an

. * * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in * case of error */ static int xmlSchemaComparePreserveReplaceStrings(const xmlChar *x, const xmlChar *y, int invert) { int tmp; while ((*x != 0) && (*y != 0)) { if (IS_WSP_REPLACE_CH(*y)) { if (! IS_WSP_SPACE_CH(*x)) { if ((*x - 0x20) < 0) { if (invert) return(1); else return(-1); } else { if (invert) return(-1); else return(1); } } } else { tmp = *x - *y; if (tmp < 0) { if (invert) return(1); else return(-1); } if (tmp > 0) { if (invert) return(-1); else return(1); } } x++; y++; } if (*x != 0) { if (invert) return(-1); else return(1); } if (*y != 0) { if (invert) return(1); else return(-1); } return(0); } /** * xmlSchemaComparePreserveCollapseStrings: * @x: a first string value * @y: a second string value * * Compare 2 string for their normalized values. * @x is a string with whitespace of

, @y is * a string with a whitespace of

. I.e. @x could * be an

and @y an

. * * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in * case of error */ static int xmlSchemaComparePreserveCollapseStrings(const xmlChar *x, const xmlChar *y, int invert) { int tmp; /* * Skip leading blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; while ((*x != 0) && (*y != 0)) { if IS_WSP_BLANK_CH(*y) { if (! IS_WSP_SPACE_CH(*x)) { /* * The yv character would have been replaced to 0x20. */ if ((*x - 0x20) < 0) { if (invert) return(1); else return(-1); } else { if (invert) return(-1); else return(1); } } x++; y++; /* * Skip contiguous blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; } else { tmp = *x++ - *y++; if (tmp < 0) { if (invert) return(1); else return(-1); } if (tmp > 0) { if (invert) return(-1); else return(1); } } } if (*x != 0) { if (invert) return(-1); else return(1); } if (*y != 0) { /* * Skip trailing blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; if (*y != 0) { if (invert) return(1); else return(-1); } } return(0); } /** * xmlSchemaComparePreserveCollapseStrings: * @x: a first string value * @y: a second string value * * Compare 2 string for their normalized values. * @x is a string with whitespace of

, @y is * a string with a whitespace of

. I.e. @x could * be an

and @y an

. * * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in * case of error */ static int xmlSchemaCompareReplaceCollapseStrings(const xmlChar *x, const xmlChar *y, int invert) { int tmp; /* * Skip leading blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; while ((*x != 0) && (*y != 0)) { if IS_WSP_BLANK_CH(*y) { if (! IS_WSP_BLANK_CH(*x)) { /* * The yv character would have been replaced to 0x20. */ if ((*x - 0x20) < 0) { if (invert) return(1); else return(-1); } else { if (invert) return(-1); else return(1); } } x++; y++; /* * Skip contiguous blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; } else { if IS_WSP_BLANK_CH(*x) { /* * The xv character would have been replaced to 0x20. */ if ((0x20 - *y) < 0) { if (invert) return(1); else return(-1); } else { if (invert) return(-1); else return(1); } } tmp = *x++ - *y++; if (tmp < 0) return(-1); if (tmp > 0) return(1); } } if (*x != 0) { if (invert) return(-1); else return(1); } if (*y != 0) { /* * Skip trailing blank chars of the collapsed string. */ while IS_WSP_BLANK_CH(*y) y++; if (*y != 0) { if (invert) return(1); else return(-1); } } return(0); } /** * xmlSchemaCompareReplacedStrings: * @x: a first string value * @y: a second string value * * Compare 2 string for their normalized values. * * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in * case of error */ static int xmlSchemaCompareReplacedStrings(const xmlChar *x, const xmlChar *y) { int tmp; while ((*x != 0) && (*y != 0)) { if IS_WSP_BLANK_CH(*y) { if (! IS_WSP_BLANK_CH(*x)) { if ((*x - 0x20) < 0) return(-1); else return(1); } } else { if IS_WSP_BLANK_CH(*x) { if ((0x20 - *y) < 0) return(-1); else return(1); } tmp = *x - *y; if (tmp < 0) return(-1); if (tmp > 0) return(1); } x++; y++; } if (*x != 0) return(1); if (*y != 0) return(-1); return(0); } /** * xmlSchemaCompareNormStrings: * @x: a first string value * @y: a second string value * * Compare 2 string for their normalized values. * * Returns -1 if x < y, 0 if x == y, 1 if x > y, and -2 in * case of error */ static int xmlSchemaCompareNormStrings(const xmlChar *x, const xmlChar *y) { int tmp; while (IS_BLANK_CH(*x)) x++; while (IS_BLANK_CH(*y)) y++; while ((*x != 0) && (*y != 0)) { if (IS_BLANK_CH(*x)) { if (!IS_BLANK_CH(*y)) { tmp = *x - *y; return(tmp); } while (IS_BLANK_CH(*x)) x++; while (IS_BLANK_CH(*y)) y++; } else { tmp = *x++ - *y++; if (tmp < 0) return(-1); if (tmp > 0) return(1); } } if (*x != 0) { while (IS_BLANK_CH(*x)) x++; if (*x != 0) return(1); } if (*y != 0) { while (IS_BLANK_CH(*y)) y++; if (*y != 0) return(-1); } return(0); } /** * xmlSchemaCompareFloats: * @x: a first float or double value * @y: a second float or double value * * Compare 2 values * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ static int xmlSchemaCompareFloats(xmlSchemaValPtr x, xmlSchemaValPtr y) { double d1, d2; if ((x == NULL) || (y == NULL)) return(-2); /* * Cast everything to doubles. */ if (x->type == XML_SCHEMAS_DOUBLE) d1 = x->value.d; else if (x->type == XML_SCHEMAS_FLOAT) d1 = x->value.f; else return(-2); if (y->type == XML_SCHEMAS_DOUBLE) d2 = y->value.d; else if (y->type == XML_SCHEMAS_FLOAT) d2 = y->value.f; else return(-2); /* * Check for special cases. */ if (xmlXPathIsNaN(d1)) { if (xmlXPathIsNaN(d2)) return(0); return(1); } if (xmlXPathIsNaN(d2)) return(-1); if (d1 == xmlXPathPINF) { if (d2 == xmlXPathPINF) return(0); return(1); } if (d2 == xmlXPathPINF) return(-1); if (d1 == xmlXPathNINF) { if (d2 == xmlXPathNINF) return(0); return(-1); } if (d2 == xmlXPathNINF) return(1); /* * basic tests, the last one we should have equality, but * portability is more important than speed and handling * NaN or Inf in a portable way is always a challenge, so ... */ if (d1 < d2) return(-1); if (d1 > d2) return(1); if (d1 == d2) return(0); return(2); } /** * xmlSchemaCompareValues: * @x: a first value * @xvalue: the first value as a string (optional) * @xwtsp: the whitespace type * @y: a second value * @xvalue: the second value as a string (optional) * @ywtsp: the whitespace type * * Compare 2 values * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, 3 if not * comparable and -2 in case of error */ static int xmlSchemaCompareValuesInternal(xmlSchemaValType xtype, xmlSchemaValPtr x, const xmlChar *xvalue, xmlSchemaWhitespaceValueType xws, xmlSchemaValType ytype, xmlSchemaValPtr y, const xmlChar *yvalue, xmlSchemaWhitespaceValueType yws) { switch (xtype) { case XML_SCHEMAS_UNKNOWN: case XML_SCHEMAS_ANYTYPE: return(-2); case XML_SCHEMAS_INTEGER: case XML_SCHEMAS_NPINTEGER: case XML_SCHEMAS_NINTEGER: case XML_SCHEMAS_NNINTEGER: case XML_SCHEMAS_PINTEGER: case XML_SCHEMAS_INT: case XML_SCHEMAS_UINT: case XML_SCHEMAS_LONG: case XML_SCHEMAS_ULONG: case XML_SCHEMAS_SHORT: case XML_SCHEMAS_USHORT: case XML_SCHEMAS_BYTE: case XML_SCHEMAS_UBYTE: case XML_SCHEMAS_DECIMAL: if ((x == NULL) || (y == NULL)) return(-2); if (ytype == xtype) return(xmlSchemaCompareDecimals(x, y)); if ((ytype == XML_SCHEMAS_DECIMAL) || (ytype == XML_SCHEMAS_INTEGER) || (ytype == XML_SCHEMAS_NPINTEGER) || (ytype == XML_SCHEMAS_NINTEGER) || (ytype == XML_SCHEMAS_NNINTEGER) || (ytype == XML_SCHEMAS_PINTEGER) || (ytype == XML_SCHEMAS_INT) || (ytype == XML_SCHEMAS_UINT) || (ytype == XML_SCHEMAS_LONG) || (ytype == XML_SCHEMAS_ULONG) || (ytype == XML_SCHEMAS_SHORT) || (ytype == XML_SCHEMAS_USHORT) || (ytype == XML_SCHEMAS_BYTE) || (ytype == XML_SCHEMAS_UBYTE)) return(xmlSchemaCompareDecimals(x, y)); return(-2); case XML_SCHEMAS_DURATION: if ((x == NULL) || (y == NULL)) return(-2); if (ytype == XML_SCHEMAS_DURATION) return(xmlSchemaCompareDurations(x, y)); return(-2); case XML_SCHEMAS_TIME: case XML_SCHEMAS_GDAY: case XML_SCHEMAS_GMONTH: case XML_SCHEMAS_GMONTHDAY: case XML_SCHEMAS_GYEAR: case XML_SCHEMAS_GYEARMONTH: case XML_SCHEMAS_DATE: case XML_SCHEMAS_DATETIME: if ((x == NULL) || (y == NULL)) return(-2); if ((ytype == XML_SCHEMAS_DATETIME) || (ytype == XML_SCHEMAS_TIME) || (ytype == XML_SCHEMAS_GDAY) || (ytype == XML_SCHEMAS_GMONTH) || (ytype == XML_SCHEMAS_GMONTHDAY) || (ytype == XML_SCHEMAS_GYEAR) || (ytype == XML_SCHEMAS_DATE) || (ytype == XML_SCHEMAS_GYEARMONTH)) return (xmlSchemaCompareDates(x, y)); return (-2); /* * Note that we will support comparison of string types against * anySimpleType as well. */ case XML_SCHEMAS_ANYSIMPLETYPE: case XML_SCHEMAS_STRING: case XML_SCHEMAS_NORMSTRING: case XML_SCHEMAS_TOKEN: case XML_SCHEMAS_LANGUAGE: case XML_SCHEMAS_NMTOKEN: case XML_SCHEMAS_NAME: case XML_SCHEMAS_NCNAME: case XML_SCHEMAS_ID: case XML_SCHEMAS_IDREF: case XML_SCHEMAS_ENTITY: case XML_SCHEMAS_ANYURI: { const xmlChar *xv, *yv; if (x == NULL) xv = xvalue; else xv = x->value.str; if (y == NULL) yv = yvalue; else yv = y->value.str; /* * TODO: Compare those against QName. */ if (ytype == XML_SCHEMAS_QNAME) { TODO if (y == NULL) return(-2); return (-2); } if ((ytype == XML_SCHEMAS_ANYSIMPLETYPE) || (ytype == XML_SCHEMAS_STRING) || (ytype == XML_SCHEMAS_NORMSTRING) || (ytype == XML_SCHEMAS_TOKEN) || (ytype == XML_SCHEMAS_LANGUAGE) || (ytype == XML_SCHEMAS_NMTOKEN) || (ytype == XML_SCHEMAS_NAME) || (ytype == XML_SCHEMAS_NCNAME) || (ytype == XML_SCHEMAS_ID) || (ytype == XML_SCHEMAS_IDREF) || (ytype == XML_SCHEMAS_ENTITY) || (ytype == XML_SCHEMAS_ANYURI)) { if (xws == XML_SCHEMA_WHITESPACE_PRESERVE) { if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) { /* TODO: What about x < y or x > y. */ if (xmlStrEqual(xv, yv)) return (0); else return (2); } else if (yws == XML_SCHEMA_WHITESPACE_REPLACE) return (xmlSchemaComparePreserveReplaceStrings(xv, yv, 0)); else if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE) return (xmlSchemaComparePreserveCollapseStrings(xv, yv, 0)); } else if (xws == XML_SCHEMA_WHITESPACE_REPLACE) { if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) return (xmlSchemaComparePreserveReplaceStrings(yv, xv, 1)); if (yws == XML_SCHEMA_WHITESPACE_REPLACE) return (xmlSchemaCompareReplacedStrings(xv, yv)); if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE) return (xmlSchemaCompareReplaceCollapseStrings(xv, yv, 0)); } else if (xws == XML_SCHEMA_WHITESPACE_COLLAPSE) { if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) return (xmlSchemaComparePreserveCollapseStrings(yv, xv, 1)); if (yws == XML_SCHEMA_WHITESPACE_REPLACE) return (xmlSchemaCompareReplaceCollapseStrings(yv, xv, 1)); if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE) return (xmlSchemaCompareNormStrings(xv, yv)); } else return (-2); } return (-2); } case XML_SCHEMAS_QNAME: case XML_SCHEMAS_NOTATION: if ((x == NULL) || (y == NULL)) return(-2); if ((ytype == XML_SCHEMAS_QNAME) || (ytype == XML_SCHEMAS_NOTATION)) { if ((xmlStrEqual(x->value.qname.name, y->value.qname.name)) && (xmlStrEqual(x->value.qname.uri, y->value.qname.uri))) return(0); return(2); } return (-2); case XML_SCHEMAS_FLOAT: case XML_SCHEMAS_DOUBLE: if ((x == NULL) || (y == NULL)) return(-2); if ((ytype == XML_SCHEMAS_FLOAT) || (ytype == XML_SCHEMAS_DOUBLE)) return (xmlSchemaCompareFloats(x, y)); return (-2); case XML_SCHEMAS_BOOLEAN: if ((x == NULL) || (y == NULL)) return(-2); if (ytype == XML_SCHEMAS_BOOLEAN) { if (x->value.b == y->value.b) return(0); if (x->value.b == 0) return(-1); return(1); } return (-2); case XML_SCHEMAS_HEXBINARY: if ((x == NULL) || (y == NULL)) return(-2); if (ytype == XML_SCHEMAS_HEXBINARY) { if (x->value.hex.total == y->value.hex.total) { int ret = xmlStrcmp(x->value.hex.str, y->value.hex.str); if (ret > 0) return(1); else if (ret == 0) return(0); } else if (x->value.hex.total > y->value.hex.total) return(1); return(-1); } return (-2); case XML_SCHEMAS_BASE64BINARY: if ((x == NULL) || (y == NULL)) return(-2); if (ytype == XML_SCHEMAS_BASE64BINARY) { if (x->value.base64.total == y->value.base64.total) { int ret = xmlStrcmp(x->value.base64.str, y->value.base64.str); if (ret > 0) return(1); else if (ret == 0) return(0); else return(-1); } else if (x->value.base64.total > y->value.base64.total) return(1); else return(-1); } return (-2); case XML_SCHEMAS_IDREFS: case XML_SCHEMAS_ENTITIES: case XML_SCHEMAS_NMTOKENS: TODO break; } return -2; } /** * xmlSchemaCompareValues: * @x: a first value * @y: a second value * * Compare 2 values * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ int xmlSchemaCompareValues(xmlSchemaValPtr x, xmlSchemaValPtr y) { xmlSchemaWhitespaceValueType xws, yws; if ((x == NULL) || (y == NULL)) return(-2); if (x->type == XML_SCHEMAS_STRING) xws = XML_SCHEMA_WHITESPACE_PRESERVE; else if (x->type == XML_SCHEMAS_NORMSTRING) xws = XML_SCHEMA_WHITESPACE_REPLACE; else xws = XML_SCHEMA_WHITESPACE_COLLAPSE; if (y->type == XML_SCHEMAS_STRING) yws = XML_SCHEMA_WHITESPACE_PRESERVE; else if (x->type == XML_SCHEMAS_NORMSTRING) yws = XML_SCHEMA_WHITESPACE_REPLACE; else yws = XML_SCHEMA_WHITESPACE_COLLAPSE; return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type, y, NULL, yws)); } /** * xmlSchemaCompareValuesWhtsp: * @x: a first value * @xws: the whitespace value of x * @y: a second value * @yws: the whitespace value of y * * Compare 2 values * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ int xmlSchemaCompareValuesWhtsp(xmlSchemaValPtr x, xmlSchemaWhitespaceValueType xws, xmlSchemaValPtr y, xmlSchemaWhitespaceValueType yws) { if ((x == NULL) || (y == NULL)) return(-2); return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type, y, NULL, yws)); } /** * xmlSchemaCompareValuesWhtspExt: * @x: a first value * @xws: the whitespace value of x * @y: a second value * @yws: the whitespace value of y * * Compare 2 values * * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in * case of error */ static int xmlSchemaCompareValuesWhtspExt(xmlSchemaValType xtype, xmlSchemaValPtr x, const xmlChar *xvalue, xmlSchemaWhitespaceValueType xws, xmlSchemaValType ytype, xmlSchemaValPtr y, const xmlChar *yvalue, xmlSchemaWhitespaceValueType yws) { return(xmlSchemaCompareValuesInternal(xtype, x, xvalue, xws, ytype, y, yvalue, yws)); } /** * xmlSchemaNormLen: * @value: a string * * Computes the UTF8 length of the normalized value of the string * * Returns the length or -1 in case of error. */ static int xmlSchemaNormLen(const xmlChar *value) { const xmlChar *utf; int ret = 0; if (value == NULL) return(-1); utf = value; while (IS_BLANK_CH(*utf)) utf++; while (*utf != 0) { if (utf[0] & 0x80) { if ((utf[1] & 0xc0) != 0x80) return(-1); if ((utf[0] & 0xe0) == 0xe0) { if ((utf[2] & 0xc0) != 0x80) return(-1); if ((utf[0] & 0xf0) == 0xf0) { if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80) return(-1); utf += 4; } else { utf += 3; } } else { utf += 2; } } else if (IS_BLANK_CH(*utf)) { while (IS_BLANK_CH(*utf)) utf++; if (*utf == 0) break; } else { utf++; } ret++; } return(ret); } /** * xmlSchemaGetFacetValueAsULong: * @facet: an schemas type facet * * Extract the value of a facet * * Returns the value as a long */ unsigned long xmlSchemaGetFacetValueAsULong(xmlSchemaFacetPtr facet) { /* * TODO: Check if this is a decimal. */ if (facet == NULL) return 0; return ((unsigned long) facet->val->value.decimal.lo); } /** * xmlSchemaValidateListSimpleTypeFacet: * @facet: the facet to check * @value: the lexical repr of the value to validate * @actualLen: the number of list items * @expectedLen: the resulting expected number of list items * * Checks the value of a list simple type against a facet. * * Returns 0 if the value is valid, a positive error code * number otherwise and -1 in case of an internal error. */ int xmlSchemaValidateListSimpleTypeFacet(xmlSchemaFacetPtr facet, const xmlChar *value, unsigned long actualLen, unsigned long *expectedLen) { if (facet == NULL) return(-1); /* * TODO: Check if this will work with large numbers. * (compare value.decimal.mi and value.decimal.hi as well?). */ if (facet->type == XML_SCHEMA_FACET_LENGTH) { if (actualLen != facet->val->value.decimal.lo) { if (expectedLen != NULL) *expectedLen = facet->val->value.decimal.lo; return (XML_SCHEMAV_CVC_LENGTH_VALID); } } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) { if (actualLen < facet->val->value.decimal.lo) { if (expectedLen != NULL) *expectedLen = facet->val->value.decimal.lo; return (XML_SCHEMAV_CVC_MINLENGTH_VALID); } } else if (facet->type == XML_SCHEMA_FACET_MAXLENGTH) { if (actualLen > facet->val->value.decimal.lo) { if (expectedLen != NULL) *expectedLen = facet->val->value.decimal.lo; return (XML_SCHEMAV_CVC_MAXLENGTH_VALID); } } else /* * NOTE: That we can pass NULL as xmlSchemaValPtr to * xmlSchemaValidateFacet, since the remaining facet types * are: XML_SCHEMA_FACET_PATTERN, XML_SCHEMA_FACET_ENUMERATION. */ return(xmlSchemaValidateFacet(NULL, facet, value, NULL)); return (0); } /** * xmlSchemaValidateLengthFacet: * @type: the built-in type * @facet: the facet to check * @value: the lexical repr. of the value to be validated * @val: the precomputed value * @ws: the whitespace type of the value * @length: the actual length of the value * * Checka a value against a

,

and

* facet; sets @length to the computed length of @value. * * Returns 0 if the value is valid, a positive error code * otherwise and -1 in case of an internal or API error. */ static int xmlSchemaValidateLengthFacetInternal(xmlSchemaFacetPtr facet, xmlSchemaTypeType valType, const xmlChar *value, xmlSchemaValPtr val, unsigned long *length, xmlSchemaWhitespaceValueType ws) { unsigned int len = 0; if ((length == NULL) || (facet == NULL)) return (-1); *length = 0; if ((facet->type != XML_SCHEMA_FACET_LENGTH) && (facet->type != XML_SCHEMA_FACET_MAXLENGTH) && (facet->type != XML_SCHEMA_FACET_MINLENGTH)) return (-1); /* * TODO: length, maxLength and minLength must be of type * nonNegativeInteger only. Check if decimal is used somehow. */ if ((facet->val == NULL) || ((facet->val->type != XML_SCHEMAS_DECIMAL) && (facet->val->type != XML_SCHEMAS_NNINTEGER)) || (facet->val->value.decimal.frac != 0)) { return(-1); } if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY)) len = val->value.hex.total; else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY)) len = val->value.base64.total; else { switch (valType) { case XML_SCHEMAS_STRING: case XML_SCHEMAS_NORMSTRING: if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) { /* * This is to ensure API compatibility with the old * xmlSchemaValidateLengthFacet(). Anyway, this was and * is not the correct handling. * TODO: Get rid of this case somehow. */ if (valType == XML_SCHEMAS_STRING) len = xmlUTF8Strlen(value); else len = xmlSchemaNormLen(value); } else if (value != NULL) { if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) len = xmlSchemaNormLen(value); else /* * Should be OK for

as well. */ len = xmlUTF8Strlen(value); } break; case XML_SCHEMAS_IDREF: case XML_SCHEMAS_TOKEN: case XML_SCHEMAS_LANGUAGE: case XML_SCHEMAS_NMTOKEN: case XML_SCHEMAS_NAME: case XML_SCHEMAS_NCNAME: case XML_SCHEMAS_ID: /* * FIXME: What exactly to do with anyURI? */ case XML_SCHEMAS_ANYURI: if (value != NULL) len = xmlSchemaNormLen(value); break; case XML_SCHEMAS_QNAME: case XML_SCHEMAS_NOTATION: /* * For QName and NOTATION, those facets are * deprecated and should be ignored. */ return (0); default: TODO } } *length = (unsigned long) len; /* * TODO: Return the whole expected value, i.e.

,

and

. */ if (facet->type == XML_SCHEMA_FACET_LENGTH) { if (len != facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_LENGTH_VALID); } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) { if (len < facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_MINLENGTH_VALID); } else { if (len > facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_MAXLENGTH_VALID); } return (0); } /** * xmlSchemaValidateLengthFacet: * @type: the built-in type * @facet: the facet to check * @value: the lexical repr. of the value to be validated * @val: the precomputed value * @length: the actual length of the value * * Checka a value against a

,

and

* facet; sets @length to the computed length of @value. * * Returns 0 if the value is valid, a positive error code * otherwise and -1 in case of an internal or API error. */ int xmlSchemaValidateLengthFacet(xmlSchemaTypePtr type, xmlSchemaFacetPtr facet, const xmlChar *value, xmlSchemaValPtr val, unsigned long *length) { if (type == NULL) return(-1); return (xmlSchemaValidateLengthFacetInternal(facet, type->builtInType, value, val, length, XML_SCHEMA_WHITESPACE_UNKNOWN)); } /** * xmlSchemaValidateLengthFacetWhtsp: * @facet: the facet to check * @valType: the built-in type * @value: the lexical repr. of the value to be validated * @val: the precomputed value * @ws: the whitespace type of the value * @length: the actual length of the value * * Checka a value against a

,

and

* facet; sets @length to the computed length of @value. * * Returns 0 if the value is valid, a positive error code * otherwise and -1 in case of an internal or API error. */ int xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet, xmlSchemaValType valType, const xmlChar *value, xmlSchemaValPtr val, unsigned long *length, xmlSchemaWhitespaceValueType ws) { return (xmlSchemaValidateLengthFacetInternal(facet, valType, value, val, length, ws)); } /** * xmlSchemaValidateFacetInternal: * @facet: the facet to check * @fws: the whitespace type of the facet's value * @valType: the built-in type of the value * @value: the lexical repr of the value to validate * @val: the precomputed value * @ws: the whitespace type of the value * * Check a value against a facet condition * * Returns 0 if the element is schemas valid, a positive error code * number otherwise and -1 in case of internal or API error. */ static int xmlSchemaValidateFacetInternal(xmlSchemaFacetPtr facet, xmlSchemaWhitespaceValueType fws, xmlSchemaValType valType, const xmlChar *value, xmlSchemaValPtr val, xmlSchemaWhitespaceValueType ws) { int ret; if (facet == NULL) return(-1); switch (facet->type) { case XML_SCHEMA_FACET_PATTERN: /* * NOTE that for patterns, the @value needs to be the normalized * value, *not* the lexical initial value or the canonical value. */ if (value == NULL) return(-1); ret = xmlRegexpExec(facet->regexp, value); if (ret == 1) return(0); if (ret == 0) return(XML_SCHEMAV_CVC_PATTERN_VALID); return(ret); case XML_SCHEMA_FACET_MAXEXCLUSIVE: ret = xmlSchemaCompareValues(val, facet->val); if (ret == -2) return(-1); if (ret == -1) return(0); return(XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID); case XML_SCHEMA_FACET_MAXINCLUSIVE: ret = xmlSchemaCompareValues(val, facet->val); if (ret == -2) return(-1); if ((ret == -1) || (ret == 0)) return(0); return(XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID); case XML_SCHEMA_FACET_MINEXCLUSIVE: ret = xmlSchemaCompareValues(val, facet->val); if (ret == -2) return(-1); if (ret == 1) return(0); return(XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID); case XML_SCHEMA_FACET_MININCLUSIVE: ret = xmlSchemaCompareValues(val, facet->val); if (ret == -2) return(-1); if ((ret == 1) || (ret == 0)) return(0); return(XML_SCHEMAV_CVC_MININCLUSIVE_VALID); case XML_SCHEMA_FACET_WHITESPACE: /* TODO whitespaces */ /* * NOTE: Whitespace should be handled to normalize * the value to be validated against a the facets; * not to normalize the value in-between. */ return(0); case XML_SCHEMA_FACET_ENUMERATION: if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) { /* * This is to ensure API compatibility with the old * xmlSchemaValidateFacet(). * TODO: Get rid of this case. */ if ((facet->value != NULL) && (xmlStrEqual(facet->value, value))) return(0); } else { ret = xmlSchemaCompareValuesWhtspExt(facet->val->type, facet->val, facet->value, fws, valType, val, value, ws); if (ret == -2) return(-1); if (ret == 0) return(0); } return(XML_SCHEMAV_CVC_ENUMERATION_VALID); case XML_SCHEMA_FACET_LENGTH: /* * SPEC (1.3)

*/ if ((valType == XML_SCHEMAS_QNAME) || (valType == XML_SCHEMAS_NOTATION)) return (0); /* No break on purpose. */ case XML_SCHEMA_FACET_MAXLENGTH: case XML_SCHEMA_FACET_MINLENGTH: { unsigned int len = 0; if ((valType == XML_SCHEMAS_QNAME) || (valType == XML_SCHEMAS_NOTATION)) return (0); /* * TODO: length, maxLength and minLength must be of type * nonNegativeInteger only. Check if decimal is used somehow. */ if ((facet->val == NULL) || ((facet->val->type != XML_SCHEMAS_DECIMAL) && (facet->val->type != XML_SCHEMAS_NNINTEGER)) || (facet->val->value.decimal.frac != 0)) { return(-1); } if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY)) len = val->value.hex.total; else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY)) len = val->value.base64.total; else { switch (valType) { case XML_SCHEMAS_STRING: case XML_SCHEMAS_NORMSTRING: if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) { /* * This is to ensure API compatibility with the old * xmlSchemaValidateFacet(). Anyway, this was and * is not the correct handling. * TODO: Get rid of this case somehow. */ if (valType == XML_SCHEMAS_STRING) len = xmlUTF8Strlen(value); else len = xmlSchemaNormLen(value); } else if (value != NULL) { if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) len = xmlSchemaNormLen(value); else /* * Should be OK for

as well. */ len = xmlUTF8Strlen(value); } break; case XML_SCHEMAS_IDREF: case XML_SCHEMAS_TOKEN: case XML_SCHEMAS_LANGUAGE: case XML_SCHEMAS_NMTOKEN: case XML_SCHEMAS_NAME: case XML_SCHEMAS_NCNAME: case XML_SCHEMAS_ID: case XML_SCHEMAS_ANYURI: if (value != NULL) len = xmlSchemaNormLen(value); break; default: TODO } } if (facet->type == XML_SCHEMA_FACET_LENGTH) { if (len != facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_LENGTH_VALID); } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) { if (len < facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_MINLENGTH_VALID); } else { if (len > facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_MAXLENGTH_VALID); } break; } case XML_SCHEMA_FACET_TOTALDIGITS: case XML_SCHEMA_FACET_FRACTIONDIGITS: if ((facet->val == NULL) || ((facet->val->type != XML_SCHEMAS_PINTEGER) && (facet->val->type != XML_SCHEMAS_NNINTEGER)) || (facet->val->value.decimal.frac != 0)) { return(-1); } if ((val == NULL) || ((val->type != XML_SCHEMAS_DECIMAL) && (val->type != XML_SCHEMAS_INTEGER) && (val->type != XML_SCHEMAS_NPINTEGER) && (val->type != XML_SCHEMAS_NINTEGER) && (val->type != XML_SCHEMAS_NNINTEGER) && (val->type != XML_SCHEMAS_PINTEGER) && (val->type != XML_SCHEMAS_INT) && (val->type != XML_SCHEMAS_UINT) && (val->type != XML_SCHEMAS_LONG) && (val->type != XML_SCHEMAS_ULONG) && (val->type != XML_SCHEMAS_SHORT) && (val->type != XML_SCHEMAS_USHORT) && (val->type != XML_SCHEMAS_BYTE) && (val->type != XML_SCHEMAS_UBYTE))) { return(-1); } if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) { if (val->value.decimal.total > facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_TOTALDIGITS_VALID); } else if (facet->type == XML_SCHEMA_FACET_FRACTIONDIGITS) { if (val->value.decimal.frac > facet->val->value.decimal.lo) return(XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID); } break; default: TODO } return(0); } /** * xmlSchemaValidateFacet: * @base: the base type * @facet: the facet to check * @value: the lexical repr of the value to validate * @val: the precomputed value * * Check a value against a facet condition * * Returns 0 if the element is schemas valid, a positive error code * number otherwise and -1 in case of internal or API error. */ int xmlSchemaValidateFacet(xmlSchemaTypePtr base, xmlSchemaFacetPtr facet, const xmlChar *value, xmlSchemaValPtr val) { /* * This tries to ensure API compatibility regarding the old * xmlSchemaValidateFacet() and the new xmlSchemaValidateFacetInternal() and * xmlSchemaValidateFacetWhtsp(). */ if (val != NULL) return(xmlSchemaValidateFacetInternal(facet, XML_SCHEMA_WHITESPACE_UNKNOWN, val->type, value, val, XML_SCHEMA_WHITESPACE_UNKNOWN)); else if (base != NULL) return(xmlSchemaValidateFacetInternal(facet, XML_SCHEMA_WHITESPACE_UNKNOWN, base->builtInType, value, val, XML_SCHEMA_WHITESPACE_UNKNOWN)); return(-1); } /** * xmlSchemaValidateFacetWhtsp: * @facet: the facet to check * @fws: the whitespace type of the facet's value * @valType: the built-in type of the value * @value: the lexical (or normalized for pattern) repr of the value to validate * @val: the precomputed value * @ws: the whitespace type of the value * * Check a value against a facet condition. This takes value normalization * according to the specified whitespace types into account. * Note that @value needs to be the *normalized* value if the facet * is of type

. * * Returns 0 if the element is schemas valid, a positive error code * number otherwise and -1 in case of internal or API error. */ int xmlSchemaValidateFacetWhtsp(xmlSchemaFacetPtr facet, xmlSchemaWhitespaceValueType fws, xmlSchemaValType valType, const xmlChar *value, xmlSchemaValPtr val, xmlSchemaWhitespaceValueType ws) { return(xmlSchemaValidateFacetInternal(facet, fws, valType, value, val, ws)); } #if 0 #ifndef DBL_DIG #define DBL_DIG 16 #endif #ifndef DBL_EPSILON #define DBL_EPSILON 1E-9 #endif #define INTEGER_DIGITS DBL_DIG #define FRACTION_DIGITS (DBL_DIG + 1) #define EXPONENT_DIGITS (3 + 2) /** * xmlXPathFormatNumber: * @number: number to format * @buffer: output buffer * @buffersize: size of output buffer * * Convert the number into a string representation. */ static void xmlSchemaFormatFloat(double number, char buffer[], int buffersize) { switch (xmlXPathIsInf(number)) { case 1: if (buffersize > (int)sizeof(

)) snprintf(buffer, buffersize,

); break; case -1: if (buffersize > (int)sizeof(

)) snprintf(buffer, buffersize,

); break; default: if (xmlXPathIsNaN(number)) { if (buffersize > (int)sizeof(

)) snprintf(buffer, buffersize,

); } else if (number == 0) { snprintf(buffer, buffersize,

); } else { /* 3 is sign, decimal point, and terminating zero */ char work[DBL_DIG + EXPONENT_DIGITS + 3]; int integer_place, fraction_place; char *ptr; char *after_fraction; double absolute_value; int size; absolute_value = fabs(number); /* * Result is in work, and after_fraction points * just past the fractional part. * Use scientific notation */ integer_place = DBL_DIG + EXPONENT_DIGITS + 1; fraction_place = DBL_DIG - 1; snprintf(work, sizeof(work),

, integer_place, fraction_place, number); after_fraction = strchr(work + DBL_DIG, 'e'); /* Remove fractional trailing zeroes */ ptr = after_fraction; while (*(--ptr) == '0') ; if (*ptr != '.') ptr++; while ((*ptr++ = *after_fraction++) != 0); /* Finally copy result back to caller */ size = strlen(work) + 1; if (size > buffersize) { work[buffersize - 1] = 0; size = buffersize; } memmove(buffer, work, size); } break; } } #endif /** * xmlSchemaGetCanonValue: * @val: the precomputed value * @retValue: the returned value * * Get a the cononical lexical representation of the value. * The caller has to FREE the returned retValue. * * WARNING: Some value types are not supported yet, resulting * in a @retValue of

. * * TODO: XML Schema 1.0 does not define canonical representations * for: duration, gYearMonth, gYear, gMonthDay, gMonth, gDay, * anyURI, QName, NOTATION. This will be fixed in XML Schema 1.1. * * * Returns 0 if the value could be built, 1 if the value type is * not supported yet and -1 in case of API errors. */ int xmlSchemaGetCanonValue(xmlSchemaValPtr val, const xmlChar **retValue) { if ((retValue == NULL) || (val == NULL)) return (-1); *retValue = NULL; switch (val->type) { case XML_SCHEMAS_STRING: if (val->value.str == NULL) *retValue = BAD_CAST xmlStrdup(BAD_CAST

); else *retValue = BAD_CAST xmlStrdup((const xmlChar *) val->value.str); break; case XML_SCHEMAS_NORMSTRING: if (val->value.str == NULL) *retValue = BAD_CAST xmlStrdup(BAD_CAST

); else { *retValue = xmlSchemaWhiteSpaceReplace( (const xmlChar *) val->value.str); if ((*retValue) == NULL) *retValue = BAD_CAST xmlStrdup( (const xmlChar *) val->value.str); } break; case XML_SCHEMAS_TOKEN: case XML_SCHEMAS_LANGUAGE: case XML_SCHEMAS_NMTOKEN: case XML_SCHEMAS_NAME: case XML_SCHEMAS_NCNAME: case XML_SCHEMAS_ID: case XML_SCHEMAS_IDREF: case XML_SCHEMAS_ENTITY: case XML_SCHEMAS_NOTATION: /* Unclear */ case XML_SCHEMAS_ANYURI: /* Unclear */ if (val->value.str == NULL) return (-1); *retValue = BAD_CAST xmlSchemaCollapseString(BAD_CAST val->value.str); if (*retValue == NULL) *retValue = BAD_CAST xmlStrdup((const xmlChar *) val->value.str); break; case XML_SCHEMAS_QNAME: /* TODO: Unclear in XML Schema 1.0. */ if (val->value.qname.uri == NULL) { *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.qname.name); return (0); } else { *retValue = BAD_CAST xmlStrdup(BAD_CAST

); *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue), BAD_CAST val->value.qname.uri); *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue), BAD_CAST

); *retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue), BAD_CAST val->value.qname.uri); } break; case XML_SCHEMAS_DECIMAL: /* * TODO: Lookout for a more simple implementation. */ if ((val->value.decimal.total == 1) && (val->value.decimal.lo == 0)) { *retValue = xmlStrdup(BAD_CAST

); } else { xmlSchemaValDecimal dec = val->value.decimal; int bufsize; char *buf = NULL, *offs; /* Add room for the decimal point as well. */ bufsize = dec.total + 2; if (dec.sign) bufsize++; /* Add room for leading/trailing zero. */ if ((dec.frac == 0) || (dec.frac == dec.total)) bufsize++; buf = xmlMalloc(bufsize); if (buf == NULL) return(-1); offs = buf; if (dec.sign) *offs++ = '-'; if (dec.frac == dec.total) { *offs++ = '0'; *offs++ = '.'; } if (dec.hi != 0) snprintf(offs, bufsize - (offs - buf),

, dec.hi, dec.mi, dec.lo); else if (dec.mi != 0) snprintf(offs, bufsize - (offs - buf),

, dec.mi, dec.lo); else snprintf(offs, bufsize - (offs - buf),

, dec.lo); if (dec.frac != 0) { if (dec.frac != dec.total) { int diff = dec.total - dec.frac; /* * Insert the decimal point. */ memmove(offs + diff + 1, offs + diff, dec.frac +1); offs[diff] = '.'; } else { unsigned int i = 0; /* * Insert missing zeroes behind the decimal point. */ while (*(offs + i) != 0) i++; if (i < dec.total) { memmove(offs + (dec.total - i), offs, i +1); memset(offs, '0', dec.total - i); } } } else { /* * Append decimal point and zero. */ offs = buf + bufsize - 1; *offs-- = 0; *offs-- = '0'; *offs-- = '.'; } *retValue = BAD_CAST buf; } break; case XML_SCHEMAS_INTEGER: case XML_SCHEMAS_PINTEGER: case XML_SCHEMAS_NPINTEGER: case XML_SCHEMAS_NINTEGER: case XML_SCHEMAS_NNINTEGER: case XML_SCHEMAS_LONG: case XML_SCHEMAS_BYTE: case XML_SCHEMAS_SHORT: case XML_SCHEMAS_INT: case XML_SCHEMAS_UINT: case XML_SCHEMAS_ULONG: case XML_SCHEMAS_USHORT: case XML_SCHEMAS_UBYTE: if ((val->value.decimal.total == 1) && (val->value.decimal.lo == 0)) *retValue = xmlStrdup(BAD_CAST

); else { xmlSchemaValDecimal dec = val->value.decimal; int bufsize = dec.total + 1; /* Add room for the decimal point as well. */ if (dec.sign) bufsize++; *retValue = xmlMalloc(bufsize); if (*retValue == NULL) return(-1); if (dec.hi != 0) { if (dec.sign) snprintf((char *) *retValue, bufsize,

, dec.hi, dec.mi, dec.lo); else snprintf((char *) *retValue, bufsize,

, dec.hi, dec.mi, dec.lo); } else if (dec.mi != 0) { if (dec.sign) snprintf((char *) *retValue, bufsize,

, dec.mi, dec.lo); else snprintf((char *) *retValue, bufsize,

, dec.mi, dec.lo); } else { if (dec.sign) snprintf((char *) *retValue, bufsize,

, dec.lo); else snprintf((char *) *retValue, bufsize,

, dec.lo); } } break; case XML_SCHEMAS_BOOLEAN: if (val->value.b) *retValue = BAD_CAST xmlStrdup(BAD_CAST

); else *retValue = BAD_CAST xmlStrdup(BAD_CAST

); break; case XML_SCHEMAS_DURATION: { char buf[100]; unsigned long year; unsigned long mon, day, hour = 0, min = 0; double sec = 0, left; /* TODO: Unclear in XML Schema 1.0 */ /* * TODO: This results in a normalized output of the value * - which is NOT conformant to the spec - * since the exact values of each property are not * recoverable. Think about extending the structure to * provide a field for every property. */ year = (unsigned long) FQUOTIENT(labs(val->value.dur.mon), 12); mon = labs(val->value.dur.mon) - 12 * year; day = (unsigned long) FQUOTIENT(fabs(val->value.dur.sec), 86400); left = fabs(val->value.dur.sec) - day * 86400; if (left > 0) { hour = (unsigned long) FQUOTIENT(left, 3600); left = left - (hour * 3600); if (left > 0) { min = (unsigned long) FQUOTIENT(left, 60); sec = left - (min * 60); } } if ((val->value.dur.mon < 0) || (val->value.dur.sec < 0)) snprintf(buf, 100,

, year, mon, day, hour, min, sec); else snprintf(buf, 100,

, year, mon, day, hour, min, sec); *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_GYEAR: { char buf[30]; /* TODO: Unclear in XML Schema 1.0 */ /* TODO: What to do with the timezone? */ snprintf(buf, 30,

, val->value.date.year); *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_GMONTH: { /* TODO: Unclear in XML Schema 1.0 */ /* TODO: What to do with the timezone? */ *retValue = xmlMalloc(6); if (*retValue == NULL) return(-1); snprintf((char *) *retValue, 6,

, val->value.date.mon); } break; case XML_SCHEMAS_GDAY: { /* TODO: Unclear in XML Schema 1.0 */ /* TODO: What to do with the timezone? */ *retValue = xmlMalloc(6); if (*retValue == NULL) return(-1); snprintf((char *) *retValue, 6,

, val->value.date.day); } break; case XML_SCHEMAS_GMONTHDAY: { /* TODO: Unclear in XML Schema 1.0 */ /* TODO: What to do with the timezone? */ *retValue = xmlMalloc(8); if (*retValue == NULL) return(-1); snprintf((char *) *retValue, 8,

, val->value.date.mon, val->value.date.day); } break; case XML_SCHEMAS_GYEARMONTH: { char buf[35]; /* TODO: Unclear in XML Schema 1.0 */ /* TODO: What to do with the timezone? */ if (val->value.date.year < 0) snprintf(buf, 35,

, labs(val->value.date.year), val->value.date.mon); else snprintf(buf, 35,

, val->value.date.year, val->value.date.mon); *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_TIME: { char buf[30]; if (val->value.date.tz_flag) { xmlSchemaValPtr norm; norm = xmlSchemaDateNormalize(val, 0); if (norm == NULL) return (-1); /* * TODO: Check if

is portable. */ snprintf(buf, 30,

, norm->value.date.hour, norm->value.date.min, norm->value.date.sec); xmlSchemaFreeValue(norm); } else { snprintf(buf, 30,

, val->value.date.hour, val->value.date.min, val->value.date.sec); } *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_DATE: { char buf[30]; if (val->value.date.tz_flag) { xmlSchemaValPtr norm; norm = xmlSchemaDateNormalize(val, 0); if (norm == NULL) return (-1); /* * TODO: Append the canonical value of the * recoverable timezone and not

. */ snprintf(buf, 30,

, norm->value.date.year, norm->value.date.mon, norm->value.date.day); xmlSchemaFreeValue(norm); } else { snprintf(buf, 30,

, val->value.date.year, val->value.date.mon, val->value.date.day); } *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_DATETIME: { char buf[50]; if (val->value.date.tz_flag) { xmlSchemaValPtr norm; norm = xmlSchemaDateNormalize(val, 0); if (norm == NULL) return (-1); /* * TODO: Check if

is portable. */ snprintf(buf, 50,

, norm->value.date.year, norm->value.date.mon, norm->value.date.day, norm->value.date.hour, norm->value.date.min, norm->value.date.sec); xmlSchemaFreeValue(norm); } else { snprintf(buf, 50,

, val->value.date.year, val->value.date.mon, val->value.date.day, val->value.date.hour, val->value.date.min, val->value.date.sec); } *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_HEXBINARY: *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.hex.str); break; case XML_SCHEMAS_BASE64BINARY: /* * TODO: Is the following spec piece implemented?: * SPEC:

*/ *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.base64.str); break; case XML_SCHEMAS_FLOAT: { char buf[30]; /* * |m| < 16777216, -149 <= e <= 104. * TODO: Handle, NaN, INF, -INF. The format is not * yet conformant. The c type float does not cover * the whole range. */ snprintf(buf, 30,

, val->value.f); *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; case XML_SCHEMAS_DOUBLE: { char buf[40]; /* |m| < 9007199254740992, -1075 <= e <= 970 */ /* * TODO: Handle, NaN, INF, -INF. The format is not * yet conformant. The c type float does not cover * the whole range. */ snprintf(buf, 40,

, val->value.d); *retValue = BAD_CAST xmlStrdup(BAD_CAST buf); } break; default: *retValue = BAD_CAST xmlStrdup(BAD_CAST

); return (1); } if (*retValue == NULL) return(-1); return (0); } /** * xmlSchemaGetCanonValueWhtsp: * @val: the precomputed value * @retValue: the returned value * @ws: the whitespace type of the value * * Get a the cononical representation of the value. * The caller has to free the returned @retValue. * * Returns 0 if the value could be built, 1 if the value type is * not supported yet and -1 in case of API errors. */ int xmlSchemaGetCanonValueWhtsp(xmlSchemaValPtr val, const xmlChar **retValue, xmlSchemaWhitespaceValueType ws) { if ((retValue == NULL) || (val == NULL)) return (-1); if ((ws == XML_SCHEMA_WHITESPACE_UNKNOWN) || (ws > XML_SCHEMA_WHITESPACE_COLLAPSE)) return (-1); *retValue = NULL; switch (val->type) { case XML_SCHEMAS_STRING: if (val->value.str == NULL) *retValue = BAD_CAST xmlStrdup(BAD_CAST

); else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) *retValue = xmlSchemaCollapseString(val->value.str); else if (ws == XML_SCHEMA_WHITESPACE_REPLACE) *retValue = xmlSchemaWhiteSpaceReplace(val->value.str); if ((*retValue) == NULL) *retValue = BAD_CAST xmlStrdup(val->value.str); break; case XML_SCHEMAS_NORMSTRING: if (val->value.str == NULL) *retValue = BAD_CAST xmlStrdup(BAD_CAST

); else { if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) *retValue = xmlSchemaCollapseString(val->value.str); else *retValue = xmlSchemaWhiteSpaceReplace(val->value.str); if ((*retValue) == NULL) *retValue = BAD_CAST xmlStrdup(val->value.str); } break; default: return (xmlSchemaGetCanonValue(val, retValue)); } return (0); } /** * xmlSchemaGetValType: * @val: a schemas value * * Accessor for the type of a value * * Returns the xmlSchemaValType of the value */ xmlSchemaValType xmlSchemaGetValType(xmlSchemaValPtr val) { if (val == NULL) return(XML_SCHEMAS_UNKNOWN); return (val->type); } #define bottom_xmlschemastypes #include

0x9)

0xa))

0xd))

0x20)

0xd,

0x9

0xa

0xd)

0x9)

0xa)))

0xd)

0x9)

0xa)

0xa)

0x9)

0xd))

0xd)

0xa)

0x9))

0xd)

0xa)

0x9))

0xd)

0xa)

0x9))

0xd)

0xa)

0x9))

0x3c

0x3c)

0x30

0x30)

0xf;

0x7;

0x1;

0x2;

0x3;

0x3;

0x6;

0x8;

0xf;

0x7;

0x1;

0x2;

0x3;

0x3;

0x6;

0x8;

0x20)

0x20.

0x20)

0x20.

0x20)

0x20.

0x20

0x20)

0x20

0x80)

0xc0)

0x80)

0xe0)

0xe0)

0xc0)

0x80)

0xf0)

0xf0)

0xf8)

0xf0

0xc0)

0x80)

Summary: implementation of XML Schema Datatypes Description: module providing the XML Schema Datatypes implementation both definition and validity checking Copy: See Copyright for the status of this software. Author: Daniel Veillard

LIBXML_SCHEMAS_ENABLED

__XML_SCHEMA_TYPES_H__

C

