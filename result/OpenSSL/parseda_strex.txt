Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1_STRING_print_ex() and X509_NAME_print_ex(). Enhanced string and name printing routines handling multibyte characters, RFC2253 and a host of other options.

Three IO functions for sending data to memory, a BIO and and a FILE pointer.

This function handles display of strings, one character at a time. It is passed an unsigned long for each character because it could come from 2 or even 4 byte forms.

If we don't escape with quotes, signal we need quotes

If we get this far and do any escaping at all must escape the escape character itself: backslash.

This function sends each character in a buffer to do_esc_char(). It interprets the content formats and converts to or from UTF8 as appropriate.

Invalid UTF8String

invalid width

We don't need to worry about setting orflags correctly because if utflen==1 its value will be correct anyway otherwise each character will be > 0x7f and so the character will never be escaped on first and last.

This function hex dumps a buffer of characters

"dump" a string. This is done when the type is unknown, or the flags request it. We can either dump the content octets or the entire DER encoding. This uses the RFC2253 #01234 format.

Placing the ASN1_STRING in a temp ASN1_TYPE allows the DER encoding to readily obtained

If we don't dump DER encoding just dump content octets

Lookup table to convert tags to character widths, 0 = UTF8 encoded, -1 is used for non string types otherwise it is the number of bytes per character

0-4

5-9

10-13

15-17

18-20

21-24

25-27

28-30

This is the main function, print out an ASN1_STRING taking note of various escape and display options. Returns number of characters written or -1 if an error occurred.

Keep a copy of escape flags

Decide what to do with type, either dump content or display it

Dump everything

Ignore the string type

Else determine width based on type

Note: if string is UTF8 and we want to convert to UTF8 then we just interpret it as 1 byte per character to avoid converting twice.

Used for line indenting: print 'indent' spaces

XXX: what should this be?

XXX: what should this be?

If the field name is unknown then fix up the DER dump flag. We might want to limit this further so it will DER dump on anything other than a few 'standard' fields.

Wrappers round the main functions

Utility function: convert any string type to UTF8, returns number of bytes in output string or a negative error code

Return 1 if host is a valid hostname and 0 otherwise

Treat UTF8String as width 1 as any MSB set is invalid

Value must be <= 0x7F: check upper bytes are all zeroes

Nothing else allowed at start or end of string

Otherwise invalid if not dot or hyphen

If previous is dot or hyphen then illegal unless both are hyphens: as .- -. .. are all illegal

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/asn1_int.h

charmap.h

\\W%08lX

\\U%04lX

t escape with quotes, signal we need quotes */ if (chflgs & ASN1_STRFLGS_ESC_QUOTE) { if (do_quotes) *do_quotes = 1; if (!io_ch(arg, &chtmp, 1)) return -1; return 1; } if (!io_ch(arg, "\\", 1)) return -1; if (!io_ch(arg, &chtmp, 1)) return -1; return 2; } if (chflgs & (ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_ESC_2254)) { BIO_snprintf(tmphex, 11, "\\%02X", chtmp); if (!io_ch(arg, tmphex, 3)) return -1; return 3; } /* * If we get this far and do any escaping at all must escape the escape * character itself: backslash. */ if (chtmp ==

&& flags & ESC_FLAGS) { if (!io_ch(arg, "\\\\", 2)) return -1; return 2; } if (!io_ch(arg, &chtmp, 1)) return -1; return 1; } #define BUF_TYPE_WIDTH_MASK 0x7 #define BUF_TYPE_CONVUTF8 0x8 /* * This function sends each character in a buffer to do_esc_char(). It * interprets the content formats and converts to or from UTF8 as * appropriate. */ static int do_buf(unsigned char *buf, int buflen, int type, unsigned short flags, char *quotes, char_io *io_ch, void *arg) { int i, outlen, len; unsigned short orflags; unsigned char *p, *q; unsigned long c; p = buf; q = buf + buflen; outlen = 0; while (p != q) { if (p == buf && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_FIRST_ESC_2253; else orflags = 0; switch (type & BUF_TYPE_WIDTH_MASK) { case 4: c = ((unsigned long)*p++) << 24; c |= ((unsigned long)*p++) << 16; c |= ((unsigned long)*p++) << 8; c |= *p++; break; case 2: c = ((unsigned long)*p++) << 8; c |= *p++; break; case 1: c = *p++; break; case 0: i = UTF8_getc(p, buflen, &c); if (i < 0) return -1; /* Invalid UTF8String */ p += i; break; default: return -1; /* invalid width */ } if (p == q && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_LAST_ESC_2253; if (type & BUF_TYPE_CONVUTF8) { unsigned char utfbuf[6]; int utflen; utflen = UTF8_putc(utfbuf, sizeof utfbuf, c); for (i = 0; i < utflen; i++) { /* * We don

0123456789ABCDEF

dump

#

t dump DER encoding just dump content octets */ if (!(lflags & ASN1_STRFLGS_DUMP_DER)) { outlen = do_hex_dump(io_ch, arg, str->data, str->length); if (outlen < 0) return -1; return outlen + 1; } t.type = str->type; t.value.ptr = (char *)str; der_len = i2d_ASN1_TYPE(&t, NULL); der_buf = OPENSSL_malloc(der_len); if (der_buf == NULL) return -1; p = der_buf; i2d_ASN1_TYPE(&t, &p); outlen = do_hex_dump(io_ch, arg, der_buf, der_len); OPENSSL_free(der_buf); if (outlen < 0) return -1; return outlen + 1; } /* * Lookup table to convert tags to character widths, 0 = UTF8 encoded, -1 is * used for non string types otherwise it is the number of bytes per * character */ static const signed char tag2nbyte[] = { -1, -1, -1, -1, -1, /* 0-4 */ -1, -1, -1, -1, -1, /* 5-9 */ -1, -1, 0, -1, /* 10-13 */ -1, -1, -1, -1, /* 15-17 */ 1, 1, 1, /* 18-20 */ -1, 1, 1, 1, /* 21-24 */ -1, 1, -1, /* 25-27 */ 4, -1, 2 /* 28-30 */ }; /* * This is the main function, print out an ASN1_STRING taking note of various * escape and display options. Returns number of characters written or -1 if * an error occurred. */ static int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags, const ASN1_STRING *str) { int outlen, len; int type; char quotes; unsigned short flags; quotes = 0; /* Keep a copy of escape flags */ flags = (unsigned short)(lflags & ESC_FLAGS); type = str->type; outlen = 0; if (lflags & ASN1_STRFLGS_SHOW_TYPE) { const char *tagname; tagname = ASN1_tag2str(type); outlen += strlen(tagname); if (!io_ch(arg, tagname, outlen) || !io_ch(arg, ":", 1)) return -1; outlen++; } /* Decide what to do with type, either dump content or display it */ /* Dump everything */ if (lflags & ASN1_STRFLGS_DUMP_ALL) type = -1; /* Ignore the string type */ else if (lflags & ASN1_STRFLGS_IGNORE_TYPE) type = 1; else { /* Else determine width based on type */ if ((type > 0) && (type < 31)) type = tag2nbyte[type]; else type = -1; if ((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN)) type = 1; } if (type == -1) { len = do_dump(lflags, io_ch, arg, str); if (len < 0) return -1; outlen += len; return outlen; } if (lflags & ASN1_STRFLGS_UTF8_CONVERT) { /* * Note: if string is UTF8 and we want to convert to UTF8 then we * just interpret it as 1 byte per character to avoid converting * twice. */ if (!type) type = 1; else type |= BUF_TYPE_CONVUTF8; } len = do_buf(str->data, str->length, type, flags, &quotes, io_ch, NULL); if (len < 0) return -1; outlen += len; if (quotes) outlen += 2; if (!arg) return outlen; if (quotes && !io_ch(arg, "\"", 1)) return -1; if (do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0) return -1; if (quotes && !io_ch(arg, "\"", 1)) return -1; return outlen; } /* Used for line indenting: print

spaces */ static int do_indent(char_io *io_ch, void *arg, int indent) { int i; for (i = 0; i < indent; i++) if (!io_ch(arg, " ", 1)) return 0; return 1; } #define FN_WIDTH_LN 25 #define FN_WIDTH_SN 10 static int do_name_ex(char_io *io_ch, void *arg, const X509_NAME *n, int indent, unsigned long flags) { int i, prev = -1, orflags, cnt; int fn_opt, fn_nid; ASN1_OBJECT *fn; const ASN1_STRING *val; const X509_NAME_ENTRY *ent; char objtmp[80]; const char *objbuf; int outlen, len; char *sep_dn, *sep_mv, *sep_eq; int sep_dn_len, sep_mv_len, sep_eq_len; if (indent < 0) indent = 0; outlen = indent; if (!do_indent(io_ch, arg, indent)) return -1; switch (flags & XN_FLAG_SEP_MASK) { case XN_FLAG_SEP_MULTILINE: sep_dn = "\n"; sep_dn_len = 1; sep_mv = " + "; sep_mv_len = 3; break; case XN_FLAG_SEP_COMMA_PLUS: sep_dn = ","; sep_dn_len = 1; sep_mv = "+"; sep_mv_len = 1; indent = 0; break; case XN_FLAG_SEP_CPLUS_SPC: sep_dn = ", "; sep_dn_len = 2; sep_mv = " + "; sep_mv_len = 3; indent = 0; break; case XN_FLAG_SEP_SPLUS_SPC: sep_dn = "; "; sep_dn_len = 2; sep_mv = " + "; sep_mv_len = 3; indent = 0; break; default: return -1; } if (flags & XN_FLAG_SPC_EQ) { sep_eq = " = "; sep_eq_len = 3; } else { sep_eq = "="; sep_eq_len = 1; } fn_opt = flags & XN_FLAG_FN_MASK; cnt = X509_NAME_entry_count(n); for (i = 0; i < cnt; i++) { if (flags & XN_FLAG_DN_REV) ent = X509_NAME_get_entry(n, cnt - i - 1); else ent = X509_NAME_get_entry(n, i); if (prev != -1) { if (prev == X509_NAME_ENTRY_set(ent)) { if (!io_ch(arg, sep_mv, sep_mv_len)) return -1; outlen += sep_mv_len; } else { if (!io_ch(arg, sep_dn, sep_dn_len)) return -1; outlen += sep_dn_len; if (!do_indent(io_ch, arg, indent)) return -1; outlen += indent; } } prev = X509_NAME_ENTRY_set(ent); fn = X509_NAME_ENTRY_get_object(ent); val = X509_NAME_ENTRY_get_data(ent); fn_nid = OBJ_obj2nid(fn); if (fn_opt != XN_FLAG_FN_NONE) { int objlen, fld_len; if ((fn_opt == XN_FLAG_FN_OID) || (fn_nid == NID_undef)) { OBJ_obj2txt(objtmp, sizeof objtmp, fn, 1); fld_len = 0; /* XXX: what should this be? */ objbuf = objtmp; } else { if (fn_opt == XN_FLAG_FN_SN) { fld_len = FN_WIDTH_SN; objbuf = OBJ_nid2sn(fn_nid); } else if (fn_opt == XN_FLAG_FN_LN) { fld_len = FN_WIDTH_LN; objbuf = OBJ_nid2ln(fn_nid); } else { fld_len = 0; /* XXX: what should this be? */ objbuf = ""; } } objlen = strlen(objbuf); if (!io_ch(arg, objbuf, objlen)) return -1; if ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) { if (!do_indent(io_ch, arg, fld_len - objlen)) return -1; outlen += fld_len - objlen; } if (!io_ch(arg, sep_eq, sep_eq_len)) return -1; outlen += objlen + sep_eq_len; } /* * If the field name is unknown then fix up the DER dump flag. We * might want to limit this further so it will DER dump on anything * other than a few

0xffffffffL)

0xffff)

0xff)

0x7f)

0x7

0x8

0x7f

0xf];

0x7F:

0x7f)

