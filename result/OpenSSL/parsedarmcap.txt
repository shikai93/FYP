Copyright 2011-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Following subroutines could have been inlined, but it's not all ARM compilers support inline assembler...

Use a weak reference to getauxval() so we can use it if it is available but don't break the build if it is not.

ARM puts the feature bits for Crypto Extensions in AT_HWCAP2, whereas AArch64 used AT_HWCAP.

AT_HWCAP

AT_HWCAP2

AT_HWCAP

Capability probing by catching SIGILL appears to be problematic on iOS. But since Apple universe is "monocultural", it's actually possible to simply set pre-defined processor capability mask.

One could do same even for __aarch64__ iOS builds. It's not done exclusively for reasons of keeping code unified across platforms. Unified code works because it never triggers SIGILL on Apple devices...

www.openssl.org/source/license.html

License

arm_arch.h

s not all * ARM compilers support inline assembler... */ void _armv7_neon_probe(void); void _armv8_aes_probe(void); void _armv8_sha1_probe(void); void _armv8_sha256_probe(void); void _armv8_pmull_probe(void); unsigned long _armv7_tick(void); unsigned long OPENSSL_rdtsc(void) { if (OPENSSL_armcap_P & ARMV7_TICK) return _armv7_tick(); else return 0; } # if defined(__GNUC__) && __GNUC__>=2 void OPENSSL_cpuid_setup(void) __attribute__ ((constructor)); # endif /* * Use a weak reference to getauxval() so we can use it if it is available but * don

OPENSSL_armcap

monocultural

s actually * possible to simply set pre-defined processor capability mask. */ if (1) { OPENSSL_armcap_P = ARMV7_NEON; return; } /* * One could do same even for __aarch64__ iOS builds. It

