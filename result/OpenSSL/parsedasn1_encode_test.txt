Copyright 2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Custom test data

We conduct tests with these arrays for every type we try out. You will find the expected results together with the test structures for each type, further down.

32-bit long

We make the last byte 0xfe to avoid a clash with ASN1_LONG_UNDEF

Type specific test data

First, a few utility things that all type specific data can use, or in some cases, MUST use.

For easy creation of arrays of expected data. These macros correspond to the uses of CUSTOM_DATA above.

A structure to collect all test information in. There MUST be one instance of this for each test

1 if this package should be skipped

An array of structures to compare decoded custom data with

An array of structures that are encoded into a DER blob, which is then decoded, and result gets compared with the original.

The i2d function to use with this type

The d2i function to use with this type

Function to free a decoded structure

To facilitate the creation of an encdec_data array

LONG

If decoding is expected to succeed, set this to 1, otherwise 0

The following should fail on the second because it's the default

t_zero

t_longundef

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1 (too large positive)

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

Check that default numbers fail

The following should fail on the second because it's the default

t_zero

t_longundef

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad (illegal padding)

t_8bytes_4_neg

t_8bytes_5_negpad (illegal padding)

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

Check that default numbers fail

INT32

t_zero

t_zero

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1 (too large positive)

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

UINT32

t_zero

t_zero

t_one

t_one_neg (illegal negative value)

t_minus_256 (illegal negative value)

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg (illegal negative value)

t_4bytes_5_negpad (illegal padding)

INT64

t_zero

t_zero

t_one

t_one_neg

t_minus_256

t_9bytes_1

t_8bytes_1 (too large positive)

t_8bytes_2

t_8bytes_3_pad (illegal padding)

t_8bytes_4_neg

t_8bytes_5_negpad (illegal padding)

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg

t_4bytes_5_negpad (illegal padding)

UINT64

t_zero

t_zero

t_one

t_one_neg (illegal negative value)

t_minus_256 (illegal negative value)

t_9bytes_1

t_8bytes_1

t_8bytes_2

t_8bytes_3_pad

t_8bytes_4_neg

t_8bytes_5_negpad

t_5bytes_1

t_4bytes_1

t_4bytes_2

t_4bytes_3_pad (illegal padding)

t_4bytes_4_neg (illegal negative value)

t_4bytes_5_negpad (illegal padding)

General testing functions

Template structure to map onto any test data structure

In reality, there's more

do_decode returns a tristate: -1 Couldn't decode 0 decoded structure wasn't what was expected (failure) 1 decoded structure was what was expected (success)

do_encode returns a tristate: -1 Couldn't encode 0 encoded DER wasn't what was expected (failure) 1 encoded DER was what was expected (success)

Do an encode/decode round trip

The first item is just an INTEGER tag, INTEGER length and INTEGER content

The second item is an explicit tag, content length, INTEGER tag, INTEGER length, INTEGER bytes

The whole sequence is the sequence tag, content length, BOOLEAN true (copied from t_true), the first (firstbytes) and second (secondbytes) items

Sequence tag

ASN1_BOOLEAN TRUE

Marks decoding success

First INTEGER item (non-optional)

Second INTEGER item (optional)

Start with the explicit optional tag

Attempt to decode a custom encoding of the test structure

We force the defaults to be explicitly encoded to make sure we test for defaults that shouldn't be present (i.e. we check for failure)

Attempt to encode the test structure and compare it to custom DER

Do decode_custom checks

Do enc_dec checks

www.openssl.org/source/license.html

License

internal/numbers.h

testutil.h

-Wunused-function

-Wformat

-Wunused-function

-Wformat

s the default */ { 0xff, 0, 1 }, { 0, 0, 0 }, /* t_zero */ { 0, 0, 0 }, { 0xff, 1, 0x7fffffff }, /* t_longundef */ CUSTOM_EXPECTED_SUCCESS(1, 1), /* t_one */ CUSTOM_EXPECTED_SUCCESS(-1, -1), /* t_one_neg */ CUSTOM_EXPECTED_SUCCESS(-256, -256), /* t_minus_256 */ CUSTOM_EXPECTED_FAILURE, /* t_9bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_2 */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_3_pad */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_4_neg */ CUSTOM_EXPECTED_FAILURE, /* t_8bytes_5_negpad */ CUSTOM_EXPECTED_FAILURE, /* t_5bytes_1 */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_1 (too large positive) */ CUSTOM_EXPECTED_SUCCESS(INT32_MAX - 1, INT32_MAX -1), /* t_4bytes_2 */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_3_pad (illegal padding) */ CUSTOM_EXPECTED_SUCCESS(INT32_MIN, INT32_MIN), /* t_4bytes_4_neg */ CUSTOM_EXPECTED_FAILURE, /* t_4bytes_5_negpad (illegal padding) */ }; static ASN1_LONG_DATA long_encdec_data_32bit[] = { ENCDEC_ARRAY(LONG_MAX - 1, LONG_MAX, LONG_MIN, LONG_MIN), /* Check that default numbers fail */ { 0, ASN1_LONG_UNDEF, 1 }, { 0, 1, 0 } }; static TEST_PACKAGE long_test_package_32bit = { ASN1_ITEM_ref(ASN1_LONG_DATA), "LONG", sizeof(long) != 4, long_expected_32bit, sizeof(long_expected_32bit), sizeof(long_expected_32bit[0]), long_encdec_data_32bit, sizeof(long_encdec_data_32bit), sizeof(long_encdec_data_32bit[0]), (i2d_fn *)i2d_ASN1_LONG_DATA, (d2i_fn *)d2i_ASN1_LONG_DATA, (ifree_fn *)ASN1_LONG_DATA_free }; static ASN1_LONG_DATA long_expected_64bit[] = { /* The following should fail on the second because it

LONG

INT32

UINT32

INT64

UINT64

s more */ } EXPECTED; /* * do_decode returns a tristate: * * -1 Couldn

t what was expected (failure) * 1 decoded structure was what was expected (success) */ static int do_decode(unsigned char *bytes, long nbytes, const EXPECTED *expected, size_t expected_size, const TEST_PACKAGE *package) { EXPECTED *enctst = NULL; const unsigned char *start; int ret = 0; start = bytes; enctst = package->d2i(NULL, &bytes, nbytes); if (enctst == NULL) { if (expected->success == 0) { ret = 1; ERR_clear_error(); } else { ret = -1; } } else { if (start + nbytes == bytes && memcmp(enctst, expected, expected_size) == 0) ret = 1; else ret = 0; } package->ifree(enctst); return ret; } /* * do_encode returns a tristate: * * -1 Couldn

t what was expected (failure) * 1 encoded DER was what was expected (success) */ static int do_encode(EXPECTED *input, const unsigned char *expected, size_t expected_len, const TEST_PACKAGE *package) { unsigned char *data = NULL; int len; int ret = 0; len = package->i2d(input, &data); if (len < 0) return -1; if ((size_t)len != expected_len || memcmp(data, expected, expected_len) != 0) { if (input->success == 0) { ret = 1; ERR_clear_error(); } else { ret = 0; } } else { ret = 1; } OPENSSL_free(data); return ret; } /* Do an encode/decode round trip */ static int do_enc_dec(EXPECTED *bytes, long nbytes, const TEST_PACKAGE *package) { unsigned char *data = NULL; int len; int ret = 0; void *p = bytes; len = package->i2d(p, &data); if (len < 0) return -1; ret = do_decode(data, len, bytes, nbytes, package); OPENSSL_free(data); return ret; } static size_t der_encode_length(size_t len, unsigned char **pp) { size_t lenbytes; OPENSSL_assert(len < 0x8000); if (len > 255) lenbytes = 3; else if (len > 127) lenbytes = 2; else lenbytes = 1; if (pp != NULL) { if (lenbytes == 1) { *(*pp)++ = len; } else { *(*pp)++ = lenbytes - 1; if (lenbytes == 2) { *(*pp)++ = 0x80 | len; } else { *(*pp)++ = 0x80 | (len >> 8); *(*pp)++ = len & 0xff; } } } return lenbytes; } static size_t make_custom_der(const TEST_CUSTOM_DATA *custom_data, unsigned char **encoding, int explicit_default) { size_t firstbytes, secondbytes = 0, secondbytesinner = 0, seqbytes; const unsigned char t_true[] = { V_ASN1_BOOLEAN, 0x01, 0xff }; unsigned char *p = NULL; size_t i; /* * The first item is just an INTEGER tag, INTEGER length and INTEGER content */ firstbytes = 1 + der_encode_length(custom_data->nbytes1, NULL) + custom_data->nbytes1; for (i = custom_data->nbytes2; i > 0; i--) { if (custom_data->bytes2[i - 1] !=

) break; } if (explicit_default || i > 0) { /* * The second item is an explicit tag, content length, INTEGER tag, * INTEGER length, INTEGER bytes */ secondbytesinner = 1 + der_encode_length(custom_data->nbytes2, NULL) + custom_data->nbytes2; secondbytes = 1 + der_encode_length(secondbytesinner, NULL) + secondbytesinner; } /* * The whole sequence is the sequence tag, content length, BOOLEAN true * (copied from t_true), the first (firstbytes) and second (secondbytes) * items */ seqbytes = 1 + der_encode_length(sizeof(t_true) + firstbytes + secondbytes, NULL) + sizeof(t_true) + firstbytes + secondbytes; *encoding = p = OPENSSL_malloc(seqbytes); if (*encoding == NULL) return 0; /* Sequence tag */ *p++ = 0x30; der_encode_length(sizeof(t_true) + firstbytes + secondbytes, &p); /* ASN1_BOOLEAN TRUE */ memcpy(p, t_true, sizeof(t_true)); /* Marks decoding success */ p += sizeof(t_true); /* First INTEGER item (non-optional) */ *p++ = V_ASN1_INTEGER; der_encode_length(custom_data->nbytes1, &p); memcpy(p, custom_data->bytes1, custom_data->nbytes1); p += custom_data->nbytes1; if (secondbytes > 0) { /* Second INTEGER item (optional) */ /* Start with the explicit optional tag */ *p++ = 0xa0; der_encode_length(secondbytesinner, &p); *p++ = V_ASN1_INTEGER; der_encode_length(custom_data->nbytes2, &p); memcpy(p, custom_data->bytes2, custom_data->nbytes2); p += custom_data->nbytes2; } OPENSSL_assert(seqbytes == (size_t)(p - *encoding)); return seqbytes; } /* Attempt to decode a custom encoding of the test structure */ static int do_decode_custom(const TEST_CUSTOM_DATA *custom_data, const EXPECTED *expected, size_t expected_size, const TEST_PACKAGE *package) { unsigned char *encoding = NULL; /* * We force the defaults to be explicitly encoded to make sure we test * for defaults that shouldn

Failed custom encode round trip %u of %s

Custom encode round trip %u of %s mismatch

do_encode_custom() return unknown value

Failed custom decode round trip %u of %s

Custom decode round trip %u of %s mismatch

do_decode_custom() return unknown value

Failed encode/decode round trip %u of %s

Encode/decode round trip %u of %s mismatch

do_enc_dec() return unknown value

Printing of %s failed

0x00

0x01

0xff

0xff,

0x00

0x7f,

0xff,

0xff,

0xff

0x01,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x00,

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x7f,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x00,

0x7f,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0xff,

0x80,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x01,

0xff,

0xff,

0xff,

0xff

0x00,

0x80,

0x00,

0x00,

0x00

0xfe

0x7f,

0xff,

0xff,

0xfe

0x00,

0x7f,

0xff,

0xff,

0xfe

0x80,

0x00,

0x00,

0x00

0xff,

0x80,

0x00,

0x00,

0x00

0xff,

0xff,

0xff,

0xff,

0x10200000L

0xff,

0xff,

0x7fffffff

0xff,

0xff,

0x7fffffff

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x80000000,

0x80000000),

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x1ffffffff,

0x1ffffffff),

0x80000000,

0x80000000),

0x8000);

0x80

0x80

0xff;

0x01,

0xff

0x30;

0xa0;

0x10200000L

0x10200000L

