Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Time tests for the asn1 module

TIME string value

GENERALIZED OR UTC

expected type after set/set_string_gmt

check result

expected time_

compariston to baseline result

convertion result

Bad time

Epoch begins

ditto

Max 32bit time_t

Just before 2038

Bad UTC time

Match baseline

In various flavors

ASSUMES SIGNED TIME_T

ASSUMES SIGNED TIME_T

A baseline time to compare to

else cannot simply convert GENERALIZEDTIME to UTCTIME

On platforms where |time_t| is an unsigned integer, t will be a positive number. We check if we're on a platform with a signed |time_t| with '!(t > 0)' because some compilers are picky if you do 't < 0', or even 't <= 0' if |t| is unsigned.

On some platforms, |time_t| is signed, but a negative value is an error, and using it with gmtime() or localtime() generates a NULL. If that is the case, we can't perform tests on negative values.

www.openssl.org/source/license.html

License

testutil.h

internal/nelem.h

0

ABCD

0ABCD

1-700101000000Z

`9700101000000Z

19700101000000Z

A00101000000Z

A9700101000000Z

1A700101000000Z

19A00101000000Z

197A0101000000Z

1970A101000000Z

19700A01000000Z

197001A1000000Z

1970010A000000Z

19700101A00000Z

197001010A0000Z

1970010100A000Z

19700101000A00Z

197001010000A0Z

1970010100000AZ

700101000000X

19700101000000X

19700101000000Z

700101000000Z

20380119031407Z

380119031407Z

20371231235959Z

20371231235959Z

371231235959Z

19701006121456Z

701006121456Z

19991231000000Z

199912310000Z

991231000000Z

9912310000Z

9912310000+0000

199912310000+0000

9912310000-0000

199912310000-0000

199912310100+0100

199912302300-0100

199912302300-A000

199912302300-0A00

9912310100+0100

9912302300-0100

19011213204552Z

691006121456Z

19691006121456Z

20380119031408Z

20380119031409Z

380119031408Z

20500101120000Z

19011213204551Z

19000101120000Z

19991231000000Z

ASN1_TIME_check(%s) unexpected result

ASN1_TIME_cmp_time_t(%s vs %ld) compare failed

ASN1_TIME_diff(%s) to self failed

ASN1_TIME_diff(%s) to self not equal

ASN1_TIME_diff(%s) to baseline failed

ASN1_TIME_diff(%s) to baseline bad comparison

ASN1_TIME_cmp_time_t(%s) to baseline bad comparison

ASN1_TIME_set(%ld) failed

ASN1_TIME_set(%ld) compare failed (%s->%s)

ASN1_TIME_set(%ld) unexpected type

ASN1_TIME_set() = %*s

ASN1_TIME_new() failed

ASN1_TIME_set_string_gmt(%s) failed

ASN1_TIME_normalize(%s) failed

ASN1_TIME_set_string_gmt(%s) unexpected type

ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string_gmt() failed

ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string_gnt() to baseline bad comparison

ASN1_TIME_set_string_gmt() = %*s

ASN1_TIME_new() failed

ASN1_TIME_set_string(%s) failed

ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string() failed

ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string() to baseline bad comparison

ASN1_TIME_set_string() = %*s

ASN1_TIME_to_generalizedtime(%s) failed

ASN1_TIME_to_generalizedtime(%s) should have failed

ASN1_TIME_to_generalizedtime(%s->%s) bad result

atime=%s

re on a platform with a signed |time_t| with

* because some compilers are picky if you do

, or even

* if |t| is unsigned. */ time_t t = -1; /* * On some platforms, |time_t| is signed, but a negative value is an * error, and using it with gmtime() or localtime() generates a NULL. * If that is the case, we can

Adding negative-sign time_t tests

Adding 64-bit time_t tests

Adding negative-sign 64-bit time_t tests

0X",

0X",

0x7FFFFFFF,

0x7FFFFFFF,

0x80000000,

0x80000001,

0x80000000,

