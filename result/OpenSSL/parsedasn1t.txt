Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

ASN1 template defines, structures and functions

Macro to obtain ASN1_ADB pointer from a type (only used internally)

Macros for start and end of ASN1_ITEM definition

Macro to obtain ASN1_ADB pointer from a type (only used internally)

Macros for start and end of ASN1_ITEM definition

Macros to aid ASN1 template writing

This is a ASN1 type which just embeds a template

This pair helps declare a SEQUENCE. We can do: ASN1_SEQUENCE(stname) = { ... SEQUENCE components ... } ASN1_SEQUENCE_END(stname) This will produce an ASN1_ITEM called stname_it for a structure called stname. If you want the same structure but a different name then use: ASN1_SEQUENCE(itname) = { ... SEQUENCE components ... } ASN1_SEQUENCE_END_name(stname, itname) This will create an item called itname_it using a structure called stname.

This pair helps declare a CHOICE type. We can do: ASN1_CHOICE(chname) = { ... CHOICE options ... ASN1_CHOICE_END(chname) This will produce an ASN1_ITEM called chname_it for a structure called chname. The structure definition must look like this: typedef struct { int type; union { ASN1_SOMETHING opt1; ASN1_SOMEOTHER opt2; } value; } chname; the name of the selector must be 'type'. to use an alternative selector name use the ASN1_CHOICE_END_selector() version.

This helps with the template wrapper form of ASN1_ITEM

These help with SEQUENCE or CHOICE components

used to declare other types

implicit and explicit helper macros

Any defined by macros: the field used is in the table itself

Plain simple type

Embedded simple type

OPTIONAL simple type

IMPLICIT tagged simple type

IMPLICIT tagged OPTIONAL simple type

Same as above but EXPLICIT

SEQUENCE OF type

OPTIONAL SEQUENCE OF

Same as above but for SET OF

Finally compound types of SEQUENCE, SET, IMPLICIT, EXPLICIT and OPTIONAL

EXPLICIT using indefinite length constructed form

EXPLICIT OPTIONAL using indefinite length constructed form

Macros for the ASN1_ADB structure

This is the ASN1 template structure that defines a wrapper round the actual type. It determines the actual position of the field in the value structure, various flags such as OPTIONAL and the field name.

Various flags

tag, not used if no tagging

Offset of this field in structure

Field name

Relevant ASN1_ITEM or ASN1_ADB

Macro to extract ASN1_ITEM and ASN1_ADB pointer from ASN1_TEMPLATE

Various flags

Offset of selector field

Application callback

Table of possible types

Number of entries in tbl

Type to use if no match

Type to use if selector is NULL

NID for an object or value for an int

item for this value

template flags

Field is optional

Field is a SET OF

Field is a SEQUENCE OF

Special case: this refers to a SET OF that will be sorted into DER order when encoded and the corresponding STACK will be modified to match the new order.

Mask for SET OF or SEQUENCE OF

These flags mean the tag should be taken from the tag field. If EXPLICIT then the underlying type is used for the inner tag.

IMPLICIT tagging

EXPLICIT tagging, inner tag from underlying type

context specific IMPLICIT

context specific EXPLICIT

If tagging is in force these determine the type of tag to use. Otherwise the tag is determined by the underlying type. These values reflect the actual octet format.

Universal tag

Application tag

Context specific tag

Private tag

These are for ANY DEFINED BY type. In this case the 'item' field points to an ASN1_ADB structure which contains a table of values to decode the relevant type

This flag when present in a SEQUENCE OF, SET OF or EXPLICIT causes indefinite length constructed encoding to be used if required.

Field is embedded and not a pointer

This is the actual ASN1 item itself

The item type, primitive, SEQUENCE, CHOICE or extern

underlying type

If SEQUENCE or CHOICE this contains the contents

Number of templates if SEQUENCE or CHOICE

functions that handle this type

Structure size (usually)

Structure name

These are values for the itype field and determine how the type is interpreted. For PRIMITIVE types the underlying type determines the behaviour if items is NULL. Otherwise templates must contain a single template and the type is treated in the same way as the type specified in the template. For SEQUENCE types the templates field points to the members, the size field is the structure size. For CHOICE types the templates field points to each possible member (typically a union) and the 'size' field is the offset of the selector. The 'funcs' field is used for application specific functions. The EXTERN type uses a new style d2i/i2d. The new style should be used where possible because it avoids things like the d2i IMPLICIT hack. MSTRING is a multiple string type, it is used for a CHOICE of character strings where the actual strings all occupy an ASN1_STRING structure. In this case the 'utype' field has a special meaning, it is used as a mask of acceptable types using the B_ASN1 constants. NDEF_SEQUENCE is the same as SEQUENCE except that it will use indefinite length constructed encoding if requested.

Cache for ASN1 tag and length, so we don't keep re-reading it for things like CHOICE

Values below are valid

return value

length

class value

class value

header length

Typedefs for ASN1 function pointers

This is the ASN1_AUX structure: it handles various miscellaneous requirements. For example the use of reference counts and an informational callback. The "informational callback" is called at various points during the ASN1 encoding and decoding. It can be used to provide minor customisation of the structures used. This is most useful where the supplied routines almost do the right thing but need some extra help at a few points. If the callback returns zero then it is assumed a fatal error has occurred and the main operation should be abandoned. If major changes in the default behaviour are required then an external type is more appropriate.

Offset of reference value

Lock type to use

Offset of ASN1_ENCODING structure

For print related callbacks exarg points to this structure

For streaming related callbacks exarg points to this structure

BIO to stream through

BIO with filters appended

Streaming I/O boundary

Flags in ASN1_AUX

Use a reference count

Save the encoding of structure (useful for signatures)

The Sequence length is invalid

operation values for asn1_cb

Macro to implement a primitive type

Macro to implement a multi string type

Macro to implement standard functions in terms of ASN1_ITEM structures

This includes evil casts to remove const: they will go away when full ASN1 constification is done.

external definitions for primitive types

LONG and ZLONG are strongly discouraged for use as stored data, as the underlying C type (long) differs in size depending on the architecture. They are designed with 32-bit longs in mind.

Functions used internally by the ASN1 code

www.openssl.org/source/license.html

License

C

type

item

size

funcs

utype

informational callback

0x1)

0x1

0x2

0x3

0x3

0x1

0x2

0x3

0x0<<6)

0x1<<6)

0x2<<6)

0x3<<6)

0x3<<6)

0x3<<8)

0x1<<8)

0x1<<9)

0x1<<11)

0x1

0x0

0x1

0x2

0x4

0x5

0x6

0x10200000L

