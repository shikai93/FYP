Copyright 2008-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Generalised MIME like utilities for streaming ASN1. Although many have a PKCS7/CMS like flavour others are more general purpose.

MIME format structures Note that all are translated to lower case apart from parameter values. Quotes are stripped off

Param name e.g. "micalg"

Param value e.g. "sha1"

Name of line e.g. "content-type"

Value of line e.g. "text/plain"

Zero or more parameters

x

Output an ASN1 structure in BER format streaming if necessary

If streaming create stream BIO and copy all content through it

Free up successive BIOs until we hit the old output BIO

else just write out ASN1 structure which will have all content stored internally

Base 64 read and write of ASN1 structure

prepend the b64 BIO so all data is base64 encoded.

Streaming ASN1 PEM write

Generate the MIME "micalg" parameter from RFC3851, RFC4490

SMIME sender

We want multipart/signed

Generate a random boundary

Now write out the first part

Headers for signature

Determine smime-type header

MIME headers

Handle output of ASN1 data

If data is not detached or resigning then the output BIO is already set up to finalise when it is written through.

Let ASN1 code prepend any needed BIOs

Copy data across, passing through filter BIOs for processing

Finalize structure

Now remove any digests prepended to the BIO

SMIME reader: handle multipart/signed and opaque signing. in multipart case the content is placed in a memory BIO pointed to by "bcont". In opaque this is set to NULL

Handle multipart/signed

Split into two parts

Parse the signature piece

Get content type

Read in ASN1

OK, if not multipart/signed try opaque signature

Copy text from one BIO to another making the output CRLF at EOL

Buffer output so we don't write one line at a time. This is useful when streaming as we don't end up with one OCTET STRING per line.

Not EOF: write out all CRLF

Strip off headers if they are text/plain

Split a multipart/XXX message body into component parts: result is canonical parts in a STACK of bios

Strip CR+LF from linebuf

This is the big one: parse MIME header lines up to message body

If whitespace at line start then continuation line

Go through all characters

State machine to handle MIME headers if this looks horrible that's because it is

Blank line means end of headers

Strip a parameter of whitespace from start of param

Look for first non white space or quote

Next char is start of string if non null

Else null string

As above but strip from end of string : maybe should handle brackets?

Look for first non white space or quote

Parameter values are case sensitive so leave as is

Find a header with a given name (if possible)

Check for a multipart boundary. Returns: 0 : no boundary 1 : part boundary 2 : final boundary

Quickly eliminate if line length too short

Check for part boundary

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

internal/evp_int.h

internal/bio.h

asn1_locl.h

micalg

sha1

content-type

text/plain

-----BEGIN %s-----\n

-----END %s-----\n

micalg

,

sha1

md5

sha-256

sha-384

sha-512

gostr3411-94

unknown

smime.p7m

application/x-pkcs7-

application/pkcs7-

\r\n

\n

0

A

MIME-Version: 1.0%s

Content-Type: multipart/signed;

protocol=\"%ssignature\";

micalg=\"

\"; boundary=\"----%s\"%s%s

This is an S/MIME signed message%s%s

------%s%s

%s------%s%s

Content-Type: %ssignature;

name=\"smime.p7s\"%s

Content-Transfer-Encoding: base64%s

Content-Disposition: attachment;

filename=\"smime.p7s\"%s%s

%s------%s--%s%s

enveloped-data

signed-receipt

signed-data

certs-only

compressed-data

smime.p7z

MIME-Version: 1.0%s

Content-Disposition: attachment;

filename=\"%s\"%s

Content-Type: %smime;

smime-type=%s;

name=\"%s\"%s

Content-Transfer-Encoding: base64%s%s

%s

bcont

content-type

multipart/signed

boundary

content-type

application/x-pkcs7-signature

application/pkcs7-signature

type:

application/x-pkcs7-mime

application/pkcs7-mime

type:

t write one line at a time. This is useful * when streaming as we don

Content-Type: text/plain\r\n\r\n

\r\n

\r\n

\r\n

content-type

text/plain

type:

\r\n

\r

\n

s because it *is* */ switch (state) { case MIME_START: if (c ==

) { state = MIME_TYPE; *p = 0; ntmp = strip_ends(q); q = p + 1; } break; case MIME_TYPE: if (c ==

) { mime_debug("Found End Value\n"); *p = 0; new_hdr = mime_hdr_new(ntmp, strip_ends(q)); if (new_hdr == NULL) goto err; if (!sk_MIME_HEADER_push(headers, new_hdr)) goto err; mhdr = new_hdr; new_hdr = NULL; ntmp = NULL; q = p + 1; state = MIME_NAME; } else if (c ==

) { save_state = state; state = MIME_COMMENT; } break; case MIME_COMMENT: if (c ==

) { state = save_state; } break; case MIME_NAME: if (c ==

) { state = MIME_VALUE; *p = 0; ntmp = strip_ends(q); q = p + 1; } break; case MIME_VALUE: if (c ==

) { state = MIME_NAME; *p = 0; mime_hdr_addparam(mhdr, ntmp, strip_ends(q)); ntmp = NULL; q = p + 1; } else if (c ==

') { mime_debug(

); state = MIME_QUOTE; } else if (c == '(') { save_state = state; state = MIME_COMMENT; } break; case MIME_QUOTE: if (c == '

) { mime_debug("Found Match Quote\n"); state = MIME_VALUE; } break; } } if (state == MIME_TYPE) { new_hdr = mime_hdr_new(ntmp, strip_ends(q)); if (new_hdr == NULL) goto err; if (!sk_MIME_HEADER_push(headers, new_hdr)) goto err; mhdr = new_hdr; new_hdr = NULL; } else if (state == MIME_VALUE) mime_hdr_addparam(mhdr, ntmp, strip_ends(q)); if (p == linebuf) break; /* Blank line means end of headers */ } return headers; err: mime_hdr_free(new_hdr); sk_MIME_HEADER_pop_free(headers, mime_hdr_free); return NULL; } static char *strip_ends(char *name) { return strip_end(strip_start(name)); } /* Strip a parameter of whitespace from start of param */ static char *strip_start(char *name) { char *p, c; /* Look for first non white space or quote */ for (p = name; (c = *p); p++) { if (c ==

') { /* Next char is start of string if non null */ if (p[1]) return p + 1; /* Else null string */ return NULL; } if (!ossl_isspace(c)) return p; } return NULL; } /* As above but strip from end of string : maybe should handle brackets? */ static char *strip_end(char *name) { char *p, c; if (!name) return NULL; /* Look for first non white space or quote */ for (p = name + strlen(name) - 1; p >= name; p--) { c = *p; if (c == '

) { if (p - 1 == name) return NULL; *p = 0; return name; } if (ossl_isspace(c)) *p = 0; else return name; } return NULL; } static MIME_HEADER *mime_hdr_new(const char *name, const char *value) { MIME_HEADER *mhdr = NULL; char *tmpname = NULL, *tmpval = NULL, *p; if (name) { if ((tmpname = OPENSSL_strdup(name)) == NULL) return NULL; for (p = tmpname; *p; p++) *p = ossl_tolower(*p); } if (value) { if ((tmpval = OPENSSL_strdup(value)) == NULL) goto err; for (p = tmpval; *p; p++) *p = ossl_tolower(*p); } mhdr = OPENSSL_malloc(sizeof(*mhdr)); if (mhdr == NULL) goto err; mhdr->name = tmpname; mhdr->value = tmpval; if ((mhdr->params = sk_MIME_PARAM_new(mime_param_cmp)) == NULL) goto err; return mhdr; err: OPENSSL_free(tmpname); OPENSSL_free(tmpval); OPENSSL_free(mhdr); return NULL; } static int mime_hdr_addparam(MIME_HEADER *mhdr, const char *name, const char *value) { char *tmpname = NULL, *tmpval = NULL, *p; MIME_PARAM *mparam = NULL; if (name) { tmpname = OPENSSL_strdup(name); if (!tmpname) goto err; for (p = tmpname; *p; p++) *p = ossl_tolower(*p); } if (value) { tmpval = OPENSSL_strdup(value); if (!tmpval) goto err; } /* Parameter values are case sensitive so leave as is */ mparam = OPENSSL_malloc(sizeof(*mparam)); if (mparam == NULL) goto err; mparam->param_name = tmpname; mparam->param_value = tmpval; if (!sk_MIME_PARAM_push(mhdr->params, mparam)) goto err; return 1; err: OPENSSL_free(tmpname); OPENSSL_free(tmpval); OPENSSL_free(mparam); return 0; } static int mime_hdr_cmp(const MIME_HEADER *const *a, const MIME_HEADER *const *b) { if (!(*a)->name || !(*b)->name) return ! !(*a)->name - ! !(*b)->name; return (strcmp((*a)->name, (*b)->name)); } static int mime_param_cmp(const MIME_PARAM *const *a, const MIME_PARAM *const *b) { if (!(*a)->param_name || !(*b)->param_name) return ! !(*a)->param_name - ! !(*b)->param_name; return (strcmp((*a)->param_name, (*b)->param_name)); } /* Find a header with a given name (if possible) */ static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, const char *name) { MIME_HEADER htmp; int idx; htmp.name = (char *)name; htmp.value = NULL; htmp.params = NULL; idx = sk_MIME_HEADER_find(hdrs, &htmp); if (idx < 0) return NULL; return sk_MIME_HEADER_value(hdrs, idx); } static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, const char *name) { MIME_PARAM param; int idx; param.param_name = (char *)name; param.param_value = NULL; idx = sk_MIME_PARAM_find(hdr->params, &param); if (idx < 0) return NULL; return sk_MIME_PARAM_value(hdr->params, idx); } static void mime_hdr_free(MIME_HEADER *hdr) { if (hdr == NULL) return; OPENSSL_free(hdr->name); OPENSSL_free(hdr->value); if (hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free); OPENSSL_free(hdr); } static void mime_param_free(MIME_PARAM *param) { OPENSSL_free(param->param_name); OPENSSL_free(param->param_value); OPENSSL_free(param); } /*- * Check for a multipart boundary. Returns: * 0 : no boundary * 1 : part boundary * 2 : final boundary */ static int mime_bound_check(char *line, int linelen, const char *bound, int blen) { if (linelen == -1) linelen = strlen(line); if (blen == -1) blen = strlen(bound); /* Quickly eliminate if line length too short */ if (blen + 2 > linelen) return 0; /* Check for part boundary */ if ((strncmp(line, "--", 2) == 0) && strncmp(line + 2, bound, blen) == 0) { if (strncmp(line + blen + 2, "--", 2) == 0) return 2; else return 1; } return 0; } static int strip_eol(char *linebuf, int *plen, int flags) { int len = *plen; char *p, c; int is_eol = 0; p = linebuf + len - 1; for (p = linebuf + len - 1; len > 0; len--, p--) { c = *p; if (c ==

) is_eol = 1; else if (is_eol && flags & SMIME_ASCIICRLF && c < 33) continue; else if (c !=

0xf;

