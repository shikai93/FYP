Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This must be the first #include file

Only try and cleanup if it hasn't been marked deleted

Always free the fd_lookup_st

This one has been marked deleted so do nothing

This one has been marked deleted so do nothing

We ignore fds that have been marked as both added and deleted

This one has been marked deleted already so do nothing

If fd has just been added, remove it from the list

It is responsibility of the caller to cleanup before calling ASYNC_WAIT_CTX_clear_fd

Mark it as deleted. We don't call cleanup if explicitly asked to clear an fd. We assume the caller is going to do that (if appropriate).

www.openssl.org/source/license.html

License

async_locl.h

t been marked deleted */ if (curr->cleanup != NULL) curr->cleanup(ctx, curr->key, curr->fd, curr->custom_data); } /* Always free the fd_lookup_st */ next = curr->next; OPENSSL_free(curr); curr = next; } OPENSSL_free(ctx); } int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD fd, void *custom_data, void (*cleanup)(ASYNC_WAIT_CTX *, const void *, OSSL_ASYNC_FD, void *)) { struct fd_lookup_st *fdlookup; fdlookup = OPENSSL_zalloc(sizeof *fdlookup); if (fdlookup == NULL) return 0; fdlookup->key = key; fdlookup->fd = fd; fdlookup->custom_data = custom_data; fdlookup->cleanup = cleanup; fdlookup->add = 1; fdlookup->next = ctx->fds; ctx->fds = fdlookup; ctx->numadd++; return 1; } int ASYNC_WAIT_CTX_get_fd(ASYNC_WAIT_CTX *ctx, const void *key, OSSL_ASYNC_FD *fd, void **custom_data) { struct fd_lookup_st *curr; curr = ctx->fds; while (curr != NULL) { if (curr->del) { /* This one has been marked deleted so do nothing */ curr = curr->next; continue; } if (curr->key == key) { *fd = curr->fd; *custom_data = curr->custom_data; return 1; } curr = curr->next; } return 0; } int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *fd, size_t *numfds) { struct fd_lookup_st *curr; curr = ctx->fds; *numfds = 0; while (curr != NULL) { if (curr->del) { /* This one has been marked deleted so do nothing */ curr = curr->next; continue; } if (fd != NULL) { *fd = curr->fd; fd++; } (*numfds)++; curr = curr->next; } return 1; } int ASYNC_WAIT_CTX_get_changed_fds(ASYNC_WAIT_CTX *ctx, OSSL_ASYNC_FD *addfd, size_t *numaddfds, OSSL_ASYNC_FD *delfd, size_t *numdelfds) { struct fd_lookup_st *curr; *numaddfds = ctx->numadd; *numdelfds = ctx->numdel; if (addfd == NULL && delfd == NULL) return 1; curr = ctx->fds; while (curr != NULL) { /* We ignore fds that have been marked as both added and deleted */ if (curr->del && !curr->add && (delfd != NULL)) { *delfd = curr->fd; delfd++; } if (curr->add && !curr->del && (addfd != NULL)) { *addfd = curr->fd; addfd++; } curr = curr->next; } return 1; } int ASYNC_WAIT_CTX_clear_fd(ASYNC_WAIT_CTX *ctx, const void *key) { struct fd_lookup_st *curr, *prev; curr = ctx->fds; prev = NULL; while (curr != NULL) { if (curr->del == 1) { /* This one has been marked deleted already so do nothing */ curr = curr->next; continue; } if (curr->key == key) { /* If fd has just been added, remove it from the list */ if (curr->add == 1) { if (ctx->fds == curr) { ctx->fds = curr->next; } else { prev->next = curr->next; } /* It is responsibility of the caller to cleanup before calling * ASYNC_WAIT_CTX_clear_fd */ OPENSSL_free(curr); ctx->numadd--; return 1; } /* * Mark it as deleted. We don

