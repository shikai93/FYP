Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL licenses, (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.openssl.org/source/license.html or in the file LICENSE in the source distribution.

Should we fragment records or not? 0 = no, !0 = ye

Choose a sufficiently large type likely to be unused for this custom BIO

Pretend we wrote out the record header

Create a new one byte long record for each byte in the record in the input buffer

Content type

Version hi

Version lo

Length hi

Length lo

Data

We can't fragment anything after the ServerHello (or CCS <= TLS1.2), otherwise we get a bad record MAC TODO(TLS1.3): Change TLS1_3_VERSION_DRAFT to TLS1_3_VERSION before release

Write any data we have left after fragmenting

We don't support this - not needed anyway

We do 2 test runs. The first time around we just do a normal handshake with lots of async io going on. The second time around we also break up all records so that the content is only one byte length (up until the CCS)

BIOs get freed on error

Send and receive some test data. Do the whole thing twice to ensure we hit at least one async event in both reading and writing

Write some test data. It should never take more than 2 attempts (the first one might be a retryable fail).

Now read the test data. It may take more attempts here because it could fail once for each byte read, including all overhead bytes from the record header/padding etc.

Also frees the BIOs

www.openssl.org/source/license.html

License

../ssl/packet_locl.h

ssltestlib.h

testutil.h

Async filter

t fragment anything after the ServerHello (or CCS <= * TLS1.2), otherwise we get a bad record MAC * TODO(TLS1.3): Change TLS1_3_VERSION_DRAFT to TLS1_3_VERSION * before release */ if (contenttype == SSL3_RT_CHANGE_CIPHER_SPEC || (negversion == TLS1_3_VERSION_DRAFT && msgtype == SSL3_MT_SERVER_HELLO)) { fragment = 0; break; } } } /* Write any data we have left after fragmenting */ ret = 0; if ((int)written < inl) { ret = BIO_write(next, in + written, inl - written); } if (ret <= 0 && BIO_should_write(next)) BIO_set_retry_write(bio); else ret += written; } else { ctrs->wctr++; BIO_set_retry_write(bio); } return ret; } static long async_ctrl(BIO *bio, int cmd, long num, void *ptr) { long ret; BIO *next = BIO_next(bio); if (next == NULL) return 0; switch (cmd) { case BIO_CTRL_DUP: ret = 0L; break; default: ret = BIO_ctrl(next, cmd, num, ptr); break; } return ret; } static int async_gets(BIO *bio, char *buf, int size) { /* We don

Test data

0x80

