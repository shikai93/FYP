Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

don't generate another error code here

Because only AF_INET addresses will reach this far, we can assert that l should be 4

don't generate another error code here

Note: under Windows the third parameter is of type (char ) whereas under other systems it is (void ) if you don't have a cast it will choke the compiler: if you do have a cast then you can either go for (char ) or (void ).

Caching gethostbyname() results forever is wrong, so we have to let the true gethostbyname() worry about this

Not making wsa_state available to the rest of the code is formally wrong. But the structures we use are [believed to be] invariable among Winsock DLLs, while API availability is [expected to be] probed at run-time with DSO_global_lookup.

OPENSSL_SYS_WINDOWS

don't make sock_init() call exit()

2011-02-18 SMS. VMS ioctl() can't tolerate a 64-bit "void arg", but we observe that all the consumers pass in an "unsigned long ", so we arrange a local copy with a short pointer, and use that, instead.

__INITIAL_POINTER_SIZE == 64

__INITIAL_POINTER_SIZE == 64 [else]

defined(OPENSSL_SYS_VMS)

defined(OPENSSL_SYS_VMS) [else]

__DJGPP__

make sure this call always pushes an error level; BIO_socket_ioctl() does so, so we do too.

BSD4.x

BSD4.x

make sure this call always pushes an error level; BIO_socket_ioctl() does so, so we do too.

www.openssl.org/source/license.html

License

bio_lcl.h

t generate another error code here */ if (BIO_lookup(str, NULL, BIO_LOOKUP_CLIENT, AF_INET, SOCK_STREAM, &res)) { size_t l; if (BIO_ADDRINFO_family(res) != AF_INET) { BIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET); } else if (BIO_ADDR_rawaddress(BIO_ADDRINFO_address(res), NULL, &l)) { /* * Because only AF_INET addresses will reach this far, we can assert * that l should be 4 */ if (ossl_assert(l == 4)) ret = BIO_ADDR_rawaddress(BIO_ADDRINFO_address(res), ip, &l); } BIO_ADDRINFO_free(res); } else { ERR_add_error_data(2, "host=", str); } return ret; } int BIO_get_port(const char *str, unsigned short *port_ptr) { BIO_ADDRINFO *res = NULL; int ret = 0; if (str == NULL) { BIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_DEFINED); return (0); } if (BIO_sock_init() != 1) return 0; /* don

host=

t have a cast it will * choke the compiler: if you do have a cast then you can either go for * (char *) or (void *). */ i = getsockopt(sock, SOL_SOCKET, SO_ERROR, (void *)&j, &size); if (i < 0) return (get_last_socket_error()); else return (j); } # if OPENSSL_API_COMPAT < 0x10100000L struct hostent *BIO_gethostbyname(const char *name) { /* * Caching gethostbyname() results forever is wrong, so we have to let * the true gethostbyname() worry about this */ # if (defined(NETWARE_BSDSOCK) && !defined(__NOVELL_LIBC__)) return gethostbyname((char *)name); # else return gethostbyname(name); # endif } # endif int BIO_sock_init(void) { # ifdef OPENSSL_SYS_WINDOWS static struct WSAData wsa_state; if (!wsa_init_done) { int err; wsa_init_done = 1; memset(&wsa_state, 0, sizeof(wsa_state)); /* * Not making wsa_state available to the rest of the code is formally * wrong. But the structures we use are [believed to be] invariable * among Winsock DLLs, while API availability is [expected to be] * probed at run-time with DSO_global_lookup. */ if (WSAStartup(0x0202, &wsa_state) != 0) { err = WSAGetLastError(); SYSerr(SYS_F_WSASTARTUP, err); BIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP); return (-1); } } # endif /* OPENSSL_SYS_WINDOWS */ # ifdef WATT32 extern int _watt_do_exit; _watt_do_exit = 0; /* don

void *arg

unsigned long *

:

0x10100000L

0x10100000L

0x0202,

0x10100000L

