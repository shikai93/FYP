Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

TODO: Convert to new style write function

TODO: Convert to new style read function

If there is stuff left over, grab it

We may have done a partial read. try to do more. We have nothing in the buffer. If we get an error and have read some data, just return it and let them retry to get the error again. copy direct to parent address space

else

we are going to be doing some buffering

Lets re-read using ourselves :-)

add to buffer and return

else

stuff already in buffer, so add to it first, then flush

lets fill it up if we can

we now have a full buffer needing flushing

we only get here if the buffer has been flushed and we still have stuff to write

we now have inl bytes to write

copy the rest into the buffer since we have only a small amount left

if (ip == 1)

Ensure there's stuff in the input buffer

reserve space for a '\0'

read another chunk

www.openssl.org/source/license.html

License

bio_lcl.h

internal/cryptlib.h

buffer

\n

s stuff in the input buffer */ { char fake_buf[1]; (void)buffer_read(b, fake_buf, 0); } if (num > ctx->ibuf_len) num = ctx->ibuf_len; memcpy(ptr, &(ctx->ibuf[ctx->ibuf_off]), num); ret = num; break; default: if (b->next_bio == NULL) return (0); ret = BIO_ctrl(b->next_bio, cmd, num, ptr); break; } return (ret); malloc_error: BIOerr(BIO_F_BUFFER_CTRL, ERR_R_MALLOC_FAILURE); return (0); } static long buffer_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp) { long ret = 1; if (b->next_bio == NULL) return (0); switch (cmd) { default: ret = BIO_callback_ctrl(b->next_bio, cmd, fp); break; } return (ret); } static int buffer_gets(BIO *b, char *buf, int size) { BIO_F_BUFFER_CTX *ctx; int num = 0, i, flag; char *p; ctx = (BIO_F_BUFFER_CTX *)b->ptr; size--; /* reserve space for a

*/ BIO_clear_retry_flags(b); for (;;) { if (ctx->ibuf_len > 0) { p = &(ctx->ibuf[ctx->ibuf_off]); flag = 0; for (i = 0; (i < ctx->ibuf_len) && (i < size); i++) { *(buf++) = p[i]; if (p[i] ==

) { flag = 1; i++; break; } } num += i; size -= i; ctx->ibuf_len -= i; ctx->ibuf_off += i; if (flag || size == 0) { *buf =

; return (num); } } else { /* read another chunk */ i = BIO_read(b->next_bio, ctx->ibuf, ctx->ibuf_size); if (i <= 0) { BIO_copy_next_retry(b); *buf =

