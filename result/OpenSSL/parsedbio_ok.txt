Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

From: Arne Ansper <arne@cyber.ee> Why BIO_f_reliable? I wrote function which took BIO as argument, read data from it and processed it. Then I wanted to store the input file in encrypted form. OK I pushed BIO_f_cipher to the BIO stack and everything was OK. BUT if user types wrong password BIO_f_cipher outputs only garbage and my function crashes. Yes I can and I should fix my function, but BIO_f_cipher is easy way to add encryption support to many existing applications and it's hard to debug and fix them all. So I wanted another BIO which would catch the incorrect passwords and file damages which cause garbage on BIO_f_cipher's output. The easy way is to push the BIO_f_md and save the checksum at the end of the file. However there are several problems with this approach: 1) you must somehow separate checksum from actual data. 2) you need lot's of memory when reading the file, because you must read to the end of the file and verify the checksum before letting the application to read the data. BIO_f_reliable tries to solve both problems, so that you can read and write arbitrary long streams using only fixed amount of memory. BIO_f_reliable splits data stream into blocks. Each block is prefixed with it's length and suffixed with it's digest. So you need only several Kbytes of memory to buffer single block before verifying it's digest. BIO_f_reliable goes further and adds several important capabilities: 1) the digest of the block is computed over the whole stream -- so nobody can rearrange the blocks or remove or replace them. 2) to detect invalid passwords right at the start BIO_f_reliable adds special prefix to the stream. In order to avoid known plain-text attacks this prefix is generated as follows: ) digest is initialized with random seed instead of standardized one. ) same seed is written to output ) well-known text is then hashed and the output of the digest is also written to output. reader can now read the seed from stream, hash the same string and then compare the digest output. Bad things: BIO_f_reliable knows what's going on in EVP_Digest. I initially wrote and tested this code on x86 machine and wrote the digests out in machine-dependent order :( There are people using this code and I cannot change this easily without making existing data files unreadable.

<= 0 when finished

output block is ready

must process signature

TODO: Convert to new style write function

TODO: Convert to new style read function

ok_puts,

ok_gets,

copy clean bytes to output buffer

all clean bytes are out

copy start of the next block into proper place

output buffer full -- cancel

no clean bytes in buffer -- fill it

nothing new

no signature yet -- check if we got one

signature ok -- check if we got block

invalid block -- cancel

at this point all pending data has been written

More to read

More to read in buffer

More to read in buffer

do a final write

Finally flush the underlying BIO

FIXME: there's absolutely no guarantee this makes any sense at all, particularly now EVP_MD_CTX has been restructured.

always true

there might be parts from next block lurking around !

www.openssl.org/source/license.html

License

s hard to debug and fix them all. So I wanted another BIO which would catch the incorrect passwords and file damages which cause garbage on BIO_f_cipher

s of memory when reading the file, because you must read to the end of the file and verify the checksum before letting the application to read the data. BIO_f_reliable tries to solve both problems, so that you can read and write arbitrary long streams using only fixed amount of memory. BIO_f_reliable splits data stream into blocks. Each block is prefixed with it

s digest. So you need only several Kbytes of memory to buffer single block before verifying it

s going on in EVP_Digest. I initially wrote and tested this code on x86 machine and wrote the digests out in machine-dependent order :( There are people using this code and I cannot change this easily without making existing data files unreadable. */ #include <stdio.h> #include <errno.h> #include <assert.h> #include "internal/cryptlib.h" #include <openssl/buffer.h> #include "internal/bio.h" #include <openssl/evp.h> #include <openssl/rand.h> #include "internal/evp_int.h" static int ok_write(BIO *h, const char *buf, int num); static int ok_read(BIO *h, char *buf, int size); static long ok_ctrl(BIO *h, int cmd, long arg1, void *arg2); static int ok_new(BIO *h); static int ok_free(BIO *data); static long ok_callback_ctrl(BIO *h, int cmd, bio_info_cb *fp); static __owur int sig_out(BIO *b); static __owur int sig_in(BIO *b); static __owur int block_out(BIO *b); static __owur int block_in(BIO *b); #define OK_BLOCK_SIZE (1024*4) #define OK_BLOCK_BLOCK 4 #define IOBS (OK_BLOCK_SIZE+ OK_BLOCK_BLOCK+ 3*EVP_MAX_MD_SIZE) #define WELLKNOWN "The quick brown fox jumped over the lazy dog

typedef struct ok_struct { size_t buf_len; size_t buf_off; size_t buf_len_save; size_t buf_off_save; int cont; /* <= 0 when finished */ int finished; EVP_MD_CTX *md; int blockout; /* output block is ready */ int sigio; /* must process signature */ unsigned char buf[IOBS]; } BIO_OK_CTX; static const BIO_METHOD methods_ok = { BIO_TYPE_CIPHER,

