Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

maximum precomputation table size for variable sliding windows

this one works - simple but works

BN_FLG_CONSTTIME only supported by BN_mod_exp_mont()

For even modulus m = 2^km_odd, it might make sense to compute a^p mod m_odd and a^p mod 2^k separately (with Montgomery exponentiation for the odd part), using appropriate exponent reductions, and combine the results using the CRT. For now, we use Montgomery only if the modulus is odd; otherwise, exponentiation using the reciprocal-based quick remaindering algorithm is used. (Timing obtained with expspeed.c [computations a^p mod m where a, p, m are of the same length: 256, 512, 1024, 2048, 4096, 8192 bits], compared to the running time of the standard algorithm: BN_mod_exp_mont 33 .. 40 % [AMD K6-2, Linux, debug configuration] 55 .. 77 % [UltraSparc processor, but debug-solaris-sparcv8-gcc conf.] BN_mod_exp_recp 50 .. 70 % [AMD K6-2, Linux, debug configuration] 62 .. 118 % [UltraSparc, debug-solaris-sparcv8-gcc] On the Sparc, BN_mod_exp_recp was faster than BN_mod_exp_mont at 2048 and more bits, but at 512 and 1024 bits, it was slower even than the standard algorithm! "Real" timings [linux-elf, solaris-sparcv9-gcc configurations] should be obtained when the new Montgomery reduction code has been integrated into OpenSSL.)

Table of variables obtained from 'ctx'

BN_FLG_CONSTTIME only supported by BN_mod_exp_mont()

x0 mod 1 is still zero.

ignore sign of 'm'

1

2

This is used to avoid multiplication etc when there is only the value '1' in the buffer.

The 'value' of the window

The top bit of the window

The bottom bit of the window

We now have wstart on a 'set' bit, we now need to work out how bit a window to do. To do this we need to scan forward until the last set bit before the end of the window

wend is the size of the current window

add the 'bytes above'

wvalue will be an odd number < 2^window

move the 'window' down further

Table of variables obtained from 'ctx'

x0 mod 1 is still zero.

If this is not done, things will break in the montgomery part

1

2

This is used to avoid multiplication etc when there is only the value '1' in the buffer.

The 'value' of the window

The top bit of the window

The bottom bit of the window

by Shay Gueron's suggestion

borrow j

2^(topBN_BITS2) - m

Upper words will be zero if the corresponding words of 'm' were 0xfff[...], so decrement r->top accordingly.

We now have wstart on a 'set' bit, we now need to work out how bit a window to do. To do this we need to scan forward until the last set bit before the end of the window

wend is the size of the current window

add the 'bytes above'

wvalue will be an odd number < 2^window

move the 'window' down further

borrow j

borrow val[0]

BN_mod_exp_mont_consttime() stores the precomputed powers in a specific layout so that accessing any of these table values shows the same access pattern as far as cache lines are concerned. The following functions are used to transfer a BIGNUM from/to that table.

this works because 'buf' is explicitly zeroed

We declare table 'volatile' in order to discourage compiler from reordering loads from the table. Concern is that if reordered in specific manner loads might give away the information we are trying to conceal. Some would argue that compiler can reorder them anyway, but it can as well be argued that doing so would be violation of standard...

equivalent of idx / xstride

equivalent of idx % xstride

Given a pointer value, compute the next address that is a cache line multiple.

This variant of BN_mod_exp_mont() uses fixed windows and the special precomputation memory layout to limit data-dependency to a minimum to protect secret exponents (cf. the hyper-threading timing attacks pointed out by Colin Percival, http://www.daemonology.net/hyperthreading-considered-harmful/)

x0 mod 1 is still zero.

Allocate a montgomery context if it was not supplied by the caller. If this is not done, things will break in the montgomery part.

If the size of the operands allow it, perform the optimized RSAZ exponentiation. For further information see crypto/bn/rsaz_exp.c and accompanying assembly modules.

Get the window size to use with size of p.

~5% improvement for RSA2048 sign, and even for RSA4096

reserve space for mont->N.d[] copy

Allocate a buffer large enough to hold all of the pre-computed powers of am, am itself and tmp.

lay down tmp and am right after powers table

prepare a^0 in Montgomery domain

by Shay Gueron's suggestion

2^(topBN_BITS2) - m

prepare a^1 in Montgomery domain

multiple of 5, but less than 32

BN_to_montgomery can contaminate words above .top [in BN_DEBUG[_DEBUG] build]...

Calculate a^i = a^(i-1) a

switch to 64-bit domain

Scan the exponent one window at a time starting from the most significant bits.

retry once and fall back

back to 32-bit domain

This optimization uses ideas from http://eprint.iacr.org/2011/239, specifically optimization of cache-timing attack countermeasures and pre-computation optimization.

Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as 512-bit RSA is hardly relevant, we omit it to spare size...

BN_to_montgomery can contaminate words above .top [in BN_DEBUG[_DEBUG] build]...

copy mont->N.d[] to improve cache locality

Calculate a^i = a^(i-1) a

same as above, but uses squaring for 1/2 of operations

Scan the exponent one window at a time starting from the most significant bits.

non-zero ret means it's not error

If the window size is greater than 1, then calculate val[i=2..2^winsize-1]. Powers are computed as aa^(i-1) (even powers could instead be computed as (a^(i/2))^2 to use the slight performance advantage of sqr over mul).

Calculate a^i = a^(i-1) a

Scan the exponent one window at a time starting from the most significant bits.

The 'value' of the window

Scan the window, squaring the result as we go

Fetch the appropriate pre-computed value from the pre-buf

Multiply the result into the intermediate result

Convert the final result from montgomery to standard format

borrow am

BN_ucmp(r, (m)) < 0 ? 1

BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is probably more overhead than always using BN_mod (which uses BN_copy if a similar test returns true).

We can use BN_mod and do not need BN_nnmod because our accumulator is never negative (the result of BN_mod does not depend on the sign of the modulus).

BN_FLG_CONSTTIME only supported by BN_mod_exp_mont()

make sure that 'a' is reduced

x0 mod 1 is still zero.

except for Montgomery factor

bits-1 >= 0

The result is accumulated in the product rw.

bit 'bits-1' of 'p' is always set

First, square rw.

overflow

Second, multiply rw by 'a' if exponent bit is set.

overflow

Finally, set r:=rw.

can happen only if a == 1

The old fallback, simple version :-)

Table of variables obtained from 'ctx'

BN_FLG_CONSTTIME only supported by BN_mod_exp_mont()

x0 mod 1 is still zero.

1

2

This is used to avoid multiplication etc when there is only the value '1' in the buffer.

The 'value' of the window

The top bit of the window

The bottom bit of the window

We now have wstart on a 'set' bit, we now need to work out how bit a window to do. To do this we need to scan forward until the last set bit before the end of the window

wend is the size of the current window

add the 'bytes above'

wvalue will be an odd number < 2^window

move the 'window' down further

www.openssl.org/source/license.html

www.daemonology.net/hyperthreading-considered-harmful/)

eprint.iacr.org/2011/239,

License

internal/cryptlib.h

internal/constant_time_locl.h

bn_lcl.h

rsaz_exp.h

sparc_arch.h

Real

ctx

m

1

value

set

bytes above

window

ctx

1

value

s suggestion */ j = m->top; /* borrow j */ if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) { if (bn_wexpand(r, j) == NULL) goto err; /* 2^(top*BN_BITS2) - m */ r->d[0] = (0 - m->d[0]) & BN_MASK2; for (i = 1; i < j; i++) r->d[i] = (~m->d[i]) & BN_MASK2; r->top = j; /* * Upper words will be zero if the corresponding words of

were * 0xfff[...], so decrement r->top accordingly. */ bn_correct_top(r); } else #endif if (!BN_to_montgomery(r, BN_value_one(), mont, ctx)) goto err; for (;;) { if (BN_is_bit_set(p, wstart) == 0) { if (!start) { if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err; } if (wstart == 0) break; wstart--; continue; } /* * We now have wstart on a

bit, we now need to work out how bit * a window to do. To do this we need to scan forward until the last * set bit before the end of the window */ j = wstart; wvalue = 1; wend = 0; for (i = 1; i < window; i++) { if (wstart - i < 0) break; if (BN_is_bit_set(p, wstart - i)) { wvalue <<= (i - wend); wvalue |= 1; wend = i; } } /* wend is the size of the current window */ j = wend + 1; /* add the

*/ if (!start) for (i = 0; i < j; i++) { if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err; } /* wvalue will be an odd number < 2^window */ if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx)) goto err; /* move the

down further */ wstart -= wend + 1; wvalue = 0; start = 0; if (wstart < 0) break; } #if defined(SPARC_T4_MONT) if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) { j = mont->N.top; /* borrow j */ val[0]->d[0] = 1; /* borrow val[0] */ for (i = 1; i < j; i++) val[0]->d[i] = 0; val[0]->top = j; if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx)) goto err; } else #endif if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return (ret); } #if defined(SPARC_T4_MONT) static BN_ULONG bn_get_bits(const BIGNUM *a, int bitpos) { BN_ULONG ret = 0; int wordpos; wordpos = bitpos / BN_BITS2; bitpos %= BN_BITS2; if (wordpos >= 0 && wordpos < a->top) { ret = a->d[wordpos] & BN_MASK2; if (bitpos) { ret >>= bitpos; if (++wordpos < a->top) ret |= a->d[wordpos] << (BN_BITS2 - bitpos); } } return ret & BN_MASK2; } #endif /* * BN_mod_exp_mont_consttime() stores the precomputed powers in a specific * layout so that accessing any of these table values shows the same access * pattern as far as cache lines are concerned. The following functions are * used to transfer a BIGNUM from/to that table. */ static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int window) { int i, j; int width = 1 << window; BN_ULONG *table = (BN_ULONG *)buf; if (top > b->top) top = b->top; /* this works because

is explicitly * zeroed */ for (i = 0, j = idx; i < top; i++, j += width) { table[j] = b->d[i]; } return 1; } static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int window) { int i, j; int width = 1 << window; /* * We declare table

in order to discourage compiler * from reordering loads from the table. Concern is that if * reordered in specific manner loads might give away the * information we are trying to conceal. Some would argue that * compiler can reorder them anyway, but it can as well be * argued that doing so would be violation of standard... */ volatile BN_ULONG *table = (volatile BN_ULONG *)buf; if (bn_wexpand(b, top) == NULL) return 0; if (window <= 3) { for (i = 0; i < top; i++, table += width) { BN_ULONG acc = 0; for (j = 0; j < width; j++) { acc |= table[j] & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1)); } b->d[i] = acc; } } else { int xstride = 1 << (window - 2); BN_ULONG y0, y1, y2, y3; i = idx >> (window - 2); /* equivalent of idx / xstride */ idx &= xstride - 1; /* equivalent of idx % xstride */ y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1); y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1); y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1); y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1); for (i = 0; i < top; i++, table += width) { BN_ULONG acc = 0; for (j = 0; j < xstride; j++) { acc |= ( (table[j + 0 * xstride] & y0) | (table[j + 1 * xstride] & y1) | (table[j + 2 * xstride] & y2) | (table[j + 3 * xstride] & y3) ) & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1)); } b->d[i] = acc; } } b->top = top; bn_correct_top(b); return 1; } /* * Given a pointer value, compute the next address that is a cache line * multiple. */ #define MOD_EXP_CTIME_ALIGN(x_) \ ((unsigned char*)(x_) + (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - (((size_t)(x_)) & (MOD_EXP_CTIME_MIN_CACHE_LINE_MASK)))) /* * This variant of BN_mod_exp_mont() uses fixed windows and the special * precomputation memory layout to limit data-dependency to a minimum to * protect secret exponents (cf. the hyper-threading timing attacks pointed * out by Colin Percival, * http://www.daemonology.net/hyperthreading-considered-harmful/) */ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { int i, bits, ret = 0, window, wvalue; int top; BN_MONT_CTX *mont = NULL; int numPowers; unsigned char *powerbufFree = NULL; int powerbufLen = 0; unsigned char *powerbuf = NULL; BIGNUM tmp, am; #if defined(SPARC_T4_MONT) unsigned int t4 = 0; #endif bn_check_top(a); bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS); return (0); } top = m->top; bits = BN_num_bits(p); if (bits == 0) { /* x**0 mod 1 is still zero. */ if (BN_is_one(m)) { ret = 1; BN_zero(rr); } else { ret = BN_one(rr); } return ret; } BN_CTX_start(ctx); /* * Allocate a montgomery context if it was not supplied by the caller. If * this is not done, things will break in the montgomery part. */ if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } #ifdef RSAZ_ENABLED /* * If the size of the operands allow it, perform the optimized * RSAZ exponentiation. For further information see * crypto/bn/rsaz_exp.c and accompanying assembly modules. */ if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024) && rsaz_avx2_eligible()) { if (NULL == bn_wexpand(rr, 16)) goto err; RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d, mont->n0[0]); rr->top = 16; rr->neg = 0; bn_correct_top(rr); ret = 1; goto err; } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) { if (NULL == bn_wexpand(rr, 8)) goto err; RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d); rr->top = 8; rr->neg = 0; bn_correct_top(rr); ret = 1; goto err; } #endif /* Get the window size to use with size of p. */ window = BN_window_bits_for_ctime_exponent_size(bits); #if defined(SPARC_T4_MONT) if (window >= 5 && (top & 15) == 0 && top <= 64 && (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) == (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0])) window = 5; else #endif #if defined(OPENSSL_BN_ASM_MONT5) if (window >= 5) { window = 5; /* ~5% improvement for RSA2048 sign, and even * for RSA4096 */ /* reserve space for mont->N.d[] copy */ powerbufLen += top * sizeof(mont->N.d[0]); } #endif (void)0; /* * Allocate a buffer large enough to hold all of the pre-computed powers * of am, am itself and tmp. */ numPowers = 1 << window; powerbufLen += sizeof(m->d[0]) * (top * numPowers + ((2 * top) > numPowers ? (2 * top) : numPowers)); #ifdef alloca if (powerbufLen < 3072) powerbufFree = alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH); else #endif if ((powerbufFree = OPENSSL_malloc(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL) goto err; powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree); memset(powerbuf, 0, powerbufLen); #ifdef alloca if (powerbufLen < 3072) powerbufFree = NULL; #endif /* lay down tmp and am right after powers table */ tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers); am.d = tmp.d + top; tmp.top = am.top = 0; tmp.dmax = am.dmax = top; tmp.neg = am.neg = 0; tmp.flags = am.flags = BN_FLG_STATIC_DATA; /* prepare a^0 in Montgomery domain */ #if 1 /* by Shay Gueron

s not error */ } } else #endif { if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window)) goto err; if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window)) goto err; /* * If the window size is greater than 1, then calculate * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even * powers could instead be computed as (a^(i/2))^2 to use the slight * performance advantage of sqr over mul). */ if (window > 1) { if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx)) goto err; if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2, window)) goto err; for (i = 3; i < numPowers; i++) { /* Calculate a^i = a^(i-1) * a */ if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx)) goto err; if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i, window)) goto err; } } bits--; for (wvalue = 0, i = bits % window; i >= 0; i--, bits--) wvalue = (wvalue << 1) + BN_is_bit_set(p, bits); if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue, window)) goto err; /* * Scan the exponent one window at a time starting from the most * significant bits. */ while (bits >= 0) { wvalue = 0; /* The

of the window */ /* Scan the window, squaring the result as we go */ for (i = 0; i < window; i++, bits--) { if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx)) goto err; wvalue = (wvalue << 1) + BN_is_bit_set(p, bits); } /* * Fetch the appropriate pre-computed value from the pre-buf */ if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue, window)) goto err; /* Multiply the result into the intermediate result */ if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx)) goto err; } } /* Convert the final result from montgomery to standard format */ #if defined(SPARC_T4_MONT) if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) { am.d[0] = 1; /* borrow am */ for (i = 1; i < top; i++) am.d[i] = 0; if (!BN_mod_mul_montgomery(rr, &tmp, &am, mont, ctx)) goto err; } else #endif if (!BN_from_montgomery(rr, &tmp, mont, ctx)) goto err; ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); if (powerbuf != NULL) { OPENSSL_cleanse(powerbuf, powerbufLen); OPENSSL_free(powerbufFree); } BN_CTX_end(ctx); return (ret); } int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { BN_MONT_CTX *mont = NULL; int b, bits, ret = 0; int r_is_one; BN_ULONG w, next_w; BIGNUM *r, *t; BIGNUM *swap_tmp; #define BN_MOD_MUL_WORD(r, w, m) \ (BN_mul_word(r, (w)) && \ (/* BN_ucmp(r, (m)) < 0 ? 1 :*/ \ (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1)))) /* * BN_MOD_MUL_WORD is only used with

large, so the BN_ucmp test is * probably more overhead than always using BN_mod (which uses BN_copy if * a similar test returns true). */ /* * We can use BN_mod and do not need BN_nnmod because our accumulator is * never negative (the result of BN_mod does not depend on the sign of * the modulus). */ #define BN_TO_MONTGOMERY_WORD(r, w, mont) \ (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx)) if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */ BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return 0; } bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS); return (0); } if (m->top == 1) a %= m->d[0]; /* make sure that

is reduced */ bits = BN_num_bits(p); if (bits == 0) { /* x**0 mod 1 is still zero. */ if (BN_is_one(m)) { ret = 1; BN_zero(rr); } else { ret = BN_one(rr); } return ret; } if (a == 0) { BN_zero(rr); ret = 1; return ret; } BN_CTX_start(ctx); r = BN_CTX_get(ctx); t = BN_CTX_get(ctx); if (t == NULL) goto err; if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } r_is_one = 1; /* except for Montgomery factor */ /* bits-1 >= 0 */ /* The result is accumulated in the product r*w. */ w = a; /* bit

of

is always set */ for (b = bits - 2; b >= 0; b--) { /* First, square r*w. */ next_w = w * w; if ((next_w / w) != w) { /* overflow */ if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = 1; } w = next_w; if (!r_is_one) { if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err; } /* Second, multiply r*w by

if exponent bit is set. */ if (BN_is_bit_set(p, b)) { next_w = w * a; if ((next_w / a) != w) { /* overflow */ if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = a; } w = next_w; } } /* Finally, set r:=r*w. */ if (w != 1) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } } if (r_is_one) { /* can happen only if a == 1 */ if (!BN_one(rr)) goto err; } else { if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; } ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return (ret); } /* The old fallback, simple version :-) */ int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx) { int i, j, bits, ret = 0, wstart, wend, window, wvalue; int start = 1; BIGNUM *d; /* Table of variables obtained from

*/ BIGNUM *val[TABLE_SIZE]; if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */ BNerr(BN_F_BN_MOD_EXP_SIMPLE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return 0; } bits = BN_num_bits(p); if (bits == 0) { /* x**0 mod 1 is still zero. */ if (BN_is_one(m)) { ret = 1; BN_zero(r); } else { ret = BN_one(r); } return ret; } BN_CTX_start(ctx); d = BN_CTX_get(ctx); val[0] = BN_CTX_get(ctx); if (val[0] == NULL) goto err; if (!BN_nnmod(val[0], a, m, ctx)) goto err; /* 1 */ if (BN_is_zero(val[0])) { BN_zero(r); ret = 1; goto err; } window = BN_window_bits_for_exponent_size(bits); if (window > 1) { if (!BN_mod_mul(d, val[0], val[0], m, ctx)) goto err; /* 2 */ j = 1 << (window - 1); for (i = 1; i < j; i++) { if (((val[i] = BN_CTX_get(ctx)) == NULL) || !BN_mod_mul(val[i], val[i - 1], d, m, ctx)) goto err; } } start = 1; /* This is used to avoid multiplication etc * when there is only the value

in the * buffer. */ wvalue = 0; /* The

of the window */ wstart = bits - 1; /* The top bit of the window */ wend = 0; /* The bottom bit of the window */ if (!BN_one(r)) goto err; for (;;) { if (BN_is_bit_set(p, wstart) == 0) { if (!start) if (!BN_mod_mul(r, r, r, m, ctx)) goto err; if (wstart == 0) break; wstart--; continue; } /* * We now have wstart on a

bit, we now need to work out how bit * a window to do. To do this we need to scan forward until the last * set bit before the end of the window */ j = wstart; wvalue = 1; wend = 0; for (i = 1; i < window; i++) { if (wstart - i < 0) break; if (BN_is_bit_set(p, wstart - i)) { wvalue <<= (i - wend); wvalue |= 1; wend = i; } } /* wend is the size of the current window */ j = wend + 1; /* add the

*/ if (!start) for (i = 0; i < j; i++) { if (!BN_mod_mul(r, r, r, m, ctx)) goto err; } /* wvalue will be an odd number < 2^window */ if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx)) goto err; /* move the

0xfff[...],

