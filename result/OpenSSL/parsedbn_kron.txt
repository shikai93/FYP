Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

least significant word

Returns -2 for errors because both -1 and 0 are valid results.

avoid 'uninitialized' warning

In 'tab', only odd-indexed entries are relevant: For any odd BIGNUM n, tab[BN_lsw(n) & 7] is $(-1)^{(n^2-1)/8}$ (using TeX notation). Note that the sign of n does not matter.

Kronecker symbol, implemented according to Henri Cohen, "A Course in Computational Algebraic Number Theory" (algorithm 1.4.10).

Cohen's step 1:

Cohen's step 2:

now B is non-zero

i is odd

(thus B was even, thus A must be odd!)

set 'ret' to $(-1)^{(A^2-1)/8}$

i is even

now B is positive and odd, so what remains to be done is to compute the Jacobi symbol (A/B) and multiply it by 'ret'

Cohen's step 3:

B is positive and odd

now A is non-zero

i is odd

multiply 'ret' by $(-1)^{(B^2-1)/8}$

Cohen's step 4:

multiply 'ret' by $(-1)^{(A-1)(B-1)/4}$

(A, B) := (B mod |A|, |A|)

www.openssl.org/source/license.html

License

internal/cryptlib.h

bn_lcl.h

uninitialized

tab

A Course in Computational Algebraic Number Theory

s step 1: */ if (BN_is_zero(B)) { ret = BN_abs_is_word(A, 1); goto end; } /* Cohen

ret

ret

s step 3: */ /* B is positive and odd */ if (BN_is_zero(A)) { ret = BN_is_one(B) ? ret : 0; goto end; } /* now A is non-zero */ i = 0; while (!BN_is_bit_set(A, i)) i++; err = !BN_rshift(A, A, i); if (err) goto end; if (i & 1) { /* i is odd */ /* multiply

by $(-1)^{(B^2-1)/8}$ */ ret = ret * tab[BN_lsw(B) & 7]; } /* Cohen

ret

