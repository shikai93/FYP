Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The EDK2 build doesn't use bn_conf.h; it sets THIRTY_TWO_BIT or SIXTY_FOUR_BIT in its own environment since it doesn't re-run our Configure script and needs to support both 32-bit and 64-bit.

These preprocessor symbols control various aspects of the bignum headers and library code. They're not defined by any "normal" configuration, as they are intended for development and testing purposes. NB: defining all three can be useful for debugging application code as well as openssl itself. BN_DEBUG - turn on various debugging alterations to the bignum code BN_DEBUG_RAND - uses random poisoning of unused words to trip up mismanagement of bignum internals. You must also define BN_DEBUG.

#define BN_DEBUG

#define BN_DEBUG_RAND

This next option uses the C libraries (2 word)/(1 word) function. If it is not defined, I use my C version (which is slower). The reason for this flag is that when the particular C compiler library routine is used, and the library is linked with a different compiler, the library is missing. This mostly happens when the library is built with gcc and then linked using normal cc. This would be a common occurrence because gcc normally produces code that is 2 times faster than system compilers for the big number stuff. For machines with only one compiler (or shared libraries), this should be on. Again this in only really a problem on machines using "long long's", are 32bit, and are not using my assembler code.

64-bit processor with LP64 ABI

64-bit processor other than LP64 ABI

Bignum consistency macros There is one "API" macro, bn_fix_top(), for stripping leading zeroes from bignum data after direct manipulations on the data. There is also an "internal" macro, bn_check_top(), for verifying that there are no leading zeroes. Unfortunately, some auditing is required due to the fact that bn_fix_top() has become an overabused duct-tape because bignum data is occasionally passed around in an inconsistent state. So the following changes have been made to sort this out; - bn_fix_top()s implementation has been moved to bn_correct_top() - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and bn_check_top() is as before. - if BN_DEBUG is defined; - bn_check_top() tries to pollute unused words even if the bignum 'top' is consistent. (ed: only if BN_DEBUG_RAND is defined) - bn_fix_top() maps to bn_check_top() rather than "fixing" anything. The idea is to have debug builds flag up inconsistent bignums when they occur. If that occurs in a bn_fix_top(), we examine the code in question; if the use of bn_fix_top() was appropriate (ie. it follows directly after code that manipulates the bignum) it is converted to bn_correct_top(), and if it was not appropriate, we convert it permanently to bn_check_top() and track down the cause of the bug. Eventually, no internal code should be using the bn_fix_top() macro. External applications and libraries should try this with their own code too, both in terms of building against the openssl headers with BN_DEBUG defined and linking with a version of OpenSSL built with it defined. This not only improves external code, it provides more test coverage for openssl's own code.

We cast away const without the compiler knowing, any \ genuinely constant variables that aren't mutable \ wouldn't be constructed with top!=dmax.

Debug only - safe to ignore error return

avoid unused variable warning with NDEBUG

!BN_DEBUG

Pointer to an array of 'BN_BITS2' bit chunks.

Index of last used d +1.

The next are internal book keeping for bn_expand.

Size of the d array.

one if the number is negative

Used for montgomery multiplication

number of bits in R

used to convert to montgomery form

The modulus

R(1/R mod N) - NNi = 1 (Ni is only stored for bignum algorithm)

least significant word(s) of Ni; (type changed with 0.9.9, was "BN_ULONG n0;" before)

Used for reciprocal division/mod functions It cannot be shared between threads

the divisor

the reciprocal

Used for slow "generation" functions.

To handle binary (in)compatibility

callback-specific data

if (ver==1) - handles old style callbacks

if (ver==2) - new callback style

BN_window_bits_for_exponent_size -- macro for sliding window mod_exp functions For window size 'w' (w >= 2) and a random 'b' bits exponent, the number of multiplications is a constant plus on average 2^(w-1) + (b-w)/(w+1); here 2^(w-1) is for precomputing the table (we actually need entries only for windows that have the lowest bit set), and (b-w)/(w+1) is an approximation for the expected number of w-bit windows, not counting the first one. Thus we should use w >= 6 if b > 671 w = 5 if 671 > b > 239 w = 4 if 239 > b > 79 w = 3 if 79 > b > 23 w <= 2 if 23 > b (with draws in between). Very small exponents are often selected with low Hamming weight, so we use w = 1 for b <= 23.

BN_mod_exp_mont_conttime is based on the assumption that the L1 data cache line width of the target processor is at least the following value.

Window sizes optimized for fixed window size modular exponentiation algorithm (BN_mod_exp_mont_consttime). To achieve the security goals of BN_mode_exp_mont_consttime, the maximum size of the window must not exceed log_2(MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH). Window size thresholds are defined for cache line sizes of 32 and 64, cache line sizes where log_2(32)=5 and log_2(64)=6 respectively. A window size of 7 should only be used on processors that have a 128 byte or greater cache line size.

Pentium pro 16,16,16,32,64

Alpha 16,16,16,16.64

32

32 less than

32

32

32

2011-02-22 SMS. In various places, a size_t variable or a type cast to size_t was used to perform integer-only operations on pointers. This failed on VMS with 64-bit pointers (CC /POINTER_SIZE = 64) because size_t is still only 32 bits. What's needed in these cases is an integer type with the same size as a pointer, which size_t is not certain to be. The only fix here is VMS-specific.

__INITIAL_POINTER_SIZE == 64

__INITIAL_POINTER_SIZE == 64 [else]

defined(OPENSSL_SYS_VMS)

defined(OPENSSL_SYS_VMS) [else]

BN_UMULT_HIGH section. No, I'm not trying to overwhelm you when stating that the product of N-bit numbers is 2N bits wide:-) No, I don't expect you to be impressed when I say that if the compiler doesn't support 2N integer type, then you have to replace every NN multiplication with 4 (N/2)(N/2) accompanied by some shifts and additions which unavoidably results in severe performance penalties. Of course provided that the hardware is capable of producing 2N result... That's when you normally start considering assembler implementation. However! It should be pointed out that some CPUs (most notably Alpha, PowerPC and upcoming IA-64 family:-) provide separate instruction calculating the upper half of the product placing the result into a general purpose register. Now if the compiler supports inline assembler, then it's not impossible to implement the "bignum" routines (and have the compiler optimize 'em) exhibiting "native" performance in C. That's what BN_UMULT_HIGH macro is about:-) <appro@fy.chalmers.se>

compiler

compiler

cpu

OPENSSL_NO_ASM

Using the long long type, has to be twice as wide as BN_ULONG...

No long long type

non-multiply part

non-multiply part

!BN_LLONG

www.openssl.org/source/license.html

License

t use bn_conf.h; it sets THIRTY_TWO_BIT or * SIXTY_FOUR_BIT in its own environment since it doesn

internal/bn_conf.h

internal/bn_int.h

C

re not defined by any "normal" configuration, as * they are intended for development and testing purposes. NB: defining all * three can be useful for debugging application code as well as openssl * itself. BN_DEBUG - turn on various debugging alterations to the bignum * code BN_DEBUG_RAND - uses random poisoning of unused words to trip up * mismanagement of bignum internals. You must also define BN_DEBUG. */ /* #define BN_DEBUG */ /* #define BN_DEBUG_RAND */ # ifndef OPENSSL_SMALL_FOOTPRINT # define BN_MUL_COMBA # define BN_SQR_COMBA # define BN_RECURSION # endif /* * This next option uses the C libraries (2 word)/(1 word) function. If it is * not defined, I use my C version (which is slower). The reason for this * flag is that when the particular C compiler library routine is used, and * the library is linked with a different compiler, the library is missing. * This mostly happens when the library is built with gcc and then linked * using normal cc. This would be a common occurrence because gcc normally * produces code that is 2 times faster than system compilers for the big * number stuff. For machines with only one compiler (or shared libraries), * this should be on. Again this in only really a problem on machines using * "long long

, are 32bit, and are not using my assembler code. */ # if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || \ defined(OPENSSL_SYS_WIN32) || defined(linux) # define BN_DIV2W # endif /* * 64-bit processor with LP64 ABI */ # ifdef SIXTY_FOUR_BIT_LONG # define BN_ULLONG unsigned long long # define BN_BITS4 32 # define BN_MASK2 (0xffffffffffffffffL) # define BN_MASK2l (0xffffffffL) # define BN_MASK2h (0xffffffff00000000L) # define BN_MASK2h1 (0xffffffff80000000L) # define BN_DEC_CONV (10000000000000000000UL) # define BN_DEC_NUM 19 # define BN_DEC_FMT1

# define BN_DEC_FMT2

# endif /* * 64-bit processor other than LP64 ABI */ # ifdef SIXTY_FOUR_BIT # undef BN_LLONG # undef BN_ULLONG # define BN_BITS4 32 # define BN_MASK2 (0xffffffffffffffffLL) # define BN_MASK2l (0xffffffffL) # define BN_MASK2h (0xffffffff00000000LL) # define BN_MASK2h1 (0xffffffff80000000LL) # define BN_DEC_CONV (10000000000000000000ULL) # define BN_DEC_NUM 19 # define BN_DEC_FMT1

# define BN_DEC_FMT2

# endif # ifdef THIRTY_TWO_BIT # ifdef BN_LLONG # if defined(_WIN32) && !defined(__GNUC__) # define BN_ULLONG unsigned __int64 # else # define BN_ULLONG unsigned long long # endif # endif # define BN_BITS4 16 # define BN_MASK2 (0xffffffffL) # define BN_MASK2l (0xffff) # define BN_MASK2h1 (0xffff8000L) # define BN_MASK2h (0xffff0000L) # define BN_DEC_CONV (1000000000L) # define BN_DEC_NUM 9 # define BN_DEC_FMT1

# define BN_DEC_FMT2

# endif /*- * Bignum consistency macros * There is one

macro, bn_fix_top(), for stripping leading zeroes from * bignum data after direct manipulations on the data. There is also an *

macro, bn_check_top(), for verifying that there are no leading * zeroes. Unfortunately, some auditing is required due to the fact that * bn_fix_top() has become an overabused duct-tape because bignum data is * occasionally passed around in an inconsistent state. So the following * changes have been made to sort this out; * - bn_fix_top()s implementation has been moved to bn_correct_top() * - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and * bn_check_top() is as before. * - if BN_DEBUG *is* defined; * - bn_check_top() tries to pollute unused words even if the bignum 'top' is * consistent. (ed: only if BN_DEBUG_RAND is defined) * - bn_fix_top() maps to bn_check_top() rather than

anything. * The idea is to have debug builds flag up inconsistent bignums when they * occur. If that occurs in a bn_fix_top(), we examine the code in question; if * the use of bn_fix_top() was appropriate (ie. it follows directly after code * that manipulates the bignum) it is converted to bn_correct_top(), and if it * was not appropriate, we convert it permanently to bn_check_top() and track * down the cause of the bug. Eventually, no internal code should be using the * bn_fix_top() macro. External applications and libraries should try this with * their own code too, both in terms of building against the openssl headers * with BN_DEBUG defined *and* linking with a version of OpenSSL built with it * defined. This not only improves external code, it provides more test * coverage for openssl's own code. */ # ifdef BN_DEBUG # include <assert.h> # ifdef BN_DEBUG_RAND # define bn_pollute(a) \ do { \ const BIGNUM *_bnum1 = (a); \ if (_bnum1->top < _bnum1->dmax) { \ unsigned char _tmp_char; \ /* We cast away const without the compiler knowing, any \ * *genuinely* constant variables that aren't mutable \ * wouldn't be constructed with top!=dmax. */ \ BN_ULONG *_not_const; \ memcpy(&_not_const, &_bnum1->d, sizeof(_not_const)); \ RAND_bytes(&_tmp_char, 1); /* Debug only - safe to ignore error return */\ memset(_not_const + _bnum1->top, _tmp_char, \ sizeof(*_not_const) * (_bnum1->dmax - _bnum1->top)); \ } \ } while(0) # else # define bn_pollute(a) # endif # define bn_check_top(a) \ do { \ const BIGNUM *_bnum2 = (a); \ if (_bnum2 != NULL) { \ assert(((_bnum2->top == 0) && !_bnum2->neg) || \ (_bnum2->top && (_bnum2->d[_bnum2->top - 1] != 0))); \ bn_pollute(_bnum2); \ } \ } while(0) # define bn_fix_top(a) bn_check_top(a) # define bn_check_size(bn, bits) bn_wcheck_size(bn, ((bits+BN_BITS2-1))/BN_BITS2) # define bn_wcheck_size(bn, words) \ do { \ const BIGNUM *_bnum2 = (bn); \ assert((words) <= (_bnum2)->dmax && \ (words) >= (_bnum2)->top); \ /* avoid unused variable warning with NDEBUG */ \ (void)(_bnum2); \ } while(0) # else /* !BN_DEBUG */ # define bn_pollute(a) # define bn_check_top(a) # define bn_fix_top(a) bn_correct_top(a) # define bn_check_size(bn, bits) # define bn_wcheck_size(bn, words) # endif BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w); BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w); void bn_sqr_words(BN_ULONG *rp, const BN_ULONG *ap, int num); BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d); BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, int num); BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, int num); struct bignum_st { BN_ULONG *d; /* Pointer to an array of 'BN_BITS2' bit * chunks. */ int top; /* Index of last used d +1. */ /* The next are internal book keeping for bn_expand. */ int dmax; /* Size of the d array. */ int neg; /* one if the number is negative */ int flags; }; /* Used for montgomery multiplication */ struct bn_mont_ctx_st { int ri; /* number of bits in R */ BIGNUM RR; /* used to convert to montgomery form */ BIGNUM N; /* The modulus */ BIGNUM Ni; /* R*(1/R mod N) - N*Ni = 1 (Ni is only * stored for bignum algorithm) */ BN_ULONG n0[2]; /* least significant word(s) of Ni; (type * changed with 0.9.9, was

* before) */ int flags; }; /* * Used for reciprocal division/mod functions It cannot be shared between * threads */ struct bn_recp_ctx_st { BIGNUM N; /* the divisor */ BIGNUM Nr; /* the reciprocal */ int num_bits; int shift; int flags; }; /* Used for slow

functions. */ struct bn_gencb_st { unsigned int ver; /* To handle binary (in)compatibility */ void *arg; /* callback-specific data */ union { /* if (ver==1) - handles old style callbacks */ void (*cb_1) (int, int, void *); /* if (ver==2) - new callback style */ int (*cb_2) (int, int, BN_GENCB *); } cb; }; /*- * BN_window_bits_for_exponent_size -- macro for sliding window mod_exp functions * * * For window size 'w' (w >= 2) and a random 'b' bits exponent, * the number of multiplications is a constant plus on average * * 2^(w-1) + (b-w)/(w+1); * * here 2^(w-1) is for precomputing the table (we actually need * entries only for windows that have the lowest bit set), and * (b-w)/(w+1) is an approximation for the expected number of * w-bit windows, not counting the first one. * * Thus we should use * * w >= 6 if b > 671 * w = 5 if 671 > b > 239 * w = 4 if 239 > b > 79 * w = 3 if 79 > b > 23 * w <= 2 if 23 > b * * (with draws in between). Very small exponents are often selected * with low Hamming weight, so we use w = 1 for b <= 23. */ # define BN_window_bits_for_exponent_size(b) \ ((b) > 671 ? 6 : \ (b) > 239 ? 5 : \ (b) > 79 ? 4 : \ (b) > 23 ? 3 : 1) /* * BN_mod_exp_mont_conttime is based on the assumption that the L1 data cache * line width of the target processor is at least the following value. */ # define MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH ( 64 ) # define MOD_EXP_CTIME_MIN_CACHE_LINE_MASK (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - 1) /* * Window sizes optimized for fixed window size modular exponentiation * algorithm (BN_mod_exp_mont_consttime). To achieve the security goals of * BN_mode_exp_mont_consttime, the maximum size of the window must not exceed * log_2(MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH). Window size thresholds are * defined for cache line sizes of 32 and 64, cache line sizes where * log_2(32)=5 and log_2(64)=6 respectively. A window size of 7 should only be * used on processors that have a 128 byte or greater cache line size. */ # if MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH == 64 # define BN_window_bits_for_ctime_exponent_size(b) \ ((b) > 937 ? 6 : \ (b) > 306 ? 5 : \ (b) > 89 ? 4 : \ (b) > 22 ? 3 : 1) # define BN_MAX_WINDOW_BITS_FOR_CTIME_EXPONENT_SIZE (6) # elif MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH == 32 # define BN_window_bits_for_ctime_exponent_size(b) \ ((b) > 306 ? 5 : \ (b) > 89 ? 4 : \ (b) > 22 ? 3 : 1) # define BN_MAX_WINDOW_BITS_FOR_CTIME_EXPONENT_SIZE (5) # endif /* Pentium pro 16,16,16,32,64 */ /* Alpha 16,16,16,16.64 */ # define BN_MULL_SIZE_NORMAL (16)/* 32 */ # define BN_MUL_RECURSIVE_SIZE_NORMAL (16)/* 32 less than */ # define BN_SQR_RECURSIVE_SIZE_NORMAL (16)/* 32 */ # define BN_MUL_LOW_RECURSIVE_SIZE_NORMAL (32)/* 32 */ # define BN_MONT_CTX_SET_SIZE_WORD (64)/* 32 */ /* * 2011-02-22 SMS. In various places, a size_t variable or a type cast to * size_t was used to perform integer-only operations on pointers. This * failed on VMS with 64-bit pointers (CC /POINTER_SIZE = 64) because size_t * is still only 32 bits. What's needed in these cases is an integer type * with the same size as a pointer, which size_t is not certain to be. The * only fix here is VMS-specific. */ # if defined(OPENSSL_SYS_VMS) # if __INITIAL_POINTER_SIZE == 64 # define PTR_SIZE_INT long long # else /* __INITIAL_POINTER_SIZE == 64 */ # define PTR_SIZE_INT int # endif /* __INITIAL_POINTER_SIZE == 64 [else] */ # elif !defined(PTR_SIZE_INT) /* defined(OPENSSL_SYS_VMS) */ # define PTR_SIZE_INT size_t # endif /* defined(OPENSSL_SYS_VMS) [else] */ # if !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) && !defined(PEDANTIC) /* * BN_UMULT_HIGH section. * * No, I'm not trying to overwhelm you when stating that the * product of N-bit numbers is 2*N bits wide:-) No, I don't expect * you to be impressed when I say that if the compiler doesn't * support 2*N integer type, then you have to replace every N*N * multiplication with 4 (N/2)*(N/2) accompanied by some shifts * and additions which unavoidably results in severe performance * penalties. Of course provided that the hardware is capable of * producing 2*N result... That's when you normally start * considering assembler implementation. However! It should be * pointed out that some CPUs (most notably Alpha, PowerPC and * upcoming IA-64 family:-) provide *separate* instruction * calculating the upper half of the product placing the result * into a general purpose register. Now *if* the compiler supports * inline assembler, then it's not impossible to implement the *

routines (and have the compiler optimize 'em) * exhibiting

performance in C. That's what BN_UMULT_HIGH * macro is about:-) * * <appro@fy.chalmers.se> */ # if defined(__SIZEOF_INT128__) && __SIZEOF_INT128__==16 && \ (defined(SIXRY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)) # define BN_UMULT_HIGH(a,b) (((__uint128_t)(a)*(b))>>64) # define BN_UMULT_LOHI(low,high,a,b) ({ \ __uint128_t ret=(__uint128_t)(a)*(b); \ (high)=ret>>64; (low)=ret; }) # elif defined(__alpha) && (defined(SIXTY_FOUR_BIT_LONG) || defined(SIXTY_FOUR_BIT)) # if defined(__DECC) # include <c_asm.h> # define BN_UMULT_HIGH(a,b) (BN_ULONG)asm(

,(a),(b)) # elif defined(__GNUC__) && __GNUC__>=2 # define BN_UMULT_HIGH(a,b) ({ \ register BN_ULONG ret; \ asm (

\ :

(ret) \ :

(a),

(b)); \ ret; }) # endif /* compiler */ # elif defined(_ARCH_PPC64) && defined(SIXTY_FOUR_BIT_LONG) # if defined(__GNUC__) && __GNUC__>=2 # define BN_UMULT_HIGH(a,b) ({ \ register BN_ULONG ret; \ asm (

\ :

(ret) \ :

(a),

(b)); \ ret; }) # endif /* compiler */ # elif (defined(__x86_64) || defined(__x86_64__)) && \ (defined(SIXTY_FOUR_BIT_LONG) || defined(SIXTY_FOUR_BIT)) # if defined(__GNUC__) && __GNUC__>=2 # define BN_UMULT_HIGH(a,b) ({ \ register BN_ULONG ret,discard; \ asm (

\ :

(discard),

(ret) \ :

(a),

(b) \ :

); \ ret; }) # define BN_UMULT_LOHI(low,high,a,b) \ asm (

\ :

(low),

(high) \ :

(a),

(b) \ :

); # endif # elif (defined(_M_AMD64) || defined(_M_X64)) && defined(SIXTY_FOUR_BIT) # if defined(_MSC_VER) && _MSC_VER>=1400 unsigned __int64 __umulh(unsigned __int64 a, unsigned __int64 b); unsigned __int64 _umul128(unsigned __int64 a, unsigned __int64 b, unsigned __int64 *h); # pragma intrinsic(__umulh,_umul128) # define BN_UMULT_HIGH(a,b) __umulh((a),(b)) # define BN_UMULT_LOHI(low,high,a,b) ((low)=_umul128((a),(b),&(high))) # endif # elif defined(__mips) && (defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)) # if defined(__GNUC__) && __GNUC__>=2 # define BN_UMULT_HIGH(a,b) ({ \ register BN_ULONG ret; \ asm (

\ :

(ret) \ :

(a),

(b) :

); \ ret; }) # define BN_UMULT_LOHI(low,high,a,b) \ asm (

\ :

(low),

(high) \ :

(a),

(b)); # endif # elif defined(__aarch64__) && defined(SIXTY_FOUR_BIT_LONG) # if defined(__GNUC__) && __GNUC__>=2 # define BN_UMULT_HIGH(a,b) ({ \ register BN_ULONG ret; \ asm (

\ :

(ret) \ :

(a),

0xffffffffffffffffL)

0xffffffffL)

0xffffffff00000000L)

0xffffffff80000000L)

0xffffffffffffffffLL)

0xffffffffL)

0xffffffff00000000LL)

0xffffffff80000000LL)

0xffffffffL)

0xffff)

0xffff8000L)

0xffff0000L)

0x0;

