Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Must 'OPENSSL_free' the returned data

strip leading zeros

Must 'OPENSSL_free' the returned data

get an upper bound for the length of the decimal integer num <= (BN_num_bits(a) + 1) log(2) <= 3 BN_num_bits(a) 0.101 + log(2) + 1 (rounding error) <= 3 BN_num_bits(a) / 10 + 3 BN_num_bits / 1000 + 1 + 1

negative and terminator and one spare?

We now have a series of blocks, BN_DEC_NUM chars in length, where the last one needs truncation. The blocks need to be reversed in order.

a is the start of the hex digits, and it is 'i' long

i is the number of hex digits

least significant 'hex'

paranoia

Don't set the negative flag if it's zero.

a is the start of the digits, and it is 'i' long. We chop it into BN_DEC_NUM digits at a time

i is the number of digits, a bit of an over expand

Don't set the negative flag if it's zero.

Don't set the negative flag if it's zero.

strip leading zeros

www.openssl.org/source/license.html

License

internal/ctype.h

internal/cryptlib.h

bn_lcl.h

0123456789ABCDEF

OPENSSL_free

0

-

\0

OPENSSL_free

0

\0

-

\0

-

i

hex

t set the negative flag if it

\0

-

i

0

t set the negative flag if it

-

0

X

x

t set the negative flag if it

-

-

0

bn(%zu,%zu)

bn(%zu,%zu)

0xff);

0x0f];

0x0f);

