Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

In bn_lcl.h, bn_expand() is defined as a static ossl_inline function. This is fine in itself, it will end up as an unused static function in the worst case. However, it references bn_expand2(), which is a private function in libcrypto and therefore unavailable on some systems. This may result in a linker error because of unresolved symbols. To avoid this, we define a dummy variant of bn_expand2() here, and to avoid possible clashes with libcrypto, we rename it first, using a macro.

Things in boring, not in openssl. TODO we should add them.

number of tests

additional tests for some functions

Polynomial coefficients used in GFM tests.

Look for |key| in the stanza and return it or NULL if not found.

Parse BIGNUM, return number of bytes parsed.

Return a "random" flag for if a BN should be negated.

Test constant-time modular exponentiation with 1024-bit inputs, which on x86_64 cause a different code branch to be taken.

must be odd for montgomery

Zero exponent

Regression test for carry bug in mulx4x_mont

Regression test for carry bug in sqr[x]8x_mont

Zero input

Craft an input whose Montgomery representation is 1, i.e., shorter than the modulus m, in order to test the const time precomputation scattering/gathering.

Finally, some regular test vectors.

Test that two added values have the correct parity.

Test that c + c = 0.

Test that a + (a mod p) mod p == 0.

Test that (a+d)c = ac + dc.

Test that aa = a^2.

Test that ((1/a)a) = 1.

Test that ((a/c)c)/a = 1.

Test that a^(c+d)=a^ca^d.

Test that d^2 = a, where d = sqrt(a).

Test that solution of quadratic c satisfies c^2 + c = a.

We test BN_kronecker(a, b, ctx) just for b odd (Jacobi symbol). In this case we know that if b is prime, then BN_kronecker(a, b, ctx) is congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol). So we generate a random prime b and compare these values for a number of random a's. (That is, we run the Solovay-Strassen primality test to confirm that b is prime, except that we don't want to test whether b is prime but whether BN_kronecker works.)

t := (|b|-1)/2 (note that b is odd)

r := a^t mod b

we actually need BN_kronecker(a, |b|)

Test that the functions work when |r| and |a| point to the same BIGNUM, or when |r| and |b| point to the same BIGNUM. TODO: Test where all of |r|, |a|, and |b| point to the same BIGNUM.

Test BN_uadd() and BN_usub() with the prerequisites they are documented as having. Note that these functions are frequently used when the prerequisites don't hold. In those cases, they are supposed to work as if the prerequisite hold, but we don't test that yet. TODO: test that.

Test that the functions work when |r| and |a| point to the same BIGNUM, or when |r| and |b| point to the same BIGNUM. TODO: Test where all of |r|, |a|, and |b| point to the same BIGNUM.

Test with BN_add_word() and BN_sub_word() if |b| is small enough.

Set the LSB to 1 and test rshift1 again.

rem

If N == 1, try with rshift1 as well

BN_sqrt should fail on non-squares and negative numbers.

Test with BN_mod_word() and BN_div_word() if the divisor is small enough.

Test BN_nnmod.

Reduce |a| and |b| and test the Montgomery version.

Regression test for carry propagation bug in sqr8x_reduction

There are two possible answers.

The first condition should NOT be a test.

Test edge case at 0.

Test a random numbers at various byte lengths.

Empty buffer should fail.

One byte short should fail.

Exactly right size should encode.

Pad up one byte extra.

Pad up to 256.

Test BN_rand for degenerate cases with |top| and |bottom| parameters.

top

bottom

top

bottom

top

bottom

top

bottom

top

bottom

top

bottom

Test that BN_mul never gives negative zero.

Test that BN_div never gives negative zero in the quotient.

Test that BN_div never gives negative zero in the remainder.

Test that BN_set_negative will not produce a negative zero.

Some operations also may not be used with an even modulus.

For a long time, small primes were not considered prime when do_trial_division was set.

nchecks

do_trial_division

nchecks

do_trial_division

Read test file.

www.openssl.org/source/license.html

License

../e_os.h

internal/nelem.h

internal/numbers.h

testutil.h

../crypto/bn/bn_lcl.h

%s:%d: Can't find %s

Could not decode '%s'

unexpected %s value

random

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000FFFFFFFF00

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000FFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000FFFFFFFF0000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

000000000000000000000000000000000000000000FFFFFFFFFFFFFF00000000

7878787878787878787878787878787878787878787878787878787878787878

7878787878787878787878787878787878787878787878787878787878787878

7878787878787878787878787878787878787878787878787878787878787878

7878787878787878787878787878787878787878787878787878787878787878

095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744

E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593

9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03

9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81

D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B

91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5

D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4

2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF

%d tests found no roots; probably an error

s. (That is, we run the Solovay-Strassen primality test to * confirm that b is prime, except that we don

Legendre symbol computation failed

A

B

Sum

A + B

Sum - A

Sum - B

A + B (r is a)

A + B (r is b)

Sum - A (r is a)

Sum - A (r is b)

Sum - B (r is a)

Sum - B (r is b)

t hold. In those cases, they are supposed * to work as if the prerequisite hold, but we don

A +u B

Sum -u A

Sum -u B

A +u B (r is a)

A +u B (r is b)

Sum -u A (r is a)

Sum -u A (r is b)

Sum -u B (r is a)

Sum -u B (r is b)

A + B (word)

Sum - B (word)

A

LShift1

A + A

A * 2

LShift1 / 2

LShift1 % 2

A << 1

LShift >> 1

LShift >> 1

(LShift1 | 1) / 2

(LShift | 1) >> 1

A

LShift

A << N

A >> N

A

RShift

N

A >> N

A >> 1 (rshift1)

A

Square

A^2

A * A

Square / A

Square % A

sqrt(Square)

A

B

Product

A * B

Product / A

Product % A

Product / B

Product % B

A

B

Quotient

Remainder

A / B

A % B

Quotient * B + Remainder

Got A %% B (word) =

, wanted

Got A %% B (word) mismatch

A / B (word)

Got A %% B (word) =

, wanted



Got A %% B (word) mismatch

A % B (non-negative)

A

B

M

ModMul

A * B (mod M)

A * B (mod M) (mont)

A

E

M

ModExp

A ^ E (mod M)

A ^ E (mod M) (mont)

A ^ E (mod M) (mont const

050505050505

02

4141414141414141414141274141414141414141414141414141414141414141

4141414141414141414141414141414141414141414141414141414141414141

4141414141414141414141800000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000000000000

0000000000000000000000000000000000000000000000000000000001

A

E

Exp

A ^ E

A

P

ModSqrt

sqrt(A) (mod P)

0

256

-42

1

-0

42trailing garbage is ignored

0

256

-42

cb

-0

abctrailing garbage is ignored

0

256

-42

0x1234

0X1234

-0xabcd

-0

123trailing garbage is ignored

0

\x00\x00\x00\x00

1

\x00\x00\x00\x01\x01

-1

\x00\x00\x00\x01\x81

128

\x00\x00\x00\x02\x00\x80

256

\x00\x00\x00\x02\x01\x00

-256

\x00\x00\x00\x02\x81\x00

Sum

LShift1

LShift

RShift

Square

Product

Quotient

ModMul

ModExp

Exp

ModSqrt

%s:%d: Failed %s test

%s:%d: Unknown test

0x256)

0x42)

0xCB)

0xabc)

0x1234"))

0x1234)

0X1234"))

0x1234)

0xabcd"))

0xabcd)

