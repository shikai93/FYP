Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Socket mode for BIO_listen

Socket mode for BIO_accept (set on accepted sock)

Useful if we asked for port 0

TODO: Convert to new style write function

TODO: Convert to new style read function

connect_gets,

Because we're starting a new bind, any cached name and serv are now obsolete and need to be cleaned out. QUESTION: should this be done in acpt_close_socket() instead?

This is a trick we use to avoid bit rot. at least the "else" part will always be compiled.

We're currently not iterating, but set this as preparation for possible future development in that regard

If the returned socket is invalid, this might still be retryable

If it wasn't retryable, we fail

If the accept BIO has an bio_chain, we dup it and put the new socket at the end.

use this one to start the connection

We affect the hostname regardless. However, the input string might contain a host:service spec, so we must parse it, which might or might not affect the service

www.openssl.org/source/license.html

License

bio_lcl.h

socket accept

hostname=

service=

re starting a new bind, any cached name and serv * are now obsolete and need to be cleaned out. * QUESTION: should this be done in acpt_close_socket() instead? */ OPENSSL_free(c->cache_accepting_name); c->cache_accepting_name = NULL; OPENSSL_free(c->cache_accepting_serv); c->cache_accepting_serv = NULL; OPENSSL_free(c->cache_peer_name); c->cache_peer_name = NULL; OPENSSL_free(c->cache_peer_serv); c->cache_peer_serv = NULL; c->state = ACPT_S_GET_ADDR; break; case ACPT_S_GET_ADDR: { int family = AF_UNSPEC; switch (c->accept_family) { case BIO_FAMILY_IPV6: if (1) { /* This is a trick we use to avoid bit rot. * at least the "else" part will always be * compiled. */ #ifdef AF_INET6 family = AF_INET6; } else { #endif BIOerr(BIO_F_ACPT_STATE, BIO_R_UNAVAILABLE_IP_FAMILY); goto exit_loop; } break; case BIO_FAMILY_IPV4: family = AF_INET; break; case BIO_FAMILY_IPANY: family = AF_UNSPEC; break; default: BIOerr(BIO_F_ACPT_STATE, BIO_R_UNSUPPORTED_IP_FAMILY); goto exit_loop; } if (BIO_lookup(c->param_addr, c->param_serv, BIO_LOOKUP_SERVER, family, SOCK_STREAM, &c->addr_first) == 0) goto exit_loop; } if (c->addr_first == NULL) { BIOerr(BIO_F_ACPT_STATE, BIO_R_LOOKUP_RETURNED_NOTHING); goto exit_loop; } /* We

hostname=

service=

