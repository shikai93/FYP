Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Special method for a BIO where the other endpoint is also a BIO of this kind, handled by the same thread (i.e. the "peer" is actually ourselves, wearing a different hat). Such "BIO pairs" are mainly for using the SSL library with I/O interfaces for which no specific BIO method is available. See ssl/ssltest.c for some hints on how this can be used.

TODO: Convert to new style write function

TODO: Convert to new style read function

no bio_gets

no bio_callback_ctrl

NULL if buf == NULL. If peer != NULL, then peer->ptr is also a bio_bio_st, and its "peer" member points back to us. peer != NULL iff init != 0 in the BIO.

This is for what we write (i.e. reading uses peer's struct):

valid iff peer != NULL

valid iff buf != NULL; 0 if peer == NULL

valid iff buf != NULL; 0 if len == 0

"size" elements (if != NULL)

valid iff peer != NULL; 0 if len != 0, otherwise set by peer to number of bytes it (unsuccessfully) tried to read, never more than buffer space (size-len) warrants.

enough for one TLS record (just a default)

will be set in "retry_read" situation

writer has closed, and no data is left

buffer is empty

don't ask for more than the peer can deliver in one write

we can read

now read "size" bytes

one or two iterations

wrap around ring buffer

buffer now empty, no need to advance "buf"

non-copying interface: provide pointer to available data in buffer bio_nread0: return number of available bytes bio_nread: also advance index (example usage: bio_nread0(), read from buffer, bio_nread() or just bio_nread(), read from buffer)

WARNING: The non-copying interface is largely untested as of yet and may contain bugs.

avoid code duplication -- nothing available for reading

returns 0 or -1

no ring buffer wrap-around for non-copying interface

we already closed

buffer is full

we can write

now write "num" bytes

one or two iterations

b->buf[write_offset] is the first byte we can write to.

wrap around ring buffer

non-copying interface: provide pointer to region to write to bio_nwrite0: check how much space is available bio_nwrite: also increase length (example usage: bio_nwrite0(), write to buffer, bio_nwrite() or just bio_nwrite(), write to buffer)

no ring buffer wrap-around for non-copying interface (to fulfil the promise by BIO_ctrl_get_write_guarantee, BIO_nwrite may have to be called twice)

specific CTRL codes

Affects both BIOs in the pair -- call just once! Or let BIO_free(bio1); BIO_free(bio2); do the job.

How many bytes can the caller feed to the next write without having to keep any?

If the peer unsuccessfully tried to read, how many bytes were requested? (As with BIO_CTRL_PENDING, that number can usually be treated as boolean.)

Reset request. (Can be useful after read attempts at the other side that are meant to be non-blocking, e.g. when probing SSL_read to see if any data is available.)

similar to shutdown(..., SHUT_WR)

prepare for non-copying read

non-copying read

prepare for non-copying write

non-copying write

standard CTRL codes follow

See BIO_dup_chain for circumstances we have to expect.

other_bio is always fresh

Exported convenience functions

BIO_nread0/nread/nwrite0/nwrite are available only for BIO pairs for now (conceivably some other BIOs could allow non-copying reads and writes too.)

www.openssl.org/source/license.html

License

peer

BIO pairs

e_os.h

bio_lcl.h

BIO pair

peer

s struct): */ int closed; /* valid iff peer != NULL */ size_t len; /* valid iff buf != NULL; 0 if peer == NULL */ size_t offset; /* valid iff buf != NULL; 0 if len == 0 */ size_t size; char *buf; /* "size" elements (if != NULL) */ size_t request; /* valid iff peer != NULL; 0 if len != 0, * otherwise set by peer to number of bytes * it (unsuccessfully) tried to read, never * more than buffer space (size-len) * warrants. */ }; static int bio_new(BIO *bio) { struct bio_bio_st *b = OPENSSL_zalloc(sizeof(*b)); if (b == NULL) return 0; /* enough for one TLS record (just a default) */ b->size = 17 * 1024; bio->ptr = b; return 1; } static int bio_free(BIO *bio) { struct bio_bio_st *b; if (bio == NULL) return 0; b = bio->ptr; assert(b != NULL); if (b->peer) bio_destroy_pair(bio); OPENSSL_free(b->buf); OPENSSL_free(b); return 1; } static int bio_read(BIO *bio, char *buf, int size_) { size_t size = size_; size_t rest; struct bio_bio_st *b, *peer_b; BIO_clear_retry_flags(bio); if (!bio->init) return 0; b = bio->ptr; assert(b != NULL); assert(b->peer != NULL); peer_b = b->peer->ptr; assert(peer_b != NULL); assert(peer_b->buf != NULL); peer_b->request = 0; /* will be set in "retry_read" situation */ if (buf == NULL || size == 0) return 0; if (peer_b->len == 0) { if (peer_b->closed) return 0; /* writer has closed, and no data is left */ else { BIO_set_retry_read(bio); /* buffer is empty */ if (size <= peer_b->size) peer_b->request = size; else /* * don

size

buf

num

