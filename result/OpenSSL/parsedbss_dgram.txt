Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

linux is lame

windows is lame

Standard definition causes type-punning problems.

TODO: Convert to new style write function

TODO: Convert to new style read function

dgram_gets,

TODO: Convert to new style write function

TODO: Convert to new style write function

dgram_gets,

Is a timer active?

Read current socket timeout

Get current time

Calculate time left until timer expires

Adjust socket timeout if next handshake message timer will expire earlier.

Is a timer active?

Assume this is UDP - 20 bytes for IP, 8 bytes for UDP

Assume this is UDP - 20 bytes for IP, 8 bytes for UDP

Assume this is UDP - 40 bytes for IP, 8 bytes for UDP

We don't know. Go with the historical default

assume that system supporting IP_MTU is modern enough to define socklen_t

(Linux)kernel sets DF bit on outgoing IP packets

we assume that the transport protocol is UDP and no IP options are used.

we assume that the transport protocol is UDP and no IPV6 options are used.

FIXME: if num < ret, we will only return part of an address. That should bee an error, no?

fall-through

BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE is used here for compatibility reasons. When BIO_CTRL_DGRAM_SET_PEEK_MODE was first defined its value was incorrectly clashing with BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE. The value has been updated to a non-clashing value. However to preserve binary compatiblity we now respond to both the old value and the new one

Activate SCTP-AUTH for DATA and FORWARD-TSN chunks

Test if activation was successful. When using accept(), SCTP-AUTH has to be activated for the listening socket already, otherwise the connected socket won't use it. Similarly with connect(): the socket prior to connection must be activated for SCTP-AUTH

Disable partial delivery by setting the min size larger than the max record size of 2^14 + 2048 + 13

delete key

disable sender dry event

Partial message read, this should never happen!

The buffer was too small, this means the peer sent a message that was larger than allowed.

Test if socket buffer can handle max record size (2^14 + 2048 + 13)

Test if SCTP doesn't partially deliver below max record size (2^14 + 2048 + 13)

Partially delivered notification??? Probably a bug....

Everything seems ok till now, so it's most likely a message dropped by PR-SCTP.

Test if peer uses SCTP-AUTH before continuing

dgram_sctp_write - send message on SCTP socket @b: BIO to write to @in: data to send @inl: amount of bytes in @in to send Returns -1 on error or the sent amount of bytes on success

If we're send anything else than application data, disable all user parameters and flags.

We can only send a shutdown alert if the socket is dry

Set to maximum (2^14) and ignore user input to enable transport protocol fragmentation. Returns always 2^14.

Set to maximum (2^14) and ignore input to enable transport protocol fragmentation. Returns always 2^14.

Returns always -1.

SCTP doesn't need the DTLS timer Returns always 1.

We allow transport protocol fragmentation so this is irrelevant

New shared key for SCTP AUTH. Returns 0 on success, -1 otherwise.

Get active key

Add new key

This field is missing in FreeBSD 8.2 and earlier, and FreeBSD 8.3 and higher work without it.

Reset active key

Returns 0 on success, -1 otherwise.

Get active key

Set active key

CCS has been sent, so remember that and fall through to check if we need to deactivate an old key

Returns 0 on success, -1 otherwise.

Has this command really been called or is this just a fall-through?

CSS has been both, received and sent, so deactivate an old key

Get active key

Deactivate key or delete second last key if SCTP_AUTHENTICATION_EVENT is not available.

Returns the size of the copied struct.

Returns the size of the copied struct.

Returns the size of the copied struct.

Returns the size of the copied struct.

Returns the size of the copied struct.

Returns the size of the copied struct.

Returns always 1.

Pass to default ctrl function to process SCTP unspecific commands

BIO_dgram_sctp_wait_for_dry - Wait for SCTP SENDER_DRY event @b: The BIO to check for the dry event Wait until the peer confirms all packets have been received, and so that our kernel doesn't have anything to send anymore. This is only received by the peer's kernel, not the application. Returns: -1 on error 0 when not dry yet 1 when dry

set sender dry event

peek for notification

if we find a notification, process it and try again if necessary

disable sender dry event

found notification, peek again

if we have seen the dry already, don't wait

read anything else

Check if there are any messages waiting to be read

if notification, process and try again

Return 1 if there is a message to be read, return 0 otherwise.

If the socket return value (i) is -1 and err is unexpectedly 0 at this point, the error code was overwritten by another system call before this error handling is called.

re-bias to 1/1/1970

www.openssl.org/source/license.html

License

bio_lcl.h

datagram socket

datagram sctp socket

getsockopt

getsockopt

setsockopt

setsockopt

setsockopt

setsockopt

t know. Go with the historical default */ ret = 28; break; } return ret; } static long dgram_ctrl(BIO *b, int cmd, long num, void *ptr) { long ret = 1; int *ip; bio_dgram_data *data = NULL; int sockopt_val = 0; int d_errno; # if defined(OPENSSL_SYS_LINUX) && (defined(IP_MTU_DISCOVER) || defined(IP_MTU)) socklen_t sockopt_len; /* assume that system supporting IP_MTU is * modern enough to define socklen_t */ socklen_t addr_len; BIO_ADDR addr; # endif data = (bio_dgram_data *)b->ptr; switch (cmd) { case BIO_CTRL_RESET: num = 0; ret = 0; break; case BIO_CTRL_INFO: ret = 0; break; case BIO_C_SET_FD: dgram_clear(b); b->num = *((int *)ptr); b->shutdown = (int)num; b->init = 1; break; case BIO_C_GET_FD: if (b->init) { ip = (int *)ptr; if (ip != NULL) *ip = b->num; ret = b->num; } else ret = -1; break; case BIO_CTRL_GET_CLOSE: ret = b->shutdown; break; case BIO_CTRL_SET_CLOSE: b->shutdown = (int)num; break; case BIO_CTRL_PENDING: case BIO_CTRL_WPENDING: ret = 0; break; case BIO_CTRL_DUP: case BIO_CTRL_FLUSH: ret = 1; break; case BIO_CTRL_DGRAM_CONNECT: BIO_ADDR_make(&data->peer, BIO_ADDR_sockaddr((BIO_ADDR *)ptr)); break; /* (Linux)kernel sets DF bit on outgoing IP packets */ case BIO_CTRL_DGRAM_MTU_DISCOVER: # if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO) addr_len = (socklen_t) sizeof(addr); memset(&addr, 0, sizeof(addr)); if (getsockname(b->num, &addr.sa, &addr_len) < 0) { ret = 0; break; } switch (addr.sa.sa_family) { case AF_INET: sockopt_val = IP_PMTUDISC_DO; if ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER, &sockopt_val, sizeof(sockopt_val))) < 0) perror("setsockopt"); break; # if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO) case AF_INET6: sockopt_val = IPV6_PMTUDISC_DO; if ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER, &sockopt_val, sizeof(sockopt_val))) < 0) perror("setsockopt"); break; # endif default: ret = -1; break; } # else ret = -1; # endif break; case BIO_CTRL_DGRAM_QUERY_MTU: # if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU) addr_len = (socklen_t) sizeof(addr); memset(&addr, 0, sizeof(addr)); if (getsockname(b->num, &addr.sa, &addr_len) < 0) { ret = 0; break; } sockopt_len = sizeof(sockopt_val); switch (addr.sa.sa_family) { case AF_INET: if ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val, &sockopt_len)) < 0 || sockopt_val < 0) { ret = 0; } else { /* * we assume that the transport protocol is UDP and no IP * options are used. */ data->mtu = sockopt_val - 8 - 20; ret = data->mtu; } break; # if OPENSSL_USE_IPV6 && defined(IPV6_MTU) case AF_INET6: if ((ret = getsockopt(b->num, IPPROTO_IPV6, IPV6_MTU, (void *)&sockopt_val, &sockopt_len)) < 0 || sockopt_val < 0) { ret = 0; } else { /* * we assume that the transport protocol is UDP and no IPV6 * options are used. */ data->mtu = sockopt_val - 8 - 40; ret = data->mtu; } break; # endif default: ret = 0; break; } # else ret = 0; # endif break; case BIO_CTRL_DGRAM_GET_FALLBACK_MTU: ret = -dgram_get_mtu_overhead(data); switch (BIO_ADDR_family(&data->peer)) { case AF_INET: ret += 576; break; # if OPENSSL_USE_IPV6 case AF_INET6: { # ifdef IN6_IS_ADDR_V4MAPPED struct in6_addr tmp_addr; if (BIO_ADDR_rawaddress(&data->peer, &tmp_addr, NULL) && IN6_IS_ADDR_V4MAPPED(&tmp_addr)) ret += 576; else # endif ret += 1280; } break; # endif default: ret += 576; break; } break; case BIO_CTRL_DGRAM_GET_MTU: return data->mtu; case BIO_CTRL_DGRAM_SET_MTU: data->mtu = num; ret = num; break; case BIO_CTRL_DGRAM_SET_CONNECTED: if (ptr != NULL) { data->connected = 1; BIO_ADDR_make(&data->peer, BIO_ADDR_sockaddr((BIO_ADDR *)ptr)); } else { data->connected = 0; memset(&data->peer, 0, sizeof(data->peer)); } break; case BIO_CTRL_DGRAM_GET_PEER: ret = BIO_ADDR_sockaddr_size(&data->peer); /* FIXME: if num < ret, we will only return part of an address. That should bee an error, no? */ if (num == 0 || num > ret) num = ret; memcpy(ptr, &data->peer, (ret = num)); break; case BIO_CTRL_DGRAM_SET_PEER: BIO_ADDR_make(&data->peer, BIO_ADDR_sockaddr((BIO_ADDR *)ptr)); break; case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: memcpy(&(data->next_timeout), ptr, sizeof(struct timeval)); break; # if defined(SO_RCVTIMEO) case BIO_CTRL_DGRAM_SET_RECV_TIMEOUT: # ifdef OPENSSL_SYS_WINDOWS { struct timeval *tv = (struct timeval *)ptr; int timeout = tv->tv_sec * 1000 + tv->tv_usec / 1000; if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, (void *)&timeout, sizeof(timeout)) < 0) { perror("setsockopt"); ret = -1; } } # else if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr, sizeof(struct timeval)) < 0) { perror("setsockopt"); ret = -1; } # endif break; case BIO_CTRL_DGRAM_GET_RECV_TIMEOUT: { union { size_t s; int i; } sz = { 0 }; # ifdef OPENSSL_SYS_WINDOWS int timeout; struct timeval *tv = (struct timeval *)ptr; sz.i = sizeof(timeout); if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, (void *)&timeout, &sz.i) < 0) { perror("getsockopt"); ret = -1; } else { tv->tv_sec = timeout / 1000; tv->tv_usec = (timeout % 1000) * 1000; ret = sizeof(*tv); } # else sz.i = sizeof(struct timeval); if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr, (void *)&sz) < 0) { perror("getsockopt"); ret = -1; } else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0) { OPENSSL_assert(sz.s <= sizeof(struct timeval)); ret = (int)sz.s; } else ret = sz.i; # endif } break; # endif # if defined(SO_SNDTIMEO) case BIO_CTRL_DGRAM_SET_SEND_TIMEOUT: # ifdef OPENSSL_SYS_WINDOWS { struct timeval *tv = (struct timeval *)ptr; int timeout = tv->tv_sec * 1000 + tv->tv_usec / 1000; if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, (void *)&timeout, sizeof(timeout)) < 0) { perror("setsockopt"); ret = -1; } } # else if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr, sizeof(struct timeval)) < 0) { perror("setsockopt"); ret = -1; } # endif break; case BIO_CTRL_DGRAM_GET_SEND_TIMEOUT: { union { size_t s; int i; } sz = { 0 }; # ifdef OPENSSL_SYS_WINDOWS int timeout; struct timeval *tv = (struct timeval *)ptr; sz.i = sizeof(timeout); if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, (void *)&timeout, &sz.i) < 0) { perror("getsockopt"); ret = -1; } else { tv->tv_sec = timeout / 1000; tv->tv_usec = (timeout % 1000) * 1000; ret = sizeof(*tv); } # else sz.i = sizeof(struct timeval); if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr, (void *)&sz) < 0) { perror("getsockopt"); ret = -1; } else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0) { OPENSSL_assert(sz.s <= sizeof(struct timeval)); ret = (int)sz.s; } else ret = sz.i; # endif } break; # endif case BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP: /* fall-through */ case BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP: # ifdef OPENSSL_SYS_WINDOWS d_errno = (data->_errno == WSAETIMEDOUT); # else d_errno = (data->_errno == EAGAIN); # endif if (d_errno) { ret = 1; data->_errno = 0; } else ret = 0; break; # ifdef EMSGSIZE case BIO_CTRL_DGRAM_MTU_EXCEEDED: if (data->_errno == EMSGSIZE) { ret = 1; data->_errno = 0; } else ret = 0; break; # endif case BIO_CTRL_DGRAM_SET_DONT_FRAG: sockopt_val = num ? 1 : 0; switch (data->peer.sa.sa_family) { case AF_INET: # if defined(IP_DONTFRAG) if ((ret = setsockopt(b->num, IPPROTO_IP, IP_DONTFRAG, &sockopt_val, sizeof(sockopt_val))) < 0) { perror("setsockopt"); ret = -1; } # elif defined(OPENSSL_SYS_LINUX) && defined(IP_MTU_DISCOVER) && defined (IP_PMTUDISC_PROBE) if ((sockopt_val = num ? IP_PMTUDISC_PROBE : IP_PMTUDISC_DONT), (ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER, &sockopt_val, sizeof(sockopt_val))) < 0) { perror("setsockopt"); ret = -1; } # elif defined(OPENSSL_SYS_WINDOWS) && defined(IP_DONTFRAGMENT) if ((ret = setsockopt(b->num, IPPROTO_IP, IP_DONTFRAGMENT, (const char *)&sockopt_val, sizeof(sockopt_val))) < 0) { perror("setsockopt"); ret = -1; } # else ret = -1; # endif break; # if OPENSSL_USE_IPV6 case AF_INET6: # if defined(IPV6_DONTFRAG) if ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_DONTFRAG, (const void *)&sockopt_val, sizeof(sockopt_val))) < 0) { perror("setsockopt"); ret = -1; } # elif defined(OPENSSL_SYS_LINUX) && defined(IPV6_MTUDISCOVER) if ((sockopt_val = num ? IP_PMTUDISC_PROBE : IP_PMTUDISC_DONT), (ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER, &sockopt_val, sizeof(sockopt_val))) < 0) { perror("setsockopt"); ret = -1; } # else ret = -1; # endif break; # endif default: ret = -1; break; } break; case BIO_CTRL_DGRAM_GET_MTU_OVERHEAD: ret = dgram_get_mtu_overhead(data); break; /* * BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE is used here for compatibility * reasons. When BIO_CTRL_DGRAM_SET_PEEK_MODE was first defined its value * was incorrectly clashing with BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE. The * value has been updated to a non-clashing value. However to preserve * binary compatiblity we now respond to both the old value and the new one */ case BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE: case BIO_CTRL_DGRAM_SET_PEEK_MODE: data->peekmode = (unsigned int)num; break; default: ret = 0; break; } return (ret); } static int dgram_puts(BIO *bp, const char *str) { int n, ret; n = strlen(str); ret = dgram_write(bp, str, n); return (ret); } # ifndef OPENSSL_NO_SCTP const BIO_METHOD *BIO_s_datagram_sctp(void) { return (&methods_dgramp_sctp); } BIO *BIO_new_dgram_sctp(int fd, int close_flag) { BIO *bio; int ret, optval = 20000; int auth_data = 0, auth_forward = 0; unsigned char *p; struct sctp_authchunk auth; struct sctp_authchunks *authchunks; socklen_t sockopt_len; # ifdef SCTP_AUTHENTICATION_EVENT # ifdef SCTP_EVENT struct sctp_event event; # else struct sctp_event_subscribe event; # endif # endif bio = BIO_new(BIO_s_datagram_sctp()); if (bio == NULL) return (NULL); BIO_set_fd(bio, fd, close_flag); /* Activate SCTP-AUTH for DATA and FORWARD-TSN chunks */ auth.sauth_chunk = OPENSSL_SCTP_DATA_CHUNK_TYPE; ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk)); if (ret < 0) { BIO_vfree(bio); BIOerr(BIO_F_BIO_NEW_DGRAM_SCTP, ERR_R_SYS_LIB); ERR_add_error_data(1, "Ensure SCTP AUTH chunks are enabled in kernel"); return (NULL); } auth.sauth_chunk = OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE; ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk)); if (ret < 0) { BIO_vfree(bio); BIOerr(BIO_F_BIO_NEW_DGRAM_SCTP, ERR_R_SYS_LIB); ERR_add_error_data(1, "Ensure SCTP AUTH chunks are enabled in kernel"); return (NULL); } /* * Test if activation was successful. When using accept(), SCTP-AUTH has * to be activated for the listening socket already, otherwise the * connected socket won

Ensure SCTP AUTH chunks are enabled on the

underlying socket

t partially deliver below max record size * (2^14 + 2048 + 13) */ optlen = (socklen_t) sizeof(int); ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT, &optval, &optlen); if (ret >= 0) OPENSSL_assert(optval >= 18445); /* * Partially delivered notification??? Probably a bug.... */ OPENSSL_assert(!(msg.msg_flags & MSG_NOTIFICATION)); /* * Everything seems ok till now, so it

re send anything else than application data, disable all user * parameters and flags. */ if (in[0] != 23) { memset(&handshake_sinfo, 0, sizeof(handshake_sinfo)); # ifdef SCTP_SACK_IMMEDIATELY handshake_sinfo.snd_flags = SCTP_SACK_IMMEDIATELY; # endif sinfo = &handshake_sinfo; } /* We can only send a shutdown alert if the socket is dry */ if (data->save_shutdown) { ret = BIO_dgram_sctp_wait_for_dry(b); if (ret < 0) return -1; if (ret == 0) { BIO_clear_retry_flags(b); BIO_set_retry_write(b); return -1; } } iov[0].iov_base = (char *)in; iov[0].iov_len = inl; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_iov = iov; msg.msg_iovlen = 1; msg.msg_control = (caddr_t) cmsgbuf; msg.msg_controllen = 0; msg.msg_flags = 0; # if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO) cmsg = (struct cmsghdr *)cmsgbuf; cmsg->cmsg_level = IPPROTO_SCTP; cmsg->cmsg_type = SCTP_SNDINFO; cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndinfo)); sndinfo = (struct sctp_sndinfo *)CMSG_DATA(cmsg); memset(sndinfo, 0, sizeof(*sndinfo)); sndinfo->snd_sid = sinfo->snd_sid; sndinfo->snd_flags = sinfo->snd_flags; sndinfo->snd_ppid = sinfo->snd_ppid; sndinfo->snd_context = sinfo->snd_context; msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndinfo)); cmsg = (struct cmsghdr *)&cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo))]; cmsg->cmsg_level = IPPROTO_SCTP; cmsg->cmsg_type = SCTP_PRINFO; cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_prinfo)); prinfo = (struct sctp_prinfo *)CMSG_DATA(cmsg); memset(prinfo, 0, sizeof(*prinfo)); prinfo->pr_policy = pinfo->pr_policy; prinfo->pr_value = pinfo->pr_value; msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_prinfo)); # else cmsg = (struct cmsghdr *)cmsgbuf; cmsg->cmsg_level = IPPROTO_SCTP; cmsg->cmsg_type = SCTP_SNDRCV; cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo)); sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg); memset(sndrcvinfo, 0, sizeof(*sndrcvinfo)); sndrcvinfo->sinfo_stream = sinfo->snd_sid; sndrcvinfo->sinfo_flags = sinfo->snd_flags; # ifdef __FreeBSD__ sndrcvinfo->sinfo_flags |= pinfo->pr_policy; # endif sndrcvinfo->sinfo_ppid = sinfo->snd_ppid; sndrcvinfo->sinfo_context = sinfo->snd_context; sndrcvinfo->sinfo_timetolive = pinfo->pr_value; msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndrcvinfo)); # endif ret = sendmsg(b->num, &msg, 0); BIO_clear_retry_flags(b); if (ret <= 0) { if (BIO_dgram_should_retry(ret)) { BIO_set_retry_write(b); data->_errno = get_last_socket_error(); } } return (ret); } static long dgram_sctp_ctrl(BIO *b, int cmd, long num, void *ptr) { long ret = 1; bio_dgram_sctp_data *data = NULL; socklen_t sockopt_len = 0; struct sctp_authkeyid authkeyid; struct sctp_authkey *authkey = NULL; data = (bio_dgram_sctp_data *) b->ptr; switch (cmd) { case BIO_CTRL_DGRAM_QUERY_MTU: /* * Set to maximum (2^14) and ignore user input to enable transport * protocol fragmentation. Returns always 2^14. */ data->mtu = 16384; ret = data->mtu; break; case BIO_CTRL_DGRAM_SET_MTU: /* * Set to maximum (2^14) and ignore input to enable transport * protocol fragmentation. Returns always 2^14. */ data->mtu = 16384; ret = data->mtu; break; case BIO_CTRL_DGRAM_SET_CONNECTED: case BIO_CTRL_DGRAM_CONNECT: /* Returns always -1. */ ret = -1; break; case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: /* * SCTP doesn

t have anything to send anymore. This is only received by * the peer

0x00

0xc0

0x0000ffff)))

