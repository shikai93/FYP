Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The PPKI stuff has been donated by Jeff Barber <jeffb@issl.atl.hp.com>

Additional revocation information types

Valid (not-revoked) status

No additional information

Value is CRL reason code

Value is hold instruction

Value is cert key compromise time

Value is CA key compromise time

Do not change the order here; see related case statements below

preserve=1;

:= REV_CRL_REASON

Lets get the config section we are using

BIO_printf(bio_err,"problems opening %s for extra oid's\n",p); ERR_print_errors(bio_err);



report status of cert with serial number given on command line



we definitely need a private key, so let's get it

load_key() has already printed an appropriate message



we need a certificate



lookup where to write new certificates

outdir is a directory spec, but access() for VMS demands a filename. We could use the DEC C routine to convert the directory syntax to Unixly, and give that to app_isdir, but for now the fopen will catch the error if it's not a directory



we need to load the database file

Lets check some fields



Update the db file for expired certificates



Read extensions config file

We can have sections in the ext file



FIXME: Is it really always text?

no '-extfile' option, so we look for extensions in the main configuration file

Check syntax of file

we have a stack of newly certified certificates and a data base and serial number that need updating

Rename the database and the serial file



Check syntax of file

sort the data so it will be written in serial number order

we now have a CRL

Add any extensions asked for

version 2 CRL

we have a CRL number that need updating

Rename the crlnumber file



assume all type should be strings

If no EMAIL is wanted in the subject

check some things

Ok, now we check the 'policy' stuff.

take a copy of the issuer name before we mess with it.

get the object id

lookup the object in the supplied name list

depending on the 'policy', decide what to do.

subject=X509_NAME_dup(X509_REQ_get_subject_name(req));

Build the correct Subject if no e-mail is wanted in the subject. And add it later on because of the method extensions are added (altName)

Its best to dup the subject DN and then delete any email addresses because this retains its structure.

This is now a 'bad' error.

We are now totally happy, lets make and sign the certificate

Make it an X509 v3 certificate.

Lets add the extensions, if there are any

Initialize the context structure

Use the extconf configuration db LHASH

Test the structure (needed?)

X509V3_set_ctx_test(&ctx);

Adds exts contained in the configuration file

We found extensions to be set from config file

Copy extensions from request (if any)

Set the right value for the noemailDN option

Never print signature details because signature not present

We now just add it to the database as DB_TYPE_VAL('V')

Load input file into a hash table. (This is just an easy way to read and parse the file, then put it into a convenient STACK format).

Now create a dummy X509 request structure. We don't actually have an X509 request, but we have many of the components (a public key, various DN components). The idea is that we put these components into the right X509 request structure and we can use the same code as if you had a real X509 request.

Build up the subject name set.

Skip past any leading X. X: X, etc to allow for multiple instances

Now extract the key from the SPKI structure.

We have to lookup by serial number because name lookup skips revoked certs

We now just add it to the database as DB_TYPE_REV('V')

Revoke Certificate

Retry revocation after DB insertion

Free Resources

Malloc needed char spaces

Set the first char to 0

Copy String from serial to row[DB_serial]

Copy String from serial to row[DB_serial]

Make it Upper Case

Search for the certificate

flags = 1 if y >= 2000

get actual time and make a string

ignore entries that are not valid

all on the same y2k side

CRL reason strings

Additional pseudo reasons

Given revocation information convert to a DB string. The format of the string is: revtime[,reason,extra]. Where 'revtime' is the revocation time (the current time). 'reason' is the optional CRL reason and 'extra' is any additional argument

Argument is an OID

Argument is the key compromise time

Convert revocation field to X509_REVOKED entry return code: 0 error 1 OK 2 OK and some extensions added (i.e. V2 CRL)

Hold instruction

www.openssl.org/source/license.html

License

apps.h

ca

default_ca

string_mask

utf8

new_certs_dir

certificate

serial

rand_serial

crlnumber

private_key

default_days

default_startdate

default_enddate

default_crl_days

default_crl_hours

default_md

email_in_dn

preserve

policy

x509_extensions

crl_extensions

msie_hack

name_opt

cert_opt

copy_extensions

unique_subject

database

help

-

Display this summary

verbose

-

Verbose output during processing

config

s

A config file

name

s

The particular CA definition to use

subj

s

Use arg instead of request's subject

utf8

-

Input characters are UTF8 (default ASCII)

create_serial

-

If reading serial fails, create a new random serial

rand_serial

-

Always create a random serial; do not store it

multivalue-rdn

-

Enable support for multivalued RDNs

startdate

s

Cert notBefore, YYMMDDHHMMSSZ

enddate

s

YYMMDDHHMMSSZ cert notAfter (overrides -days)

days

p

Number of days to certify the cert for

md

s

md to use; one of md2, md5, sha or sha1

policy

s

The CA 'policy' to support

keyfile

s

Private key

keyform

f

Private key file format (PEM or ENGINE)

passin

s

Input file pass phrase source

key

s

Key to decode the private key if it is encrypted

cert

<

The CA cert

selfsign

-

Sign a cert with the key associated with it

in

<

The input PEM encoded cert request(s)

out

>

Where to put the output file(s)

outdir

/

Where to put output cert

sigopt

s

Signature parameter in n:v form

notext

-

Do not print the generated certificate

batch

-

Don't ask questions

preserveDN

-

Don't re-order the DN

noemailDN

-

Don't add the EMAIL field to the DN

gencrl

-

Generate a new CRL

msie_hack

-

msie modifications to handle all those universal strings

crldays

p

Days until the next CRL is due

crlhours

p

Hours until the next CRL is due

crlsec

p

Seconds until the next CRL is due

infiles

-

The last argument, requests to process

ss_cert

<

File contains a self signed cert to sign

spkac

<

File contains DN and signed public key and challenge

revoke

<

Revoke a cert (given in file)

valid

s

Add a Valid(not-revoked) DB entry about a cert (given in file)

extensions

s

Extension section (override value in config file)

extfile

<

Configuration file with X509v3 extensions to add

status

s

Shows cert status given the serial number

updatedb

-

Updates db for expired cert

crlexts

s

CRL extension section (override value in config file)

crl_reason

s

revocation reason

crl_hold

s

the hold instruction, an OID. Sets revocation reason to certificateHold

crl_compromise

s

sets compromise time to val and the revocation reason to keyCompromise

crl_CA_compromise

s

sets compromise time to val and the revocation reason to CACompromise

engine

s

Use engine, possibly a hardware device

\0

\0

%s: Use -help for summary.\n

Using configuration from %s\n

oid_file

r

problems opening %s for extra oid's\n

Invalid global string mask setting %s\n

yes

Error verifying serial %s!\n

s get it */ if (keyfile == NULL && (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL) goto end; if (key == NULL) { free_key = 1; if (!app_passwd(passinarg, NULL, &key, NULL)) { BIO_printf(bio_err, "Error getting password\n"); goto end; } } pkey = load_key(keyfile, keyformat, 0, key, e, "CA private key"); if (key != NULL) OPENSSL_cleanse(key, strlen(key)); if (pkey == NULL) /* load_key() has already printed an appropriate message */ goto end; /*****************************************************************/ /* we need a certificate */ if (!selfsign || spkac_file || ss_cert_file || gencrl) { if (certfile == NULL && (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL) goto end; x509 = load_cert(certfile, FORMAT_PEM, "CA certificate"); if (x509 == NULL) goto end; if (!X509_check_private_key(x509, pkey)) { BIO_printf(bio_err, "CA certificate and CA private key do not match\n"); goto end; } } if (!selfsign) x509p = x509; f = NCONF_get_string(conf, BASE_SECTION, ENV_PRESERVE); if (f == NULL) ERR_clear_error(); if ((f != NULL) && ((*f ==

) || (*f ==

))) preserve = 1; f = NCONF_get_string(conf, BASE_SECTION, ENV_MSIE_HACK); if (f == NULL) ERR_clear_error(); if ((f != NULL) && ((*f ==

) || (*f ==

))) msie_hack = 1; f = NCONF_get_string(conf, section, ENV_NAMEOPT); if (f != NULL) { if (!set_nameopt(f)) { BIO_printf(bio_err, "Invalid name options: \"%s\"\n", f); goto end; } default_op = 0; } f = NCONF_get_string(conf, section, ENV_CERTOPT); if (f != NULL) { if (!set_cert_ex(&certopt, f)) { BIO_printf(bio_err, "Invalid certificate options: \"%s\"\n", f); goto end; } default_op = 0; } else { ERR_clear_error(); } f = NCONF_get_string(conf, section, ENV_EXTCOPY); if (f != NULL) { if (!set_ext_copy(&ext_copy, f)) { BIO_printf(bio_err, "Invalid extension copy option: \"%s\"\n", f); goto end; } } else { ERR_clear_error(); } /*****************************************************************/ /* lookup where to write new certificates */ if ((outdir == NULL) && (req)) { outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR); if (outdir == NULL) { BIO_printf(bio_err, "there needs to be defined a directory for new certificate to be placed in\n"); goto end; } #ifndef OPENSSL_SYS_VMS /* * outdir is a directory spec, but access() for VMS demands a * filename. We could use the DEC C routine to convert the * directory syntax to Unixly, and give that to app_isdir, * but for now the fopen will catch the error if it

%s: %s is not a directory\n

\0

entry %d: not revoked yet, but has a revocation date\n

in entry %d\n

entry %d: invalid expiry date\n

-

entry %d: bad serial number length (%d)\n

entry %d: bad char 0%o '%c' in serial number\n

%d entries loaded from the database\n

generating index\n

Updating %s ...\n

Malloc failure\n

No entries found to mark expired\n

new

new

old

Done. %d entries marked as expired\n

Successfully loaded extensions file %s\n

default

extensions

default

w

default

no default digest\n

no

message digest is %s\n

policy is %s\n

-extfile

Error Loading extension section %s\n

start date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n

today

end date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n

cannot lookup how many days to certify for\n

error generating serial number\n

error while loading serial number\n

next serial number is 00\n

next serial number is %s\n

unable to find 'section' for %s\n

Memory allocation failure\n

\n

Memory allocation failure\n

\n

Memory allocation failure\n

\n

Memory allocation failure\n

\n

Memory allocation failure\n

\n%d out of %d certificate requests certified, commit? [y/n]

\0

CERTIFICATION CANCELED: I/O error\n

y

Y

CERTIFICATION CANCELED\n

Write out database with %d new entries\n

new

new

writing new certificates\n

certificate file name too long\n

/

%02X

0

0

.

p

e

m

\0

writing %s\n

w

new

old

new

old

Data Base Updated\n

Error Loading CRL extension section %s\n

error while loading CRL number\n

cannot lookup how long until the next CRL is issued\n

making CRL\n

error setting CRL nextUpdate\n

signing CRL\n

new

new

old

no input files\n

new

new

old

Data Base Updated\n

variable lookup failed for %s::%s\n

r

Error reading certificate request in %s\n

Check that the request matches the signature\n

Certificate request and CA private key do not match\n

error unpacking public key\n

Signature verification problems....\n

Signature did not match the certificate request\n

Signature ok\n

Check that the request matches the signature\n

error unpacking public key\n

Signature verification problems....\n

Signature did not match the certificate\n

Signature ok\n

The Subject's Distinguished Name is as follows\n

\nemailAddress type needs to be of type IA5STRING\n

\nThe string contains characters that are illegal for the ASN.1 type\n

policy

Memory allocation failure\n

%s:unknown object type in 'policy' configuration\n

policy

optional

supplied

The %s field needed to be supplied and was missing\n

match

The mandatory %s field was missing\n

The %s field does not exist in the CA certificate,\n

the 'policy' is misconfigured\n

The %s field is different between\n

CA certificate (%s) and the request (%s)\n

NULL

NULL

%s:invalid type in 'policy' configuration\n

Memory allocation failure\n

The subject name appears to be ok, checking data base for clashes\n

Memory allocation failure\n

00

Memory allocation failure\n

ERROR:There is already a certificate for %s\n

ERROR:Serial number %s has already been issued,\n

check the database/serial_file for corruption\n

The matching entry has the following details\n

Expired

Revoked

Valid

\ninvalid type, Data base error\n

Type :%s\n

undef

Was revoked on:%s\n

undef

Expires on :%s\n

undef

Serial Number :%s\n

undef

File name :%s\n

undef

Subject Name :%s\n

bad

Everything appears to be ok, creating and signing the certificate\n

Extra configuration file found\n

ERROR: adding extensions in section %s\n

Successfully added extensions from file.\n

ERROR: adding extensions in section %s\n

Successfully added extensions from config\n

ERROR: adding extensions from request\n

Certificate Details:\n

Certificate is to be certified until

(%ld days)

\n

Sign the certificate? [y/n]:

\0

CERTIFICATE WILL NOT BE CERTIFIED: I/O error\n

y

Y

CERTIFICATE WILL NOT BE CERTIFIED\n

V

V

row expdate

\0

unknown

Memory allocation failure\n

row space

failed to update database\n

TXT_DB error number %ld\n

error on line %ld of %s\n

default

no name/value pairs found in %s\n

t actually * have an X509 request, but we have many of the components * (a public key, various DN components). The idea is that we * put these components into the right X509 request structure * and we can use the same code as if you had a real X509 request. */ req = X509_REQ_new(); if (req == NULL) { ERR_print_errors(bio_err); goto end; } /* * Build up the subject name set. */ n = X509_REQ_get_subject_name(req); for (i = 0;; i++) { if (sk_CONF_VALUE_num(sk) <= i) break; cv = sk_CONF_VALUE_value(sk, i); type = cv->name; /* * Skip past any leading X. X: X, etc to allow for multiple instances */ for (buf = cv->name; *buf; buf++) if ((*buf ==

) || (*buf ==

) || (*buf ==

)) { buf++; if (*buf) type = buf; break; } buf = cv->value; if ((nid = OBJ_txt2nid(type)) == NID_undef) { if (strcmp(type, "SPKAC") == 0) { spki = NETSCAPE_SPKI_b64_decode(cv->value, -1); if (spki == NULL) { BIO_printf(bio_err, "unable to load Netscape SPKAC structure\n"); ERR_print_errors(bio_err); goto end; } } continue; } if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char *)buf, -1, -1, 0)) goto end; } if (spki == NULL) { BIO_printf(bio_err, "Netscape SPKAC structure not found in %s\n", infile); goto end; } /* * Now extract the key from the SPKI structure. */ BIO_printf(bio_err, "Check that the SPKAC request matches the signature\n"); if ((pktmp = NETSCAPE_SPKI_get_pubkey(spki)) == NULL) { BIO_printf(bio_err, "error unpacking SPKAC public key\n"); goto end; } j = NETSCAPE_SPKI_verify(spki, pktmp); if (j <= 0) { EVP_PKEY_free(pktmp); BIO_printf(bio_err, "signature verification failed on SPKAC public key\n"); goto end; } BIO_printf(bio_err, "Signature ok\n"); X509_REQ_set_pubkey(req, pktmp); EVP_PKEY_free(pktmp); ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial, subj, chtype, multirdn, email_dn, startdate, enddate, days, 1, verbose, req, ext_sect, lconf, certopt, nameopt, default_op, ext_copy, 0); end: X509_REQ_free(req); CONF_free(parms); NETSCAPE_SPKI_free(spki); X509_NAME_ENTRY_free(ne); return (ok); } static int check_time_format(const char *str) { return ASN1_TIME_set_string(NULL, str); } static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type, const char *value) { const ASN1_TIME *tm = NULL; char *row[DB_NUMBER], **rrow, **irow; char *rev_str = NULL; BIGNUM *bn = NULL; int ok = -1, i; for (i = 0; i < DB_NUMBER; i++) row[i] = NULL; row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0); bn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509), NULL); if (!bn) goto end; if (BN_is_zero(bn)) row[DB_serial] = OPENSSL_strdup("00"); else row[DB_serial] = BN_bn2hex(bn); BN_free(bn); if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) { BIO_printf(bio_err, "Memory allocation failure\n"); goto end; } /* * We have to lookup by serial number because name lookup skips revoked * certs */ rrow = TXT_DB_get_by_index(db->db, DB_serial, row); if (rrow == NULL) { BIO_printf(bio_err, "Adding Entry with serial number %s to DB for %s\n", row[DB_serial], row[DB_name]); /* We now just add it to the database as DB_TYPE_REV(

) */ row[DB_type] = OPENSSL_strdup("V"); tm = X509_get0_notAfter(x509); row[DB_exp_date] = app_malloc(tm->length + 1, "row exp_data"); memcpy(row[DB_exp_date], tm->data, tm->length); row[DB_exp_date][tm->length] =

; row[DB_rev_date] = NULL; row[DB_file] = OPENSSL_strdup("unknown"); if (row[DB_type] == NULL || row[DB_file] == NULL) { BIO_printf(bio_err, "Memory allocation failure\n"); goto end; } irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), "row ptr"); for (i = 0; i < DB_NUMBER; i++) irow[i] = row[i]; irow[DB_NUMBER] = NULL; if (!TXT_DB_insert(db->db, irow)) { BIO_printf(bio_err, "failed to update database\n"); BIO_printf(bio_err, "TXT_DB error number %ld\n", db->db->error); OPENSSL_free(irow); goto end; } for (i = 0; i < DB_NUMBER; i++) row[i] = NULL; /* Revoke Certificate */ if (rev_type == REV_VALID) ok = 1; else /* Retry revocation after DB insertion */ ok = do_revoke(x509, db, rev_type, value); goto end; } else if (index_name_cmp_noconst(row, rrow)) { BIO_printf(bio_err, "ERROR:name does not match %s\n", row[DB_name]); goto end; } else if (rev_type == REV_VALID) { BIO_printf(bio_err, "ERROR:Already present, serial number %s\n", row[DB_serial]); goto end; } else if (rrow[DB_type][0] == DB_TYPE_REV) { BIO_printf(bio_err, "ERROR:Already revoked, serial number %s\n", row[DB_serial]); goto end; } else { BIO_printf(bio_err, "Revoking Certificate %s.\n", rrow[DB_serial]); rev_str = make_revocation_str(rev_type, value); if (!rev_str) { BIO_printf(bio_err, "Error in revocation arguments\n"); goto end; } rrow[DB_type][0] = DB_TYPE_REV; rrow[DB_type][1] =

; rrow[DB_rev_date] = rev_str; } ok = 1; end: for (i = 0; i < DB_NUMBER; i++) OPENSSL_free(row[i]); return (ok); } static int get_certificate_status(const char *serial, CA_DB *db) { char *row[DB_NUMBER], **rrow; int ok = -1, i; size_t serial_len = strlen(serial); /* Free Resources */ for (i = 0; i < DB_NUMBER; i++) row[i] = NULL; /* Malloc needed char spaces */ row[DB_serial] = app_malloc(serial_len + 2, "row serial#"); if (serial_len % 2) { /* * Set the first char to 0 */ row[DB_serial][0] =

; /* Copy String from serial to row[DB_serial] */ memcpy(row[DB_serial] + 1, serial, serial_len); row[DB_serial][serial_len + 1] =

; } else { /* Copy String from serial to row[DB_serial] */ memcpy(row[DB_serial], serial, serial_len); row[DB_serial][serial_len] =

; } /* Make it Upper Case */ make_uppercase(row[DB_serial]); ok = 1; /* Search for the certificate */ rrow = TXT_DB_get_by_index(db->db, DB_serial, row); if (rrow == NULL) { BIO_printf(bio_err, "Serial %s not present in db.\n", row[DB_serial]); ok = -1; goto end; } else if (rrow[DB_type][0] == DB_TYPE_VAL) { BIO_printf(bio_err, "%s=Valid (%c)\n", row[DB_serial], rrow[DB_type][0]); goto end; } else if (rrow[DB_type][0] == DB_TYPE_REV) { BIO_printf(bio_err, "%s=Revoked (%c)\n", row[DB_serial], rrow[DB_type][0]); goto end; } else if (rrow[DB_type][0] == DB_TYPE_EXP) { BIO_printf(bio_err, "%s=Expired (%c)\n", row[DB_serial], rrow[DB_type][0]); goto end; } else if (rrow[DB_type][0] == DB_TYPE_SUSP) { BIO_printf(bio_err, "%s=Suspended (%c)\n", row[DB_serial], rrow[DB_type][0]); goto end; } else { BIO_printf(bio_err, "%s=Unknown (%c).\n", row[DB_serial], rrow[DB_type][0]); ok = -1; } end: for (i = 0; i < DB_NUMBER; i++) { OPENSSL_free(row[i]); } return (ok); } static int do_updatedb(CA_DB *db) { ASN1_UTCTIME *a_tm = NULL; int i, cnt = 0; int db_y2k, a_y2k; /* flags = 1 if y >= 2000 */ char **rrow, *a_tm_s; a_tm = ASN1_UTCTIME_new(); if (a_tm == NULL) return -1; /* get actual time and make a string */ a_tm = X509_gmtime_adj(a_tm, 0); a_tm_s = app_malloc(a_tm->length + 1, "time string"); memcpy(a_tm_s, a_tm->data, a_tm->length); a_tm_s[a_tm->length] =

; if (strncmp(a_tm_s, "49", 2) <= 0) a_y2k = 1; else a_y2k = 0; for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) { rrow = sk_OPENSSL_PSTRING_value(db->db->data, i); if (rrow[DB_type][0] == DB_TYPE_VAL) { /* ignore entries that are not valid */ if (strncmp(rrow[DB_exp_date], "49", 2) <= 0) db_y2k = 1; else db_y2k = 0; if (db_y2k == a_y2k) { /* all on the same y2k side */ if (strcmp(rrow[DB_exp_date], a_tm_s) <= 0) { rrow[DB_type][0] = DB_TYPE_EXP; rrow[DB_type][1] =

; cnt++; BIO_printf(bio_err, "%s=Expired\n", rrow[DB_serial]); } } else if (db_y2k < a_y2k) { rrow[DB_type][0] = DB_TYPE_EXP; rrow[DB_type][1] =

; cnt++; BIO_printf(bio_err, "%s=Expired\n", rrow[DB_serial]); } } } ASN1_UTCTIME_free(a_tm); OPENSSL_free(a_tm_s); return (cnt); } static const char *crl_reasons[] = { /* CRL reason strings */ "unspecified", "keyCompromise", "CACompromise", "affiliationChanged", "superseded", "cessationOfOperation", "certificateHold", "removeFromCRL", /* Additional pseudo reasons */ "holdInstruction", "keyTime", "CAkeyTime" }; #define NUM_REASONS OSSL_NELEM(crl_reasons) /* * Given revocation information convert to a DB string. The format of the * string is: revtime[,reason,extra]. Where

is the revocation time * (the current time).

is the optional CRL reason and

is any * additional argument */ static char *make_revocation_str(REVINFO_TYPE rev_type, const char *rev_arg) { char *str; const char *reason = NULL, *other = NULL; ASN1_OBJECT *otmp; ASN1_UTCTIME *revtm = NULL; int i; switch (rev_type) { case REV_NONE: case REV_VALID: break; case REV_CRL_REASON: for (i = 0; i < 8; i++) { if (strcasecmp(rev_arg, crl_reasons[i]) == 0) { reason = crl_reasons[i]; break; } } if (reason == NULL) { BIO_printf(bio_err, "Unknown CRL reason %s\n", rev_arg); return NULL; } break; case REV_HOLD: /* Argument is an OID */ otmp = OBJ_txt2obj(rev_arg, 0); ASN1_OBJECT_free(otmp); if (otmp == NULL) { BIO_printf(bio_err, "Invalid object identifier %s\n", rev_arg); return NULL; } reason = "holdInstruction"; other = rev_arg; break; case REV_KEY_COMPROMISE: case REV_CA_COMPROMISE: /* Argument is the key compromise time */ if (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg)) { BIO_printf(bio_err, "Invalid time format %s. Need YYYYMMDDHHMMSSZ\n", rev_arg); return NULL; } other = rev_arg; if (rev_type == REV_KEY_COMPROMISE) reason = "keyTime"; else reason = "CAkeyTime"; break; } revtm = X509_gmtime_adj(NULL, 0); if (!revtm) return NULL; i = revtm->length + 1; if (reason) i += strlen(reason) + 1; if (other) i += strlen(other) + 1; str = app_malloc(i, "revocation reason"); OPENSSL_strlcpy(str, (char *)revtm->data, i); if (reason) { OPENSSL_strlcat(str, ",", i); OPENSSL_strlcat(str, reason, i); } if (other) { OPENSSL_strlcat(str, ",", i); OPENSSL_strlcat(str, other, i); } ASN1_UTCTIME_free(revtm); return str; } /*- * Convert revocation field to X509_REVOKED entry * return code: * 0 error * 1 OK * 2 OK and some extensions added (i.e. V2 CRL) */ static int make_revoked(X509_REVOKED *rev, const char *str) { char *tmp = NULL; int reason_code = -1; int i, ret = 0; ASN1_OBJECT *hold = NULL; ASN1_GENERALIZEDTIME *comp_time = NULL; ASN1_ENUMERATED *rtmp = NULL; ASN1_TIME *revDate = NULL; i = unpack_revinfo(&revDate, &reason_code, &hold, &comp_time, str); if (i == 0) goto end; if (rev && !X509_REVOKED_set_revocationDate(rev, revDate)) goto end; if (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)) { rtmp = ASN1_ENUMERATED_new(); if (rtmp == NULL || !ASN1_ENUMERATED_set(rtmp, reason_code)) goto end; if (!X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rtmp, 0, 0)) goto end; } if (rev && comp_time) { if (!X509_REVOKED_add1_ext_i2d (rev, NID_invalidity_date, comp_time, 0, 0)) goto end; } if (rev && hold) { if (!X509_REVOKED_add1_ext_i2d (rev, NID_hold_instruction_code, hold, 0, 0)) goto end; } if (reason_code != OCSP_REVOKED_STATUS_NOSTATUS) ret = 2; else ret = 1; end: OPENSSL_free(tmp); ASN1_OBJECT_free(hold); ASN1_GENERALIZEDTIME_free(comp_time); ASN1_ENUMERATED_free(rtmp); ASN1_TIME_free(revDate); return ret; } static int old_entry_print(const ASN1_OBJECT *obj, const ASN1_STRING *str) { char buf[25], *pbuf; const char *p; int j; j = i2a_ASN1_OBJECT(bio_err, obj); pbuf = buf; for (j = 22 - j; j > 0; j--) *(pbuf++) =

; *(pbuf++) =

; *(pbuf++) =

; BIO_puts(bio_err, buf); if (str->type == V_ASN1_PRINTABLESTRING) BIO_printf(bio_err, "PRINTABLE:

); else if (str->type == V_ASN1_T61STRING) BIO_printf(bio_err,

"); else if (str->type == V_ASN1_IA5STRING) BIO_printf(bio_err, "IA5STRING:

); else if (str->type == V_ASN1_UNIVERSALSTRING) BIO_printf(bio_err,

"); else BIO_printf(bio_err, "ASN.1 %2d:

, str->type); p = (const char *)str->data; for (j = str->length; j > 0; j--) { if ((*p >= ' ') && (*p <= '~')) BIO_printf(bio_err,

, *p); else if (*p & 0x80) BIO_printf(bio_err,

, *p); else if ((unsigned char)*p == 0xf7) BIO_printf(bio_err,

); else BIO_printf(bio_err,

, *p + '@'); p++; } BIO_printf(bio_err,

\n"); return 1; } int unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, const char *str) { char *tmp; char *rtime_str, *reason_str = NULL, *arg_str = NULL, *p; int reason_code = -1; int ret = 0; unsigned int i; ASN1_OBJECT *hold = NULL; ASN1_GENERALIZEDTIME *comp_time = NULL; tmp = OPENSSL_strdup(str); if (!tmp) { BIO_printf(bio_err, "memory allocation failure\n"); goto end; } p = strchr(tmp,

); rtime_str = tmp; if (p) { *p =

; p++; reason_str = p; p = strchr(p,

); if (p) { *p =

memory allocation failure\n

invalid revocation date %s\n

invalid reason code %s\n

missing hold instruction\n

invalid object identifier %s\n

missing compromised time\n

memory allocation failure\n

invalid compromised time %s\n

0x80)

0x%02X",

0xf7)

