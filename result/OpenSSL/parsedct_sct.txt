Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Just need cached encoding

if we aren't sure, leave the log entry type alone

With an unrecognized SCT version we don't know what such an SCT means, let alone validate one. So we return validation failure (0).

Similarly, an SCT from an unknown log also cannot be validated.

XXX: Potential for optimization. This repeats some idempotent heavy lifting on the certificate for each candidate SCT, and appears to not use any information in the SCT itself, only the certificate is processed. So it may make more sense to to do this just once, perhaps associated with the shared (by all SCTs) policy eval ctx. XXX: Failure here is global (SCT independent) and represents either an issue with the certificate (e.g. duplicate extensions) or an out of memory condition. When the certificate is incompatible with CT, we just mark the SCTs invalid, rather than report a failure to determine the validation status. That way, callbacks that want to do "soft" SCT processing will not abort handshakes with false positive internal errors. Since the function does not distinguish between certificate issues (peer's fault) and internal problems (out fault) the safe thing to do is to report a validation failure and let the callback or application decide what to do.

www.openssl.org/source/license.html

License

CT disabled

ct_locl.h

t sure, leave the log entry type alone */ return 1; } sct_validation_status_t SCT_get_validation_status(const SCT *sct) { return sct->validation_status; } int SCT_validate(SCT *sct, const CT_POLICY_EVAL_CTX *ctx) { int is_sct_valid = -1; SCT_CTX *sctx = NULL; X509_PUBKEY *pub = NULL, *log_pkey = NULL; const CTLOG *log; /* * With an unrecognized SCT version we don

soft

