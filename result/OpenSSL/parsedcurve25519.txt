Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This code is mostly taken from the ref10 version of Ed25519 in SUPERCOP 20141124 (http://bench.cr.yp.to/supercop.html). The field functions are shared by Ed25519 and X25519 where possible.

fe means field element. Here the field is \Z/(2^255-19). An element t, entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77 t[3]+2^102 t[4]+...+2^230 t[9]. Bounds on each t[i] vary depending on context.

Ignores top bit of h.

Preconditions: |h| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc. Write p=2^255-19; q=floor(h/p). Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))). Proof: Have |h|<=p so |q|<=1 so |19^2 2^(-255) q|<1/4. Also have |h-2^230 h9|<2^231 so |19 2^(-255)(h-2^230 h9)|<1/4. Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9). Then 0<y<1. Write r=h-pq. Have 0<=r<=p-1=2^255-20. Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1. Write x=r+19(2^-255)r+y. Then 0<x<2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q. Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1)) so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.

Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20.

Goal: Output h-2^255 q, which is between 0 and 2^255-20.

h10 = carry9

Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20. Have h0+...+2^230 h9 between 0 and 2^255-1; evidently 2^255 h10-2^255 q = 0. Goal: Output h0+...+2^230 h9.

h = f

h = 0

h = 1

h = f + g Can overlap h with f or g. Preconditions: |f| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc. |g| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc. Postconditions: |h| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc.

h = f - g Can overlap h with f or g. Preconditions: |f| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc. |g| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc. Postconditions: |h| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc.

h = f g Can overlap h with f or g. Preconditions: |f| bounded by 1.652^26,1.652^25,1.652^26,1.652^25,etc. |g| bounded by 1.652^26,1.652^25,1.652^26,1.652^25,etc. Postconditions: |h| bounded by 1.012^25,1.012^24,1.012^25,1.012^24,etc. Notes on implementation strategy: Using schoolbook multiplication. Karatsuba would save a little in some cost models. Most multiplications by 2 and 19 are 32-bit precomputations; cheaper than 64-bit postcomputations. There is one remaining multiplication by 19 in the carry chain; one 19 precomputation can be merged into this, but the resulting data flow is considerably less clean. There are 12 carries below. 10 of them are 2-way parallelizable and vectorizable. Can get away with 11 carries, but then data flow is much deeper. With tighter constraints on inputs can squeeze carries into int32.

1.9593752^29

1.9593752^30; still ok

|h0| <= (1.651.652^52(1+19+19+19+19)+1.651.652^50(38+38+38+38+38)) i.e. |h0| <= 1.42^60; narrower ranges for h2, h4, h6, h8 |h1| <= (1.651.652^51(1+1+19+19+19+19+19+19+19+19)) i.e. |h1| <= 1.72^59; narrower ranges for h3, h5, h7, h9

|h0| <= 2^25

|h4| <= 2^25

|h1| <= 1.712^59

|h5| <= 1.712^59

|h1| <= 2^24; from now on fits into int32

|h5| <= 2^24; from now on fits into int32

|h2| <= 1.412^60

|h6| <= 1.412^60

|h2| <= 2^25; from now on fits into int32 unchanged

|h6| <= 2^25; from now on fits into int32 unchanged

|h3| <= 1.712^59

|h7| <= 1.712^59

|h3| <= 2^24; from now on fits into int32 unchanged

|h7| <= 2^24; from now on fits into int32 unchanged

|h4| <= 1.722^34

|h8| <= 1.412^60

|h4| <= 2^25; from now on fits into int32 unchanged

|h8| <= 2^25; from now on fits into int32 unchanged

|h5| <= 1.012^24

|h9| <= 1.712^59

|h9| <= 2^24; from now on fits into int32 unchanged

|h0| <= 1.12^39

|h0| <= 2^25; from now on fits into int32 unchanged

|h1| <= 1.012^24

h = f f Can overlap h with f. Preconditions: |f| bounded by 1.652^26,1.652^25,1.652^26,1.652^25,etc. Postconditions: |h| bounded by 1.012^25,1.012^24,1.012^25,1.012^24,etc. See fe_mul.c for discussion of implementation strategy.

1.9593752^30

1.9593752^30

1.9593752^30

1.9593752^30

1.9593752^30

Compute z -1 = z (2 255 - 19 - 2) with the exponent as 2 255 - 21 = (2 5) (2 250 - 1) + 11.

t0 = z 2

t1 = t0 (2 2) = z 8

t1 = z t1 = z 9

t0 = t0 t1 = z 11 -- stash t0 away for the end.

t2 = t0 2 = z 22

t1 = t1 t2 = z (2 5 - 1)

t2 = t1 (2 5) = z ((2 5) (2 5 - 1))

t1 = t1 t2 = z ((2 5 + 1) (2 5 - 1)) = z (2 10 - 1)

Continuing similarly...

t2 = z (2 20 - 1)

t2 = z (2 40 - 1)

t2 = z (2 10) (2 40 - 1)

t1 = z (2 50 - 1)

t2 = z (2 100 - 1)

t2 = z (2 200 - 1)

t2 = z ((2 50) (2 200 - 1)

t1 = z (2 250 - 1)

t1 = z ((2 5) (2 250 - 1))

Recall t0 = z 11; out = z (2 255 - 21)

h = -f Preconditions: |f| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc. Postconditions: |h| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc.

Replace (f,g) with (g,g) if b == 1; replace (f,g) with (f,g) if b == 0. Preconditions: b in {0,1}.

return 0 if f == 0 return 1 if f != 0 Preconditions: |f| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc.

return 1 if f is in {1,3,5,...,q-2} return 0 if f is in {0,2,4,...,q-1} Preconditions: |f| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc.

h = 2 f f Can overlap h with f. Preconditions: |f| bounded by 1.652^26,1.652^25,1.652^26,1.652^25,etc. Postconditions: |h| bounded by 1.012^25,1.012^24,1.012^25,1.012^24,etc. See fe_mul.c for discussion of implementation strategy.

1.9593752^30

1.9593752^30

1.9593752^30

1.9593752^30

1.9593752^30

ge means group element. Here the group is the set of pairs (x,y) of field elements (see fe.h) satisfying -x^2 + y^2 = 1 + d x^2y^2 where d = -121665/121666. Representations: ge_p2 (projective): (X:Y:Z) satisfying x=X/Z, y=Y/Z ge_p3 (extended): (X:Y:Z:T) satisfying x=X/Z, y=Y/Z, XY=ZT ge_p1p1 (completed): ((X:Z),(Y:T)) satisfying x=X/Z, y=Y/T ge_precomp (Duif): (y+x,y-x,2dxy)

u = y^2-1

v = dy^2+1

v3 = v^3

x = uv^7

x = (uv^7)^((q-5)/8)

x = uv^3(uv^7)^((q-5)/8)

vx^2-u

vx^2+u

r = p

r = p

r = p

r = p

r = 2 p

r = 2 p

r = p + q

r = p - q

r = p + q

r = p - q

0: yes; 1..255: no

0: yes; 1..255: no

4294967295: yes; 0..254: no

1: yes; 0: no

k25519Precomp[i][j] = (j+1)256^iB

1: yes; 0: no

h = a B where a = a[0]+256a[1]+...+256^31 a[31] B is the Ed25519 base point (x,4/5) with x positive. Preconditions: a[31] <= 127

each e[i] is between 0 and 15

e[63] is between 0 and 7

each e[i] is between -8 and 8

Replace (f,g) with (g,f) if b == 1; replace (f,g) with (f,g) if b == 0. Preconditions: b in {0,1}.

h = f 121666 Can overlap h with f. Preconditions: |f| bounded by 1.12^26,1.12^25,1.12^26,1.12^25,etc. Postconditions: |h| bounded by 1.12^25,1.12^24,1.12^25,1.12^24,etc.

r = a A + b B where a = a[0]+256a[1]+...+256^31 a[31]. and b = b[0]+256b[1]+...+256^31 b[31]. B is the Ed25519 base point (x,4/5) with x positive.

A,3A,5A,7A,9A,11A,13A,15A

The set of scalars is \Z/l where l = 2^252 + 27742317777372353535851937790883648493.

Input: s[0]+256s[1]+...+256^63s[63] = s Output: s[0]+256s[1]+...+256^31s[31] = s mod l where l = 2^252 + 27742317777372353535851937790883648493. Overwrites s in place.

Input: a[0]+256a[1]+...+256^31a[31] = a b[0]+256b[1]+...+256^31b[31] = b c[0]+256c[1]+...+256^31c[31] = c Output: s[0]+256s[1]+...+256^31s[31] = (ab+c) mod l where l = 2^252 + 27742317777372353535851937790883648493.

The all-zero output results when the input is a point of small order.

We only need the u-coordinate of the curve25519 point. The map is u=(y+1)/(1-y). Since y=Y/Z, this gives u=(Z+Y)/(Z-Y).

www.openssl.org/source/license.html

bench.cr.yp.to/supercop.html).

License

ec_lcl.h

0x1ffffffLL;

0x3ffffffLL;

0xfffffffffe000000LL;

0xfffffffffc000000LL;

