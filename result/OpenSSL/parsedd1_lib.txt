Copyright 2005-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

XDTLS: figure out the right values

2 hours, the 24 hours mentioned in the DTLSv1 spec is way too long for http, the cache would over fill

We may not have a BIO set yet so can't call dtls1_min_mtu() We'll have to make do with dtls1_link_min_mtu() and max overhead

Disable timer for SCTP

If timer is not set, initialize duration with 1 second

Set timeout to current time

Add duration to current time

If no timeout is set, just return NULL

Get current time

If timer already expired, set remaining time to 0

Calculate time left until timer expires

If remaining time is less than 15 ms, set it to 0 to prevent issues because of small divergences with socket timeouts.

Get time left until timeout, return false if no timer running

Return false if timer is not expired yet

Timer expired, so return true

Reset everything

Clear retransmission buffer

Reduce MTU after 2 unsuccessful retransmissions

fail the connection, enough alerts have been sent

if no timer is expired, don't do anything

re-bias to 1/1/1970

INDENT-OFF

INDENT-ON

Not properly initialized yet

Ensure there is no state left over from a previous invocation

We only peek at incoming ClientHello's until we're sure we are going to to respond with a HelloVerifyRequest. If its a ClientHello with a valid cookie then we leave it in the BIO for accept to handle.

Note: This check deliberately excludes DTLS1_BAD_VER because that version requires the MAC to be calculated including the first ClientHello (without the cookie). Since DTLSv1_listen is stateless that cannot be supported. DTLS1_BAD_VER must use cookies in a stateful manner (e.g. via SSL_accept)

Get a packet

Technically a ClientHello could be SSL3_RT_MAX_PLAIN_LENGTH + DTLS1_RT_HEADER_LENGTH bytes long. Normally init_buf does not store the record header as well, but we do here. We've set up init_buf to be the standard size for simplicity. In practice we shouldn't ever receive a ClientHello as long as this. If we do it will get dropped in the record length check below.

Non-blocking IO

If we hit any problems we need to clear this packet from the BIO

Parse the received record. If there are any problems with it we just dump it - with no alert. RFC6347 says this "Unlike TLS, DTLS is resilient in the face of invalid records (e.g., invalid formatting, length, MAC, etc.). In general, invalid records SHOULD be silently discarded, thus preserving the association; however, an error MAY be logged for diagnostic purposes."

this packet contained a partial record, dump it

Get the record header

Check record version number. We only check that the major version is the same.

Save the sequence number: 64 bits, with top 2 bytes = epoch

We allow data remaining at the end of the packet because there could be a second record (but we ignore it)

This is an initial ClientHello so the epoch has to be 0

Get a pointer to the raw message for the later callback

Finished processing the record header, now process the message

Message sequence number can only be 0 or 1

We don't support fragment reassembly for ClientHellos whilst listening because that would require server side state (which is against the whole point of the ClientHello/HelloVerifyRequest mechanism). Instead we only look at the first ClientHello fragment and require that the cookie must be contained within it.

Non initial ClientHello fragment (or bad fragment)

Verify client version is supported

Could be malformed or the cookie does not fit within the initial ClientHello fragment. Either way we can't handle it.

Check if we have a cookie or not. If not we need to send a HelloVerifyRequest.

We have a cookie, so lets check it.

This is fatal

We treat invalid cookies in the same was as no cookie as per RFC6347

Cookie verification succeeded

There was no cookie in the ClientHello so we need to send a HelloVerifyRequest. If this fails we do not worry about trying to resend, we just drop it.

Dump the read packet, we don't need it any more. Ignore return value

Generate the cookie

This is fatal

Special case: for hello verify request, client version 1.0 and we haven't decided which version to use yet send back using version 1.0 header: otherwise some clients will ignore it.

Construct the record and message headers

Record sequence number is always the same as in the received ClientHello

End of record, start sub packet for message

Message type

Message length - doesn't follow normal TLS convention: the length isn't the last thing in the message header. We'll need to fill this in later when we know the length. Set it to zero for now

Message sequence number is always 0 for a HelloVerifyRequest

We never fragment a HelloVerifyRequest, so fragment offset is 0

Fragment length is the same as message length, but this is the last thing in the message header so we can just start a sub-packet. No need to come back later for this one.

Create the actual HelloVerifyRequest body

Close message body

Close record body

This is fatal

Fix up the message len in the message header. Its the same as the fragment len which has been filled in by WPACKET, so just copy that. Destination for the message len is after the record header plus one byte for the message content type. The source is the last 3 bytes of the message header

This is unnecessary if rbio and wbio are one and the same - but maybe they're not. We ignore errors here - some BIOs do not support this.

TODO(size_t): convert this call

Non-blocking IO...but we're stateless, so we're just going to drop this packet.

Non-blocking IO...but we're stateless, so we're just going to drop this packet.

Set expected sequence numbers to continue the handshake.

We are doing cookie exchange, so make sure we set that option in the SSL object

Tell the state machine that we've done the initial hello verify exchange

Some BIOs may not support this. If we fail we clear the client address

Dump this packet. Ignore return value

AHA! Figure out the MTU, and stick to the right size

I've seen the kernel return bogus numbers when it doesn't know (initial write), so just make sure we have a reasonable number

Set to min mtu

Subtract external overhead (e.g. IV/nonce, separate MAC)

Round encrypted payload down to cipher block size (for CBC etc.) No check for overflow since 'mtu % blocksize' cannot exceed mtu.

Subtract internal overhead (e.g. CBC padding len byte)

www.openssl.org/source/license.html

License

e_os.h

ssl_locl.h

t call dtls1_min_mtu() * We

t do anything */ if (!dtls1_is_timer_expired(s)) { return 0; } dtls1_double_timeout(s); if (dtls1_check_timeout_num(s) < 0) return -1; s->d1->timeout.read_timeouts++; if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT) { s->d1->timeout.read_timeouts = 1; } dtls1_start_timer(s); return dtls1_retransmit_buffered_messages(s); } static void get_current_time(struct timeval *t) { #if defined(_WIN32) SYSTEMTIME st; union { unsigned __int64 ul; FILETIME ft; } now; GetSystemTime(&st); SystemTimeToFileTime(&st, &now.ft); /* re-bias to 1/1/1970 */ # ifdef __MINGW32__ now.ul -= 116444736000000000ULL; # else /* *INDENT-OFF* */ now.ul -= 116444736000000000UI64; /* *INDENT-ON* */ # endif t->tv_sec = (long)(now.ul / 10000000); t->tv_usec = ((int)(now.ul % 10000000)) / 10; #else gettimeofday(t, NULL); #endif } #define LISTEN_SUCCESS 2 #define LISTEN_SEND_VERIFY_REQUEST 1 #ifndef OPENSSL_NO_SOCK int DTLSv1_listen(SSL *s, BIO_ADDR *client) { int next, n, ret = 0, clearpkt = 0; unsigned char cookie[DTLS1_COOKIE_LENGTH]; unsigned char seq[SEQ_NUM_SIZE]; const unsigned char *data; unsigned char *buf; size_t fragoff, fraglen, msglen; unsigned int rectype, versmajor, msgseq, msgtype, clientvers, cookielen; BIO *rbio, *wbio; BUF_MEM *bufm; BIO_ADDR *tmpclient = NULL; PACKET pkt, msgpkt, msgpayload, session, cookiepkt; if (s->handshake_func == NULL) { /* Not properly initialized yet */ SSL_set_accept_state(s); } /* Ensure there is no state left over from a previous invocation */ if (!SSL_clear(s)) return -1; ERR_clear_error(); rbio = SSL_get_rbio(s); wbio = SSL_get_wbio(s); if (!rbio || !wbio) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_BIO_NOT_SET); return -1; } /* * We only peek at incoming ClientHello

re sure we are going to * to respond with a HelloVerifyRequest. If its a ClientHello with a valid * cookie then we leave it in the BIO for accept to handle. */ BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_PEEK_MODE, 1, NULL); /* * Note: This check deliberately excludes DTLS1_BAD_VER because that version * requires the MAC to be calculated *including* the first ClientHello * (without the cookie). Since DTLSv1_listen is stateless that cannot be * supported. DTLS1_BAD_VER must use cookies in a stateful manner (e.g. via * SSL_accept) */ if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00)) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_UNSUPPORTED_SSL_VERSION); return -1; } if (s->init_buf == NULL) { if ((bufm = BUF_MEM_new()) == NULL) { SSLerr(SSL_F_DTLSV1_LISTEN, ERR_R_MALLOC_FAILURE); return -1; } if (!BUF_MEM_grow(bufm, SSL3_RT_MAX_PLAIN_LENGTH)) { BUF_MEM_free(bufm); SSLerr(SSL_F_DTLSV1_LISTEN, ERR_R_MALLOC_FAILURE); return -1; } s->init_buf = bufm; } buf = (unsigned char *)s->init_buf->data; do { /* Get a packet */ clear_sys_error(); /* * Technically a ClientHello could be SSL3_RT_MAX_PLAIN_LENGTH * + DTLS1_RT_HEADER_LENGTH bytes long. Normally init_buf does not store * the record header as well, but we do here. We

t ever * receive a ClientHello as long as this. If we do it will get dropped * in the record length check below. */ n = BIO_read(rbio, buf, SSL3_RT_MAX_PLAIN_LENGTH); if (n <= 0) { if (BIO_should_retry(rbio)) { /* Non-blocking IO */ goto end; } return -1; } /* If we hit any problems we need to clear this packet from the BIO */ clearpkt = 1; if (!PACKET_buf_init(&pkt, buf, n)) { SSLerr(SSL_F_DTLSV1_LISTEN, ERR_R_INTERNAL_ERROR); return -1; } /* * Parse the received record. If there are any problems with it we just * dump it - with no alert. RFC6347 says this "Unlike TLS, DTLS is * resilient in the face of invalid records (e.g., invalid formatting, * length, MAC, etc.). In general, invalid records SHOULD be silently * discarded, thus preserving the association; however, an error MAY be * logged for diagnostic purposes." */ /* this packet contained a partial record, dump it */ if (n < DTLS1_RT_HEADER_LENGTH) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_RECORD_TOO_SMALL); goto end; } if (s->msg_callback) s->msg_callback(0, 0, SSL3_RT_HEADER, buf, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg); /* Get the record header */ if (!PACKET_get_1(&pkt, &rectype) || !PACKET_get_1(&pkt, &versmajor)) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_LENGTH_MISMATCH); goto end; } if (rectype != SSL3_RT_HANDSHAKE) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_UNEXPECTED_MESSAGE); goto end; } /* * Check record version number. We only check that the major version is * the same. */ if (versmajor != DTLS1_VERSION_MAJOR) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_BAD_PROTOCOL_VERSION_NUMBER); goto end; } if (!PACKET_forward(&pkt, 1) /* Save the sequence number: 64 bits, with top 2 bytes = epoch */ || !PACKET_copy_bytes(&pkt, seq, SEQ_NUM_SIZE) || !PACKET_get_length_prefixed_2(&pkt, &msgpkt)) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_LENGTH_MISMATCH); goto end; } /* * We allow data remaining at the end of the packet because there could * be a second record (but we ignore it) */ /* This is an initial ClientHello so the epoch has to be 0 */ if (seq[0] != 0 || seq[1] != 0) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_UNEXPECTED_MESSAGE); goto end; } /* Get a pointer to the raw message for the later callback */ data = PACKET_data(&msgpkt); /* Finished processing the record header, now process the message */ if (!PACKET_get_1(&msgpkt, &msgtype) || !PACKET_get_net_3_len(&msgpkt, &msglen) || !PACKET_get_net_2(&msgpkt, &msgseq) || !PACKET_get_net_3_len(&msgpkt, &fragoff) || !PACKET_get_net_3_len(&msgpkt, &fraglen) || !PACKET_get_sub_packet(&msgpkt, &msgpayload, fraglen) || PACKET_remaining(&msgpkt) != 0) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_LENGTH_MISMATCH); goto end; } if (msgtype != SSL3_MT_CLIENT_HELLO) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_UNEXPECTED_MESSAGE); goto end; } /* Message sequence number can only be 0 or 1 */ if (msgseq > 2) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_INVALID_SEQUENCE_NUMBER); goto end; } /* * We don

t handle it. */ SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_LENGTH_MISMATCH); goto end; } /* * Check if we have a cookie or not. If not we need to send a * HelloVerifyRequest. */ if (PACKET_remaining(&cookiepkt) == 0) { next = LISTEN_SEND_VERIFY_REQUEST; } else { /* * We have a cookie, so lets check it. */ if (s->ctx->app_verify_cookie_cb == NULL) { SSLerr(SSL_F_DTLSV1_LISTEN, SSL_R_NO_VERIFY_COOKIE_CALLBACK); /* This is fatal */ return -1; } if (s->ctx->app_verify_cookie_cb(s, PACKET_data(&cookiepkt), (unsigned int)PACKET_remaining(&cookiepkt)) == 0) { /* * We treat invalid cookies in the same was as no cookie as * per RFC6347 */ next = LISTEN_SEND_VERIFY_REQUEST; } else { /* Cookie verification succeeded */ next = LISTEN_SUCCESS; } } if (next == LISTEN_SEND_VERIFY_REQUEST) { WPACKET wpkt; unsigned int version; size_t wreclen; /* * There was no cookie in the ClientHello so we need to send a * HelloVerifyRequest. If this fails we do not worry about trying * to resend, we just drop it. */ /* * Dump the read packet, we don

t decided which version to use yet send back using version * 1.0 header: otherwise some clients will ignore it. */ version = (s->method->version == DTLS_ANY_VERSION) ? DTLS1_VERSION : s->version; /* Construct the record and message headers */ if (!WPACKET_init(&wpkt, s->init_buf) || !WPACKET_put_bytes_u8(&wpkt, SSL3_RT_HANDSHAKE) || !WPACKET_put_bytes_u16(&wpkt, version) /* * Record sequence number is always the same as in the * received ClientHello */ || !WPACKET_memcpy(&wpkt, seq, SEQ_NUM_SIZE) /* End of record, start sub packet for message */ || !WPACKET_start_sub_packet_u16(&wpkt) /* Message type */ || !WPACKET_put_bytes_u8(&wpkt, DTLS1_MT_HELLO_VERIFY_REQUEST) /* * Message length - doesn

t the last thing in the message header. * We

re not. We ignore errors here - some BIOs do not * support this. */ if (BIO_dgram_get_peer(rbio, tmpclient) > 0) { (void)BIO_dgram_set_peer(wbio, tmpclient); } BIO_ADDR_free(tmpclient); tmpclient = NULL; /* TODO(size_t): convert this call */ if (BIO_write(wbio, buf, wreclen) < (int)wreclen) { if (BIO_should_retry(wbio)) { /* * Non-blocking IO...but we

re just * going to drop this packet. */ goto end; } return -1; } if (BIO_flush(wbio) <= 0) { if (BIO_should_retry(wbio)) { /* * Non-blocking IO...but we

re just * going to drop this packet. */ goto end; } return -1; } } } while (next != LISTEN_SUCCESS); /* * Set expected sequence numbers to continue the handshake. */ s->d1->handshake_read_seq = 1; s->d1->handshake_write_seq = 1; s->d1->next_handshake_write_seq = 1; DTLS_RECORD_LAYER_set_write_sequence(&s->rlayer, seq); /* * We are doing cookie exchange, so make sure we set that option in the * SSL object */ SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE); /* * Tell the state machine that we

ve seen the kernel return bogus numbers when it doesn

mtu % blocksize

0xff00)

0xff00))

