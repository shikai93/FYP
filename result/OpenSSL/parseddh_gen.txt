Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

NB: These functions have been upgraded - the previous prototypes are in dh_depr.c as wrappers to these ones. - Geoff

We generate DH parameters as follows find a prime q which is prime_len/2 bits long. p=(2q)+1 or (p-1)/2 = q For this case, g is a generator if g^((p-1)/q) mod p != 1 for values of q which are the factors of p-1. Since the factors of p-1 are q and 2, we just need to check g^2 mod p != 1 and g^q mod p != 1. Having said all that, there is another special case method for the generators 2, 3 and 5. for 2, p mod 24 == 11 for 3, p mod 12 == 5 <<<<< does not work for safe primes. for 5, p mod 10 == 3 or 7 Thanks to Phil Karn <karn@qualcomm.com> for the pointers about the special generators and for answering some of my questions. I've implemented the second simple method :-). Since DH should be using a safe prime (both p and q are prime), this generator function can take a very very long time to run.

Actually there is no reason to insist that 'generator' be a generator. It's just as OK (and in some sense better) to use a generator of the order-q subgroup.

Make sure 'ret' has the necessary elements

BN_set_word(t3,7); just have to miss out on these ones :-(

in the general case, don't worry if 'generator' is a generator or not: since we are using safe primes, it will generate either an order-q or an order-2q group, which both is OK

www.openssl.org/source/license.html

License

internal/cryptlib.h

dh_locl.h

ve implemented the second simple method :-). * Since DH should be using a safe prime (both p and q are prime), * this generator function can take a very very long time to run. */ /* * Actually there is no reason to insist that

be a generator. * It

ret

t worry if

