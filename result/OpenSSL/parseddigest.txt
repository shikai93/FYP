Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This call frees resources associated with the context

Don't assume ctx->md_data was cleaned in EVP_Digest_Final, because sometimes only copies of the context are ever finalised.

Whether it's nice or not, "Inits" can be used on "Final"'d contexts so this context may already have an ENGINE! Try to avoid releasing the previous handle, re-querying for an ENGINE, and having a reinitialisation, when it may all be unnecessary.

Ensure an ENGINE left lying around from last time is cleared (the previous check attempted to avoid this if the same ENGINE and EVP_MD could be used).

Ask if an ENGINE is reserved for this job

There's an ENGINE for this job ... (apparently)

We'll use the ENGINE's private digest definition

Store the ENGINE functional reference so we know 'type' came from an ENGINE and we need to release it when done.

The caller can assume that this removes any secret data from the context

The caller can assume that this removes any secret data from the context

Make sure it's safe to copy a digest context using an ENGINE

Null these variables, since they are getting fixed up properly below. Anything else may cause a memleak and/or double free if any of the memory allocations below fail

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/evp_int.h

evp_locl.h

t assume ctx->md_data was cleaned in EVP_Digest_Final, because * sometimes only copies of the context are ever finalised. */ if (ctx->digest && ctx->digest->cleanup && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED)) ctx->digest->cleanup(ctx); if (ctx->digest && ctx->digest->ctx_size && ctx->md_data && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) { OPENSSL_clear_free(ctx->md_data, ctx->digest->ctx_size); } EVP_PKEY_CTX_free(ctx->pctx); #ifndef OPENSSL_NO_ENGINE ENGINE_finish(ctx->engine); #endif OPENSSL_cleanse(ctx, sizeof(*ctx)); return 1; } EVP_MD_CTX *EVP_MD_CTX_new(void) { return OPENSSL_zalloc(sizeof(EVP_MD_CTX)); } void EVP_MD_CTX_free(EVP_MD_CTX *ctx) { EVP_MD_CTX_reset(ctx); OPENSSL_free(ctx); } int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type) { EVP_MD_CTX_reset(ctx); return EVP_DigestInit_ex(ctx, type, NULL); } int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl) { EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED); #ifndef OPENSSL_NO_ENGINE /* * Whether it

Inits

Final

d contexts so * this context may already have an ENGINE! Try to avoid releasing the * previous handle, re-querying for an ENGINE, and having a * reinitialisation, when it may all be unnecessary. */ if (ctx->engine && ctx->digest && (type == NULL || (type->type == ctx->digest->type))) goto skip_to_init; if (type) { /* * Ensure an ENGINE left lying around from last time is cleared (the * previous check attempted to avoid this if the same ENGINE and * EVP_MD could be used). */ ENGINE_finish(ctx->engine); if (impl != NULL) { if (!ENGINE_init(impl)) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR); return 0; } } else { /* Ask if an ENGINE is reserved for this job */ impl = ENGINE_get_digest_engine(type->type); } if (impl != NULL) { /* There

ll use the ENGINE

type

