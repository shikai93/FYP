Copyright 2011-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The default global DRBG.

The global private-key DRBG.

Support framework for NIST SP 800-90A DRBG, AES-CTR mode. The RAND_DRBG is OpenSSL's pointer to an instance of the DRBG. The OpenSSL model is to have new and free functions, and that new does all initialization. That is not the NIST model, which has instantiation and un-instantiate, and re-use within a new/free lifecycle. (No doubt this comes from the desire to support hardware DRBG, where allocation of resources on something like an HSM is a much bigger deal than just re-setting an allocated resource.)

Set/initialize |drbg| to be of type |nid|, with optional |flags|. Return -2 if the type is not supported, 1 on success and -1 on failure.

Uninitialized; that's okay.

Allocate memory and initialize a new DRBG. The |parent|, if not NULL, will be used to auto-seed this RAND_DRBG as needed.

Uninstantiate |drbg| and free all memory.

The global DRBG is free'd by rand_cleanup_drbg_int()

Instantiate |drbg|, after it has been initialized. Use |pers| and |perslen| as prediction-resistance input.

Uninstantiate |drbg|. Must be instantiated before it can be used.

Mix in the specified data to reseed |drbg|.

Generate |outlen| bytes into the buffer at |out|. Reseed if we need to or if |prediction_resistance| is set. Additional input can be sent in |adin| and |adinlen|.

Set the callbacks for entropy and nonce. We currently don't use the nonce; that's mainly for the KATs

Set the reseed interval.

Get and set the EXDATA

The following functions provide a RAND_METHOD that works on the global DRBG. They lock.

Creates a global DRBG with default settings. Returns 1 on success, 0 on failure

If you change these parameters, see RANDOMNESS_NEEDED

Initialize the global DRBGs on first use. Returns 1 on success, 0 on failure.

Clean up a DRBG and free it

Clean up the global DRBGs before exit

Copy whatever fits into the end of the buffer.

XOR any the leftover.

Get the global public DRBG. Returns pointer to the DRBG on success, NULL on failure.

Get the global private DRBG. Returns pointer to the DRBG on success, NULL on failure.

www.openssl.org/source/license.html

License

rand_lcl.h

internal/thread_once.h

internal/rand_int.h

s pointer to an instance of the DRBG. * * The OpenSSL model is to have new and free functions, and that new * does all initialization. That is not the NIST model, which has * instantiation and un-instantiate, and re-use within a new/free * lifecycle. (No doubt this comes from the desire to support hardware * DRBG, where allocation of resources on something like an HSM is * a much bigger deal than just re-setting an allocated resource.) */ static CRYPTO_ONCE rand_init_drbg = CRYPTO_ONCE_STATIC_INIT; /* * Set/initialize |drbg| to be of type |nid|, with optional |flags|. * Return -2 if the type is not supported, 1 on success and -1 on * failure. */ int RAND_DRBG_set(RAND_DRBG *drbg, int nid, unsigned int flags) { int ret = 1; drbg->state = DRBG_UNINITIALISED; drbg->flags = flags; drbg->nid = nid; switch (nid) { default: RANDerr(RAND_F_RAND_DRBG_SET, RAND_R_UNSUPPORTED_DRBG_TYPE); return -2; case 0: /* Uninitialized; that

d by rand_cleanup_drbg_int() */ if (drbg == NULL || drbg == &rand_drbg) return; ctr_uninstantiate(drbg); CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, drbg, &drbg->ex_data); OPENSSL_clear_free(drbg, sizeof(*drbg)); } /* * Instantiate |drbg|, after it has been initialized. Use |pers| and * |perslen| as prediction-resistance input. */ int RAND_DRBG_instantiate(RAND_DRBG *drbg, const unsigned char *pers, size_t perslen) { unsigned char *nonce = NULL, *entropy = NULL; size_t noncelen = 0, entropylen = 0; if (perslen > drbg->max_perslen) { RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_PERSONALISATION_STRING_TOO_LONG); goto end; } if (drbg->state != DRBG_UNINITIALISED) { RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, drbg->state == DRBG_ERROR ? RAND_R_IN_ERROR_STATE : RAND_R_ALREADY_INSTANTIATED); goto end; } drbg->state = DRBG_ERROR; if (drbg->get_entropy != NULL) entropylen = drbg->get_entropy(drbg, &entropy, drbg->strength, drbg->min_entropylen, drbg->max_entropylen); if (entropylen < drbg->min_entropylen || entropylen > drbg->max_entropylen) { RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_RETRIEVING_ENTROPY); goto end; } if (drbg->max_noncelen > 0 && drbg->get_nonce != NULL) { noncelen = drbg->get_nonce(drbg, &nonce, drbg->strength / 2, drbg->min_noncelen, drbg->max_noncelen); if (noncelen < drbg->min_noncelen || noncelen > drbg->max_noncelen) { RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_RETRIEVING_NONCE); goto end; } } if (!ctr_instantiate(drbg, entropy, entropylen, nonce, noncelen, pers, perslen)) { RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_INSTANTIATING_DRBG); goto end; } drbg->state = DRBG_READY; drbg->reseed_counter = 1; end: if (entropy != NULL && drbg->cleanup_entropy != NULL) drbg->cleanup_entropy(drbg, entropy, entropylen); if (nonce != NULL && drbg->cleanup_nonce!= NULL ) drbg->cleanup_nonce(drbg, nonce, noncelen); if (drbg->state == DRBG_READY) return 1; return 0; } /* * Uninstantiate |drbg|. Must be instantiated before it can be used. */ int RAND_DRBG_uninstantiate(RAND_DRBG *drbg) { int ret = ctr_uninstantiate(drbg); OPENSSL_cleanse(&drbg->ctr, sizeof(drbg->ctr)); drbg->state = DRBG_UNINITIALISED; return ret; } /* * Mix in the specified data to reseed |drbg|. */ int RAND_DRBG_reseed(RAND_DRBG *drbg, const unsigned char *adin, size_t adinlen) { unsigned char *entropy = NULL; size_t entropylen = 0; if (drbg->state == DRBG_ERROR) { RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_IN_ERROR_STATE); return 0; } if (drbg->state == DRBG_UNINITIALISED) { RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_NOT_INSTANTIATED); return 0; } if (adin == NULL) adinlen = 0; else if (adinlen > drbg->max_adinlen) { RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ADDITIONAL_INPUT_TOO_LONG); return 0; } drbg->state = DRBG_ERROR; if (drbg->get_entropy != NULL) entropylen = drbg->get_entropy(drbg, &entropy, drbg->strength, drbg->min_entropylen, drbg->max_entropylen); if (entropylen < drbg->min_entropylen || entropylen > drbg->max_entropylen) { RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ERROR_RETRIEVING_ENTROPY); goto end; } if (!ctr_reseed(drbg, entropy, entropylen, adin, adinlen)) goto end; drbg->state = DRBG_READY; drbg->reseed_counter = 1; end: if (entropy != NULL && drbg->cleanup_entropy != NULL) drbg->cleanup_entropy(drbg, entropy, entropylen); if (drbg->state == DRBG_READY) return 1; return 0; } /* * Generate |outlen| bytes into the buffer at |out|. Reseed if we need * to or if |prediction_resistance| is set. Additional input can be * sent in |adin| and |adinlen|. */ int RAND_DRBG_generate(RAND_DRBG *drbg, unsigned char *out, size_t outlen, int prediction_resistance, const unsigned char *adin, size_t adinlen) { if (drbg->state == DRBG_ERROR) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_IN_ERROR_STATE); return 0; } if (drbg->state == DRBG_UNINITIALISED) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_NOT_INSTANTIATED); return 0; } if (outlen > drbg->max_request) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_REQUEST_TOO_LARGE_FOR_DRBG); return 0; } if (adinlen > drbg->max_adinlen) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_ADDITIONAL_INPUT_TOO_LONG); return 0; } if (drbg->fork_count != rand_fork_count) { drbg->fork_count = rand_fork_count; drbg->state = DRBG_RESEED; } if (drbg->reseed_counter >= drbg->reseed_interval) drbg->state = DRBG_RESEED; if (drbg->state == DRBG_RESEED || prediction_resistance) { if (!RAND_DRBG_reseed(drbg, adin, adinlen)) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_RESEED_ERROR); return 0; } adin = NULL; adinlen = 0; } if (!ctr_generate(drbg, out, outlen, adin, adinlen)) { drbg->state = DRBG_ERROR; RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_GENERATE_ERROR); return 0; } if (drbg->reseed_counter >= drbg->reseed_interval) drbg->state = DRBG_RESEED; else drbg->reseed_counter++; return 1; } /* * Set the callbacks for entropy and nonce. We currently don

