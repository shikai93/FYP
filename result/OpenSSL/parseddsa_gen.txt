Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Parameter generation follows the updated Appendix 2.2 for FIPS PUB 186, also Appendix 2.2 of FIPS PUB 186-1 (i.e. use SHA as defined in FIPS PUB 180-1)

invalid q size

use SHA1 as default

Only consume as much seed as is expected.

find q

step 1

If we come back through, use random seed next time.

precompute "SEED + 1" for step 7:

step 2

step 3

step 4

do a callback call

step 5

step 6

"offset = 2"

step 7

now 'buf' contains "SEED + offset - 1"

obtain "SEED + offset + k" by incrementing:

step 8

more of step 8

step 9

step 10

step 11

found it

step 13

"offset = offset + n + 1"

step 14

We now need to generate g

Set r0=(p-1)/q

g=test^r0%p

This is a parameter generation algorithm for the DSA2 algorithm as described in FIPS 186-3.

If unverifiable g generation only don't need seed

if p, q already supplied generate g only

find q

step 1

step 2

Take least significant bits of md

step 3

step 4

Provided seed didn't produce a prime: error

do a callback call

step 5

Copy seed to seed_out before we mess with it

step 6

"offset = 1"

step 7

now 'buf' contains "SEED + offset - 1"

obtain "SEED + offset + k" by incrementing:

step 8

more of step 8

step 9

step 10

step 11

found it

step 13

"offset = offset + n + 1"

step 14

We now need to generate g

Set r0=(p-1)/q

g=test^r0%p

www.openssl.org/source/license.html

License

internal/cryptlib.h

dsa_locl.h

SEED + 1

offset = 2

buf

SEED + offset - 1

SEED + offset + k

offset = offset + n + 1

t need seed */ if (!ret->p || !ret->q || idx >= 0) { if (seed_len == 0) seed_len = mdsize; seed = OPENSSL_malloc(seed_len); if (seed_out) seed_tmp = seed_out; else seed_tmp = OPENSSL_malloc(seed_len); if (seed == NULL || seed_tmp == NULL) goto err; if (seed_in) memcpy(seed, seed_in, seed_len); } if ((ctx = BN_CTX_new()) == NULL) goto err; if ((mont = BN_MONT_CTX_new()) == NULL) goto err; BN_CTX_start(ctx); r0 = BN_CTX_get(ctx); g = BN_CTX_get(ctx); W = BN_CTX_get(ctx); X = BN_CTX_get(ctx); c = BN_CTX_get(ctx); test = BN_CTX_get(ctx); if (test == NULL) goto err; /* if p, q already supplied generate g only */ if (ret->p && ret->q) { p = ret->p; q = ret->q; if (idx >= 0) memcpy(seed_tmp, seed, seed_len); goto g_only; } else { p = BN_CTX_get(ctx); q = BN_CTX_get(ctx); if (q == NULL) goto err; } if (!BN_lshift(test, BN_value_one(), L - 1)) goto err; for (;;) { for (;;) { /* find q */ unsigned char *pmd; /* step 1 */ if (!BN_GENCB_call(cb, 0, m++)) goto err; if (!seed_in) { if (RAND_bytes(seed, seed_len) <= 0) goto err; } /* step 2 */ if (!EVP_Digest(seed, seed_len, md, NULL, evpmd, NULL)) goto err; /* Take least significant bits of md */ if (mdsize > qsize) pmd = md + mdsize - qsize; else pmd = md; if (mdsize < qsize) memset(md + mdsize, 0, qsize - mdsize); /* step 3 */ pmd[0] |= 0x80; pmd[qsize - 1] |= 0x01; if (!BN_bin2bn(pmd, qsize, q)) goto err; /* step 4 */ r = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx, seed_in ? 1 : 0, cb); if (r > 0) break; if (r != 0) goto err; /* Provided seed didn

offset = 1

buf

SEED + offset - 1

SEED + offset + k

offset = offset + n + 1

0x80;

0x01;

0x80;

0x01;

0x67,

0x67,

0x65,

0x6e

0xff;

0xff;

0xff;

0xffff)

