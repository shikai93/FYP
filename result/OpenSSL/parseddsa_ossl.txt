Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Original version from Steven Schoch <schoch@sheba.arc.nasa.gov>

dsa_mod_exp,

dsa_bn_mod_exp,

if the digest length is greater than the size of q use the BN_num_bits(dsa->q) leftmost bits of the digest, see fips 186-3, 4.2

Compute s = inv(k) (m + xr) mod q

s = xr

s = m + xr

Redo if r or s is zero as required by FIPS 186-3: this is very unlikely.

Get random k

We calculate k from SHA512(private_key + H(message) + random). This protects the private key from a weak PRNG.

Compute r = (g^k mod p) mod q

We do not want timing information to leak the length of k, so we compute g^k using an equivalent exponent of fixed length. (This is a kludge that we need because the BN_mod_exp_mont() does not let us specify the desired timing behaviour.)

Compute part of 's = inv(k) (m + xr) mod q'

fips 186-3 allows only different sizes for q

Calculate W = inv(S) mod Q save W in u2

save M in u1

if the digest length is greater than the size of q use the BN_num_bits(dsa->q) leftmost bits of the digest, see fips 186-3, 4.2

u1 = M w mod q

u2 = r w mod q

let u1 = u1 mod q

V is now in u1. If the signature is correct, it will be equal to R.

www.openssl.org/source/license.html

License

internal/cryptlib.h

dsa_locl.h

OpenSSL DSA method

s = inv(k) (m + xr) mod q

