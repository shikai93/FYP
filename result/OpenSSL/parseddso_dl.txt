Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Part of the hack in "dl_load" ...

ctrl

init

finish

For this DSO_METHOD, our meth_data STACK will contain; (i) the handle (shl_t) returned from shl_load(). NB: I checked on HPUX11 and shl_t is itself a pointer type so the cast is safe.

We don't do any fancy retries or anything, just take the method's (or DSO's if it has the callback set) best translation of the platform-independent filename and try once with that.

Success, stick the converted filename we've loaded under into the DSO (it also serves as the indicator that we are currently loaded).

Cleanup!

Is this statement legal?

Should push the value back onto the stack in case of a retry.

If the first file specification is a rooted path, it rules. same goes if the second file specification is missing.

If the first file specification is missing, the second one rules.

This part isn't as trivial as it looks. It assumes that the second file specification really is a directory, and makes no checks whatsoever. Therefore, the result becomes the concatenation of filespec2 followed by a slash followed by filespec1.

This function is identical to the one in dso_dlfcn.c, but as it is highly unlikely that both the "dl" and "dlfcn" variants are being compiled at the same time, there's no great duplicating the code. Figuring out an elegant way to share one copy of the code would be more difficult and would not leave the implementations independent.

We will convert this to "%s.s?" or "lib%s.s?"

The length of ".s?"

The length of "lib"

DSO_DL

www.openssl.org/source/license.html

License

dso_locl.h

dl_load

OpenSSL 'dl' shared library method

t do any fancy retries or anything, just take the method

s if it has the callback set) best translation of the * platform-independent filename and try once with that. */ char *filename = DSO_convert_filename(dso, NULL); if (filename == NULL) { DSOerr(DSO_F_DL_LOAD, DSO_R_NO_FILENAME); goto err; } ptr = shl_load(filename, BIND_IMMEDIATE | (dso->flags & DSO_FLAG_NO_NAME_TRANSLATION ? 0 : DYNAMIC_PATH), 0L); if (ptr == NULL) { char errbuf[160]; DSOerr(DSO_F_DL_LOAD, DSO_R_LOAD_FAILED); if (openssl_strerror_r(errno, errbuf, sizeof(errbuf))) ERR_add_error_data(4, "filename(", filename, "): ", errbuf); goto err; } if (!sk_push(dso->meth_data, (char *)ptr)) { DSOerr(DSO_F_DL_LOAD, DSO_R_STACK_ERROR); goto err; } /* * Success, stick the converted filename we

symname(

):

/

t as trivial as it looks. It assumes that the * second file specification really is a directory, and makes no * checks whatsoever. Therefore, the result becomes the * concatenation of filespec2 followed by a slash followed by * filespec1. */ { int spec2len, len; spec2len = (filespec2 ? strlen(filespec2) : 0); len = spec2len + (filespec1 ? strlen(filespec1) : 0); if (spec2len && filespec2[spec2len - 1] ==

) { spec2len--; len--; } merged = OPENSSL_malloc(len + 2); if (merged == NULL) { DSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE); return (NULL); } strcpy(merged, filespec2); merged[spec2len] =

; strcpy(&merged[spec2len + 1], filespec1); } return (merged); } /* * This function is identical to the one in dso_dlfcn.c, but as it is highly * unlikely that both the "dl" *and* "dlfcn" variants are being compiled at * the same time, there

/

%s.s?

lib%s.s?

.s?

lib

lib%s%s

%s%s

%s

