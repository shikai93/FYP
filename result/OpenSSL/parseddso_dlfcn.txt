Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

We need to do this early, because stdio.h includes the header files that handle _GNU_SOURCE and other similar macros. Defining it later is simply too late, because those headers are protected from re- inclusion.

make sure dladdr is declared

Part of the hack in "dlfcn_load" ...

ctrl

init

finish

Prior to using the dlopen() function, we should decide on the flag we send. There's a few different ways of doing this and it's a messy venn-diagram to match up which platforms support what. So as we don't have autoconf yet, I'm implementing a hack that could be hacked further relatively easily to deal with cases as we find them. Initially this is to cope with OpenBSD.

Hope this works everywhere else

For this DSO_METHOD, our meth_data STACK will contain; (i) the handle (void) returned from dlopen().

See applicable comments in dso_dl.c

Success

Cleanup!

Should push the value back onto the stack in case of a retry.

For now I'm not aware of any errors associated with dlclose()

If the first file specification is a rooted path, it rules. same goes if the second file specification is missing.

If the first file specification is missing, the second one rules.

This part isn't as trivial as it looks. It assumes that the second file specification really is a directory, and makes no checks whatsoever. Therefore, the result becomes the concatenation of filespec2 followed by a slash followed by filespec1.

We will convert this to "%s.so" or "lib%s.so" etc

The length of ".so"

The length of "lib"

This is a quote from IRIX manual for dladdr(3c): <dlfcn.h> does not contain a prototype for dladdr or definition of Dl_info. The #include <dlfcn.h> in the SYNOPSIS line is traditional, but contains no dladdr prototype and no IRIX library contains an implementation. Write your own declaration based on the code below. The following code is dependent on internal interfaces that are not part of the IRIX compatibility guarantee; however, there is no future intention to change this interface, so on a practical level, the code below is safe to use on IRIX.

__sgi

DSO_DLFCN

www.openssl.org/source/license.html

License

dso_locl.h

dlfcn_load

OpenSSL 'dlfcn' shared library method

s a few different ways of doing this and it

t have * autoconf yet, I

filename(

):

m not aware of any errors associated with dlclose() */ dlclose(ptr); return (1); } static DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname) { void *ptr; union { DSO_FUNC_TYPE sym; void *dlret; } u; if ((dso == NULL) || (symname == NULL)) { DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER); return (NULL); } if (sk_void_num(dso->meth_data) < 1) { DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR); return (NULL); } ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1); if (ptr == NULL) { DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE); return (NULL); } u.dlret = dlsym(ptr, symname); if (u.dlret == NULL) { DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE); ERR_add_error_data(4, "symname(", symname, "): ", dlerror()); return (NULL); } return u.sym; } static char *dlfcn_merger(DSO *dso, const char *filespec1, const char *filespec2) { char *merged; if (!filespec1 && !filespec2) { DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER); return (NULL); } /* * If the first file specification is a rooted path, it rules. same goes * if the second file specification is missing. */ if (!filespec2 || (filespec1 != NULL && filespec1[0] ==

)) { merged = OPENSSL_strdup(filespec1); if (merged == NULL) { DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); return (NULL); } } /* * If the first file specification is missing, the second one rules. */ else if (!filespec1) { merged = OPENSSL_strdup(filespec2); if (merged == NULL) { DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); return (NULL); } } else { /* * This part isn

/

/

/

%s.so

lib%s.so

.so

lib

lib%s

%s

%s

dlfcn_pathbyaddr():

