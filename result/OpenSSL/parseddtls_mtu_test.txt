Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

for SSL_READ_ETM()

For record MTU values between 500 and 539, call DTLS_get_data_mtu() to query the payload MTU which will fit.

Now get out of the way

Now for all values in the range of payload MTUs, send a payload of that size and see what actual record size we end up with.

DTLS_get_data_mtu() with record MTU 500+i returned mtus[i] ...

We sent a packet smaller than or equal to mtus[j] and that made a record larger than the record MTU 500+j!

We sent a larger packet than mtus[i] and that still fits within the record MTU 500+i, so DTLS_get_data_mtu() was overly pessimistic.

We only care about iterating over each enc/mac; we don't want to repeat the test for each auth/kx variant. So keep life simple and only do (non-DH) PSK.

As noted above, only one test for each enc/mac variant.

mtu_test() returns 2 if it used Encrypt-then-MAC

www.openssl.org/source/license.html

License

ssltestlib.h

testutil.h

../ssl/ssl_locl.h

psk

Channel established

%s%s MTU for record mtu %d = %lu

-noEtM



Cipher %s MTU %d

record %zu for payload %zu

%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d

%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d

PSK

PSK-

%s OK

%s without EtM OK

0x5a,

0x5a,

0x5a,

