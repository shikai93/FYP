Copyright 2001-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

AES key schedule to use

Set if key initialised

Set if an iv is set

Temporary IV store

IV length

It is OK to generate IVs

TLS AAD length

AES key schedules to use

AES key schedule to use

Set if key initialised

Set if an iv is set

Set if tag is valid

Set if message length set

L and M parameters from RFC3610

TLS AAD length

AES key schedule to use for encryption

AES key schedule to use for decryption

Set if key initialised

Set if an iv is set

Temporary IV store

Store partial data blocks

Store partial AAD blocks

IV length

AES-NI section

minor size optimization

If we have an iv can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

key_len is two AES keys

We set both the encrypt and decrypt key here because decrypt needs both. We could possibly optimise to remove setting the decrypt for an encryption operation.

If we have an iv we can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

OPENSSL_NO_OCB

Initial Fujitsu SPARC64 X support

Key-length specific subroutines were chosen for following reason. Each SPARC T4 core can execute up to 8 threads which share core's resources. Loading as much key material to registers allows to minimize references to shared memory interface, as well as amount of instructions in inner loops [much needed on T4]. But then having non-key-length specific routines would require conditional branches either in inner loops or on subroutines' entries. Former is hardly acceptable, while latter means code size increase to size occupied by multiple key-length specific subroutines, so why fight?

If we have an iv can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

key_len is two AES keys

We set both the encrypt and decrypt key here because decrypt needs both. We could possibly optimise to remove setting the decrypt for an encryption operation.

If we have an iv we can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

OPENSSL_NO_OCB

terminate potentially open 'else'

increment counter (64-bit int) by 1

Allocate memory for IV if needed

Special case: -1 length restores whole IV

Fixed field must be at least 4 bytes and invocation field at least 8.

Invocation field will be at least 8 bytes in size and so no need to check wrap around or increment more than last 8 bytes.

Save the AAD for later use

Correct length for explicit IV

If decrypting correct for tag too

Extra padding: tag appended to record

terminate potentially open 'else'

If we have an iv can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

Handle TLS GCM packet format. This consists of the last portion of the IV followed by the payload and finally the tag. On encrypt generate IV, encrypt payload and write the tag. On verify retrieve IV, decrypt payload and verify tag.

Encrypt/decrypt must be performed in place

Set IV from start of buffer or generate IV and write to start of buffer.

Use saved AAD

Fix buffer and length to point to payload

Encrypt payload

Finally write tag

Decrypt

Retrieve tag

If tag mismatch wipe buffer

If not set up, return error

Don't reuse the IV

key1 and key2 are used as an indicator both key and IV are set

key_len is two AES keys

terminate potentially open 'else'

Save the AAD for later use

Correct length for explicit IV

If decrypting correct for tag too

Extra padding: tag appended to record

Sanity check length

Just copy to first part of IV

fall thru

Encrypt/decrypt must be performed in place

If encrypting set explicit IV from sequence number (start of AAD)

Get rest of IV from explicit IV

Correct length value

Use saved AAD

Fix buffer to point to payload

If not set up, return error

EVP_Final() doesn't return any data

If have AAD need message length

If not set length yet do it

Indicates if IV has been set

AES wrap with padding has IV length of 4, without padding 8

No final operation so always return zero length

Input length must always be non-zero

If decrypting need at least 16 bytes and multiple of 8

If not padding input must be multiple of 8

If padding round up to multiple of 8

8 byte prefix

If not padding output will be exactly 8 bytes smaller than input. If padding it will be at least 8 bytes smaller but we don't know how much.

IV len must be 1 to 15

Tag len must be 0 to 16

We set both the encrypt and decrypt key here because decrypt needs both. We could possibly optimise to remove setting the decrypt for an encryption operation.

If we have an iv we can set it directly, otherwise use saved IV.

If key set use IV, otherwise copy

If IV or Key not set then return error

Need to ensure we are only passing full blocks to low level OCB routines. We do it here rather than in EVP_EncryptUpdate/ EVP_DecryptUpdate because we need to pass full blocks of AAD too and those routines don't support that

Are we dealing with AAD or normal data here?

If we've got a partially filled buffer from a previous call then use that data first

If we get here we've filled the buffer, so process it

Do we have a partial block to handle at the end?

If we've got some full blocks to handle, then process these first

Handle any trailing partial block

First of all empty the buffer of any partial block that we might have been provided - both for data and AAD

If decrypting then verify

If encrypting then just get the tag

Don't reuse the IV

OPENSSL_NO_OCB

www.openssl.org/source/license.html

License

internal/evp_int.h

modes_lcl.h

evp_locl.h

ppc_arch.h

sparc_arch.h

s * resources. Loading as much key material to registers allows to * minimize references to shared memory interface, as well as amount * of instructions in inner loops [much needed on T4]. But then having * non-key-length specific routines would require conditional branches * either in inner loops or on subroutines

arm_arch.h

else

else

t reuse the IV */ gctx->iv_set = 0; return 0; } } #define CUSTOM_FLAGS (EVP_CIPH_FLAG_DEFAULT_ASN1 \ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \ | EVP_CIPH_CUSTOM_COPY) BLOCK_CIPHER_custom(NID_aes, 128, 1, 12, gcm, GCM, EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS) BLOCK_CIPHER_custom(NID_aes, 192, 1, 12, gcm, GCM, EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS) BLOCK_CIPHER_custom(NID_aes, 256, 1, 12, gcm, GCM, EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS) static int aes_xts_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,c); if (type == EVP_CTRL_COPY) { EVP_CIPHER_CTX *out = ptr; EVP_AES_XTS_CTX *xctx_out = EVP_C_DATA(EVP_AES_XTS_CTX,out); if (xctx->xts.key1) { if (xctx->xts.key1 != &xctx->ks1) return 0; xctx_out->xts.key1 = &xctx_out->ks1; } if (xctx->xts.key2) { if (xctx->xts.key2 != &xctx->ks2) return 0; xctx_out->xts.key2 = &xctx_out->ks2; } return 1; } else if (type != EVP_CTRL_INIT) return -1; /* key1 and key2 are used as an indicator both key and IV are set */ xctx->xts.key1 = NULL; xctx->xts.key2 = NULL; return 1; } static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc) { EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx); if (!iv && !key) return 1; if (key) do { #ifdef AES_XTS_ASM xctx->stream = enc ? AES_xts_encrypt : AES_xts_decrypt; #else xctx->stream = NULL; #endif /* key_len is two AES keys */ #ifdef HWAES_CAPABLE if (HWAES_CAPABLE) { if (enc) { HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) HWAES_encrypt; # ifdef HWAES_xts_encrypt xctx->stream = HWAES_xts_encrypt; # endif } else { HWAES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) HWAES_decrypt; # ifdef HWAES_xts_decrypt xctx->stream = HWAES_xts_decrypt; #endif } HWAES_set_encrypt_key(key + EVP_CIPHER_CTX_key_length(ctx) / 2, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks2.ks); xctx->xts.block2 = (block128_f) HWAES_encrypt; xctx->xts.key1 = &xctx->ks1; break; } else #endif #ifdef BSAES_CAPABLE if (BSAES_CAPABLE) xctx->stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt; else #endif #ifdef VPAES_CAPABLE if (VPAES_CAPABLE) { if (enc) { vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) vpaes_encrypt; } else { vpaes_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) vpaes_decrypt; } vpaes_set_encrypt_key(key + EVP_CIPHER_CTX_key_length(ctx) / 2, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks2.ks); xctx->xts.block2 = (block128_f) vpaes_encrypt; xctx->xts.key1 = &xctx->ks1; break; } else #endif (void)0; /* terminate potentially open

*/ if (enc) { AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) AES_encrypt; } else { AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks1.ks); xctx->xts.block1 = (block128_f) AES_decrypt; } AES_set_encrypt_key(key + EVP_CIPHER_CTX_key_length(ctx) / 2, EVP_CIPHER_CTX_key_length(ctx) * 4, &xctx->ks2.ks); xctx->xts.block2 = (block128_f) AES_encrypt; xctx->xts.key1 = &xctx->ks1; } while (0); if (iv) { xctx->xts.key2 = &xctx->ks2; memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, 16); } return 1; } static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t len) { EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx); if (!xctx->xts.key1 || !xctx->xts.key2) return 0; if (!out || !in || len < AES_BLOCK_SIZE) return 0; if (xctx->stream) (*xctx->stream) (in, out, len, xctx->xts.key1, xctx->xts.key2, EVP_CIPHER_CTX_iv_noconst(ctx)); else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx), in, out, len, EVP_CIPHER_CTX_encrypting(ctx))) return 0; return 1; } #define aes_xts_cleanup NULL #define XTS_FLAGS (EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \ | EVP_CIPH_CUSTOM_COPY) BLOCK_CIPHER_custom(NID_aes, 128, 1, 16, xts, XTS, XTS_FLAGS) BLOCK_CIPHER_custom(NID_aes, 256, 1, 16, xts, XTS, XTS_FLAGS) static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c); switch (type) { case EVP_CTRL_INIT: cctx->key_set = 0; cctx->iv_set = 0; cctx->L = 8; cctx->M = 12; cctx->tag_set = 0; cctx->len_set = 0; cctx->tls_aad_len = -1; return 1; case EVP_CTRL_AEAD_TLS1_AAD: /* Save the AAD for later use */ if (arg != EVP_AEAD_TLS1_AAD_LEN) return 0; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); cctx->tls_aad_len = arg; { uint16_t len = EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1]; /* Correct length for explicit IV */ if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN) return 0; len -= EVP_CCM_TLS_EXPLICIT_IV_LEN; /* If decrypting correct for tag too */ if (!EVP_CIPHER_CTX_encrypting(c)) { if (len < cctx->M) return 0; len -= cctx->M; } EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8; EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff; } /* Extra padding: tag appended to record */ return cctx->M; case EVP_CTRL_CCM_SET_IV_FIXED: /* Sanity check length */ if (arg != EVP_CCM_TLS_FIXED_IV_LEN) return 0; /* Just copy to first part of IV */ memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg); return 1; case EVP_CTRL_AEAD_SET_IVLEN: arg = 15 - arg; /* fall thru */ case EVP_CTRL_CCM_SET_L: if (arg < 2 || arg > 8) return 0; cctx->L = arg; return 1; case EVP_CTRL_AEAD_SET_TAG: if ((arg & 1) || arg < 4 || arg > 16) return 0; if (EVP_CIPHER_CTX_encrypting(c) && ptr) return 0; if (ptr) { cctx->tag_set = 1; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); } cctx->M = arg; return 1; case EVP_CTRL_AEAD_GET_TAG: if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set) return 0; if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg)) return 0; cctx->tag_set = 0; cctx->iv_set = 0; cctx->len_set = 0; return 1; case EVP_CTRL_COPY: { EVP_CIPHER_CTX *out = ptr; EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out); if (cctx->ccm.key) { if (cctx->ccm.key != &cctx->ks) return 0; cctx_out->ccm.key = &cctx_out->ks; } return 1; } default: return -1; } } static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx); if (!iv && !key) return 1; if (key) do { #ifdef HWAES_CAPABLE if (HWAES_CAPABLE) { HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &cctx->ks.ks); CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L, &cctx->ks, (block128_f) HWAES_encrypt); cctx->str = NULL; cctx->key_set = 1; break; } else #endif #ifdef VPAES_CAPABLE if (VPAES_CAPABLE) { vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &cctx->ks.ks); CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L, &cctx->ks, (block128_f) vpaes_encrypt); cctx->str = NULL; cctx->key_set = 1; break; } #endif AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &cctx->ks.ks); CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L, &cctx->ks, (block128_f) AES_encrypt); cctx->str = NULL; cctx->key_set = 1; } while (0); if (iv) { memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, 15 - cctx->L); cctx->iv_set = 1; } return 1; } static int aes_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t len) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx); CCM128_CONTEXT *ccm = &cctx->ccm; /* Encrypt/decrypt must be performed in place */ if (out != in || len < (EVP_CCM_TLS_EXPLICIT_IV_LEN + (size_t)cctx->M)) return -1; /* If encrypting set explicit IV from sequence number (start of AAD) */ if (EVP_CIPHER_CTX_encrypting(ctx)) memcpy(out, EVP_CIPHER_CTX_buf_noconst(ctx), EVP_CCM_TLS_EXPLICIT_IV_LEN); /* Get rest of IV from explicit IV */ memcpy(EVP_CIPHER_CTX_iv_noconst(ctx) + EVP_CCM_TLS_FIXED_IV_LEN, in, EVP_CCM_TLS_EXPLICIT_IV_LEN); /* Correct length value */ len -= EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx->M; if (CRYPTO_ccm128_setiv(ccm, EVP_CIPHER_CTX_iv_noconst(ctx), 15 - cctx->L, len)) return -1; /* Use saved AAD */ CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx), cctx->tls_aad_len); /* Fix buffer to point to payload */ in += EVP_CCM_TLS_EXPLICIT_IV_LEN; out += EVP_CCM_TLS_EXPLICIT_IV_LEN; if (EVP_CIPHER_CTX_encrypting(ctx)) { if (cctx->str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len, cctx->str) : CRYPTO_ccm128_encrypt(ccm, in, out, len)) return -1; if (!CRYPTO_ccm128_tag(ccm, out + len, cctx->M)) return -1; return len + EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx->M; } else { if (cctx->str ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len, cctx->str) : !CRYPTO_ccm128_decrypt(ccm, in, out, len)) { unsigned char tag[16]; if (CRYPTO_ccm128_tag(ccm, tag, cctx->M)) { if (!CRYPTO_memcmp(tag, in + len, cctx->M)) return len; } } OPENSSL_cleanse(out, len); return -1; } } static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t len) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx); CCM128_CONTEXT *ccm = &cctx->ccm; /* If not set up, return error */ if (!cctx->key_set) return -1; if (cctx->tls_aad_len >= 0) return aes_ccm_tls_cipher(ctx, out, in, len); /* EVP_*Final() doesn

t know how much. */ return inlen - 8; } } if (pad) { if (EVP_CIPHER_CTX_encrypting(ctx)) rv = CRYPTO_128_wrap_pad(&wctx->ks.ks, wctx->iv, out, in, inlen, (block128_f) AES_encrypt); else rv = CRYPTO_128_unwrap_pad(&wctx->ks.ks, wctx->iv, out, in, inlen, (block128_f) AES_decrypt); } else { if (EVP_CIPHER_CTX_encrypting(ctx)) rv = CRYPTO_128_wrap(&wctx->ks.ks, wctx->iv, out, in, inlen, (block128_f) AES_encrypt); else rv = CRYPTO_128_unwrap(&wctx->ks.ks, wctx->iv, out, in, inlen, (block128_f) AES_decrypt); } return rv ? (int)rv : -1; } #define WRAP_FLAGS (EVP_CIPH_WRAP_MODE \ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_FLAG_DEFAULT_ASN1) static const EVP_CIPHER aes_128_wrap = { NID_id_aes128_wrap, 8, 16, 8, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_128_wrap(void) { return &aes_128_wrap; } static const EVP_CIPHER aes_192_wrap = { NID_id_aes192_wrap, 8, 24, 8, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_192_wrap(void) { return &aes_192_wrap; } static const EVP_CIPHER aes_256_wrap = { NID_id_aes256_wrap, 8, 32, 8, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_256_wrap(void) { return &aes_256_wrap; } static const EVP_CIPHER aes_128_wrap_pad = { NID_id_aes128_wrap_pad, 8, 16, 4, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_128_wrap_pad(void) { return &aes_128_wrap_pad; } static const EVP_CIPHER aes_192_wrap_pad = { NID_id_aes192_wrap_pad, 8, 24, 4, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_192_wrap_pad(void) { return &aes_192_wrap_pad; } static const EVP_CIPHER aes_256_wrap_pad = { NID_id_aes256_wrap_pad, 8, 32, 4, WRAP_FLAGS, aes_wrap_init_key, aes_wrap_cipher, NULL, sizeof(EVP_AES_WRAP_CTX), NULL, NULL, NULL, NULL }; const EVP_CIPHER *EVP_aes_256_wrap_pad(void) { return &aes_256_wrap_pad; } #ifndef OPENSSL_NO_OCB static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,c); EVP_CIPHER_CTX *newc; EVP_AES_OCB_CTX *new_octx; switch (type) { case EVP_CTRL_INIT: octx->key_set = 0; octx->iv_set = 0; octx->ivlen = EVP_CIPHER_CTX_iv_length(c); octx->iv = EVP_CIPHER_CTX_iv_noconst(c); octx->taglen = 16; octx->data_buf_len = 0; octx->aad_buf_len = 0; return 1; case EVP_CTRL_AEAD_SET_IVLEN: /* IV len must be 1 to 15 */ if (arg <= 0 || arg > 15) return 0; octx->ivlen = arg; return 1; case EVP_CTRL_AEAD_SET_TAG: if (!ptr) { /* Tag len must be 0 to 16 */ if (arg < 0 || arg > 16) return 0; octx->taglen = arg; return 1; } if (arg != octx->taglen || EVP_CIPHER_CTX_encrypting(c)) return 0; memcpy(octx->tag, ptr, arg); return 1; case EVP_CTRL_AEAD_GET_TAG: if (arg != octx->taglen || !EVP_CIPHER_CTX_encrypting(c)) return 0; memcpy(ptr, octx->tag, arg); return 1; case EVP_CTRL_COPY: newc = (EVP_CIPHER_CTX *)ptr; new_octx = EVP_C_DATA(EVP_AES_OCB_CTX,newc); return CRYPTO_ocb128_copy_ctx(&new_octx->ocb, &octx->ocb, &new_octx->ksenc.ks, &new_octx->ksdec.ks); default: return -1; } } # ifdef HWAES_CAPABLE # ifdef HWAES_ocb_encrypt void HWAES_ocb_encrypt(const unsigned char *in, unsigned char *out, size_t blocks, const void *key, size_t start_block_num, unsigned char offset_i[16], const unsigned char L_[][16], unsigned char checksum[16]); # else # define HWAES_ocb_encrypt ((ocb128_f)NULL) # endif # ifdef HWAES_ocb_decrypt void HWAES_ocb_decrypt(const unsigned char *in, unsigned char *out, size_t blocks, const void *key, size_t start_block_num, unsigned char offset_i[16], const unsigned char L_[][16], unsigned char checksum[16]); # else # define HWAES_ocb_decrypt ((ocb128_f)NULL) # endif # endif static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc) { EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,ctx); if (!iv && !key) return 1; if (key) { do { /* * We set both the encrypt and decrypt key here because decrypt * needs both. We could possibly optimise to remove setting the * decrypt for an encryption operation. */ # ifdef HWAES_CAPABLE if (HWAES_CAPABLE) { HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksenc.ks); HWAES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksdec.ks); if (!CRYPTO_ocb128_init(&octx->ocb, &octx->ksenc.ks, &octx->ksdec.ks, (block128_f) HWAES_encrypt, (block128_f) HWAES_decrypt, enc ? HWAES_ocb_encrypt : HWAES_ocb_decrypt)) return 0; break; } # endif # ifdef VPAES_CAPABLE if (VPAES_CAPABLE) { vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksenc.ks); vpaes_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksdec.ks); if (!CRYPTO_ocb128_init(&octx->ocb, &octx->ksenc.ks, &octx->ksdec.ks, (block128_f) vpaes_encrypt, (block128_f) vpaes_decrypt, NULL)) return 0; break; } # endif AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksenc.ks); AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &octx->ksdec.ks); if (!CRYPTO_ocb128_init(&octx->ocb, &octx->ksenc.ks, &octx->ksdec.ks, (block128_f) AES_encrypt, (block128_f) AES_decrypt, NULL)) return 0; } while (0); /* * If we have an iv we can set it directly, otherwise use saved IV. */ if (iv == NULL && octx->iv_set) iv = octx->iv; if (iv) { if (CRYPTO_ocb128_setiv(&octx->ocb, iv, octx->ivlen, octx->taglen) != 1) return 0; octx->iv_set = 1; } octx->key_set = 1; } else { /* If key set use IV, otherwise copy */ if (octx->key_set) CRYPTO_ocb128_setiv(&octx->ocb, iv, octx->ivlen, octx->taglen); else memcpy(octx->iv, iv, octx->ivlen); octx->iv_set = 1; } return 1; } static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t len) { unsigned char *buf; int *buf_len; int written_len = 0; size_t trailing_len; EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,ctx); /* If IV or Key not set then return error */ if (!octx->iv_set) return -1; if (!octx->key_set) return -1; if (in != NULL) { /* * Need to ensure we are only passing full blocks to low level OCB * routines. We do it here rather than in EVP_EncryptUpdate/ * EVP_DecryptUpdate because we need to pass full blocks of AAD too * and those routines don

ve got a partially filled buffer from a previous call then * use that data first */ if (*buf_len > 0) { unsigned int remaining; remaining = AES_BLOCK_SIZE - (*buf_len); if (remaining > len) { memcpy(buf + (*buf_len), in, len); *(buf_len) += len; return 0; } memcpy(buf + (*buf_len), in, remaining); /* * If we get here we

ve got some full blocks to handle, then process these first */ if (len != trailing_len) { if (out == NULL) { if (!CRYPTO_ocb128_aad(&octx->ocb, in, len - trailing_len)) return -1; } else if (EVP_CIPHER_CTX_encrypting(ctx)) { if (!CRYPTO_ocb128_encrypt (&octx->ocb, in, out, len - trailing_len)) return -1; } else { if (!CRYPTO_ocb128_decrypt (&octx->ocb, in, out, len - trailing_len)) return -1; } written_len += len - trailing_len; in += len - trailing_len; } /* Handle any trailing partial block */ if (trailing_len > 0) { memcpy(buf, in, trailing_len); *buf_len = trailing_len; } return written_len; } else { /* * First of all empty the buffer of any partial block that we might * have been provided - both for data and AAD */ if (octx->data_buf_len > 0) { if (EVP_CIPHER_CTX_encrypting(ctx)) { if (!CRYPTO_ocb128_encrypt(&octx->ocb, octx->data_buf, out, octx->data_buf_len)) return -1; } else { if (!CRYPTO_ocb128_decrypt(&octx->ocb, octx->data_buf, out, octx->data_buf_len)) return -1; } written_len = octx->data_buf_len; octx->data_buf_len = 0; } if (octx->aad_buf_len > 0) { if (!CRYPTO_ocb128_aad (&octx->ocb, octx->aad_buf, octx->aad_buf_len)) return -1; octx->aad_buf_len = 0; } /* If decrypting then verify */ if (!EVP_CIPHER_CTX_encrypting(ctx)) { if (octx->taglen < 0) return -1; if (CRYPTO_ocb128_finish(&octx->ocb, octx->tag, octx->taglen) != 0) return -1; octx->iv_set = 0; return written_len; } /* If encrypting then just get the tag */ if (CRYPTO_ocb128_tag(&octx->ocb, octx->tag, 16) != 1) return -1; /* Don

0xff;

0xff;

0x7))

0x7)

