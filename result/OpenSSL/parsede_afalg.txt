Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Required for vmsplice

Local Linkage Functions

Engine Id and Name

Async mode

Get waitfd from ASYNC_WAIT_CTX if it is alreday set

waitfd is not set in ASYNC_WAIT_CTX, create a new one and set it. efd will be signaled when AIO operation completes

make fd non-blocking in async mode

Sync mode

Initialise for AIO

if efd has not been initialised yet do it here

The pointer has to be converted to unsigned value first to avoid sign extension on cast to 64 bit value in 32-bit builds

Perform AIO read on AFALG socket, this in turn performs an async crypto operation in kernel space

While AIO read is being performed pause job

Check for completion of AIO read

Get results of AIO read

events.res indicates the actual status of the operation. Handle the error condition first.

Underlying operation cannot be completed at the time of previous submission. Resubmit for the operation.

Retries exceed for -EBUSY or unrecoverable error condition for this instance of operation.

Operation successful.

cipher direction (i.e. encrypt or decrypt) and iv are sent to the kernel as part of sendmsg()'s ancillary data

iov that describes input data

ZERO_COPY mode Works best when buffer is 4k aligned OPENS: out of place processing (i.e. out != in)

Input data is not sent as part of call to sendmsg()

Sendmsg() sends iv and cipher direction to the kernel

vmsplice and splice are used to pin the user space input buffer for kernel space processing avoiding copys from user to kernel space

Sendmsg() sends iv, cipher direction and input data to the kernel

Setup AFALG socket for crypto processing

Setup AIO ctx to allow async AFALG crypto processing

set iv now for decrypt operation as the input buffer can be overwritten for inplace operation where in = out.

Send input data to kernel space

Perform async crypto operation in kernel space

close efd in sync mode, async mode is closed in afalg_waitfd_cleanup()

Ensure the afalg error handling is set up

Create _hidden_aes_128_cbc by calling afalg_aes_128_cbc now, as bind_aflag can only be called by one thread at a time.

Test if we can actually create an AF_ALG socket

KERNEL VERSION

www.openssl.org/source/license.html

License

AFALG ENGINE requires Kernel Headers >= 4.1.0

Skipping Compilation of AFALG engine

e_afalg.h

e_afalg_err.c

afalg

AFALG engine support

%s: ASYNC_get_wait_ctx error

%s: Failed to get eventfd :

%s: Failed to set wait fd

%s: Failed to set event fd as NONBLOCKING

%s: Failed to get eventfd :

%s: io_setup error :

\0

%s: io_read failed :

%s: read failed for event fd :

%s: eventfd read %d bytes, eval = %lu\n

%s: retry %d for io_read failed :

%s: Crypto Operation failed with code %lld\n

%s: io_getevents failed :

%s: io_geteventd read 0 bytes\n

%s: Failed to set socket option :

\0

\0

%s: Failed to open socket :

%s: Failed to bind socket :

%s: Socket Accept Failed :

s ancillary data */ cmsg = CMSG_FIRSTHDR(&msg); afalg_set_op_sk(cmsg, enc); cmsg = CMSG_NXTHDR(&msg, cmsg); afalg_set_iv_sk(cmsg, iv, ALG_AES_IV_LEN); /* iov that describes input data */ iov.iov_base = (unsigned char *)in; iov.iov_len = inl; msg.msg_flags = MSG_MORE; # ifdef ALG_ZERO_COPY /* * ZERO_COPY mode * Works best when buffer is 4k aligned * OPENS: out of place processing (i.e. out != in) */ /* Input data is not sent as part of call to sendmsg() */ msg.msg_iovlen = 0; msg.msg_iov = NULL; /* Sendmsg() sends iv and cipher direction to the kernel */ sbytes = sendmsg(actx->sfd, &msg, 0); if (sbytes < 0) { ALG_PERR("%s: sendmsg failed for zero copy cipher operation : ", __func__); return 0; } /* * vmsplice and splice are used to pin the user space input buffer for * kernel space processing avoiding copys from user to kernel space */ ret = vmsplice(actx->zc_pipe[1], &iov, 1, SPLICE_F_GIFT); if (ret < 0) { ALG_PERR("%s: vmsplice failed : ", __func__); return 0; } ret = splice(actx->zc_pipe[0], NULL, actx->sfd, NULL, inl, 0); if (ret < 0) { ALG_PERR("%s: splice failed : ", __func__); return 0; } # else msg.msg_iovlen = 1; msg.msg_iov = &iov; /* Sendmsg() sends iv, cipher direction and input data to the kernel */ sbytes = sendmsg(actx->sfd, &msg, 0); if (sbytes < 0) { ALG_PERR("%s: sendmsg failed for cipher operation : ", __func__); return 0; } if (sbytes != (ssize_t) inl) { ALG_WARN("Cipher operation send bytes %zd != inlen %zd\n", sbytes, inl); return 0; } # endif return 1; } static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc) { int ciphertype; int ret; afalg_ctx *actx; char ciphername[ALG_MAX_SALG_NAME]; if (ctx == NULL || key == NULL) { ALG_WARN("%s: Null Parameter\n", __func__); return 0; } if (EVP_CIPHER_CTX_cipher(ctx) == NULL) { ALG_WARN("%s: Cipher object NULL\n", __func__); return 0; } actx = EVP_CIPHER_CTX_get_cipher_data(ctx); if (actx == NULL) { ALG_WARN("%s: Cipher data NULL\n", __func__); return 0; } ciphertype = EVP_CIPHER_CTX_nid(ctx); switch (ciphertype) { case NID_aes_128_cbc: strncpy(ciphername, "cbc(aes)", ALG_MAX_SALG_NAME); break; default: ALG_WARN("%s: Unsupported Cipher type %d\n", __func__, ciphertype); return 0; } ciphername[ALG_MAX_SALG_NAME-1]=

%s: Unsupported IV length :%d\n

skcipher

NULL parameter passed to function %s\n

%s afalg ctx passed\n

NULL

Uninitialised

NULL parameter passed to function %s\n

%s afalg ctx passed\n

NULL

Uninitialised

.

.

ASYNC AFALG not supported this kernel(%d.%d.%d)\n

ASYNC AFALG requires kernel version %d.%d.%d or later\n

0x08)

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

MAGIC Number to identify correct initialisation of afalg_ctx.

www.openssl.org/source/license.html

License

-Wvariadic-macros

ALG_DBG:

ALG_INFO:

ALG_WARN:

ALG_ERR:

ALG_PERR:

ALG_PERR:

0x1890671

www.openssl.org/source/license.html

License

