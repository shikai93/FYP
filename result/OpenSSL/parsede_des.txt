Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

----------^^^ this is not a typo, just a way to detect that assembler support was in general requested...

Because of various casts and different names can't use IMPLEMENT_BLOCK_CIPHER

Although we have a CFB-r implementation for DES, it doesn't pack the right way, so wrap it here

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/evp_int.h

sparc_arch.h

t use * IMPLEMENT_BLOCK_CIPHER */ static int des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { BLOCK_CIPHER_ecb_loop() DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i), EVP_CIPHER_CTX_get_cipher_data(ctx), EVP_CIPHER_CTX_encrypting(ctx)); return 1; } static int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { while (inl >= EVP_MAXCHUNK) { int num = EVP_CIPHER_CTX_num(ctx); DES_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num); EVP_CIPHER_CTX_set_num(ctx, num); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) { int num = EVP_CIPHER_CTX_num(ctx); DES_ofb64_encrypt(in, out, (long)inl, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num); EVP_CIPHER_CTX_set_num(ctx, num); } return 1; } static int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { EVP_DES_KEY *dat = (EVP_DES_KEY *) EVP_CIPHER_CTX_get_cipher_data(ctx); if (dat->stream.cbc != NULL) { (*dat->stream.cbc) (in, out, inl, &dat->ks.ks, EVP_CIPHER_CTX_iv_noconst(ctx)); return 1; } while (inl >= EVP_MAXCHUNK) { DES_ncbc_encrypt(in, out, (long)EVP_MAXCHUNK, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), EVP_CIPHER_CTX_encrypting(ctx)); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) DES_ncbc_encrypt(in, out, (long)inl, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), EVP_CIPHER_CTX_encrypting(ctx)); return 1; } static int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { while (inl >= EVP_MAXCHUNK) { int num = EVP_CIPHER_CTX_num(ctx); DES_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num, EVP_CIPHER_CTX_encrypting(ctx)); EVP_CIPHER_CTX_set_num(ctx, num); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) { int num = EVP_CIPHER_CTX_num(ctx); DES_cfb64_encrypt(in, out, (long)inl, EVP_CIPHER_CTX_get_cipher_data(ctx), (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num, EVP_CIPHER_CTX_encrypting(ctx)); EVP_CIPHER_CTX_set_num(ctx, num); } return 1; } /* * Although we have a CFB-r implementation for DES, it doesn

0x80

0x80

0x80)

