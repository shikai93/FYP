Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

---------^^^ this is not a typo, just a way to detect that assembler support was in general requested...

Because of various casts and different args can't use IMPLEMENT_BLOCK_CIPHER

Although we have a CFB-r implementation for 3-DES, it doesn't pack the right way, so wrap it here

Decrypt first block which will end up as icv

Decrypt central blocks

If decrypting in place move whole output along a block so the next des_ede_cbc_cipher is in place.

Decrypt final block which will be IV

Reverse order of everything

Decrypt again using new IV

Work out SHA1 hash of first portion

Copy input to output buffer + 8 so we have space for IV

Work out ICV

Generate random IV

Encrypt everything after IV in place

Sanity check input length: we typically only wrap keys so EVP_MAXCHUNK is more than will ever be needed. Also input length must be a multiple of 8 bits.

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/evp_int.h

evp_locl.h

sparc_arch.h

t use * IMPLEMENT_BLOCK_CIPHER */ static int des_ede_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { BLOCK_CIPHER_ecb_loop() DES_ecb3_encrypt((const_DES_cblock *)(in + i), (DES_cblock *)(out + i), &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3, EVP_CIPHER_CTX_encrypting(ctx)); return 1; } static int des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { while (inl >= EVP_MAXCHUNK) { int num = EVP_CIPHER_CTX_num(ctx); DES_ede3_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK, &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num); EVP_CIPHER_CTX_set_num(ctx, num); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) { int num = EVP_CIPHER_CTX_num(ctx); DES_ede3_ofb64_encrypt(in, out, (long)inl, &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num); EVP_CIPHER_CTX_set_num(ctx, num); } return 1; } static int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { DES_EDE_KEY *dat = data(ctx); if (dat->stream.cbc != NULL) { (*dat->stream.cbc) (in, out, inl, dat->ks.ks, EVP_CIPHER_CTX_iv_noconst(ctx)); return 1; } while (inl >= EVP_MAXCHUNK) { DES_ede3_cbc_encrypt(in, out, (long)EVP_MAXCHUNK, &dat->ks1, &dat->ks2, &dat->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), EVP_CIPHER_CTX_encrypting(ctx)); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) DES_ede3_cbc_encrypt(in, out, (long)inl, &dat->ks1, &dat->ks2, &dat->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), EVP_CIPHER_CTX_encrypting(ctx)); return 1; } static int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) { while (inl >= EVP_MAXCHUNK) { int num = EVP_CIPHER_CTX_num(ctx); DES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num, EVP_CIPHER_CTX_encrypting(ctx)); EVP_CIPHER_CTX_set_num(ctx, num); inl -= EVP_MAXCHUNK; in += EVP_MAXCHUNK; out += EVP_MAXCHUNK; } if (inl) { int num = EVP_CIPHER_CTX_num(ctx); DES_ede3_cfb64_encrypt(in, out, (long)inl, &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3, (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx), &num, EVP_CIPHER_CTX_encrypting(ctx)); EVP_CIPHER_CTX_set_num(ctx, num); } return 1; } /* * Although we have a CFB-r implementation for 3-DES, it doesn

0x80

0x80

0x80)

0x4a,

0xdd,

0xa2,

0x2c,

0x79,

0xe8,

0x21,

0x05

