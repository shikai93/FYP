Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Compute the x-coordinate x/z for the point 2(x/z) in Montgomery projective coordinates. Uses algorithm Mdouble in appendix of Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over GF(2^m) without precomputation" (CHES '99, LNCS 1717). modified to not require precomputation of c=b^{2^{m-1}}.

Since Mdouble is static we can guarantee that ctx != NULL.

Compute the x-coordinate x1/z1 for the point (x1/z1)+(x2/x2) in Montgomery projective coordinates. Uses algorithm Madd in appendix of Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over GF(2^m) without precomputation" (CHES '99, LNCS 1717).

Since Madd is static we can guarantee that ctx != NULL.

Compute the x, y affine coordinates from the point (x1, z1) (x2, z2) using Montgomery point multiplication algorithm Mxy() in appendix of Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over GF(2^m) without precomputation" (CHES '99, LNCS 1717). Returns: 0 on error 1 if return value should be the point at infinity 2 otherwise

Since Mxy is static we can guarantee that ctx != NULL.

Computes scalarpoint and stores the result in r. point can not equal r. Uses a modified algorithm 2P of Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over GF(2^m) without precomputation" (CHES '99, LNCS 1717). To protect against side-channel attack the function uses constant time swap, avoiding conditional branches.

if result should be point at infinity

only support affine coordinates

Since point_multiply is static we can guarantee that ctx != NULL.

x1 = x

z1 = 1

z2 = x1^2 = x^2

x2 = x^4 + b

find top most bit and go one past it

if top most bit was at word break, go to next word

convert out of "projective" coordinates

GF(2^m) field elements should always have BIGNUM::neg = 0

Computes the sum scalargroup->generator + scalars[0]points[0] + ... + scalars[num-1]points[num-1] gracefully ignoring NULL scalar values.

This implementation is more efficient than the wNAF implementation for 2 or fewer points. Use the ec_wNAF_mul implementation for 3 or more points, or if we can perform a fast multiplication based on precomputation.

Precomputation for point multiplication: fall back to wNAF methods because ec_GF2m_simple_mul() uses ec_wNAF_mul() if appropriate

www.openssl.org/source/license.html

License

internal/bn_int.h

ec_lcl.h

Fast multiplication on elliptic curves over * GF(2^m) without precomputation

99, LNCS 1717). * modified to not require precomputation of c=b^{2^{m-1}}. */ static int gf2m_Mdouble(const EC_GROUP *group, BIGNUM *x, BIGNUM *z, BN_CTX *ctx) { BIGNUM *t1; int ret = 0; /* Since Mdouble is static we can guarantee that ctx != NULL. */ BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); if (t1 == NULL) goto err; if (!group->meth->field_sqr(group, x, x, ctx)) goto err; if (!group->meth->field_sqr(group, t1, z, ctx)) goto err; if (!group->meth->field_mul(group, z, x, t1, ctx)) goto err; if (!group->meth->field_sqr(group, x, x, ctx)) goto err; if (!group->meth->field_sqr(group, t1, t1, ctx)) goto err; if (!group->meth->field_mul(group, t1, group->b, t1, ctx)) goto err; if (!BN_GF2m_add(x, x, t1)) goto err; ret = 1; err: BN_CTX_end(ctx); return ret; } /*- * Compute the x-coordinate x1/z1 for the point (x1/z1)+(x2/x2) in Montgomery * projective coordinates. * Uses algorithm Madd in appendix of * Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over * GF(2^m) without precomputation" (CHES

Fast multiplication on elliptic curves over * GF(2^m) without precomputation

99, LNCS 1717). * Returns: * 0 on error * 1 if return value should be the point at infinity * 2 otherwise */ static int gf2m_Mxy(const EC_GROUP *group, const BIGNUM *x, const BIGNUM *y, BIGNUM *x1, BIGNUM *z1, BIGNUM *x2, BIGNUM *z2, BN_CTX *ctx) { BIGNUM *t3, *t4, *t5; int ret = 0; if (BN_is_zero(z1)) { BN_zero(x2); BN_zero(z2); return 1; } if (BN_is_zero(z2)) { if (!BN_copy(x2, x)) return 0; if (!BN_GF2m_add(z2, x, y)) return 0; return 2; } /* Since Mxy is static we can guarantee that ctx != NULL. */ BN_CTX_start(ctx); t3 = BN_CTX_get(ctx); t4 = BN_CTX_get(ctx); t5 = BN_CTX_get(ctx); if (t5 == NULL) goto err; if (!BN_one(t5)) goto err; if (!group->meth->field_mul(group, t3, z1, z2, ctx)) goto err; if (!group->meth->field_mul(group, z1, z1, x, ctx)) goto err; if (!BN_GF2m_add(z1, z1, x1)) goto err; if (!group->meth->field_mul(group, z2, z2, x, ctx)) goto err; if (!group->meth->field_mul(group, x1, z2, x1, ctx)) goto err; if (!BN_GF2m_add(z2, z2, x2)) goto err; if (!group->meth->field_mul(group, z2, z2, z1, ctx)) goto err; if (!group->meth->field_sqr(group, t4, x, ctx)) goto err; if (!BN_GF2m_add(t4, t4, y)) goto err; if (!group->meth->field_mul(group, t4, t4, t3, ctx)) goto err; if (!BN_GF2m_add(t4, t4, z2)) goto err; if (!group->meth->field_mul(group, t3, t3, x, ctx)) goto err; if (!group->meth->field_div(group, t3, t5, t3, ctx)) goto err; if (!group->meth->field_mul(group, t4, t3, t4, ctx)) goto err; if (!group->meth->field_mul(group, x2, x1, t3, ctx)) goto err; if (!BN_GF2m_add(z2, x2, x)) goto err; if (!group->meth->field_mul(group, z2, z2, t4, ctx)) goto err; if (!BN_GF2m_add(z2, z2, y)) goto err; ret = 2; err: BN_CTX_end(ctx); return ret; } /*- * Computes scalar*point and stores the result in r. * point can not equal r. * Uses a modified algorithm 2P of * Lopez, J. and Dahab, R. "Fast multiplication on elliptic curves over * GF(2^m) without precomputation" (CHES

projective

