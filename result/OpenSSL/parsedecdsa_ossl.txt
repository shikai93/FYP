Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

this value is later returned in kinvp

this value is later returned in rp

get random k

We do not want timing information to leak the length of k, so we compute Gk using an equivalent scalar of fixed bit-length.

compute r the x-coordinate of generator k

NID_X9_62_characteristic_two_field

compute the inverse of k

We want inverse in constant time, therefore we utilize the fact order must be prime and use Fermats Little Theorem instead.

clear old values if necessary

save the pre-computed values

Need to truncate digest if it is too long: first truncate whole bytes.

If still too long truncate remaining bits with a shift

if kinv and r have been supplied by the caller don't to generate new kinv and r values

s != 0 => we have a valid signature

returns 1: correct signature 0: incorrect signature -1: error

Ensure signature uses DER and doesn't have trailing garbage

check input values

signature is invalid

calculate tmp1 = inv(S) mod order

digest -> m

Need to truncate digest if it is too long: first truncate whole bytes.

If still too long truncate remaining bits with a shift

u1 = m tmp mod order

u2 = r w mod q

NID_X9_62_characteristic_two_field

if the signature is correct u1 is equal to sig->r

www.openssl.org/source/license.html

License

ec_lcl.h

t to * generate new kinv and r values */ if (in_kinv != NULL && in_r != NULL) { ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_NEED_NEW_SETUP_VALUES); goto err; } } else /* s != 0 => we have a valid signature */ break; } while (1); ok = 1; err: if (!ok) { ECDSA_SIG_free(ret); ret = NULL; } BN_CTX_free(ctx); BN_clear_free(m); BN_clear_free(tmp); BN_clear_free(kinv); return ret; } /*- * returns * 1: correct signature * 0: incorrect signature * -1: error */ int ossl_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len, const unsigned char *sigbuf, int sig_len, EC_KEY *eckey) { ECDSA_SIG *s; const unsigned char *p = sigbuf; unsigned char *der = NULL; int derlen = -1; int ret = -1; s = ECDSA_SIG_new(); if (s == NULL) return (ret); if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err; /* Ensure signature uses DER and doesn

0x7)))

0x7)))

