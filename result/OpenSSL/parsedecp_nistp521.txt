Copyright 2011-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Copyright 2011 Google Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

A 64-bit implementation of the NIST P-521 elliptic curve point multiplication OpenSSL integration was taken from Emilia Kasper's work in ecp_nistp224.c. Otherwise based on Emilia's P224 work, which was inspired by my curve25519 work which got its smarts from Daniel J. Bernstein's work on the same.

even with gcc, the typedef won't work for 32-bit platforms

nonstandard; implemented by gcc on 64-bit platforms

The underlying field. P521 operates over GF(2^521-1). We can serialise an element of this field into 66 bytes where the most significant byte contains only a single bit. We call this an felem_bytearray.

These are the parameters of P521, taken from FIPS 186-3, section D.1.2.5. These values are big-endian.

p

a = -3

b

x

y

The representation of field elements. ------------------------------------ We represent field elements with nine values. These values are either 64 or 128 bits and the field element represented is: v[0]2^0 + v[1]2^58 + v[2]2^116 + ... + v[8]2^464 (mod p) Each of the nine values is called a 'limb'. Since the limbs are spaced only 58 bits apart, but are greater than 58 bits in length, the most significant bits of each limb overlap with the least significant bits of the next. A field element with 64-bit limbs is an 'felem'. One with 128-bit limbs is a 'largefelem'

bin66_to_felem takes a little-endian byte array and converts it into felem form. This assumes that the CPU is little-endian.

felem_to_bin66 takes an felem and serialises into a little endian, 66 byte array. This assumes that the CPU is little-endian.

To preserve endianness when using BN_bn2bin and BN_bin2bn

BN_to_felem converts an OpenSSL BIGNUM into an felem

BN_bn2bin eats leading zeroes

felem_to_BN converts an felem into an OpenSSL BIGNUM

Field operations ----------------

felem_sum64 sets out = out + in.

felem_scalar sets out = in scalar

felem_scalar64 sets out = out scalar

felem_scalar128 sets out = out scalar

felem_neg sets |out| to |-in| On entry: in[i] < 2^59 + 2^14 On exit: out[i] < 2^62

In order to prevent underflow, we subtract from 0 mod p.

felem_diff64 subtracts |in| from |out| On entry: in[i] < 2^59 + 2^14 On exit: out[i] < out[i] + 2^62

In order to prevent underflow, we add 0 mod p before subtracting.

felem_diff_128_64 subtracts |in| from |out| On entry: in[i] < 2^62 + 2^17 On exit: out[i] < out[i] + 2^63

In order to prevent underflow, we add 0 mod p before subtracting.

felem_diff_128_64 subtracts |in| from |out| On entry: in[i] < 2^126 On exit: out[i] < out[i] + 2^127 - 2^69

In order to prevent underflow, we add 0 mod p before subtracting.

felem_square sets |out| = |in|^2 On entry: in[i] < 2^62 On exit: out[i] < 17 max(in[i]) max(in[i])

We have many cases were we want to do in[x] in[y] + in[y] in[x] This is obviously just 2 in[x] in[y] However, rather than do the doubling on the 128 bit result, we double one of the inputs to the multiplication by reading from |inx2|

The remaining limbs fall above 2^521, with the first falling at 2^522. They correspond to locations one bit up from the limbs produced above so we would have to multiply by two to align them. Again, rather than operate on the 128-bit result, we double one of the inputs to the multiplication. If we want to double for both this reason, and the reason above, then we end up multiplying by four.

9

10

11

12

13

14

15

16

felem_mul sets |out| = |in1| |in2| On entry: in1[i] < 2^64 in2[i] < 2^63 On exit: out[i] < 17 max(in1[i]) max(in2[i])

See comment in felem_square about the use of in2x2 here

felem_reduce converts a largefelem to an felem. On entry: in[i] < 2^128 On exit: out[i] < 2^59 + 2^14

out[i] < 2^58

out[1] < 2^58 + 2^6 + 2^58 = 2^59 + 2^6

out[x > 1] < 2^58 + 2^6 + 2^58 + 2^12 < 2^59 + 2^13

overflow1 < 2^13 + 2^7 + 2^59

overflow2 < 2^13

out[0] < 2^60

out[1] < 2^59 + 2^6 + 2^13

out[0] < 2^58 out[1] < 2^59 + 2^6 + 2^13 + 2^2 < 2^59 + 2^14

felem_inv calculates |out| = |in|^{-1} Based on Fermat's Little Theorem: a^p = a (mod p) a^{p-1} = 1 (mod p) a^{p-2} = a^{-1} (mod p)

2^1

2^2 - 2^0

2^3 - 2^1

2^3 - 2^0

2^4 - 2^1

2^3 - 2^1

2^4 - 2^2

2^4 - 2^0

2^5 - 2^1

2^6 - 2^2

2^7 - 2^3

2^8 - 2^4

2^8 - 2^1

2^9 - 2^2

2^8 - 2^0

2^16 - 2^8

2^16 - 2^0

2^32 - 2^16

2^32 - 2^0

2^64 - 2^32

2^64 - 2^0

2^128 - 2^64

2^128 - 2^0

2^256 - 2^128

2^256 - 2^0

2^512 - 2^256

2^512 - 2^0

2^521 - 2^9

2^512 - 2^2

2^512 - 3

This is 2^521-1, expressed as an felem

felem_is_zero returns a limb with all bits set if |in| == 0 (mod p) and 0 otherwise. On entry: in[i] < 2^59 + 2^14

ftmp[8] < 2^57

ftmp[8] < 2^57 + 4

The ninth limb of 2(2^521-1) is 0x03ffffffffffffff, which is greater than our bound for ftmp[8]. Therefore we only have to check if the zero is zero or 2^521-1.

We know that ftmp[i] < 2^63, therefore the only way that the top bit can be set is if is_zero was 0 before the decrement.

felem_contract converts |in| to its unique, minimal representation. On entry: in[i] < 2^59 + 2^14

out[8] < 2^57

out[8] < 2^57 + 4

If the value is greater than 2^521-1 then we have to subtract 2^521-1 out. See the comments in felem_is_zero regarding why we don't test for other multiples of the prime.

First, if |out| is equal to 2^521-1, we subtract it out to get zero.

is_p is 0 iff |out| == 2^521-1 and all ones otherwise

In order to test that |out| >= 2^521-1 we need only test if out[8] >> 57 is greater than zero as (2^521-1) + x >= 2^522

Eliminate negative coefficients

Group operations ---------------- Building on top of the field operations we have the operations on the elliptic curve group itself. Points on the curve are represented in Jacobian coordinates

point_double calculates 2(x_in, y_in, z_in) The method is taken from: http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed. while x_out == y_in is not (maybe this works, but it's not tested).

delta = z^2

delta[i] < 2^59 + 2^14

gamma = y^2

gamma[i] < 2^59 + 2^14

beta = xgamma

beta[i] < 2^59 + 2^14

alpha = 3(x-delta)(x+delta)

ftmp[i] < 2^61

ftmp2[i] < 2^60 + 2^15

ftmp2[i] < 32^60 + 32^15

tmp[i] < 17(32^121 + 32^76) = 612^121 + 612^76 < 642^121 + 642^76 = 2^127 + 2^82 < 2^128

x' = alpha^2 - 8beta

tmp[i] < 172^120 < 2^125

ftmp[i] < 2^62 + 2^17

tmp[i] < 2^125 + 2^63 + 2^62 + 2^17

z' = (y + z)^2 - gamma - delta

delta[i] < 2^60 + 2^15

ftmp[i] < 2^60 + 2^15

tmp[i] < 17(2^122) < 2^127

tmp[i] < 2^127 + 2^63

y' = alpha(4beta - x') - 8gamma^2

beta[i] < 2^61 + 2^16

beta[i] < 2^61 + 2^60 + 2^16

tmp[i] < 17((2^59 + 2^14)(2^61 + 2^60 + 2^16)) = 17(2^120 + 2^75 + 2^119 + 2^74 + 2^75 + 2^30) = 17(2^120 + 2^119 + 2^76 + 2^74 + 2^30) < 2^128

tmp2[i] < 17(2^59 + 2^14)^2 = 17(2^118 + 2^74 + 2^28)

tmp2[i] < 817(2^118 + 2^74 + 2^28) = 2^125 + 2^121 + 2^81 + 2^77 + 2^35 + 2^31 < 2^126

tmp[i] < 2^127 - 2^69 + 17(2^120 + 2^119 + 2^76 + 2^74 + 2^30) = 2^127 + 2^124 + 2^122 + 2^120 + 2^118 + 2^80 + 2^78 + 2^76 + 2^74 + 2^69 + 2^34 + 2^30 < 2^128

copy_conditional copies in to out iff mask is all ones.

point_add calculates (x1, y1, z1) + (x2, y2, z2) The method is taken from http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl, adapted for mixed addition (z2 = 1, or z2 = 0 for the point at infinity). This function includes a branch for checking whether the two input points are equal (while not equal to the point at infinity). This case never happens during single point multiplication, so there is no timing leak for ECDH or ECDSA signing.

ftmp = z1z1 = z12

ftmp2 = z2z2 = z22

u1 = ftmp3 = x1z2z2

ftmp5 = z1 + z2

ftmp5[i] < 2^61

ftmp5 = (z1 + z2)2 - z1z1 - z2z2 = 2z1z2

tmp[i] < 172^122

tmp[i] < 172^122 + 2^63

tmp[i] < 172^122 + 2^64

ftmp2 = z2 z2z2

s1 = ftmp6 = y1 z23

We'll assume z2 = 1 (special case z2 = 0 is handled later)

u1 = ftmp3 = x1z2z2

ftmp5 = 2z1z2

s1 = ftmp6 = y1 z23

u2 = x2z1z1

tmp[i] < 172^120

h = ftmp4 = u2 - u1

tmp[i] < 172^120 + 2^63

z_out = ftmp5 h

ftmp = z1 z1z1

s2 = tmp = y2 z13

tmp[i] < 172^120

r = ftmp5 = (s2 - s1)2

tmp[i] < 172^120 + 2^63

ftmp5[i] < 2^61

I = ftmp = (2h)2

ftmp[i] < 2^61

tmp[i] < 172^122

J = ftmp2 = h I

V = ftmp4 = U1 I

x_out = r2 - J - 2V

tmp[i] < 172^122

tmp[i] < 172^122 + 2^63

ftmp4[i] < 2^61

tmp[i] < 172^122 + 2^64

y_out = r(V-x_out) - 2 s1 J

ftmp3[i] < 2^60 + 2^60 = 2^61

tmp[i] < 172^122

tmp2[i] < 172^120

tmp2[i] < 172^121

tmp[i] < 2^127 - 2^69 + 172^122 = 2^126 - 2^122 - 2^6 - 2^2 - 1 < 2^127

Base point pre computation -------------------------- Two different sorts of precomputed tables are used in the following code. Each contain various points on the curve, where each point is three field elements (x, y, z). For the base point table, z is usually 1 (0 for the point at infinity). This table has 16 elements: index | bits | point ------+---------+------------------------------ 0 | 0 0 0 0 | 0G 1 | 0 0 0 1 | 1G 2 | 0 0 1 0 | 2^130G 3 | 0 0 1 1 | (2^130 + 1)G 4 | 0 1 0 0 | 2^260G 5 | 0 1 0 1 | (2^260 + 1)G 6 | 0 1 1 0 | (2^260 + 2^130)G 7 | 0 1 1 1 | (2^260 + 2^130 + 1)G 8 | 1 0 0 0 | 2^390G 9 | 1 0 0 1 | (2^390 + 1)G 10 | 1 0 1 0 | (2^390 + 2^130)G 11 | 1 0 1 1 | (2^390 + 2^130 + 1)G 12 | 1 1 0 0 | (2^390 + 2^260)G 13 | 1 1 0 1 | (2^390 + 2^260 + 1)G 14 | 1 1 1 0 | (2^390 + 2^260 + 2^130)G 15 | 1 1 1 1 | (2^390 + 2^260 + 2^130 + 1)G The reason for this is so that we can clock bits into four different locations when doing simple scalar multiplies against the base point. Tables for other points have table[i] = iG for i in 0 .. 16.

gmul is the table of precomputed base points

select_point selects the |idx|th point from a precomputation table and copies it to out.

pre_comp below is of the size provided in |size|

get_bit returns the |i|th bit in |in|

Interleaved point multiplication using precomputed point multiples: The small point multiples 0P, 1P, ..., 16P are in pre_comp[], the scalars in scalars[]. If g_scalar is non-NULL, we also add this multiple of the generator, using certain (large) precomputed multiples in g_pre_comp. Output point (X, Y, Z) is stored in x_out, y_out, z_out

set nq to the point at infinity

Loop over all scalars msb-to-lsb, interleaving additions of multiples of the generator (last quarter of rounds) and additions of other points multiples (every 5th round).

save two point operations in the first round

double

add multiples of the generator

select the point to add, in constant time

The 1 argument below is for "mixed"

do other additions every 5 doublings

loop over all scalars

select the point to add or subtract, in constant time

(X, -Y, Z) is the negative point

Precomputation for the group generator.

point_set_compressed_coordinates

point2oct

oct2point

field_div

field_encode

field_decode

field_set_to_one

set private

keycopy

keyfinish



FUNCTIONS TO MANAGE PRECOMPUTATION



OPENSSL EC_METHOD FUNCTIONS

Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') = (X/Z^2, Y/Z^3)

points below is of size |num|, and tmp_felems is of size |num+1/

Runs in constant time, unless an input is the point at infinity (which normally shouldn't happen).

Computes scalargenerator + \sum scalars[i]points[i], ignoring NULL values Result is stored in r (r can equal one of the inputs).

we have precomputation, try to use it

try to use the standard precomputation

get the generator from precomputation

precomputation matches generator

we don't have valid precomputation: treat the generator as a random point

unless we precompute multiples for just one point, converting those into affine form is time well spent

we treat NULL scalars as 0, and NULL points as points at infinity, i.e., they contribute nothing to the linear combination

we didn't have a valid precomputation, so we pick the generator

the i^th point

reduce scalar to 0 <= scalar < 2^521

this is an unusual input, and we don't guarantee constant-timeness

precompute multiples

the scalar for the generator

reduce scalar to 0 <= scalar < 2^521

this is an unusual input, and we don't guarantee constant-timeness

do the multiplication with generator precomputation

do the multiplication without generator precomputation

reduce the output to its unique minimal representation

throw away old precomputation

get the generator

if the generator is the standard one, use built-in precomputation

compute 2^130G, 2^260G, 2^390G

g_pre_comp[0] is the point at infinity

the remaining multiples

2^130G + 2^260G

2^130G + 2^390G

2^260G + 2^390G

2^130G + 2^260G + 2^390G

odd multiples: add G

www.openssl.org/source/license.html

www.apache.org/licenses/LICENSE-2.0

hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b

hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl,

License

License

AS IS

s work in ecp_nistp224.c. * Otherwise based on Emilia

s work on the same. */ #include <openssl/e_os2.h> #ifdef OPENSSL_NO_EC_NISTP_64_GCC_128 NON_EMPTY_TRANSLATION_UNIT #else # include <string.h> # include <openssl/err.h> # include "ec_lcl.h" # if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)) /* even with gcc, the typedef won

Need GCC 3.1 or later to define type uint128_t

limb

felem

largefelem

s Little Theorem: * a^p = a (mod p) * a^{p-1} = 1 (mod p) * a^{p-2} = a^{-1} (mod p) */ static void felem_inv(felem out, const felem in) { felem ftmp, ftmp2, ftmp3, ftmp4; largefelem tmp; unsigned i; felem_square(tmp, in); felem_reduce(ftmp, tmp); /* 2^1 */ felem_mul(tmp, in, ftmp); felem_reduce(ftmp, tmp); /* 2^2 - 2^0 */ felem_assign(ftmp2, ftmp); felem_square(tmp, ftmp); felem_reduce(ftmp, tmp); /* 2^3 - 2^1 */ felem_mul(tmp, in, ftmp); felem_reduce(ftmp, tmp); /* 2^3 - 2^0 */ felem_square(tmp, ftmp); felem_reduce(ftmp, tmp); /* 2^4 - 2^1 */ felem_square(tmp, ftmp2); felem_reduce(ftmp3, tmp); /* 2^3 - 2^1 */ felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^4 - 2^2 */ felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^4 - 2^0 */ felem_assign(ftmp2, ftmp3); felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^5 - 2^1 */ felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^6 - 2^2 */ felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^7 - 2^3 */ felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^8 - 2^4 */ felem_assign(ftmp4, ftmp3); felem_mul(tmp, ftmp3, ftmp); felem_reduce(ftmp4, tmp); /* 2^8 - 2^1 */ felem_square(tmp, ftmp4); felem_reduce(ftmp4, tmp); /* 2^9 - 2^2 */ felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^8 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 8; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^16 - 2^8 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^16 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 16; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^32 - 2^16 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^32 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 32; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^64 - 2^32 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^64 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 64; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^128 - 2^64 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^128 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 128; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^256 - 2^128 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^256 - 2^0 */ felem_assign(ftmp2, ftmp3); for (i = 0; i < 256; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^512 - 2^256 */ } felem_mul(tmp, ftmp3, ftmp2); felem_reduce(ftmp3, tmp); /* 2^512 - 2^0 */ for (i = 0; i < 9; i++) { felem_square(tmp, ftmp3); felem_reduce(ftmp3, tmp); /* 2^521 - 2^9 */ } felem_mul(tmp, ftmp3, ftmp4); felem_reduce(ftmp3, tmp); /* 2^512 - 2^2 */ felem_mul(tmp, ftmp3, in); felem_reduce(out, tmp); /* 2^512 - 3 */ } /* This is 2^521-1, expressed as an felem */ static const felem kPrime = { 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x03ffffffffffffff, 0x01ffffffffffffff }; /*- * felem_is_zero returns a limb with all bits set if |in| == 0 (mod p) and 0 * otherwise. * On entry: * in[i] < 2^59 + 2^14 */ static limb felem_is_zero(const felem in) { felem ftmp; limb is_zero, is_p; felem_assign(ftmp, in); ftmp[0] += ftmp[8] >> 57; ftmp[8] &= bottom57bits; /* ftmp[8] < 2^57 */ ftmp[1] += ftmp[0] >> 58; ftmp[0] &= bottom58bits; ftmp[2] += ftmp[1] >> 58; ftmp[1] &= bottom58bits; ftmp[3] += ftmp[2] >> 58; ftmp[2] &= bottom58bits; ftmp[4] += ftmp[3] >> 58; ftmp[3] &= bottom58bits; ftmp[5] += ftmp[4] >> 58; ftmp[4] &= bottom58bits; ftmp[6] += ftmp[5] >> 58; ftmp[5] &= bottom58bits; ftmp[7] += ftmp[6] >> 58; ftmp[6] &= bottom58bits; ftmp[8] += ftmp[7] >> 58; ftmp[7] &= bottom58bits; /* ftmp[8] < 2^57 + 4 */ /* * The ninth limb of 2*(2^521-1) is 0x03ffffffffffffff, which is greater * than our bound for ftmp[8]. Therefore we only have to check if the * zero is zero or 2^521-1. */ is_zero = 0; is_zero |= ftmp[0]; is_zero |= ftmp[1]; is_zero |= ftmp[2]; is_zero |= ftmp[3]; is_zero |= ftmp[4]; is_zero |= ftmp[5]; is_zero |= ftmp[6]; is_zero |= ftmp[7]; is_zero |= ftmp[8]; is_zero--; /* * We know that ftmp[i] < 2^63, therefore the only way that the top bit * can be set is if is_zero was 0 before the decrement. */ is_zero = ((s64) is_zero) >> 63; is_p = ftmp[0] ^ kPrime[0]; is_p |= ftmp[1] ^ kPrime[1]; is_p |= ftmp[2] ^ kPrime[2]; is_p |= ftmp[3] ^ kPrime[3]; is_p |= ftmp[4] ^ kPrime[4]; is_p |= ftmp[5] ^ kPrime[5]; is_p |= ftmp[6] ^ kPrime[6]; is_p |= ftmp[7] ^ kPrime[7]; is_p |= ftmp[8] ^ kPrime[8]; is_p--; is_p = ((s64) is_p) >> 63; is_zero |= is_p; return is_zero; } static int felem_is_zero_int(const felem in) { return (int)(felem_is_zero(in) & ((limb) 1)); } /*- * felem_contract converts |in| to its unique, minimal representation. * On entry: * in[i] < 2^59 + 2^14 */ static void felem_contract(felem out, const felem in) { limb is_p, is_greater, sign; static const limb two58 = ((limb) 1) << 58; felem_assign(out, in); out[0] += out[8] >> 57; out[8] &= bottom57bits; /* out[8] < 2^57 */ out[1] += out[0] >> 58; out[0] &= bottom58bits; out[2] += out[1] >> 58; out[1] &= bottom58bits; out[3] += out[2] >> 58; out[2] &= bottom58bits; out[4] += out[3] >> 58; out[3] &= bottom58bits; out[5] += out[4] >> 58; out[4] &= bottom58bits; out[6] += out[5] >> 58; out[5] &= bottom58bits; out[7] += out[6] >> 58; out[6] &= bottom58bits; out[8] += out[7] >> 58; out[7] &= bottom58bits; /* out[8] < 2^57 + 4 */ /* * If the value is greater than 2^521-1 then we have to subtract 2^521-1 * out. See the comments in felem_is_zero regarding why we don

s not tested). */ static void point_double(felem x_out, felem y_out, felem z_out, const felem x_in, const felem y_in, const felem z_in) { largefelem tmp, tmp2; felem delta, gamma, beta, alpha, ftmp, ftmp2; felem_assign(ftmp, x_in); felem_assign(ftmp2, x_in); /* delta = z^2 */ felem_square(tmp, z_in); felem_reduce(delta, tmp); /* delta[i] < 2^59 + 2^14 */ /* gamma = y^2 */ felem_square(tmp, y_in); felem_reduce(gamma, tmp); /* gamma[i] < 2^59 + 2^14 */ /* beta = x*gamma */ felem_mul(tmp, x_in, gamma); felem_reduce(beta, tmp); /* beta[i] < 2^59 + 2^14 */ /* alpha = 3*(x-delta)*(x+delta) */ felem_diff64(ftmp, delta); /* ftmp[i] < 2^61 */ felem_sum64(ftmp2, delta); /* ftmp2[i] < 2^60 + 2^15 */ felem_scalar64(ftmp2, 3); /* ftmp2[i] < 3*2^60 + 3*2^15 */ felem_mul(tmp, ftmp, ftmp2); /*- * tmp[i] < 17(3*2^121 + 3*2^76) * = 61*2^121 + 61*2^76 * < 64*2^121 + 64*2^76 * = 2^127 + 2^82 * < 2^128 */ felem_reduce(alpha, tmp); /* x

= (y + z)^2 - gamma - delta */ felem_sum64(delta, gamma); /* delta[i] < 2^60 + 2^15 */ felem_assign(ftmp, y_in); felem_sum64(ftmp, z_in); /* ftmp[i] < 2^60 + 2^15 */ felem_square(tmp, ftmp); /* * tmp[i] < 17(2^122) < 2^127 */ felem_diff_128_64(tmp, delta); /* tmp[i] < 2^127 + 2^63 */ felem_reduce(z_out, tmp); /* y

) - 8*gamma^2 */ felem_scalar64(beta, 4); /* beta[i] < 2^61 + 2^16 */ felem_diff64(beta, x_out); /* beta[i] < 2^61 + 2^60 + 2^16 */ felem_mul(tmp, alpha, beta); /*- * tmp[i] < 17*((2^59 + 2^14)(2^61 + 2^60 + 2^16)) * = 17*(2^120 + 2^75 + 2^119 + 2^74 + 2^75 + 2^30) * = 17*(2^120 + 2^119 + 2^76 + 2^74 + 2^30) * < 2^128 */ felem_square(tmp2, gamma); /*- * tmp2[i] < 17*(2^59 + 2^14)^2 * = 17*(2^118 + 2^74 + 2^28) */ felem_scalar128(tmp2, 8); /*- * tmp2[i] < 8*17*(2^118 + 2^74 + 2^28) * = 2^125 + 2^121 + 2^81 + 2^77 + 2^35 + 2^31 * < 2^126 */ felem_diff128(tmp, tmp2); /*- * tmp[i] < 2^127 - 2^69 + 17(2^120 + 2^119 + 2^76 + 2^74 + 2^30) * = 2^127 + 2^124 + 2^122 + 2^120 + 2^118 + 2^80 + 2^78 + 2^76 + * 2^74 + 2^69 + 2^34 + 2^30 * < 2^128 */ felem_reduce(y_out, tmp); } /* copy_conditional copies in to out iff mask is all ones. */ static void copy_conditional(felem out, const felem in, limb mask) { unsigned i; for (i = 0; i < NLIMBS; ++i) { const limb tmp = mask & (in[i] ^ out[i]); out[i] ^= tmp; } } /*- * point_add calculates (x1, y1, z1) + (x2, y2, z2) * * The method is taken from * http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl, * adapted for mixed addition (z2 = 1, or z2 = 0 for the point at infinity). * * This function includes a branch for checking whether the two input points * are equal (while not equal to the point at infinity). This case never * happens during single point multiplication, so there is no timing leak for * ECDH or ECDSA signing. */ static void point_add(felem x3, felem y3, felem z3, const felem x1, const felem y1, const felem z1, const int mixed, const felem x2, const felem y2, const felem z2) { felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out; largefelem tmp, tmp2; limb x_equal, y_equal, z1_is_zero, z2_is_zero; z1_is_zero = felem_is_zero(z1); z2_is_zero = felem_is_zero(z2); /* ftmp = z1z1 = z1**2 */ felem_square(tmp, z1); felem_reduce(ftmp, tmp); if (!mixed) { /* ftmp2 = z2z2 = z2**2 */ felem_square(tmp, z2); felem_reduce(ftmp2, tmp); /* u1 = ftmp3 = x1*z2z2 */ felem_mul(tmp, x1, ftmp2); felem_reduce(ftmp3, tmp); /* ftmp5 = z1 + z2 */ felem_assign(ftmp5, z1); felem_sum64(ftmp5, z2); /* ftmp5[i] < 2^61 */ /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */ felem_square(tmp, ftmp5); /* tmp[i] < 17*2^122 */ felem_diff_128_64(tmp, ftmp); /* tmp[i] < 17*2^122 + 2^63 */ felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 17*2^122 + 2^64 */ felem_reduce(ftmp5, tmp); /* ftmp2 = z2 * z2z2 */ felem_mul(tmp, ftmp2, z2); felem_reduce(ftmp2, tmp); /* s1 = ftmp6 = y1 * z2**3 */ felem_mul(tmp, y1, ftmp2); felem_reduce(ftmp6, tmp); } else { /* * We

mixed

EC_nistp521

, Y

t happen). */ ec_GFp_nistp_points_make_affine_internal(num, points, sizeof(felem), tmp_felems, (void (*)(void *))felem_one, (int (*)(const void *)) felem_is_zero_int, (void (*)(void *, const void *)) felem_assign, (void (*)(void *, const void *)) felem_square_reduce, (void (*) (void *, const void *, const void *)) felem_mul_reduce, (void (*)(void *, const void *)) felem_inv, (void (*)(void *, const void *)) felem_contract); } /* * Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL * values Result is stored in r (r can equal one of the inputs). */ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar, size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx) { int ret = 0; int j; int mixed = 0; BN_CTX *new_ctx = NULL; BIGNUM *x, *y, *z, *tmp_scalar; felem_bytearray g_secret; felem_bytearray *secrets = NULL; felem (*pre_comp)[17][3] = NULL; felem *tmp_felems = NULL; felem_bytearray tmp; unsigned i, num_bytes; int have_pre_comp = 0; size_t num_points = num; felem x_in, y_in, z_in, x_out, y_out, z_out; NISTP521_PRE_COMP *pre = NULL; felem(*g_pre_comp)[3] = NULL; EC_POINT *generator = NULL; const EC_POINT *p = NULL; const BIGNUM *p_scalar = NULL; if (ctx == NULL) if ((ctx = new_ctx = BN_CTX_new()) == NULL) return 0; BN_CTX_start(ctx); x = BN_CTX_get(ctx); y = BN_CTX_get(ctx); z = BN_CTX_get(ctx); tmp_scalar = BN_CTX_get(ctx); if (tmp_scalar == NULL) goto err; if (scalar != NULL) { pre = group->pre_comp.nistp521; if (pre) /* we have precomputation, try to use it */ g_pre_comp = &pre->g_pre_comp[0]; else /* try to use the standard precomputation */ g_pre_comp = (felem(*)[3]) gmul; generator = EC_POINT_new(group); if (generator == NULL) goto err; /* get the generator from precomputation */ if (!felem_to_BN(x, g_pre_comp[1][0]) || !felem_to_BN(y, g_pre_comp[1][1]) || !felem_to_BN(z, g_pre_comp[1][2])) { ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB); goto err; } if (!EC_POINT_set_Jprojective_coordinates_GFp(group, generator, x, y, z, ctx)) goto err; if (0 == EC_POINT_cmp(group, generator, group->generator, ctx)) /* precomputation matches generator */ have_pre_comp = 1; else /* * we don

t have a valid precomputation, so we pick the * generator */ { p = EC_GROUP_get0_generator(group); p_scalar = scalar; } else /* the i^th point */ { p = points[i]; p_scalar = scalars[i]; } if ((p_scalar != NULL) && (p != NULL)) { /* reduce scalar to 0 <= scalar < 2^521 */ if ((BN_num_bits(p_scalar) > 521) || (BN_is_negative(p_scalar))) { /* * this is an unusual input, and we don

0x01,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff},

0x01,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xff,

0xfc},

0x00,

0x51,

0x95,

0x3e,

0xb9,

0x61,

0x8e,

0x1c,

0x9a,

0x1f,

0x92,

0x9a,

0x21,

0xa0,

0xb6,

0x85,

0x40,

0xee,

0xa2,

0xda,

0x72,

0x5b,

0x99,

0xb3,

0x15,

0xf3,

0xb8,

0xb4,

0x89,

0x91,

0x8e,

0xf1,

0x09,

0xe1,

0x56,

0x19,

0x39,

0x51,

0xec,

0x7e,

0x93,

0x7b,

0x16,

0x52,

0xc0,

0xbd,

0x3b,

0xb1,

0xbf,

0x07,

0x35,

0x73,

0xdf,

0x88,

0x3d,

0x2c,

0x34,

0xf1,

0xef,

0x45,

0x1f,

0xd4,

0x6b,

0x50,

0x3f,

0x00},

0x00,

0xc6,

0x85,

0x8e,

0x06,

0xb7,

0x04,

0x04,

0xe9,

0xcd,

0x9e,

0x3e,

0xcb,

0x66,

0x23,

0x95,

0xb4,

0x42,

0x9c,

0x64,

0x81,

0x39,

0x05,

0x3f,

0xb5,

0x21,

0xf8,

0x28,

0xaf,

0x60,

0x6b,

0x4d,

0x3d,

0xba,

0xa1,

0x4b,

0x5e,

0x77,

0xef,

0xe7,

0x59,

0x28,

0xfe,

0x1d,

0xc1,

0x27,

0xa2,

0xff,

0xa8,

0xde,

0x33,

0x48,

0xb3,

0xc1,

0x85,

0x6a,

0x42,

0x9b,

0xf9,

0x7e,

0x7e,

0x31,

0xc2,

0xe5,

0xbd,

0x66},

0x01,

0x18,

0x39,

0x29,

0x6a,

0x78,

0x9a,

0x3b,

0xc0,

0x04,

0x5c,

0x8a,

0x5f,

0xb4,

0x2c,

0x7d,

0x1b,

0xd9,

0x98,

0xf5,

0x44,

0x49,

0x57,

0x9b,

0x44,

0x68,

0x17,

0xaf,

0xbd,

0x17,

0x27,

0x3e,

0x66,

0x2c,

0x97,

0xee,

0x72,

0x99,

0x5e,

0xf4,

0x26,

0x40,

0xc5,

0x50,

0xb9,

0x01,

0x3f,

0xad,

0x07,

0x61,

0x35,

0x3c,

0x70,

0x86,

0xa2,

0x72,

0xc2,

0x40,

0x88,

0xbe,

0x94,

0x76,

0x9f,

0xd1,

0x66,

0x50}

0x1ffffffffffffff;

0x3ffffffffffffff;

0xfffffffffffff;

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x03ffffffffffffff,

0x01ffffffffffffff

0x03ffffffffffffff,

0x017e7e31c2e5bd66,

0x022cf0615a90a6fe,

0x00127a2ffa8de334,

0x01dfbf9d64a3f877,

0x006b4d3dbaa14b5e,

0x014fed487e0a2bd8,

0x015b4429c6481390,

0x03a73678fb2d988e,

0x00c6858e06b70404},

0x00be94769fd16650,

0x031c21a89cb09022,

0x039013fad0761353,

0x02657bd099031542,

0x03273e662c97ee72,

0x01e6d11a05ebef45,

0x03d1bd998f544495,

0x03001172297ed0b1,

0x011839296a789a3b},

0x0373faacbc875bae,

0x00f325023721c671,

0x00f666fd3dbde5ad,

0x01a6932363f88ea7,

0x01fc6d9e13f9c47b,

0x03bcbffc2bbf734e,

0x013ee3c3647f3a92,

0x029409fefe75d07d,

0x00ef9199963d85e5},

0x011173743ad5b178,

0x02499c7c21bf7d46,

0x035beaeabb8b1a58,

0x00f989c4752ea0a3,

0x0101e1de48a9c1a3,

0x01a20076be28ba6c,

0x02f8052e5eb2de95,

0x01bfe8f82dea117c,

0x0160074d3c36ddb7},

0x012f3fc373393b3b,

0x03d3d6172f1419fa,

0x02adc943c0b86873,

0x00d475584177952b,

0x012a4d1673750ee2,

0x00512517a0f13b0c,

0x02b184671a7b1734,

0x0315b84236f1a50a,

0x00a4afc472edbdb9},

0x00152a7077f385c4,

0x03044007d8d1c2ee,

0x0065829d61d52b52,

0x00494ff6b6631d0d,

0x00a11d94d5f06bcf,

0x02d2f89474d9282e,

0x0241c5727c06eeb9,

0x0386928710fbdb9d,

0x01f883f727b0dfbe},

0x019b0c3c9185544d,

0x006243a37c9d97db,

0x02ee3cbe030a2ad2,

0x00cfdd946bb51e0d,

0x0271c00932606b91,

0x03f817d1ec68c561,

0x03f37009806a369c,

0x03c1f30baf184fd5,

0x01091022d6d2f065},

0x0292c583514c45ed,

0x0316fca51f9a286c,

0x00300af507c1489a,

0x0295f69008298cf1,

0x02c0ed8274943d7b,

0x016509b9b47a431e,

0x02bc9de9634868ce,

0x005b34929bffcb09,

0x000c1a0121681524},

0x0286abc0292fb9f2,

0x02665eee9805b3f7,

0x01ed7455f17f26d6,

0x0346355b83175d13,

0x006284944cd0a097,

0x0191895bcdec5e51,

0x02e288370afda7d9,

0x03b22312bfefa67a,

0x01d104d3fc0613fe},

0x0092421a12f7e47f,

0x0077a83fa373c501,

0x03bd25c5f696bd0d,

0x035c41e4d5459761,

0x01ca0d1742b24f53,

0x00aaab27863a509c,

0x018b6de47df73917,

0x025c0b771705cd01,

0x01fd51d566d760a7},

0x01dd92ff6b0d1dbd,

0x039c5e2e8f8afa69,

0x0261ed13242c3b27,

0x0382c6e67026e6a0,

0x01d60b10be2089f9,

0x03c15f3dce86723f,

0x03c764a32d2a062d,

0x017307eac0fad056,

0x018207c0b96c5256},

0x0196a16d60e13154,

0x03e6ce74c0267030,

0x00ddbf2b4e52a5aa,

0x012738241bbf31c8,

0x00ebe8dc04685a28,

0x024c2ad6d380d4a2,

0x035ee062a6e62d0e,

0x0029ed74af7d3a0f,

0x00eef32aec142ebd},

0x00c31ec398993b39,

0x03a9f45bcda68253,

0x00ac733c24c70890,

0x00872b111401ff01,

0x01d178c23195eafb,

0x03bca2c816b87f74,

0x0261a9af46fbad7a,

0x0324b2a8dd3d28f9,

0x00918121d8f24e23},

0x032bc8c1ca983cd7,

0x00d869dfb08fc8c6,

0x01693cb61fce1516,

0x012a5ea68f4e88a8,

0x010869cab88d7ae3,

0x009081ad277ceee1,

0x033a77166d064cdc,

0x03955235a1fb3a95,

0x01251a4a9b25b65e},

0x00148a3a1b27f40b,

0x0123186df1b31fdc,

0x00026e7beaad34ce,

0x01db446ac1d3dbba,

0x0299c1a33437eaec,

0x024540610183cbb7,

0x0173bb0e9ce92e46,

0x02b937e43921214b,

0x01ab0436a9bf01b5},

0x0383381640d46948,

0x008dacbf0e7f330f,

0x03602122bcc3f318,

0x01ee596b200620d6,

0x03bd0585fda430b3,

0x014aed77fd123a83,

0x005ace749e52f742,

0x0390fe041da2b842,

0x0189a8ceb3299242},

0x012a19d6b3282473,

0x00c0915918b423ce,

0x023a954eb94405ae,

0x00529f692be26158,

0x0289fa1b6fa4b2aa,

0x0198ae4ceea346ef,

0x0047d8cdfbdedd49,

0x00cc8c8953f0f6b8,

0x001424abbff49203},

0x0256732a1115a03a,

0x0351bc38665c6733,

0x03f7b950fb4a6447,

0x000afffa94c22155,

0x025763d0a4dab540,

0x000511e92d4fc283,

0x030a7e9eda0ee96c,

0x004c3cd93a28bf0a,

0x017edb3a8719217f},

0x011de5675a88e673,

0x031d7d0f5e567fbe,

0x0016b2062c970ae5,

0x03f4a2be49d90aa7,

0x03cef0bd13822866,

0x03f0923dcf774a6c,

0x0284bebc4f322f72,

0x016ab2645302bb2c,

0x01793f95dace0e2a},

0x010646e13527a28f,

0x01ca1babd59dc5e7,

0x01afedfd9a5595df,

0x01f15785212ea6b1,

0x0324e5d64f6ae3f4,

0x02d680f526d00645,

0x0127920fadf627a7,

0x03b383f75df4f684,

0x0089e0057e783b0a},

0x00f334b9eb3c26c6,

0x0298fdaa98568dce,

0x01c2d24843a82292,

0x020bcb24fa1b0711,

0x02cbdb3d2b1875e6,

0x0014907598f89422,

0x03abe3aa43b26664,

0x02cbf47f720bc168,

0x0133b5e73014b79b},

0x034aab5dab05779d,

0x00cdc5d71fee9abb,

0x0399f16bd4bd9d30,

0x03582fa592d82647,

0x02be1cdfb775b0e9,

0x0034f7cea32e94cb,

0x0335a7f08f56f286,

0x03b707e9565d1c8b,

0x0015c946ea5b614f},

0x024676f6cff72255,

0x00d14625cac96378,

0x00532b6008bc3767,

0x01fc16721b985322,

0x023355ea1b091668,

0x029de7afdc0317c3,

0x02fc8a7ca2da037c,

0x02de1217d74a6f30,

0x013f7173175b73bf},

0x0344913f441490b5,

0x0200f9e272b61eca,

0x0258a246b1dd55d2,

0x03753db9ea496f36,

0x025e02937a09c5ef,

0x030cbd3d14012692,

0x01793a67e70dc72a,

0x03ec1d37048a662e,

0x006550f700c32a8d},

0x00d3f48a347eba27,

0x008e636649b61bd8,

0x00d3b93716778fb3,

0x004d1915757bd209,

0x019d5311a3da44e0,

0x016d1afcbbe6aade,

0x0241bf5f73265616,

0x0384672e5d50d39b,

0x005009fee522b684},

0x029b4fab064435fe,

0x018868ee095bbb07,

0x01ea3d6936cc92b8,

0x000608b00f78a2f3,

0x02db911073d1c20f,

0x018205938470100a,

0x01f1e4964cbe6ff2,

0x021a19a29eed4663,

0x01414485f42afa81},

0x01612b3a17f63e34,

0x03813992885428e6,

0x022b3c215b5a9608,

0x029b4057e19f2fcb,

0x0384059a587af7e6,

0x02d6400ace6fe610,

0x029354d896e8e331,

0x00c047ee6dfba65e,

0x0037720542e9d49d},

0x02ce9eed7c5e9278,

0x0374ed703e79643b,

0x01316c54c4072006,

0x005aaa09054b2ee8,

0x002824000c840d57,

0x03d4eba24771ed86,

0x0189c50aabc3bdae,

0x0338c01541e15510,

0x00466d56e38eed42},

0x007efd8330ad8bd6,

0x02465ed48047710b,

0x0034c6606b215e0c,

0x016ae30c53cbf839,

0x01fa17bd37161216,

0x018ead4e61ce8ab9,

0x005482ed5f5dee46,

0x037543755bba1d7f,

0x005e5ac7e70a9d0f},

0x0117e1bb2fdcb2a2,

0x03deea36249f40c4,

0x028d09b4a6246cb7,

0x03524b8855bcf756,

0x023d7d109d5ceb58,

0x0178e43e3223ef9c,

0x0154536a0c6e966a,

0x037964d1286ee9fe,

0x0199bcd90e125055},

