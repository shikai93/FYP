Copyright 2001-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

mul

precompute_mult

have_precompute_mult

field_div

field_encode

field_decode

field_set_to_one

set private

keycopy

keyfinish

Most method functions in this file are designed to work with non-trivial representations of field elements if necessary (see ecp_mont.c): while standard modular addition and subtraction are used, the field_mul and field_sqr methods will be used for multiplication, and field_encode and field_decode (if defined) will be used for converting between representations. Functions ec_GFp_simple_points_make_affine() and ec_GFp_simple_point_get_affine_coordinates() specifically assume that if a non-trivial representation is used, it is a Montgomery representation (i.e. 'encoding' means multiplying by some factor R).

p must be a prime > 3

group->field

group->a

group->b

group->a_is_minus3

check the discriminant: y^2 = x^3 + ax + b is an elliptic curve <=> 4a^3 + 27b^2 != 0 (mod p) 0 =< a, b < p

tmp_1 = 4a^3

tmp_2 = 27b^2

unlike for projective coordinates, we do not tolerate this

transform (X, Y, Z) into (x, y) := (X/Z^2, Y/Z^3)

field_sqr works on standard representation

in the Montgomery case, field_mul will cancel out Montgomery factor in X:

field_mul works on standard representation

in the Montgomery case, field_mul will cancel out Montgomery factor in Y:

Note that in this function we must not read components of 'a' or 'b' once we have written the corresponding components of 'r'. ('r' might be one of 'a' or 'b'.)

n1, n2

n1 = X_a

n2 = Y_a

n1 = X_a Z_b^2

n2 = Y_a Z_b^3

n3, n4

n3 = X_b

n4 = Y_b

n3 = X_b Z_a^2

n4 = Y_b Z_a^3

n5, n6

n5 = n1 - n3

n6 = n2 - n4

a is the same point as b

a is the inverse of b

'n7', 'n8'

'n7' = n1 + n3

'n8' = n2 + n4

Z_r

Z_r = Z_a Z_b n5

X_r

X_r = n6^2 - n5^2 'n7'

'n9'

n9 = n5^2 'n7' - 2 X_r

Y_r

now n5 is n5^3

now 0 <= n0 < 2p, and n0 is even

Y_r = (n6 'n9' - 'n8' 'n5^3') / 2

otherwise we already called BN_CTX_end

Note that in this function we must not read components of 'a' once we have written the corresponding components of 'r'. ('r' might the same as 'a'.)

n1

n1 = 3 X_a^2 + a_curve

n1 = 3 (X_a + Z_a^2) (X_a - Z_a^2) = 3 X_a^2 - 3 Z_a^4

n1 = 3 X_a^2 + a_curve Z_a^4

Z_r

Z_r = 2 Y_a Z_a

n2

n2 = 4 X_a Y_a^2

X_r

X_r = n1^2 - 2 n2

n3

n3 = 8 Y_a^4

Y_r

Y_r = n1 (n2 - X_r) - n3

point is its own inverse

We have a curve defined by a Weierstrass equation y^2 = x^3 + ax + b. The point to consider is given in Jacobian projective coordinates where (X, Y, Z) represents (x, y) = (X/Z^2, Y/Z^3). Substituting this and multiplying by Z^6 transforms the above equation into Y^2 = X^3 + aXZ^4 + bZ^6. To test this, we add up the right-hand side in 'rh'.

rh := X^2

rh := (rh + aZ^4)X

rh := rh + bZ^6

point->Z_is_one

rh := (rh + a)X

rh := rh + b

'lh' := Y^2

return values: -1 error 0 equal (in affine coordinates) 1 not equal

We have to decide whether (X_a/Z_a^2, Y_a/Z_a^3) = (X_b/Z_b^2, Y_b/Z_b^3), or equivalently, whether (X_aZ_b^2, Y_aZ_b^3) = (X_bZ_a^2, Y_bZ_a^3).

compare X_aZ_b^2 with X_bZ_a^2

points differ

tmp1_ = tmp1

tmp2_ = tmp2

compare Y_aZ_b^3 with Y_bZ_a^3

points differ

points are equal

Set each prod_Z[i] to the product of points[0]->Z .. points[i]->Z, skipping any zero-valued inputs (pretend that they're 1).

Now use a single explicit inversion to replace every non-zero points[i]->Z by its inverse.

In the Montgomery case, we just turned RH (representing H) into 1/(RH), but we need R(1/H) (representing 1/H); i.e. we need to multiply by the Montgomery factor twice.

Loop invariant: tmp is the product of the inverses of points[0]->Z .. points[i]->Z (zero-valued inputs skipped).

Set tmp_Z to the inverse of points[i]->Z (as product of Z inverses 0 .. i, Z values 0 .. i - 1).

Update tmp to satisfy the loop invariant for i - 1.

Replace points[i]->Z by its inverse.

Replace points[0]->Z by its inverse.

Finally, fix up the X and Y coordinates for all points.

turn (X, Y, 1/Z) into (X/Z^2, Y/Z^3, 1)

www.openssl.org/source/license.html

License

ec_lcl.h

encoding

a

b

r

r

a

b

n7

n8

n7

n8

n7

n9

n7

n9

n8

n5^3

a

r

r

a

rh

lh

