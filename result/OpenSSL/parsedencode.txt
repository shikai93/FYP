Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

We assume that PEM encoded files are EBCDIC files (i.e., printable text files). Convert them here while decoding. When encoding, output is EBCDIC (text) format again. (No need for conversion in the conv_bin2ascii macro, as the underlying textstring data_bin2ascii[] is already EBCDIC)

64 char lines pad input with 0 left over chars are set to = 1 byte => xx== 2 bytes => xxx= 3 bytes => xxxx

0xF0 is a EOLN 0xF1 is ignore but next needs to be 0xF0 (for \r\n processing). 0xF2 is EOF 0xE0 is ignore at start of line. 0xFF is error

Too much output data!

Only ctx->num is used during decoding.

-1 for error 0 for last line 1 for full line Note: even though EVP_DecodeUpdate attempts to detect and report end of content, the context doesn't currently remember it and will accept more data in the next call. Therefore, the caller is responsible for checking and rejecting a 0 return value in the middle of content. Note: even though EVP_DecodeUpdate has historically tried to detect end of content based on line length, this has never worked properly. Therefore, we now return 0 when one of the following is true: - Padding or B64_EOF was detected and the last block is complete. - Input has zero-length. -1 is returned if: - Invalid characters are detected. - There is extra trailing padding, or data after padding. - B64_EOF is detected after an incomplete base64 block.

Legacy behaviour: an empty input chunk signals end of input.

More data after padding.

Only save valid base64 characters.

We increment n once per loop, and empty the buffer as soon as we reach 64 characters, so this can only happen if someone's manually messed with the ctx. Refuse to write any more data.

Legacy behaviour: if the current line is a full base64-block (i.e., has 0 mod 4 base64 characters), it is processed immediately. We keep this behaviour as applications may not be calling EVP_DecodeFinal properly.

EOF in the middle of a base64 block.

Legacy behaviour. This should probably rather be zeroed on error.

trim white space from the start of the line.

strip off stuff at the end of the line ascii2bin values B64_WS, B64_EOLN, B64_EOLN and B64_EOF

www.openssl.org/source/license.html

License

internal/cryptlib.h

evp_locl.h

ABCDEFGHIJKLMNOPQRSTUVWXYZ\ abcdefghijklmnopqrstuvwxyz0123456789+/

\n

\0

\n

\0

\n

\0

=

=

\0

t currently remember it and will accept more data * in the next call. Therefore, the caller is responsible for checking and * rejecting a 0 return value in the middle of content. * * Note: even though EVP_DecodeUpdate has historically tried to detect end of * content based on line length, this has never worked properly. Therefore, * we now return 0 when one of the following is true: * - Padding or B64_EOF was detected and the last block is complete. * - Input has zero-length. * -1 is returned if: * - Invalid characters are detected. * - There is extra trailing padding, or data after padding. * - B64_EOF is detected after an incomplete base64 block. */ int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { int seof = 0, eof = 0, rv = -1, ret = 0, i, v, tmp, n, decoded_len; unsigned char *d; n = ctx->num; d = ctx->enc_data; if (n > 0 && d[n - 1] ==

) { eof++; if (n > 1 && d[n - 2] ==

) eof++; } /* Legacy behaviour: an empty input chunk signals end of input. */ if (inl == 0) { rv = 0; goto end; } for (i = 0; i < inl; i++) { tmp = *(in++); v = conv_ascii2bin(tmp); if (v == B64_ERROR) { rv = -1; goto end; } if (tmp ==

) { eof++; } else if (eof > 0 && B64_BASE64(v)) { /* More data after padding. */ rv = -1; goto end; } if (eof > 2) { rv = -1; goto end; } if (v == B64_EOF) { seof = 1; goto tail; } /* Only save valid base64 characters. */ if (B64_BASE64(v)) { if (n >= 64) { /* * We increment n once per loop, and empty the buffer as soon as * we reach 64 characters, so this can only happen if someone

0x3f])

0x3f])

0xF0

0xF1

0xF0

0xF2

0xE0

0xFF

0xF0

0xF1

0xF2

0xE0

0xFF

0x13)

0xF3)

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xE0,

0xF0,

0xFF,

0xFF,

0xF1,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xE0,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0x3E,

0xFF,

0xF2,

0xFF,

0x3F,

0x34,

0x35,

0x36,

0x37,

0x38,

0x39,

0x3A,

0x3B,

0x3C,

0x3D,

0xFF,

0xFF,

0xFF,

0x00,

0xFF,

0xFF,

0xFF,

0x00,

0x01,

0x02,

0x03,

0x04,

0x05,

0x06,

0x07,

0x08,

0x09,

0x0A,

0x0B,

0x0C,

0x0D,

0x0E,

0x0F,

0x10,

0x11,

0x12,

0x13,

0x14,

0x15,

0x16,

0x17,

0x18,

0x19,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0x1A,

0x1B,

0x1C,

0x1D,

0x1E,

0x1F,

0x20,

0x21,

0x22,

0x23,

0x24,

0x25,

0x26,

0x27,

0x28,

0x29,

0x2A,

0x2B,

0x2C,

0x2D,

0x2E,

0x2F,

0x30,

0x31,

0x32,

0x33,

0xFF,

0xFF,

0xFF,

0xFF,

0xFF,

0x80)

0x80)

0x80)

0x80)

0x80)

0x80))

0xff;

0xff;

0xff;

