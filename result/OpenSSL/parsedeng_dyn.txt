Copyright 2001-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Shared libraries implementing ENGINEs for use by the "dynamic" ENGINE loader should implement the hook-up functions with the following prototypes.

Our ENGINE handlers

Predeclare our context type

The implementation for the important control command

The constants used when creating the ENGINE

Loading code stores state inside the ENGINE structure via the "ex_data" element. We load all our state into a single structure and use that as a single context in the "ex_data" stack.

The DSO object we load that supplies the ENGINE code

The function pointer to the version checking shared library function

The function pointer to the engine-binding shared library function

The default name/path for loading the shared library

Whether to continue loading on a version check failure

If non-NULL, stipulates the 'id' of the ENGINE to be loaded

If non-zero, a successfully loaded ENGINE should be added to the internal ENGINE list. If 2, the add must succeed or the entire load should fail.

The symbol name for the version checking function

The symbol name for the "initialise ENGINE structure" function

Whether to never use 'dirs', use 'dirs' as a fallback, or only use 'dirs' for loading. Default is to use 'dirs' as a fallback.

A stack of directories from which ENGINEs could be loaded

This is the "ex_data" index we obtain and reserve for use with our context structure.

Because our ex_data element may or may not get allocated depending on whether a "first-use" occurs before the ENGINE is freed, we have a memory leak problem to solve. We can't declare a "new" handler for the ex_data as we don't want a dynamic_data_ctx in all ENGINE structures of all types (this is a bug in the design of CRYPTO_EX_DATA). As such, we just declare a "free" handler and that will get called if an ENGINE is being destroyed and there was an ex_data element corresponding to our context type.

Construct the per-ENGINE context. We create it blindly and then use a lock to check for a race - if so, all but one of the threads "racing" will have wasted their time. The alternative involves creating everything inside the lock which is far worse.

Good, we're the first

If we lost the race to set the context, c is non-NULL and ctx is the context of the thread that won.

This function retrieves the context structure from an ENGINE's "ex_data", or if it doesn't exist yet, sets it up.

Create and register the ENGINE ex_data, and associate our "free" function with it to ensure any allocated contexts get freed when an ENGINE goes underground.

Avoid a race by checking again inside this lock

Good, someone didn't beat us to it

In theory we could "give back" the index here if (new_idx>-1), but it's not possible and wouldn't gain us much if it were.

Check if the context needs to be created

"set_data" will set errors if necessary

If the "add" worked, it gets a structural reference. So either way, we release our just-created reference.

If the "add" didn't work, it was probably a conflict because it was already added (eg. someone calling ENGINE_load_blah then calling ENGINE_load_builtin_engines() perhaps).

We always return failure - the "dynamic" engine itself can't be used for anything.

This should never be called on account of "dynamic_init" always failing.

All our control commands require the ENGINE to be uninitialised

a NULL 'p' or a string of zero-length is the same thing

a NULL 'p' or a string of zero-length is the same thing

a NULL 'p' or a string of zero-length is the same thing

Unless told not to, try a direct load

If we're not allowed to use 'dirs' or we have none, fail

Found what we're looking for

We have to find a bind function otherwise it'll always end badly

Do we perform version checking?

Now we try to find a version checking function and decide how to cope with failure if/when it fails.

We fail if the version checker veto'd the load or if it is deferring to us (by returning its version) and we think it is too old.

Fail

First binary copy the ENGINE structure so that we can roll back if the hand-over fails

Provide the ERR, "ex_data", memory, and locking callbacks so the loaded library uses our state rather than its own. FIXME: As noted in engine.h, much of this would be simplified if each area of code provided its own "summary" structure of all related callbacks. It would also increase opaqueness.

Now that we've loaded the dynamic engine, make sure no "dynamic" ENGINE elements will show through.

Try to bind the ENGINE onto our own ENGINE structure

Copy the original ENGINE structure back

Do we try to add this ENGINE to the internal list too?

Do we tolerate this or fail?

Fail - NB: By this time, it's too late to rollback, and trying to do so allows the bind_engine() code to have created leaks. We just have to fail where we are, after the ENGINE has changed.

Tolerate

www.openssl.org/source/license.html

License

eng_int.h

internal/dso.h

dynamic

dynamic

Dynamic engine loading support

SO_PATH

Specifies the path to the new ENGINE shared library

NO_VCHECK

Specifies to continue even if version checking fails (boolean)

ID

Specifies an ENGINE id name for loading

LIST_ADD

Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)

DIR_LOAD

Specifies whether to load from 'DIR_ADD' directories (0=no,1=yes,2=mandatory)

DIR_ADD

Adds a directory from which ENGINEs can be loaded

LOAD

Load up the ENGINE specified by other settings

ex_data

ex_data

id

initialise ENGINE structure

dirs

dirs

dirs

dirs

ex_data

first-use

t declare a "new" handler for the ex_data as * we don

free

racing

v_check

bind_engine

re the first */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c->dirs); OPENSSL_free(c); return ret; } /* * This function retrieves the context structure from an ENGINE

ex_data

t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx < 0) { /* * Create and register the ENGINE ex_data, and associate our "free" * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx < 0) { /* Good, someone didn

give back

s not possible and wouldn

set_data

add

add

t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); } static int dynamic_init(ENGINE *e) { /* * We always return failure - the "dynamic" engine itself can

dynamic_init

p

p

p

re not allowed to use

or we have none, fail */ if (!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1) return 0; for (loop = 0; loop < num; loop++) { const char *s = sk_OPENSSL_STRING_value(ctx->dirs, loop); char *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx->dynamic_dso, merge, NULL, 0)) { /* Found what we

ll always end badly */ if (! (ctx->bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx->dynamic_dso, ctx->DYNAMIC_F2))) { ctx->bind_engine = NULL; DSO_free(ctx->dynamic_dso); ctx->dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx->no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx->v_check = (dynamic_v_check_fn) DSO_bind_func(ctx->dynamic_dso, ctx->DYNAMIC_F1); if (ctx->v_check) vcheck_res = ctx->v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto

ex_data

summary

ve loaded the dynamic engine, make sure no "dynamic" * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ if (!ctx->bind_engine(e, ctx->engine_id, &fns)) { ctx->bind_engine = NULL; ctx->v_check = NULL; DSO_free(ctx->dynamic_dso); ctx->dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, &cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ if (ctx->list_add_value > 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx->list_add_value > 1) { /* * Fail - NB: By this time, it

