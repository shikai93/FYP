Copyright 2001-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The type of the items in the table

The 'nid' of this algorithm/mode

ENGINEs that implement this algorithm/mode.

The default ENGINE to perform this algorithm/mode.

Zero if 'sk' is newer than the cached 'funct', non-zero otherwise

The type exposed in eng_int.h

ENGINE_TABLE

Global flags (ENGINE_TABLE_FLAG_).

API function manipulating 'table_flags'

Internal functions for the "piles" hash table

Privately exposed (via eng_int.h) functions for adding and/or removing ENGINEs from the implementation table

The cleanup callback needs to be added

A registration shouldn't add duplicate entries

if 'setdefault', this ENGINE goes to the head of the list

"touch" this ENGINE_PILE

Iterate the 'c->sk' stack removing any occurrence of 'e'

return a functional reference for a given 'nid'

Check again inside the lock otherwise we could race against cleanup operations. But don't worry about a fprintf(stderr).

Try to initialise the ENGINE?

Update 'funct'

If there was a previous default we release it.

If it failed, it is unlikely to succeed again until some future registrations have taken place. In all cases, we cache.

Whatever happened, any failed init()s are not failures in this context, so clear our error state.

Table enumeration

www.openssl.org/source/license.html

License

internal/cryptlib.h

eng_int.h

nid

sk

funct

table_flags

piles

t add duplicate entries */ (void)sk_ENGINE_delete_ptr(fnd->sk, e); /* * if

, this ENGINE goes to the head of the list */ if (!sk_ENGINE_push(fnd->sk, e)) goto end; /* "touch" this ENGINE_PILE */ fnd->uptodate = 0; if (setdefault) { if (!engine_unlocked_init(e)) { ENGINEerr(ENGINE_F_ENGINE_TABLE_REGISTER, ENGINE_R_INIT_FAILED); goto end; } if (fnd->funct) engine_unlocked_finish(fnd->funct, 0); fnd->funct = e; fnd->uptodate = 1; } nids++; } ret = 1; end: CRYPTO_THREAD_unlock(global_engine_lock); return ret; } static void int_unregister_cb(ENGINE_PILE *pile, ENGINE *e) { int n; /* Iterate the

stack removing any occurrence of

*/ while ((n = sk_ENGINE_find(pile->sk, e)) >= 0) { (void)sk_ENGINE_delete(pile->sk, n); pile->uptodate = 0; } if (pile->funct == e) { engine_unlocked_finish(e, 0); pile->funct = NULL; } } IMPLEMENT_LHASH_DOALL_ARG(ENGINE_PILE, ENGINE); void engine_table_unregister(ENGINE_TABLE **table, ENGINE *e) { CRYPTO_THREAD_write_lock(global_engine_lock); if (int_table_check(table, 0)) lh_ENGINE_PILE_doall_ENGINE(&(*table)->piles, int_unregister_cb, e); CRYPTO_THREAD_unlock(global_engine_lock); } static void int_cleanup_cb_doall(ENGINE_PILE *p) { if (!p) return; sk_ENGINE_free(p->sk); if (p->funct) engine_unlocked_finish(p->funct, 0); OPENSSL_free(p); } void engine_table_cleanup(ENGINE_TABLE **table) { CRYPTO_THREAD_write_lock(global_engine_lock); if (*table) { lh_ENGINE_PILE_doall(&(*table)->piles, int_cleanup_cb_doall); lh_ENGINE_PILE_free(&(*table)->piles); *table = NULL; } CRYPTO_THREAD_unlock(global_engine_lock); } /* return a functional reference for a given

*/ #ifndef ENGINE_TABLE_DEBUG ENGINE *engine_table_select(ENGINE_TABLE **table, int nid) #else ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f, int l) #endif { ENGINE *ret = NULL; ENGINE_PILE tmplate, *fnd = NULL; int initres, loop = 0; if (!(*table)) { #ifdef ENGINE_TABLE_DEBUG fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, nothing " "registered!\n", f, l, nid); #endif return NULL; } ERR_set_mark(); CRYPTO_THREAD_write_lock(global_engine_lock); /* * Check again inside the lock otherwise we could race against cleanup * operations. But don

engine_table_dbg: %s:%d, nid=%d, using

ENGINE '%s' cached\n

engine_table_dbg: %s:%d, nid=%d, no

registered implementations would initialise\n

funct

engine_table_dbg: %s:%d, nid=%d,

setting default to '%s'\n

engine_table_dbg: %s:%d, nid=%d, using

newly initialised '%s'\n

engine_table_dbg: %s:%d, nid=%d, caching

ENGINE '%s'\n

engine_table_dbg: %s:%d, nid=%d, caching

'no matching ENGINE'\n

