Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

longest known is SHA512

Default PKCS#5 iteration count

digest can only handle a single block

digest is extensible-output function, XOF

DigestAlgorithmIdentifier flags...

NULL or absent parameter accepted. Use NULL

NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent

Custom handling via ctrl

Note if suitable for use in FIPS mode

Digest ctrls

Minimum Algorithm specific ctrl value

!EVP_MD

values for EVP_MD_CTX flags

digest update will be called once only

context has already been cleaned

Don't free up ctx->md_data in EVP_MD_CTX_reset

FIPS and pad options are ignored in 1.0.0, definitions are here so we don't accidentally reuse the values for other purposes.

Allow use of non FIPS digest in FIPS mode

The following PAD options are also currently ignored in 1.0.0, digest parameters are handled through EVP_DigestSign() and EVP_DigestVerify() instead.

RSA mode to use

PKCS#1 v1.5 mode

X9.31 mode

PSS mode

Don't initialize md_data

Some functions such as EVP_DigestSign only finalise copies of internal contexts so additional data can be included after the finalisation call. This is inefficient if this functionality is not required: it is disabled if the following flag is set.

Values for cipher flags

Modes for ciphers

Set if variable length cipher

Set if the iv handling should be done by the cipher itself

Set if the cipher's init() function should be called if key is NULL

Call ctrl() to init cipher parameters

Don't use standard key length function

Don't use standard block padding

cipher handles random key generation

cipher has its own additional copying logic

Allow use default ASN1 get/set iv

Buffer length in bits not bytes: CFB1 mode only

Note if suitable for use in FIPS mode

Allow non FIPS cipher in FIPS mode

Cipher handles any and all padding logic as well as finalisation.

Cipher can handle pipeline operations

Cipher context flag to indicate we can handle wrap mode: if allowed in older applications it could overflow buffers.

ctrl() values

AEAD cipher deduces payload length and returns number of bytes required to store MAC and eventual padding. Subsequent call to EVP_Cipher even appends/verifies MAC.

Used by composite AEAD ciphers, no-op in GCM, CCM...

Set the GCM invocation field, decrypt only

EVP_CTRL_SET_SBOX takes the char specifying S-boxes

EVP_CTRL_SBOX_USED takes a 'size_t' and 'char ', pointing at a pre-allocated buffer with specified size

EVP_CTRL_KEY_MESH takes 'size_t' number of bytes to mesh the key after, 0 switches meshing off

EVP_CTRL_BLOCK_PADDING_MODE takes the padding mode

Set the output buffers to use for a pipelined operation

Set the input buffers to use for a pipelined operation

Set the input buffer lengths to use for a pipelined operation

Padding modes

RFC 5246 defines additional data to be 13 bytes in length

GCM TLS constants

Length of fixed part of IV derived from PRF

Length of explicit part of IV part of TLS records

Length of tag for TLS

CCM TLS constants

Length of fixed part of IV derived from PRF

Length of explicit part of IV part of TLS records

Total length of CCM IV length for TLS

Length of tag for TLS

Length of CCM8 tag for TLS

Length of tag for TLS

Password based encryption function

Add some extra combinations

_owu

_owu

_owu

_owu

_owu

_owu

_owu

_owu

_owu

_owu

does nothing :-)

This should now be supported through the dev_crypto ENGINE. But also, why are rc4 and md5 declarations made here inside a "NO_DES" precompiler branch?

calls methods

These are used by EVP_CIPHER methods

PKCS5 password based encryption

PBE type

Can appear as the outermost AlgorithmIdentifier

Is an PRF type OID

Is a PKCS#5 v2.0 KDF

Used by GOST key encryption in TLS

Method handles all operations: don't assume any digest related defaults.

www.openssl.org/source/license.html

License

C

t free up ctx->md_data * in EVP_MD_CTX_reset */ /* * FIPS and pad options are ignored in 1.0.0, definitions are here so we * don

t initialize md_data */ /* * Some functions such as EVP_DigestSign only finalise copies of internal * contexts so additional data can be included after the finalisation call. * This is inefficient if this functionality is not required: it is disabled * if the following flag is set. */ # define EVP_MD_CTX_FLAG_FINALISE 0x0200 EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len); EVP_CIPHER *EVP_CIPHER_meth_dup(const EVP_CIPHER *cipher); void EVP_CIPHER_meth_free(EVP_CIPHER *cipher); int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len); int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags); int EVP_CIPHER_meth_set_impl_ctx_size(EVP_CIPHER *cipher, int ctx_size); int EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher, int (*init) (EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc)); int EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher, int (*do_cipher) (EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl)); int EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher, int (*cleanup) (EVP_CIPHER_CTX *)); int EVP_CIPHER_meth_set_set_asn1_params(EVP_CIPHER *cipher, int (*set_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *)); int EVP_CIPHER_meth_set_get_asn1_params(EVP_CIPHER *cipher, int (*get_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *)); int EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher, int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr)); int (*EVP_CIPHER_meth_get_init(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc); int (*EVP_CIPHER_meth_get_do_cipher(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl); int (*EVP_CIPHER_meth_get_cleanup(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *); int (*EVP_CIPHER_meth_get_set_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *, ASN1_TYPE *); int (*EVP_CIPHER_meth_get_get_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *, ASN1_TYPE *); int (*EVP_CIPHER_meth_get_ctrl(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Values for cipher flags */ /* Modes for ciphers */ # define EVP_CIPH_STREAM_CIPHER 0x0 # define EVP_CIPH_ECB_MODE 0x1 # define EVP_CIPH_CBC_MODE 0x2 # define EVP_CIPH_CFB_MODE 0x3 # define EVP_CIPH_OFB_MODE 0x4 # define EVP_CIPH_CTR_MODE 0x5 # define EVP_CIPH_GCM_MODE 0x6 # define EVP_CIPH_CCM_MODE 0x7 # define EVP_CIPH_XTS_MODE 0x10001 # define EVP_CIPH_WRAP_MODE 0x10002 # define EVP_CIPH_OCB_MODE 0x10003 # define EVP_CIPH_MODE 0xF0007 /* Set if variable length cipher */ # define EVP_CIPH_VARIABLE_LENGTH 0x8 /* Set if the iv handling should be done by the cipher itself */ # define EVP_CIPH_CUSTOM_IV 0x10 /* Set if the cipher

t use standard key length function */ # define EVP_CIPH_CUSTOM_KEY_LENGTH 0x80 /* Don

size_t

char *

size_t

NO_DES

0x0001

0x0002

0x0004

0x0008

0x0010

0x0020

0x0040

0x0100

0x0200

0x0400

0x0001

0x0002

0x0004

0x0008

0x0001

0x0002

0x0018

0x0000

0x0008

0x0018

0x0400

0x1

0x2

0x3

0x1000

0x0001/*

0x0002/*

0x0004/*

0x0008/*

0xF0/*

0x00/*

0x10/*

0x20/*

0x0100/*

0x0200

0x0

0x1

0x2

0x3

0x4

0x5

0x6

0x7

0x10001

0x10002

0x10003

0xF0007

0x8

0x10

0x20

0x40

0x80

0x100

0x200

0x400

0x1000

0x2000

0x4000

0x8000

0x100000

0x200000

0x400000

0X800000

0x1

0x0

0x1

0x2

0x3

0x4

0x5

0x6

0x7

0x8

0x9

0x10

0x11

0x12

0x13

0x14

0x15

0x16

0x17

0x18

0x19

0x1a

0x1b

0x1c

0x1d

0x1e

0x1f

0x20

0x21

0x22

0x23

0x24

0x10100000L

0x10100000L

0x10100000L

0x0

0x1

0x2

0x1

0x2

0x4

0x1

0x2

0x3

0x5

0x7

0x8

0x9

0xa

0x1000

