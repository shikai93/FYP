Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Parse the client's renegotiation binding and abort if it's not right

Parse the length byte

Check that the extension matches

The servername extension is treated as follows: - Only the hostname type is supported with a maximum length of 255. - The servername is rejected if too long or if it contains zeros, in which case an fatal alert is generated. - The servername field is maintained together with the session cache. - When a session is resumed, the servername call back invoked in order to allow the application to position itself to the right context. - The servername is acknowledged if it is new for a session or when it is identical to a previously used for the same session. Applications can control the behaviour. They can at any time set a 'desirable' servername for a new SSL object. This can be the case for example with HTTPS when a Host: header field is received and a renegotiation is requested. In this case, a possible servername presented in the new client hello is only acknowledged if it matches the value of the Host: field. - Applications must use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION if they provide for changing an explicit servername context for the session, i.e. when the session has been established with a servername extension. - On session reconnect, the servername extension may be absent.

ServerNameList must be at least 1 byte long.

Although the intent was for server_name to be extensible, RFC 4366 was not clear about it; and so OpenSSL among other implementations, always and only allows a 'host_name' name types. RFC 6066 corrected the mistake but adding new name types is nevertheless no longer feasible, so act as if no other SNI types can exist, to simplify parsing. Also note that the RFC permits only one SNI value per type, i.e., we can only have a single hostname.

TODO(openssl-team): if the SNI doesn't match, we MUST fall back to a full handshake.

TODO(openssl-team): currently, we re-authenticate the user upon resumption. Instead, we MUST ignore the login.

OPENSSL_NO_EC

Not defined if we get one of these in a client Certificate

We don't know what to do with any other type so ignore it.

We remove any OCSP_RESPIDs from a previous handshake to prevent unbounded memory growth - CVE-2016-6304

TODO(size_t): Convert d2i_ to size_t

Read in request_extensions

We shouldn't accept this extension on a renegotiation.

Save the ALPN extension in a ClientHello.|pkt| holds the contents of the ALPN extension, not including type and length. |al| is a pointer to the alert value to send in the event of a failure. Returns: 1 on success, 0 on error.

Protocol names can't be empty.

Ignore this if we have no SRTP profiles

Pull off the length of the cipher suite list and check it is even

Search all profiles for a match initially

Only look for match in profiles of higher preference than current match. If no profiles have been have been configured then this does nothing.

Now extract the MKI value as a sanity check, but discard it for now

Process a psk_kex_modes extension received in the ClientHello. |pkt| contains the raw PACKET data for the extension. Returns 1 on success or 0 on failure. If a failure occurs then |al| is set to an appropriate alert value.

Process a key_share extension received in the ClientHello. |pkt| contains the raw PACKET data for the extension. Returns 1 on success or 0 on failure. If a failure occurs then |al| is set to an appropriate alert value.

Sanity check

Get our list of supported curves

Get the clients list of supported curves.

This can only happen if the supported_groups extension was not sent, because we verify that the length is non-zero when we process that extension.

If we already found a suitable key_share we loop through the rest to verify the structure, but don't process them.

Check if this share is in supported_groups sent from client

Check if this share is for a group we can use

Share not suitable

Can happen for some curves, e.g. X25519

Set up EVP_PKEY with named curve as parameters

Each group is 2 bytes and we must have at least 1.

The extension must always be empty

If we have no PSK kex mode that we recognise then we can't resume so ignore this extension

We found a PSK

We've just been told to use this session for this context so make sure the sid_ctx matches up.

For simplicity we do our age calculations in seconds. If the client does it in ms then it could appear that their ticket age is longer than ours (our ticket age calculation should always be slightly longer than the client's due to the network latency). Therefore we add 1000ms to our age calculation to adjust for rounding errors.

Ticket age is within tolerance and not expired. We allow it for early data

The ciphersuite is not compatible with this session.

Add the server's renegotiation binding

Still add this even if SSL_OP_NO_RENEGOTIATION is set

s->s3->group_id is non zero if we accepted a key_share

Get our list of supported groups

Copy group ID if supported

Check if the client is already using our preferred group. If so we don't need to add this extension

Add extension header

Sub-packet for supported_groups extension

In TLSv1.3 we include the certificate status itself. In <= TLSv1.2 we send back an empty extension, with the certificate status appearing as a separate message

Don't use encrypt_then_mac if AEAD or RC4 might want to disable for other cases too.

No key_share received from client

Must be resuming.

Generate encoding of server key

This causes the crypto state to be updated based on the derived keys

65000

32 bytes length

www.openssl.org/source/license.html

License

../ssl_locl.h

statem_locl.h

s renegotiation binding and abort if it

desirable

host_name

t match, we MUST * fall back to a full handshake. */ s->servername_done = s->session->ext.hostname && PACKET_equal(&hostname, s->session->ext.hostname, strlen(s->session->ext.hostname)); } return 1; } #ifndef OPENSSL_NO_SRP int tls_parse_ctos_srp(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET srp_I; if (!PACKET_as_length_prefixed_1(pkt, &srp_I) || PACKET_contains_zero_byte(&srp_I)) { *al = SSL_AD_DECODE_ERROR; return 0; } /* * TODO(openssl-team): currently, we re-authenticate the user * upon resumption. Instead, we MUST ignore the login. */ if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) { *al = SSL_AD_INTERNAL_ERROR; return 0; } return 1; } #endif #ifndef OPENSSL_NO_EC int tls_parse_ctos_ec_pt_formats(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET ec_point_format_list; if (!PACKET_as_length_prefixed_1(pkt, &ec_point_format_list) || PACKET_remaining(&ec_point_format_list) == 0) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->hit) { if (!PACKET_memdup(&ec_point_format_list, &s->session->ext.ecpointformats, &s->session->ext.ecpointformats_len)) { *al = SSL_AD_INTERNAL_ERROR; return 0; } } return 1; } #endif /* OPENSSL_NO_EC */ int tls_parse_ctos_session_ticket(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { if (s->ext.session_ticket_cb && !s->ext.session_ticket_cb(s, PACKET_data(pkt), PACKET_remaining(pkt), s->ext.session_ticket_cb_arg)) { *al = SSL_AD_INTERNAL_ERROR; return 0; } return 1; } int tls_parse_ctos_sig_algs(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET supported_sig_algs; if (!PACKET_as_length_prefixed_2(pkt, &supported_sig_algs) || PACKET_remaining(&supported_sig_algs) == 0) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->hit && !tls1_save_sigalgs(s, &supported_sig_algs)) { *al = SSL_AD_DECODE_ERROR; return 0; } return 1; } #ifndef OPENSSL_NO_OCSP int tls_parse_ctos_status_request(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET responder_id_list, exts; /* Not defined if we get one of these in a client Certificate */ if (x != NULL) return 1; if (!PACKET_get_1(pkt, (unsigned int *)&s->ext.status_type)) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->ext.status_type != TLSEXT_STATUSTYPE_ocsp) { /* * We don

t accept this extension on a * renegotiation. */ if (SSL_IS_FIRST_HANDSHAKE(s)) s->s3->npn_seen = 1; return 1; } #endif /* * Save the ALPN extension in a ClientHello.|pkt| holds the contents of the ALPN * extension, not including type and length. |al| is a pointer to the alert * value to send in the event of a failure. Returns: 1 on success, 0 on error. */ int tls_parse_ctos_alpn(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET protocol_list, save_protocol_list, protocol; if (!SSL_IS_FIRST_HANDSHAKE(s)) return 1; if (!PACKET_as_length_prefixed_2(pkt, &protocol_list) || PACKET_remaining(&protocol_list) < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } save_protocol_list = protocol_list; do { /* Protocol names can

t process them. */ if (found) continue; /* Check if this share is in supported_groups sent from client */ if (!check_in_list(s, group_id, clntcurves, clnt_num_curves, 0)) { *al = SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_TLS_PARSE_CTOS_KEY_SHARE, SSL_R_BAD_KEY_SHARE); return 0; } /* Check if this share is for a group we can use */ if (!check_in_list(s, group_id, srvrcurves, srvr_num_curves, 1)) { /* Share not suitable */ continue; } group_nid = tls1_ec_curve_id2nid(group_id, &curve_flags); if (group_nid == 0) { *al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_TLS_PARSE_CTOS_KEY_SHARE, SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS); return 0; } if ((curve_flags & TLS_CURVE_TYPE) == TLS_CURVE_CUSTOM) { /* Can happen for some curves, e.g. X25519 */ EVP_PKEY *key = EVP_PKEY_new(); if (key == NULL || !EVP_PKEY_set_type(key, group_nid)) { *al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_TLS_PARSE_CTOS_KEY_SHARE, ERR_R_EVP_LIB); EVP_PKEY_free(key); return 0; } s->s3->peer_tmp = key; } else { /* Set up EVP_PKEY with named curve as parameters */ EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL); if (pctx == NULL || EVP_PKEY_paramgen_init(pctx) <= 0 || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, group_nid) <= 0 || EVP_PKEY_paramgen(pctx, &s->s3->peer_tmp) <= 0) { *al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_TLS_PARSE_CTOS_KEY_SHARE, ERR_R_EVP_LIB); EVP_PKEY_CTX_free(pctx); return 0; } EVP_PKEY_CTX_free(pctx); pctx = NULL; } s->s3->group_id = group_id; if (!EVP_PKEY_set1_tls_encodedpoint(s->s3->peer_tmp, PACKET_data(&encoded_pt), PACKET_remaining(&encoded_pt))) { *al = SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_TLS_PARSE_CTOS_KEY_SHARE, SSL_R_BAD_ECPOINT); return 0; } found = 1; } #endif return 1; } #ifndef OPENSSL_NO_EC int tls_parse_ctos_supported_groups(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET supported_groups_list; /* Each group is 2 bytes and we must have at least 1. */ if (!PACKET_as_length_prefixed_2(pkt, &supported_groups_list) || PACKET_remaining(&supported_groups_list) == 0 || (PACKET_remaining(&supported_groups_list) % 2) != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->hit || SSL_IS_TLS13(s)) { OPENSSL_free(s->session->ext.supportedgroups); s->session->ext.supportedgroups = NULL; s->session->ext.supportedgroups_len = 0; if (!PACKET_memdup(&supported_groups_list, &s->session->ext.supportedgroups, &s->session->ext.supportedgroups_len)) { *al = SSL_AD_INTERNAL_ERROR; return 0; } } return 1; } #endif int tls_parse_ctos_ems(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { /* The extension must always be empty */ if (PACKET_remaining(pkt) != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS; return 1; } int tls_parse_ctos_early_data(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { if (PACKET_remaining(pkt) != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->hello_retry_request) { *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } return 1; } int tls_parse_ctos_psk(SSL *s, PACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { PACKET identities, binders, binder; size_t binderoffset, hashsize; SSL_SESSION *sess = NULL; unsigned int id, i, ext = 0; const EVP_MD *md = NULL; /* * If we have no PSK kex mode that we recognise then we can

ve just been told to use this session for this context so * make sure the sid_ctx matches up. */ memcpy(sess->sid_ctx, s->sid_ctx, s->sid_ctx_length); sess->sid_ctx_length = s->sid_ctx_length; ext = 1; } else { uint32_t ticket_age = 0, now, agesec, agems; int ret = tls_decrypt_ticket(s, PACKET_data(&identity), PACKET_remaining(&identity), NULL, 0, &sess); if (ret == TICKET_FATAL_ERR_MALLOC || ret == TICKET_FATAL_ERR_OTHER) { *al = SSL_AD_INTERNAL_ERROR; return 0; } if (ret == TICKET_NO_DECRYPT) continue; ticket_age = (uint32_t)ticket_agel; now = (uint32_t)time(NULL); agesec = now - (uint32_t)sess->time; agems = agesec * (uint32_t)1000; ticket_age -= sess->ext.tick_age_add; /* * For simplicity we do our age calculations in seconds. If the * client does it in ms then it could appear that their ticket age * is longer than ours (our ticket age calculation should always be * slightly longer than the client

s renegotiation binding */ EXT_RETURN tls_construct_stoc_renegotiate(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { if (!s->s3->send_connection_binding) return EXT_RETURN_NOT_SENT; /* Still add this even if SSL_OP_NO_RENEGOTIATION is set */ if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_renegotiate) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_start_sub_packet_u8(pkt) || !WPACKET_memcpy(pkt, s->s3->previous_client_finished, s->s3->previous_client_finished_len) || !WPACKET_memcpy(pkt, s->s3->previous_server_finished, s->s3->previous_server_finished_len) || !WPACKET_close(pkt) || !WPACKET_close(pkt)) { SSLerr(SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } return EXT_RETURN_SENT; } EXT_RETURN tls_construct_stoc_server_name(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { if (s->hit || s->servername_done != 1 || s->session->ext.hostname == NULL) return EXT_RETURN_NOT_SENT; if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_TLS_CONSTRUCT_STOC_SERVER_NAME, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } return EXT_RETURN_SENT; } #ifndef OPENSSL_NO_EC EXT_RETURN tls_construct_stoc_ec_pt_formats(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey; unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth; int using_ecc = ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA)) && (s->session->ext.ecpointformats != NULL); const unsigned char *plist; size_t plistlen; if (!using_ecc) return EXT_RETURN_NOT_SENT; tls1_get_formatlist(s, &plist, &plistlen); if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_ec_point_formats) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_sub_memcpy_u8(pkt, plist, plistlen) || !WPACKET_close(pkt)) { SSLerr(SSL_F_TLS_CONSTRUCT_STOC_EC_PT_FORMATS, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } return EXT_RETURN_SENT; } #endif #ifndef OPENSSL_NO_EC EXT_RETURN tls_construct_stoc_supported_groups(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx, int *al) { const unsigned char *groups; size_t numgroups, i, first = 1; /* s->s3->group_id is non zero if we accepted a key_share */ if (s->s3->group_id == 0) return EXT_RETURN_NOT_SENT; /* Get our list of supported groups */ if (!tls1_get_curvelist(s, 0, &groups, &numgroups) || numgroups == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_GROUPS, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } /* Copy group ID if supported */ for (i = 0; i < numgroups; i++, groups += 2) { if (tls_curve_allowed(s, groups, SSL_SECOP_CURVE_SUPPORTED)) { if (first) { /* * Check if the client is already using our preferred group. If * so we don

0xfd,

0xe8,

0x00,

0x20,

0x30,

0x1e,

0x30,

0x08,

0x06,

0x06,

0x2a,

0x85,

0x03,

0x02,

0x02,

0x09,

0x30,

0x08,

0x06,

0x06,

0x2a,

0x85,

0x03,

0x02,

0x02,

0x16,

0x30,

0x08,

0x06,

0x06,

0x2a,

0x85,

0x03,

0x02,

0x02,

0x17

0xFFFF)

0x80

0xFFFF)

0x81)

