Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Since there appears to be no way to extract the sent/received alert from the SSL object directly, we use the info callback and stash the result in ex_data.

|ctx_data| itself is stack-allocated.

Select the appropriate server CTX. Returns SSL_TLSEXT_ERR_OK if a match was found. If |ignore| is 1, returns SSL_TLSEXT_ERR_NOACK on mismatch. Otherwise, returns SSL_TLSEXT_ERR_ALERT_FATAL on mismatch. An empty SNI extension also returns SSL_TSLEXT_ERR_NOACK.

Copy over all the SSL_CTX options - reasonable behavior allows testing of cases where the options between two contexts differ/conflict

Don't set an explicit alert, to test library defaults.

The server_name extension was given too much extensibility when it was written, so parsing the normal case is a bit complex.

Extract the length of the supplied list of names.

The list in practice only has a single element, so we only consider the first one.

Now we can finally pull out the byte array with the actual hostname.

Copy over all the SSL_CTX options - reasonable behavior allows testing of cases where the options between two contexts differ/conflict

(RFC 6066): If the server understood the ClientHello extension but does not recognize the server name, the server SHOULD take one of two actions: either abort the handshake by sending a fatal-level unrecognized_name(112) alert or continue the handshake. This behaviour is up to the application to configure; we test both configurations to ensure the state machine propagates the result correctly.

For the purposes of testing we just send back a dummy OCSP response

Parse the comma-separated list into TLS format.

Should never have reuse.

Test values are small, so we omit length limit checks.

foo => '3', 'f', 'o', 'o' foo,bar => '3', 'f', 'o', 'o', '3', 'b', 'a', 'r'

The client SHOULD select the first protocol advertised by the server that it also supports. In the event that the client doesn't support any of server's protocols, or the server doesn't advertise any, it SHOULD select the first protocol that it supports.

Accept both OPENSSL_NPN_NEGOTIATED and OPENSSL_NPN_NO_OVERLAP.

The server SHOULD select the most highly preferred protocol that it supports and that is also advertised by the client. In the event that the server supports no protocols that the client advertises, then the server SHALL respond with a fatal "no_application_protocol" alert.

SSL_select_next_proto isn't const-correct...

The result points either to |in| or to |ctx_data->alpn_protocols|. The callback is allowed to point to |in| or to a long-lived buffer, so we can return directly without storing a copy.

Unlike NPN, we don't tolerate a mismatch.

known group

!OPENSSL_NO_SRP

Configure callbacks and other properties that can't be set directly in the server/client CONF.

Link the two contexts for SNI purposes. Also do early callbacks here, as setting both early and SNI is bad.

The initial_ctx/session_ctx always handles the encrypt/decrypt of the session ticket. This ticket_key callback is assigned to the second session (assigned via SNI), and should never be invoked

Reversed return value convention...

Use fixed session ticket keys so that we can decrypt a ticket created with one CTX in another CTX. Don't address server2 for the moment.

The default log list includes EC keys, so CT can't work without EC.

!OPENSSL_NO_SRP

Configure per-SSL callbacks and other properties.

The status for each connection phase.

An SSL object and associated read-write buffers.

Buffer lengths are int to match the SSL read/write API.

Note that we could do the handshake transparently under an SSL_write, but separating the steps is more helpful for debugging test failures.

Memory bios should never block with SSL_ERROR_WANT_WRITE.

Send/receive some application data. The read-write sequence is Peer A: (R) W - first read will yield no data Peer B: R W ... Peer A: R W Peer B: R W Peer A: R

We read everything available...

Else continue with write.

... but we only write one write-buffer-full of data.

SSL_write will only succeed with a complete write.

We should perhaps check for SSL_ERROR_WANT_READ/WRITE here but this doesn't yet occur with current app data sizes.

We could simply finish when there was nothing to read, and we have nothing left to write. But keeping track of the expected number of bytes to read gives us somewhat better guarantees that all data sent is in fact received.

We are a client that succeeded this step previously, but the server wanted to retry. Probably there is a no_renegotiation warning alert waiting for us. Attempt to continue the handshake.

Reset the count of the amount of app data we need to read/write

Check if we are the peer that is going to initiate

If we already asked for a renegotiation then fall through to the SSL_read() below.

If we are the client we will always attempt to resume the session. The server may or may not resume dependent on the setting of SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION

If status is PEER_RETRY it means we're waiting on the peer to continue the handshake. As far as setting up the renegotiation is concerned that is a success. The next step will continue the handshake to its conclusion. If status is PEER_SUCCESS then we are the server and we have successfully sent the HelloRequest. We need to continue to wait until the handshake arrives from the client.

This is a one step handshake. We shouldn't get anything other than PEER_SUCCESS

The SSL object is still expecting app data, even though it's going to get a handshake message. We try to read, and it should fail - after which we should be in a handshake

We're not actually expecting data - we're expecting a reneg to start

If we're not in init yet then we're not done with setup yet

RFC 5246 says: Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed. This is a change from TLS 1.0 to conform with widespread implementation practice. However, (a) OpenSSL requires that a connection be shutdown for all protocol versions. (b) We test lower versions, too. So we just implement shutdown. We do a full bidirectional shutdown so that we can compare sent and received close_notify alerts and get some test coverage for SSL_shutdown as a bonus.

On 0, we retry.

Both parties succeeded.

Client errored.

Server errored.

Peers are in inconsistent state.

One or both peers not done.

Determine the handshake outcome. last_status: the status of the peer to have acted last. previous_status: the status of the peer that didn't act last. client_spoke_last: 1 if the client went last.

Shouldn't ever happen

Both succeeded.

Let the first peer finish.

Second peer succeeded despite the fact that the first peer already errored. This shouldn't happen.

The client failed immediately before sending the ClientHello

First peer succeeded but second peer errored. TODO(emilia): we should be able to continue here (with some application data?) to ensure the first peer receives the alert / close_notify. (No tests currently exercise this branch.)

We errored; let the peer finish.

Both peers errored. Return the one that errored first.

Control should never reach here.

Convert unsigned char buf's that shouldn't contain any NUL-bytes to char.

Assert that the string does not contain NUL-bytes.

For SCTP we have to set various options on the socket prior to connecting. This is done automatically by BIO_new_dgram_sctp(). We don't actually need the created BIO though so we free it again immediately.

Port is 4463. It could be anything. It will fail if it's already being used for some other SCTP service. It seems unlikely though so we don't worry about it here.

Maybe the kernel doesn't support the socket family, even if BIO_lookup() added it in the returned result...

Success, don't try any more addresses

Note that |extra| points to the correct client/server configuration within |test_ctx|. When configuring the handshake, general mode settings are taken from |test_ctx|, and client/server-specific settings should be taken from |extra|. The configuration code should never reach into |test_ctx->extra| or |test_ctx->resume_extra| directly. (We could refactor test mode settings into a substructure. This would result in cleaner argument passing but would complicate the test configuration parsing.)

API dictates unsigned int rather than size_t.

Setup SSL and buffers; additional configuration happens below.

In case we're testing resumption without tickets.

Non-blocking bio.

The bios are now owned by the SSL object.

Half-duplex handshake loop. Client and server speak to each other synchronously in the same process. We use non-blocking BIOs, so whenever one peer blocks for read, it returns PEER_RETRY to indicate that it's the other peer's turn to write. The handshake succeeds once both peers have succeeded. If one peer errors out, we also let the other peer retry (and presumably fail).

client went last

server went last

For now, client starts each phase. Since each phase is started separately, we can later control this more precisely, for example, to test client-initiated and server-initiated shutdown.

We've waited for too long. Give up.

With "real" sockets we only swap to processing the peer if they are expecting to retry. Otherwise we just retry the same endpoint again.

At this point, there's been so many PEER_RETRY in a row that it's likely both sides are stuck waiting for a read. It's time to give up.

Continue.

We don't support SNI on second handshake yet, so server2_ctx is NULL.

www.openssl.org/source/license.html

License

internal/sockets.h

internal/nelem.h

handshake_helper.h

testutil.h

F

CN

server2

server1

t set an explicit alert, to test library defaults. */ return SSL_TLSEXT_ERR_ALERT_FATAL; } } static int early_select_server_ctx(SSL *s, void *arg, int ignore) { const char *servername; const unsigned char *p; size_t len, remaining; HANDSHAKE_EX_DATA *ex_data = (HANDSHAKE_EX_DATA*)(SSL_get_ex_data(s, ex_data_idx)); /* * The server_name extension was given too much extensibility when it * was written, so parsing the normal case is a bit complex. */ if (!SSL_early_get0_ext(s, TLSEXT_TYPE_server_name, &p, &remaining) || remaining <= 2) return 0; /* Extract the length of the supplied list of names. */ len = (*(p++) << 1); len += *(p++); if (len + 2 != remaining) return 0; remaining = len; /* * The list in practice only has a single element, so we only consider * the first one. */ if (remaining == 0 || *p++ != TLSEXT_NAMETYPE_host_name) return 0; remaining--; /* Now we can finally pull out the byte array with the actual hostname. */ if (remaining <= 2) return 0; len = (*(p++) << 1); len += *(p++); if (len + 2 > remaining) return 0; remaining = len; servername = (const char *)p; if (len == strlen("server2") && strncmp(servername, "server2", len) == 0) { SSL_CTX *new_ctx = arg; SSL_set_SSL_CTX(s, new_ctx); /* * Copy over all the SSL_CTX options - reasonable behavior * allows testing of cases where the options between two * contexts differ/conflict */ SSL_clear_options(s, 0xFFFFFFFFL); SSL_set_options(s, SSL_CTX_get_options(new_ctx)); ex_data->servername = SSL_TEST_SERVERNAME_SERVER2; return 1; } else if (len == strlen("server1") && strncmp(servername, "server1", len) == 0) { ex_data->servername = SSL_TEST_SERVERNAME_SERVER1; return 1; } else if (ignore) { ex_data->servername = SSL_TEST_SERVERNAME_SERVER1; return 1; } return 0; } /* * (RFC 6066): * If the server understood the ClientHello extension but * does not recognize the server name, the server SHOULD take one of two * actions: either abort the handshake by sending a fatal-level * unrecognized_name(112) alert or continue the handshake. * * This behaviour is up to the application to configure; we test both * configurations to ensure the state machine propagates the result * correctly. */ static int servername_ignore_cb(SSL *s, int *ad, void *arg) { return select_server_ctx(s, arg, 1); } static int servername_reject_cb(SSL *s, int *ad, void *arg) { return select_server_ctx(s, arg, 0); } static int early_ignore_cb(SSL *s, int *al, void *arg) { if (!early_select_server_ctx(s, arg, 1)) { *al = SSL_AD_UNRECOGNIZED_NAME; return 0; } return 1; } static int early_reject_cb(SSL *s, int *al, void *arg) { if (!early_select_server_ctx(s, arg, 0)) { *al = SSL_AD_UNRECOGNIZED_NAME; return 0; } return 1; } static int early_nov12_cb(SSL *s, int *al, void *arg) { int ret; unsigned int v; const unsigned char *p; v = SSL_early_get0_legacy_version(s); if (v > TLS1_2_VERSION || v < SSL3_VERSION) { *al = SSL_AD_PROTOCOL_VERSION; return 0; } (void)SSL_early_get0_session_id(s, &p); if (p == NULL || SSL_early_get0_random(s, &p) == 0 || SSL_early_get0_ciphers(s, &p) == 0 || SSL_early_get0_compression_methods(s, &p) == 0) { *al = SSL_AD_INTERNAL_ERROR; return 0; } ret = early_select_server_ctx(s, arg, 0); SSL_set_max_proto_version(s, TLS1_1_VERSION); if (!ret) *al = SSL_AD_UNRECOGNIZED_NAME; return ret; } static unsigned char dummy_ocsp_resp_good_val = 0xff; static unsigned char dummy_ocsp_resp_bad_val = 0xfe; static int server_ocsp_cb(SSL *s, void *arg) { unsigned char *resp; resp = OPENSSL_malloc(1); if (resp == NULL) return SSL_TLSEXT_ERR_ALERT_FATAL; /* * For the purposes of testing we just send back a dummy OCSP response */ *resp = *(unsigned char *)arg; if (!SSL_set_tlsext_status_ocsp_resp(s, resp, 1)) return SSL_TLSEXT_ERR_ALERT_FATAL; return SSL_TLSEXT_ERR_OK; } static int client_ocsp_cb(SSL *s, void *arg) { const unsigned char *resp; int len; len = SSL_get_tlsext_status_ocsp_resp(s, &resp); if (len != 1 || *resp != dummy_ocsp_resp_good_val) return 0; return 1; } static int verify_reject_cb(X509_STORE_CTX *ctx, void *arg) { X509_STORE_CTX_set_error(ctx, X509_V_ERR_APPLICATION_VERIFICATION); return 0; } static int verify_accept_cb(X509_STORE_CTX *ctx, void *arg) { return 1; } static int broken_session_ticket_cb(SSL *s, unsigned char *key_name, unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) { return 0; } static int do_not_call_session_ticket_cb(SSL *s, unsigned char *key_name, unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) { HANDSHAKE_EX_DATA *ex_data = (HANDSHAKE_EX_DATA*)(SSL_get_ex_data(s, ex_data_idx)); ex_data->session_ticket_do_not_call = 1; return 0; } /* Parse the comma-separated list into TLS format. */ static int parse_protos(const char *protos, unsigned char **out, size_t *outlen) { size_t len, i, prefix; len = strlen(protos); /* Should never have reuse. */ if (!TEST_ptr_null(*out) /* Test values are small, so we omit length limit checks. */ || !TEST_ptr(*out = OPENSSL_malloc(len + 1))) return 0; *outlen = len + 1; /* * foo =>

,

,

,

* foo,bar =>

,

,

,

,

,

,

,

*/ memcpy(*out + 1, protos, len); prefix = 0; i = prefix + 1; while (i <= len) { if ((*out)[i] ==

) { if (!TEST_int_gt(i - 1, prefix)) goto err; (*out)[prefix] = i - 1 - prefix; prefix = i; } i++; } if (!TEST_int_gt(len, prefix)) goto err; (*out)[prefix] = len - prefix; return 1; err: OPENSSL_free(*out); *out = NULL; return 0; } #ifndef OPENSSL_NO_NEXTPROTONEG /* * The client SHOULD select the first protocol advertised by the server that it * also supports. In the event that the client doesn

s * protocols, or the server doesn

no_application_protocol

t const-correct... */ unsigned char *tmp_out; /* * The result points either to |in| or to |ctx_data->alpn_protocols|. * The callback is allowed to point to |in| or to a long-lived buffer, * so we can return directly without storing a copy. */ ret = SSL_select_next_proto(&tmp_out, outlen, ctx_data->alpn_protocols, ctx_data->alpn_protocols_len, in, inlen); *out = tmp_out; /* Unlike NPN, we don

2048

t be set directly * in the server/client CONF. */ static int configure_handshake_ctx(SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx, const SSL_TEST_CTX *test, const SSL_TEST_EXTRA_CONF *extra, CTX_DATA *server_ctx_data, CTX_DATA *server2_ctx_data, CTX_DATA *client_ctx_data) { unsigned char *ticket_keys; size_t ticket_key_len; if (!TEST_int_eq(SSL_CTX_set_max_send_fragment(server_ctx, test->max_fragment_size), 1)) goto err; if (server2_ctx != NULL) { if (!TEST_int_eq(SSL_CTX_set_max_send_fragment(server2_ctx, test->max_fragment_size), 1)) goto err; } if (!TEST_int_eq(SSL_CTX_set_max_send_fragment(client_ctx, test->max_fragment_size), 1)) goto err; switch (extra->client.verify_callback) { case SSL_TEST_VERIFY_ACCEPT_ALL: SSL_CTX_set_cert_verify_callback(client_ctx, &verify_accept_cb, NULL); break; case SSL_TEST_VERIFY_REJECT_ALL: SSL_CTX_set_cert_verify_callback(client_ctx, &verify_reject_cb, NULL); break; case SSL_TEST_VERIFY_NONE: break; } /* * Link the two contexts for SNI purposes. * Also do early callbacks here, as setting both early and SNI is bad. */ switch (extra->server.servername_callback) { case SSL_TEST_SERVERNAME_IGNORE_MISMATCH: SSL_CTX_set_tlsext_servername_callback(server_ctx, servername_ignore_cb); SSL_CTX_set_tlsext_servername_arg(server_ctx, server2_ctx); break; case SSL_TEST_SERVERNAME_REJECT_MISMATCH: SSL_CTX_set_tlsext_servername_callback(server_ctx, servername_reject_cb); SSL_CTX_set_tlsext_servername_arg(server_ctx, server2_ctx); break; case SSL_TEST_SERVERNAME_CB_NONE: break; case SSL_TEST_SERVERNAME_EARLY_IGNORE_MISMATCH: SSL_CTX_set_early_cb(server_ctx, early_ignore_cb, server2_ctx); break; case SSL_TEST_SERVERNAME_EARLY_REJECT_MISMATCH: SSL_CTX_set_early_cb(server_ctx, early_reject_cb, server2_ctx); break; case SSL_TEST_SERVERNAME_EARLY_NO_V12: SSL_CTX_set_early_cb(server_ctx, early_nov12_cb, server2_ctx); } if (extra->server.cert_status != SSL_TEST_CERT_STATUS_NONE) { SSL_CTX_set_tlsext_status_type(client_ctx, TLSEXT_STATUSTYPE_ocsp); SSL_CTX_set_tlsext_status_cb(client_ctx, client_ocsp_cb); SSL_CTX_set_tlsext_status_arg(client_ctx, NULL); SSL_CTX_set_tlsext_status_cb(server_ctx, server_ocsp_cb); SSL_CTX_set_tlsext_status_arg(server_ctx, ((extra->server.cert_status == SSL_TEST_CERT_STATUS_GOOD_RESPONSE) ? &dummy_ocsp_resp_good_val : &dummy_ocsp_resp_bad_val)); } /* * The initial_ctx/session_ctx always handles the encrypt/decrypt of the * session ticket. This ticket_key callback is assigned to the second * session (assigned via SNI), and should never be invoked */ if (server2_ctx != NULL) SSL_CTX_set_tlsext_ticket_key_cb(server2_ctx, do_not_call_session_ticket_cb); if (extra->server.broken_session_ticket) { SSL_CTX_set_tlsext_ticket_key_cb(server_ctx, broken_session_ticket_cb); } #ifndef OPENSSL_NO_NEXTPROTONEG if (extra->server.npn_protocols != NULL) { if (!TEST_true(parse_protos(extra->server.npn_protocols, &server_ctx_data->npn_protocols, &server_ctx_data->npn_protocols_len))) goto err; SSL_CTX_set_npn_advertised_cb(server_ctx, server_npn_cb, server_ctx_data); } if (extra->server2.npn_protocols != NULL) { if (!TEST_true(parse_protos(extra->server2.npn_protocols, &server2_ctx_data->npn_protocols, &server2_ctx_data->npn_protocols_len)) || !TEST_ptr(server2_ctx)) goto err; SSL_CTX_set_npn_advertised_cb(server2_ctx, server_npn_cb, server2_ctx_data); } if (extra->client.npn_protocols != NULL) { if (!TEST_true(parse_protos(extra->client.npn_protocols, &client_ctx_data->npn_protocols, &client_ctx_data->npn_protocols_len))) goto err; SSL_CTX_set_next_proto_select_cb(client_ctx, client_npn_cb, client_ctx_data); } #endif if (extra->server.alpn_protocols != NULL) { if (!TEST_true(parse_protos(extra->server.alpn_protocols, &server_ctx_data->alpn_protocols, &server_ctx_data->alpn_protocols_len))) goto err; SSL_CTX_set_alpn_select_cb(server_ctx, server_alpn_cb, server_ctx_data); } if (extra->server2.alpn_protocols != NULL) { if (!TEST_ptr(server2_ctx) || !TEST_true(parse_protos(extra->server2.alpn_protocols, &server2_ctx_data->alpn_protocols, &server2_ctx_data->alpn_protocols_len ))) goto err; SSL_CTX_set_alpn_select_cb(server2_ctx, server_alpn_cb, server2_ctx_data); } if (extra->client.alpn_protocols != NULL) { unsigned char *alpn_protos = NULL; size_t alpn_protos_len; if (!TEST_true(parse_protos(extra->client.alpn_protocols, &alpn_protos, &alpn_protos_len)) /* Reversed return value convention... */ || !TEST_int_eq(SSL_CTX_set_alpn_protos(client_ctx, alpn_protos, alpn_protos_len), 0)) goto err; OPENSSL_free(alpn_protos); } /* * Use fixed session ticket keys so that we can decrypt a ticket created with * one CTX in another CTX. Don

t work without EC. */ #if !defined(OPENSSL_NO_CT) && !defined(OPENSSL_NO_EC) if (!TEST_true(SSL_CTX_set_default_ctlog_list_file(client_ctx))) goto err; switch (extra->client.ct_validation) { case SSL_TEST_CT_VALIDATION_PERMISSIVE: if (!TEST_true(SSL_CTX_enable_ct(client_ctx, SSL_CT_VALIDATION_PERMISSIVE))) goto err; break; case SSL_TEST_CT_VALIDATION_STRICT: if (!TEST_true(SSL_CTX_enable_ct(client_ctx, SSL_CT_VALIDATION_STRICT))) goto err; break; case SSL_TEST_CT_VALIDATION_NONE: break; } #endif #ifndef OPENSSL_NO_SRP if (extra->server.srp_user != NULL) { SSL_CTX_set_srp_username_callback(server_ctx, server_srp_cb); server_ctx_data->srp_user = OPENSSL_strdup(extra->server.srp_user); server_ctx_data->srp_password = OPENSSL_strdup(extra->server.srp_password); SSL_CTX_set_srp_cb_arg(server_ctx, server_ctx_data); } if (extra->server2.srp_user != NULL) { if (!TEST_ptr(server2_ctx)) goto err; SSL_CTX_set_srp_username_callback(server2_ctx, server_srp_cb); server2_ctx_data->srp_user = OPENSSL_strdup(extra->server2.srp_user); server2_ctx_data->srp_password = OPENSSL_strdup(extra->server2.srp_password); SSL_CTX_set_srp_cb_arg(server2_ctx, server2_ctx_data); } if (extra->client.srp_user != NULL) { if (!TEST_true(SSL_CTX_set_srp_username(client_ctx, extra->client.srp_user))) goto err; SSL_CTX_set_srp_client_pwd_callback(client_ctx, client_srp_cb); client_ctx_data->srp_password = OPENSSL_strdup(extra->client.srp_password); SSL_CTX_set_srp_cb_arg(client_ctx, client_ctx_data); } #endif /* !OPENSSL_NO_SRP */ return 1; err: return 0; } /* Configure per-SSL callbacks and other properties. */ static void configure_handshake_ssl(SSL *server, SSL *client, const SSL_TEST_EXTRA_CONF *extra) { if (extra->client.servername != SSL_TEST_SERVERNAME_NONE) SSL_set_tlsext_host_name(client, ssl_servername_name(extra->client.servername)); } /* The status for each connection phase. */ typedef enum { PEER_SUCCESS, PEER_RETRY, PEER_ERROR, PEER_WAITING, PEER_TEST_FAILURE } peer_status_t; /* An SSL object and associated read-write buffers. */ typedef struct peer_st { SSL *ssl; /* Buffer lengths are int to match the SSL read/write API. */ unsigned char *write_buf; int write_buf_len; unsigned char *read_buf; int read_buf_len; int bytes_to_write; int bytes_to_read; peer_status_t status; } PEER; static int create_peer(PEER *peer, SSL_CTX *ctx) { static const int peer_buffer_size = 64 * 1024; SSL *ssl = NULL; unsigned char *read_buf = NULL, *write_buf = NULL; if (!TEST_ptr(ssl = SSL_new(ctx)) || !TEST_ptr(write_buf = OPENSSL_zalloc(peer_buffer_size)) || !TEST_ptr(read_buf = OPENSSL_zalloc(peer_buffer_size))) goto err; peer->ssl = ssl; peer->write_buf = write_buf; peer->read_buf = read_buf; peer->write_buf_len = peer->read_buf_len = peer_buffer_size; return 1; err: SSL_free(ssl); OPENSSL_free(write_buf); OPENSSL_free(read_buf); return 0; } static void peer_free_data(PEER *peer) { SSL_free(peer->ssl); OPENSSL_free(peer->write_buf); OPENSSL_free(peer->read_buf); } /* * Note that we could do the handshake transparently under an SSL_write, * but separating the steps is more helpful for debugging test failures. */ static void do_handshake_step(PEER *peer) { if (!TEST_int_eq(peer->status, PEER_RETRY)) { peer->status = PEER_TEST_FAILURE; } else { int ret = SSL_do_handshake(peer->ssl); if (ret == 1) { peer->status = PEER_SUCCESS; } else if (ret == 0) { peer->status = PEER_ERROR; } else { int error = SSL_get_error(peer->ssl, ret); /* Memory bios should never block with SSL_ERROR_WANT_WRITE. */ if (error != SSL_ERROR_WANT_READ) peer->status = PEER_ERROR; } } } /*- * Send/receive some application data. The read-write sequence is * Peer A: (R) W - first read will yield no data * Peer B: R W * ... * Peer A: R W * Peer B: R W * Peer A: R */ static void do_app_data_step(PEER *peer) { int ret = 1, write_bytes; if (!TEST_int_eq(peer->status, PEER_RETRY)) { peer->status = PEER_TEST_FAILURE; return; } /* We read everything available... */ while (ret > 0 && peer->bytes_to_read) { ret = SSL_read(peer->ssl, peer->read_buf, peer->read_buf_len); if (ret > 0) { if (!TEST_int_le(ret, peer->bytes_to_read)) { peer->status = PEER_TEST_FAILURE; return; } peer->bytes_to_read -= ret; } else if (ret == 0) { peer->status = PEER_ERROR; return; } else { int error = SSL_get_error(peer->ssl, ret); if (error != SSL_ERROR_WANT_READ) { peer->status = PEER_ERROR; return; } /* Else continue with write. */ } } /* ... but we only write one write-buffer-full of data. */ write_bytes = peer->bytes_to_write < peer->write_buf_len ? peer->bytes_to_write : peer->write_buf_len; if (write_bytes) { ret = SSL_write(peer->ssl, peer->write_buf, write_bytes); if (ret > 0) { /* SSL_write will only succeed with a complete write. */ if (!TEST_int_eq(ret, write_bytes)) { peer->status = PEER_TEST_FAILURE; return; } peer->bytes_to_write -= ret; } else { /* * We should perhaps check for SSL_ERROR_WANT_READ/WRITE here * but this doesn

re waiting on the peer to * continue the handshake. As far as setting up the renegotiation is * concerned that is a success. The next step will continue the * handshake to its conclusion. * * If status is PEER_SUCCESS then we are the server and we have * successfully sent the HelloRequest. We need to continue to wait * until the handshake arrives from the client. */ if (peer->status == PEER_RETRY) peer->status = PEER_SUCCESS; else if (peer->status == PEER_SUCCESS) peer->status = PEER_RETRY; return; } } else if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_SERVER || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_CLIENT) { if (SSL_is_server(peer->ssl) != (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_SERVER)) { peer->status = PEER_SUCCESS; return; } ret = SSL_key_update(peer->ssl, test_ctx->key_update_type); if (!ret) { peer->status = PEER_ERROR; return; } do_handshake_step(peer); /* * This is a one step handshake. We shouldn

s going to * get a handshake message. We try to read, and it should fail - after which * we should be in a handshake */ ret = SSL_read(peer->ssl, &buf, sizeof(buf)); if (ret >= 0) { /* * We

re expecting a reneg to * start */ peer->status = PEER_ERROR; return; } else { int error = SSL_get_error(peer->ssl, ret); if (error != SSL_ERROR_WANT_READ) { peer->status = PEER_ERROR; return; } /* If we

re not done with setup yet */ if (!SSL_in_init(peer->ssl)) return; } peer->status = PEER_SUCCESS; } /* * RFC 5246 says: * * Note that as of TLS 1.1, * failure to properly close a connection no longer requires that a * session not be resumed. This is a change from TLS 1.0 to conform * with widespread implementation practice. * * However, * (a) OpenSSL requires that a connection be shutdown for all protocol versions. * (b) We test lower versions, too. * So we just implement shutdown. We do a full bidirectional shutdown so that we * can compare sent and received close_notify alerts and get some test coverage * for SSL_shutdown as a bonus. */ static void do_shutdown_step(PEER *peer) { int ret; if (!TEST_int_eq(peer->status, PEER_RETRY)) { peer->status = PEER_TEST_FAILURE; return; } ret = SSL_shutdown(peer->ssl); if (ret == 1) { peer->status = PEER_SUCCESS; } else if (ret < 0) { /* On 0, we retry. */ int error = SSL_get_error(peer->ssl, ret); if (error != SSL_ERROR_WANT_READ && error != SSL_ERROR_WANT_WRITE) peer->status = PEER_ERROR; } } typedef enum { HANDSHAKE, RENEG_APPLICATION_DATA, RENEG_SETUP, RENEG_HANDSHAKE, APPLICATION_DATA, SHUTDOWN, CONNECTION_DONE } connect_phase_t; static connect_phase_t next_phase(const SSL_TEST_CTX *test_ctx, connect_phase_t phase) { switch (phase) { case HANDSHAKE: if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RENEG_SERVER || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RENEG_CLIENT || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_CLIENT || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_SERVER) return RENEG_APPLICATION_DATA; return APPLICATION_DATA; case RENEG_APPLICATION_DATA: return RENEG_SETUP; case RENEG_SETUP: if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_SERVER || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_CLIENT) return APPLICATION_DATA; return RENEG_HANDSHAKE; case RENEG_HANDSHAKE: return APPLICATION_DATA; case APPLICATION_DATA: return SHUTDOWN; case SHUTDOWN: return CONNECTION_DONE; case CONNECTION_DONE: TEST_error("Trying to progress after connection done"); break; } return -1; } static void do_connect_step(const SSL_TEST_CTX *test_ctx, PEER *peer, connect_phase_t phase) { switch (phase) { case HANDSHAKE: do_handshake_step(peer); break; case RENEG_APPLICATION_DATA: do_app_data_step(peer); break; case RENEG_SETUP: do_reneg_setup_step(test_ctx, peer); break; case RENEG_HANDSHAKE: do_handshake_step(peer); break; case APPLICATION_DATA: do_app_data_step(peer); break; case SHUTDOWN: do_shutdown_step(peer); break; case CONNECTION_DONE: TEST_error("Action after connection done"); break; } } typedef enum { /* Both parties succeeded. */ HANDSHAKE_SUCCESS, /* Client errored. */ CLIENT_ERROR, /* Server errored. */ SERVER_ERROR, /* Peers are in inconsistent state. */ INTERNAL_ERROR, /* One or both peers not done. */ HANDSHAKE_RETRY } handshake_status_t; /* * Determine the handshake outcome. * last_status: the status of the peer to have acted last. * previous_status: the status of the peer that didn

t ever happen */ return INTERNAL_ERROR; case PEER_SUCCESS: switch (previous_status) { case PEER_TEST_FAILURE: return INTERNAL_ERROR; case PEER_SUCCESS: /* Both succeeded. */ return HANDSHAKE_SUCCESS; case PEER_WAITING: case PEER_RETRY: /* Let the first peer finish. */ return HANDSHAKE_RETRY; case PEER_ERROR: /* * Second peer succeeded despite the fact that the first peer * already errored. This shouldn

s that shouldn

t actually need the created BIO though so we free it again * immediately. */ BIO *tmpbio = BIO_new_dgram_sctp(sock, BIO_NOCLOSE); if (tmpbio == NULL) return 0; BIO_free(tmpbio); return 1; } static int create_sctp_socks(int *ssock, int *csock) { BIO_ADDRINFO *res = NULL; const BIO_ADDRINFO *ai = NULL; int lsock = INVALID_SOCKET, asock = INVALID_SOCKET; int consock = INVALID_SOCKET; int ret = 0; int family = 0; if (BIO_sock_init() != 1) return 0; /* * Port is 4463. It could be anything. It will fail if it

t * worry about it here. */ if (!BIO_lookup_ex(NULL, "4463", BIO_LOOKUP_SERVER, family, SOCK_STREAM, IPPROTO_SCTP, &res)) return 0; for (ai = res; ai != NULL; ai = BIO_ADDRINFO_next(ai)) { family = BIO_ADDRINFO_family(ai); lsock = BIO_socket(family, SOCK_STREAM, IPPROTO_SCTP, 0); if (lsock == INVALID_SOCKET) { /* Maybe the kernel doesn

t try any more addresses */ break; } if (lsock == INVALID_SOCKET) goto err; BIO_ADDRINFO_free(res); res = NULL; if (!BIO_lookup_ex(NULL, "4463", BIO_LOOKUP_CLIENT, family, SOCK_STREAM, IPPROTO_SCTP, &res)) goto err; consock = BIO_socket(family, SOCK_STREAM, IPPROTO_SCTP, 0); if (consock == INVALID_SOCKET) goto err; if (!set_sock_as_sctp(consock) || !BIO_connect(consock, BIO_ADDRINFO_address(res), 0) || !BIO_socket_nbio(consock, 1)) goto err; asock = BIO_accept_ex(lsock, NULL, BIO_SOCK_NONBLOCK); if (asock == INVALID_SOCKET) goto err; *csock = consock; *ssock = asock; consock = asock = INVALID_SOCKET; ret = 1; err: BIO_ADDRINFO_free(res); if (consock != INVALID_SOCKET) BIO_closesocket(consock); if (lsock != INVALID_SOCKET) BIO_closesocket(lsock); if (asock != INVALID_SOCKET) BIO_closesocket(asock); return ret; } #endif /* * Note that |extra| points to the correct client/server configuration * within |test_ctx|. When configuring the handshake, general mode settings * are taken from |test_ctx|, and client/server-specific settings should be * taken from |extra|. * * The configuration code should never reach into |test_ctx->extra| or * |test_ctx->resume_extra| directly. * * (We could refactor test mode settings into a substructure. This would result * in cleaner argument passing but would complicate the test configuration * parsing.) */ static HANDSHAKE_RESULT *do_handshake_internal( SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx, const SSL_TEST_CTX *test_ctx, const SSL_TEST_EXTRA_CONF *extra, SSL_SESSION *session_in, SSL_SESSION **session_out) { PEER server, client; BIO *client_to_server = NULL, *server_to_client = NULL; HANDSHAKE_EX_DATA server_ex_data, client_ex_data; CTX_DATA client_ctx_data, server_ctx_data, server2_ctx_data; HANDSHAKE_RESULT *ret = HANDSHAKE_RESULT_new(); int client_turn = 1, client_turn_count = 0; connect_phase_t phase = HANDSHAKE; handshake_status_t status = HANDSHAKE_RETRY; const unsigned char* tick = NULL; size_t tick_len = 0; SSL_SESSION* sess = NULL; const unsigned char *proto = NULL; /* API dictates unsigned int rather than size_t. */ unsigned int proto_len = 0; EVP_PKEY *tmp_key; const STACK_OF(X509_NAME) *names; time_t start; if (ret == NULL) return NULL; memset(&server_ctx_data, 0, sizeof(server_ctx_data)); memset(&server2_ctx_data, 0, sizeof(server2_ctx_data)); memset(&client_ctx_data, 0, sizeof(client_ctx_data)); memset(&server, 0, sizeof(server)); memset(&client, 0, sizeof(client)); memset(&server_ex_data, 0, sizeof(server_ex_data)); memset(&client_ex_data, 0, sizeof(client_ex_data)); if (!configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, test_ctx, extra, &server_ctx_data, &server2_ctx_data, &client_ctx_data)) { TEST_note("configure_handshake_ctx"); return NULL; } /* Setup SSL and buffers; additional configuration happens below. */ if (!create_peer(&server, server_ctx)) { TEST_note("creating server context"); goto err; } if (!create_peer(&client, client_ctx)) { TEST_note("creating client context"); goto err; } server.bytes_to_write = client.bytes_to_read = test_ctx->app_data_size; client.bytes_to_write = server.bytes_to_read = test_ctx->app_data_size; configure_handshake_ssl(server.ssl, client.ssl, extra); if (session_in != NULL) { /* In case we

ex data

s the other peer

ve waited for too long. Give up. */ ret->result = SSL_TEST_INTERNAL_ERROR; goto err; } /* * With "real" sockets we only swap to processing the peer * if they are expecting to retry. Otherwise we just retry the * same endpoint again. */ if ((client_turn && server.status == PEER_RETRY) || (!client_turn && client.status == PEER_RETRY)) client_turn ^= 1; } else { if (client_turn_count++ >= 2000) { /* * At this point, there

s likely both sides are stuck waiting for a read. * It

0xFFFFFFFFL);

0xFFFFFFFFL);

0xff;

0xfe;

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

These alerts are in the 2-byte format returned by the info_callback.

(Latest) alert sent by the client; 0 if no alert.

Number of fatal or close_notify alerts sent.

(Latest) alert received by the server; 0 if no alert.

(Latest) alert sent by the server; 0 if no alert.

Number of fatal or close_notify alerts sent.

(Latest) alert received by the client; 0 if no alert.

Negotiated protocol. On success, these should always match.

Server connection

Session ticket status

Was this called on the second context?

Was the handshake resumed?

Temporary key type

server certificate key type

server signing hash

server signature type

server CA names

client certificate key type

client signing hash

client signature type

Client CA names

Do a handshake and report some information about the result.

HEADER_HANDSHAKE_HELPER_H

www.openssl.org/source/license.html

License

ssl_test_ctx.h

