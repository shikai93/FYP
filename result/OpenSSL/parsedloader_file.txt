Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

For d2i_DSAPrivateKey

For the PKCS8 stuff o.O

For d2i_RSAPrivateKey

For the PKCS8 stuff o.O

Password prompting ------------------

This is used anywhere a pem_password_cb is needed

The file scheme decoders ------------------------ Each possible data type has its own decoder, which either operates through a given PEM name, or attempts to decode to see if the blob it's given is decodable for its data type. The assumption is that only the correct data type will match the content.

The try_decode function is called to check if the blob of data can be used by this handler, and if it can, decodes it into a supported OpenSSL type and returns a OSSL_STORE_INFO with the decoded data. Input: pem_name: If this blob comes from a PEM file, this holds the PEM name. If it comes from another type of file, this is NULL. pem_header: If this blob comes from a PEM file, this holds the PEM headers. If it comes from another type of file, this is NULL. blob: The blob of data to match with what this handler can use. len: The length of the blob. handler_ctx: For a handler marked repeatable, this pointer can be used to create a context for the handler. IT IS THE HANDLER'S RESPONSIBILITY TO CREATE AND DESTROY THIS CONTEXT APPROPRIATELY, i.e. create on first call and destroy when about to return NULL. matchcount: A pointer to an int to count matches for this data. Usually becomes 0 (no match) or 1 (match!), but may be higher in the (unlikely) event that the data matches more than one possibility. The int will always be zero when the function is called. ui_method: Application UI method for getting a password, pin or any other interactive data. ui_data: Application data to be passed to ui_method when it's called. Output: a OSSL_STORE_INFO

The eof function should return 1 if there's no more data to be found with the handler_ctx, otherwise 0. This is only used when the handler is marked repeatable.

The destroy_ctx function is used to destroy the handler_ctx that was intiated by a repeatable try_decode fuction. This is only used when the handler is marked repeatable.

flags

PKCS#12 decoder. It operates by decoding all of the blob content, extracting all the interesting data from it and storing them internally, then serving them one piece at a time.

Initial parsing

No match, there is no PEM PKCS12 tag

repeatable

Encrypted PKCS#8 decoder. It operates by just decrypting the given blob into a new blob, which is returned as an EMBEDDED STORE_INFO. The whole decoding process will then start over with the new blob.

Private key decoder. Decodes all sorts of private keys, both PKCS#8 encoded ones and old style PEM ones (with the key type is encoded into the PEM name).

No match

Public key decoder. Only supports SubjectPublicKeyInfo formated keys.

No match

Key parameter decoder.

X.509 certificate decoder.

In most cases, we can try to interpret the serialized data as a trusted cert (X509 + X509_AUX) and fall back to reading it as a normal cert (just X509), but if the PEM name specifically declares it as a trusted cert, then no fallback should be engaged. |ignore_trusted| tells if the fallback can be used (1) or not (0).

No match

X.509 CRL decoder.

No match

To finish it all off, we collect all the handlers.

The loader itself -----------------

Used with is_raw and is_pem

The following are used when the handler is marked as repeatable

Used with is_dir

The directory reading utility we have combines opening with reading the first name. To make sure we can detect the end at the right time, we read early and cache the name.

First step, just take the URI as is.

Second step, if the URI appears to start with the 'file' scheme, extract the path and make that the second path to check. There's a special case if the URI also contains an authority, then the full URI shouldn't be used as a path anywhere.

Invalidate using the full URI

Windows file: URIs with a drive letter start with a /

We know it's absolute, so no need to check

If the scheme "file" was an explicit part of the URI, the path must be absolute. So says RFC 8089

Successfully found a working path, clear possible collected errors

Try to copy everything, even if we know that some of them must be NULL for the moment. This prevents errors in the future, when more components may be used.

Internal function to decode an already opened PEM file

more than one match => ambiguous, kill any result

10 is the number of characters in "Proc-Type:", which PEM_get_EVP_CIPHER_INFO() requires to be present. If the PEM header has less characters than that, it's not worth spending cycles on it.

\0

On the first call (with a NULL context), OPENSSL_DIR_read() cares about the second argument. On the following calls, it only cares that it isn't NULL. Therefore, we can safely give it our URI here.

PEM record name

PEM record header

DER encoded data

DER encoded data length

If a PEM name matches more than one handler, the handlers are badly coded.

If there are other errors on the stack, they already show what the problem is.

We bail out on ambiguity

www.openssl.org/source/license.html

", 2) == 0) {

License

e_os.h

internal/asn1_int.h

internal/ctype.h

internal/o_dir.h

internal/cryptlib.h

internal/store_int.h

store_locl.h

pass phrase

s given is decodable for its data type. The assumption is that * only the correct data type will match the content. */ /*- * The try_decode function is called to check if the blob of data can * be used by this handler, and if it can, decodes it into a supported * OpenSSL type and returns a OSSL_STORE_INFO with the decoded data. * Input: * pem_name: If this blob comes from a PEM file, this holds * the PEM name. If it comes from another type of * file, this is NULL. * pem_header: If this blob comes from a PEM file, this holds * the PEM headers. If it comes from another type of * file, this is NULL. * blob: The blob of data to match with what this handler * can use. * len: The length of the blob. * handler_ctx: For a handler marked repeatable, this pointer can * be used to create a context for the handler. IT IS * THE HANDLER

s called. * Output: * a OSSL_STORE_INFO */ typedef OSSL_STORE_INFO *(*file_try_decode_fn)(const char *pem_name, const char *pem_header, const unsigned char *blob, size_t len, void **handler_ctx, int *matchcount, const UI_METHOD *ui_method, void *ui_data); /* * The eof function should return 1 if there





PKCS12 import password

PKCS12

PKCS8 decrypt password

PKCS8Encrypted

PRIVATE KEY

PrivateKey

PUBKEY

PARAMETERS

params

X509Certificate

X509CRL

file

s a special case if the URI also contains an authority, then * the full URI shouldn

file:

//

localhost/

/

/

:

/

a

z

s absolute, so no need to check */ path_data[path_data_n].check_absolute = 0; } } #endif path_data[path_data_n++].path = p; } for (i = 0, path = NULL; path == NULL && i < path_data_n; i++) { /* * If the scheme "file" was an explicit part of the URI, the path must * be absolute. So says RFC 8089 */ if (path_data[i].check_absolute && path_data[i].path[0] !=

) { OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE); ERR_add_error_data(1, path_data[i].path); return NULL; } if (stat(path_data[i].path, &st) < 0) { SYSerr(SYS_F_STAT, errno); ERR_add_error_data(1, path_data[i].path); } else { path = path_data[i].path; } } if (path == NULL) { return NULL; } /* Successfully found a working path, clear possible collected errors */ ERR_clear_error(); ctx = OPENSSL_zalloc(sizeof(*ctx)); if (ctx == NULL) { OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_MALLOC_FAILURE); return NULL; } if ((st.st_mode & S_IFDIR) == S_IFDIR) { /* * Try to copy everything, even if we know that some of them must be * NULL for the moment. This prevents errors in the future, when more * components may be used. */ ctx->_.dir.uri = OPENSSL_strdup(uri); ctx->type = is_dir; if (ctx->_.dir.uri == NULL) goto err; ctx->_.dir.last_entry = OPENSSL_DIR_read(&ctx->_.dir.ctx, path); ctx->_.dir.last_errno = errno; if (ctx->_.dir.last_entry == NULL) { if (ctx->_.dir.last_errno != 0) { char errbuf[256]; errno = ctx->_.dir.last_errno; openssl_strerror_r(errno, errbuf, sizeof(errbuf)); OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_SYS_LIB); ERR_add_error_data(1, errbuf); goto err; } ctx->_.dir.end_reached = 1; } } else { BIO *buff = NULL; char peekbuf[4096]; if ((buff = BIO_new(BIO_f_buffer())) == NULL || (ctx->_.file.file = BIO_new_file(path, "rb")) == NULL) { BIO_free_all(buff); goto err; } ctx->_.file.file = BIO_push(buff, ctx->_.file.file); if (BIO_buffer_peek(ctx->_.file.file, peekbuf, sizeof(peekbuf) - 1) > 0) { peekbuf[sizeof(peekbuf) - 1] =

; if (strstr(peekbuf, "-----BEGIN ") != NULL) ctx->type = is_pem; } } return ctx; err: OSSL_STORE_LOADER_CTX_free(ctx); return NULL; } static int file_ctrl(OSSL_STORE_LOADER_CTX *ctx, int cmd, va_list args) { int ret = 1; switch (cmd) { case OSSL_STORE_C_USE_SECMEM: { int on = *(va_arg(args, int *)); switch (on) { case 0: ctx->flags &= ~FILE_FLAG_SECMEM; break; case 1: ctx->flags |= FILE_FLAG_SECMEM; break; default: OSSL_STOREerr(OSSL_STORE_F_FILE_CTRL, ERR_R_PASSED_INVALID_ARGUMENT); ret = 0; break; } } break; default: break; } return ret; } /* Internal function to decode an already opened PEM file */ OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp) { OSSL_STORE_LOADER_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx)); if (ctx == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_FILE_ATTACH_PEM_BIO_INT, ERR_R_MALLOC_FAILURE); return NULL; } ctx->_.file.file = bp; ctx->type = is_pem; return ctx; } static OSSL_STORE_INFO *file_load_try_decode(OSSL_STORE_LOADER_CTX *ctx, const char *pem_name, const char *pem_header, unsigned char *data, size_t len, const UI_METHOD *ui_method, void *ui_data, int *matchcount) { OSSL_STORE_INFO *result = NULL; BUF_MEM *new_mem = NULL; char *new_pem_name = NULL; int t = 0; again: { size_t i = 0; void *handler_ctx = NULL; const FILE_HANDLER **matching_handlers = OPENSSL_zalloc(sizeof(*matching_handlers) * OSSL_NELEM(file_handlers)); if (matching_handlers == NULL) { OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD_TRY_DECODE, ERR_R_MALLOC_FAILURE); goto err; } *matchcount = 0; for (i = 0; i < OSSL_NELEM(file_handlers); i++) { const FILE_HANDLER *handler = file_handlers[i]; int try_matchcount = 0; void *tmp_handler_ctx = NULL; OSSL_STORE_INFO *tmp_result = handler->try_decode(pem_name, pem_header, data, len, &tmp_handler_ctx, &try_matchcount, ui_method, ui_data); if (try_matchcount > 0) { if (matching_handlers) matching_handlers[*matchcount] = handler; if (handler_ctx) handler->destroy_ctx(&handler_ctx); handler_ctx = tmp_handler_ctx; if ((*matchcount += try_matchcount) > 1) { /* more than one match => ambiguous, kill any result */ OSSL_STORE_INFO_free(result); OSSL_STORE_INFO_free(tmp_result); if (handler->destroy_ctx != NULL) handler->destroy_ctx(&handler_ctx); handler_ctx = NULL; tmp_result = NULL; result = NULL; } if (result == NULL) result = tmp_result; } } if (*matchcount == 1 && matching_handlers[0]->repeatable) { ctx->_.file.last_handler = matching_handlers[0]; ctx->_.file.last_handler_ctx = handler_ctx; } OPENSSL_free(matching_handlers); } err: OPENSSL_free(new_pem_name); BUF_MEM_free(new_mem); if (result != NULL && (t = OSSL_STORE_INFO_get_type(result)) == OSSL_STORE_INFO_EMBEDDED) { pem_name = new_pem_name = ossl_store_info_get0_EMBEDDED_pem_name(result); new_mem = ossl_store_info_get0_EMBEDDED_buffer(result); data = (unsigned char *)new_mem->data; len = new_mem->length; OPENSSL_free(result); result = NULL; goto again; } if (result != NULL) ERR_clear_error(); return result; } static OSSL_STORE_INFO *file_load_try_repeat(OSSL_STORE_LOADER_CTX *ctx, const UI_METHOD *ui_method, void *ui_data) { OSSL_STORE_INFO *result = NULL; int try_matchcount = 0; if (ctx->_.file.last_handler != NULL) { result = ctx->_.file.last_handler->try_decode(NULL, NULL, NULL, 0, &ctx->_.file.last_handler_ctx, &try_matchcount, ui_method, ui_data); if (result == NULL) { ctx->_.file.last_handler->destroy_ctx(&ctx->_.file.last_handler_ctx); ctx->_.file.last_handler_ctx = NULL; ctx->_.file.last_handler = NULL; } } return result; } static void pem_free_flag(void *pem_data, int secure, size_t num) { if (secure) OPENSSL_secure_clear_free(pem_data, num); else OPENSSL_free(pem_data); } static int file_read_pem(BIO *bp, char **pem_name, char **pem_header, unsigned char **data, long *len, const UI_METHOD *ui_method, void *ui_data, int secure) { int i = secure ? PEM_read_bio_ex(bp, pem_name, pem_header, data, len, PEM_FLAG_SECURE | PEM_FLAG_EAY_COMPATIBLE) : PEM_read_bio(bp, pem_name, pem_header, data, len); if (i <= 0) return 0; /* * 10 is the number of characters in "Proc-Type:", which * PEM_get_EVP_CIPHER_INFO() requires to be present. * If the PEM header has less characters than that, it

PEM

\0

]

>

:

\\

/



/

.

t NULL. Therefore, we can safely give * it our URI here. */ ctx->_.dir.last_entry = OPENSSL_DIR_read(&ctx->_.dir.ctx, ctx->_.dir.uri); ctx->_.dir.last_errno = errno; if (ctx->_.dir.last_entry == NULL && ctx->_.dir.last_errno == 0) ctx->_.dir.end_reached = 1; if (newname != NULL && (result = OSSL_STORE_INFO_new_NAME(newname)) == NULL) { OPENSSL_free(newname); OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, ERR_R_OSSL_STORE_LIB); return NULL; } } while (result == NULL && !file_eof(ctx)); } else { int matchcount = -1; result = file_load_try_repeat(ctx, ui_method, ui_data); if (result != NULL) return result; if (file_eof(ctx)) return NULL; do { char *pem_name = NULL; /* PEM record name */ char *pem_header = NULL; /* PEM record header */ unsigned char *data = NULL; /* DER encoded data */ long len = 0; /* DER encoded data length */ matchcount = -1; if (ctx->type == is_pem) { if (!file_read_pem(ctx->_.file.file, &pem_name, &pem_header, &data, &len, ui_method, ui_data, (ctx->flags & FILE_FLAG_SECMEM) != 0)) { ctx->errcnt++; goto endloop; } } else { if (!file_read_asn1(ctx->_.file.file, &data, &len)) { ctx->errcnt++; goto endloop; } } result = file_load_try_decode(ctx, pem_name, pem_header, data, len, ui_method, ui_data, &matchcount); if (result != NULL) goto endloop; /* * If a PEM name matches more than one handler, the handlers are * badly coded. */ if (!ossl_assert(pem_name == NULL || matchcount <= 1)) { ctx->errcnt++; goto endloop; } if (matchcount > 1) { OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE); } else if (matchcount == 1) { /* * If there are other errors on the stack, they already show * what the problem is. */ if (ERR_peek_error() == 0) { OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE); if (pem_name != NULL) ERR_add_error_data(3, "PEM type is

, pem_name,

); } } if (matchcount > 0) ctx->errcnt++; endloop: pem_free_flag(pem_name, (ctx->flags & FILE_FLAG_SECMEM) != 0, 0); pem_free_flag(pem_header, (ctx->flags & FILE_FLAG_SECMEM) != 0, 0); pem_free_flag(data, (ctx->flags & FILE_FLAG_SECMEM) != 0, len); } while (matchcount == 0 && !file_eof(ctx) && !file_error(ctx)); /* We bail out on ambiguity */ if (matchcount > 1) return NULL; } return result; } static int file_error(OSSL_STORE_LOADER_CTX *ctx) { return ctx->errcnt > 0; } static int file_eof(OSSL_STORE_LOADER_CTX *ctx) { if (ctx->type == is_dir) return ctx->_.dir.end_reached; if (ctx->_.file.last_handler != NULL && !ctx->_.file.last_handler->eof(ctx->_.file.last_handler_ctx)) return 0; return BIO_eof(ctx->_.file.file); } static int file_close(OSSL_STORE_LOADER_CTX *ctx) { if (ctx->type == is_dir) { OPENSSL_DIR_end(&ctx->_.dir.ctx); } else { BIO_free_all(ctx->_.file.file); } OSSL_STORE_LOADER_CTX_free(ctx); return 1; } int ossl_store_file_detach_pem_bio_int(OSSL_STORE_LOADER_CTX *ctx) { OSSL_STORE_LOADER_CTX_free(ctx); return 1; } static OSSL_STORE_LOADER file_loader = {

