Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

the following pointers may be changed as long as 'allow_customize' is set

empty

Parse a "malloc failure spec" string. This likes like a set of fields separated by semicolons. Each field has a count and an optional failure percentage. For example: 100@0;100@25;0@0 or 100;100@25;0 This means 100 mallocs succeed, then next 100 fail 25% of the time, and all remaining (count is zero) succeed.

Get the count (atol will stop at the @ if there), and percentage

Windows doesn't have random(), but it has rand() Some rand() implementations aren't good, but we're not dealing with secure randomness here.

See if the current malloc should fail.

If we used up this one, go to the next.

Can't shrink the buffer since memcpy below copies |old_len| bytes.

www.openssl.org/source/license.html

License

e_os.h

internal/cryptlib.h

internal/cryptlib_int.h

allow_customize

malloc failure spec

;

\0

@

t have random(), but it has rand() * Some rand() implementations aren

re not * dealing with secure randomness here. */ #ifdef _WIN32 # define random() rand() #endif /* * See if the current malloc should fail. */ static int shouldfail(void) { int roll = (int)(random() % 100); int shoulditfail = roll < md_fail_percent; int len; char buff[80]; if (md_tracefd > 0) { BIO_snprintf(buff, sizeof(buff), "%c C%ld %%%d R%d\n", shoulditfail ?

:

, md_count, md_fail_percent, roll); len = strlen(buff); if (write(md_tracefd, buff, len) != len) perror("shouldfail write failed"); #ifndef OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE if (shoulditfail) { void *addrs[30]; int num = backtrace(addrs, OSSL_NELEM(addrs)); backtrace_symbols_fd(addrs, num, md_tracefd); } #endif } if (md_count) { /* If we used up this one, go to the next. */ if (--md_count == 0) parseit(); } return shoulditfail; } void ossl_malloc_setup_failures(void) { const char *cp = getenv("OPENSSL_MALLOC_FAILURES"); if (cp != NULL && (md_failstring = strdup(cp)) != NULL) parseit(); if ((cp = getenv("OPENSSL_MALLOC_FD")) != NULL) md_tracefd = atoi(cp); } #endif void *CRYPTO_malloc(size_t num, const char *file, int line) { void *ret = NULL; if (malloc_impl != NULL && malloc_impl != CRYPTO_malloc) return malloc_impl(num, file, line); if (num == 0) return NULL; FAILTEST(); allow_customize = 0; #ifndef OPENSSL_NO_CRYPTO_MDEBUG if (call_malloc_debug) { CRYPTO_mem_debug_malloc(NULL, num, 0, file, line); ret = malloc(num); CRYPTO_mem_debug_malloc(ret, num, 1, file, line); } else { ret = malloc(num); } #else (void)(file); (void)(line); ret = malloc(num); #endif return ret; } void *CRYPTO_zalloc(size_t num, const char *file, int line) { void *ret = CRYPTO_malloc(num, file, line); FAILTEST(); if (ret != NULL) memset(ret, 0, num); return ret; } void *CRYPTO_realloc(void *str, size_t num, const char *file, int line) { if (realloc_impl != NULL && realloc_impl != &CRYPTO_realloc) return realloc_impl(str, num, file, line); FAILTEST(); if (str == NULL) return CRYPTO_malloc(num, file, line); if (num == 0) { CRYPTO_free(str, file, line); return NULL; } allow_customize = 0; #ifndef OPENSSL_NO_CRYPTO_MDEBUG if (call_malloc_debug) { void *ret; CRYPTO_mem_debug_realloc(str, NULL, num, 0, file, line); ret = realloc(str, num); CRYPTO_mem_debug_realloc(str, ret, num, 1, file, line); return ret; } #else (void)(file); (void)(line); #endif return realloc(str, num); } void *CRYPTO_clear_realloc(void *str, size_t old_len, size_t num, const char *file, int line) { void *ret = NULL; if (str == NULL) return CRYPTO_malloc(num, file, line); if (num == 0) { CRYPTO_clear_free(str, old_len, file, line); return NULL; } /* Can

