Copyright 2003-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Give a string of hex digits convert to a buffer

Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its hex representation @@@ (Contents of buffer are always kept in ASCII, also on EBCDIC machines)

We can use "real" strerror_r. The OpenSSL version differs in that it gives 1 on success and 0 on failure for consistency with other OpenSSL functions. Real strerror_r does it the other way around

Fall back to non-thread safe strerror()...its all we can do

Can this ever happen?

www.openssl.org/source/license.html

License

e_os.h

internal/cryptlib.h

internal/o_str.h

\0

\0

\0

0

1

2

3

4

5

6

7

8

9

a

A

b

B

c

C

d

D

e

E

f

F

:

len

ed string with its * hex representation @@@ (Contents of buffer are always kept in ASCII, also * on EBCDIC machines) */ char *OPENSSL_buf2hexstr(const unsigned char *buffer, long len) { static const char hexdig[] = "0123456789ABCDEF"; char *tmp, *q; const unsigned char *p; int i; if (len == 0) { return OPENSSL_zalloc(1); } if ((tmp = OPENSSL_malloc(len * 3)) == NULL) { CRYPTOerr(CRYPTO_F_OPENSSL_BUF2HEXSTR, ERR_R_MALLOC_FAILURE); return NULL; } q = tmp; for (i = 0, p = buffer; i < len; i++, p++) { *q++ = hexdig[(*p >> 4) & 0xf]; *q++ = hexdig[*p & 0xf]; *q++ =

; } q[-1] = 0; #ifdef CHARSET_EBCDIC ebcdic2ascii(tmp, tmp, q - tmp - 1); #endif return tmp; } int openssl_strerror_r(int errnum, char *buf, size_t buflen) { #if defined(_MSC_VER) && _MSC_VER>=1400 return !strerror_s(buf, buflen, errnum); #elif defined(_GNU_SOURCE) return strerror_r(errnum, buf, buflen) != NULL; #elif (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \ (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600) /* * We can use "real" strerror_r. The OpenSSL version differs in that it * gives 1 on success and 0 on failure for consistency with other OpenSSL * functions. Real strerror_r does it the other way around */ return !strerror_r(errnum, buf, buflen); #else char *err; /* Fall back to non-thread safe strerror()...its all we can do */ if (buflen < 2) return 0; err = strerror(errnum); /* Can this ever happen? */ if (err == NULL) return 0; strncpy(buf, err, buflen - 1); buf[buflen - 1] =

0x0A;

0x0B;

0x0C;

0x0D;

0x0E;

0x0F;

0xf];

0xf];

Copyright 2003-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

to get size_t

www.openssl.org/source/license.html

License

