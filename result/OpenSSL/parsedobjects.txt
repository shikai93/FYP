Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

www.openssl.org/source/license.html

License

www.secg.org/)

www.wapforum.org/)

csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html

www.ietf.org/rfc/rfc5639.txt)

www.ietf.org/rfc/rfc6962.txt)

cabforum.org/extended-validation/)

1.3.36.8.3.3

SEC 2: Recommended Elliptic Curve Domain Parameters

role

internet 7

mail

mail

mail

MIME MHS

t consitute a problem, as # references are realized via long name "Mail" (with capital M). internet 7 : : Mail Private 1 : enterprises : Enterprises # RFC 2247 Enterprises 1466 344 : dcobject : dcObject # RFC 1495 Mail 1 : mime-mhs : MIME MHS mime-mhs 1 : mime-mhs-headings : mime-mhs-headings mime-mhs 2 : mime-mhs-bodies : mime-mhs-bodies mime-mhs-headings 1 : id-hex-partial-message : id-hex-partial-message mime-mhs-headings 2 : id-hex-multipart-message : id-hex-multipart-message # RFC 3274 !Cname zlib-compression id-smime-alg 8 : ZLIB : zlib compression # AES aka Rijndael !Alias csor 2 16 840 1 101 3 !Alias nistAlgorithms csor 4 !Alias aes nistAlgorithms 1 aes 1 : AES-128-ECB : aes-128-ecb aes 2 : AES-128-CBC : aes-128-cbc !Cname aes-128-ofb128 aes 3 : AES-128-OFB : aes-128-ofb !Cname aes-128-cfb128 aes 4 : AES-128-CFB : aes-128-cfb aes 5 : id-aes128-wrap aes 6 : id-aes128-GCM : aes-128-gcm aes 7 : id-aes128-CCM : aes-128-ccm aes 8 : id-aes128-wrap-pad aes 21 : AES-192-ECB : aes-192-ecb aes 22 : AES-192-CBC : aes-192-cbc !Cname aes-192-ofb128 aes 23 : AES-192-OFB : aes-192-ofb !Cname aes-192-cfb128 aes 24 : AES-192-CFB : aes-192-cfb aes 25 : id-aes192-wrap aes 26 : id-aes192-GCM : aes-192-gcm aes 27 : id-aes192-CCM : aes-192-ccm aes 28 : id-aes192-wrap-pad aes 41 : AES-256-ECB : aes-256-ecb aes 42 : AES-256-CBC : aes-256-cbc !Cname aes-256-ofb128 aes 43 : AES-256-OFB : aes-256-ofb !Cname aes-256-cfb128 aes 44 : AES-256-CFB : aes-256-cfb aes 45 : id-aes256-wrap aes 46 : id-aes256-GCM : aes-256-gcm aes 47 : id-aes256-CCM : aes-256-ccm aes 48 : id-aes256-wrap-pad # There are no OIDs for these modes... : AES-128-CFB1 : aes-128-cfb1 : AES-192-CFB1 : aes-192-cfb1 : AES-256-CFB1 : aes-256-cfb1 : AES-128-CFB8 : aes-128-cfb8 : AES-192-CFB8 : aes-192-cfb8 : AES-256-CFB8 : aes-256-cfb8 : AES-128-CTR : aes-128-ctr : AES-192-CTR : aes-192-ctr : AES-256-CTR : aes-256-ctr : AES-128-OCB : aes-128-ocb : AES-192-OCB : aes-192-ocb : AES-256-OCB : aes-256-ocb : AES-128-XTS : aes-128-xts : AES-256-XTS : aes-256-xts : DES-CFB1 : des-cfb1 : DES-CFB8 : des-cfb8 : DES-EDE3-CFB1 : des-ede3-cfb1 : DES-EDE3-CFB8 : des-ede3-cfb8 # OIDs for SHA224, SHA256, SHA385 and SHA512, according to x9.84 and # http://csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html # "Middle" names are specified to be id-sha256, id-sha384, etc., but # we adhere to unprefixed capitals for backward compatibility... !Alias nist_hashalgs nistAlgorithms 2 nist_hashalgs 1 : SHA256 : sha256 nist_hashalgs 2 : SHA384 : sha384 nist_hashalgs 3 : SHA512 : sha512 nist_hashalgs 4 : SHA224 : sha224 nist_hashalgs 5 : SHA512-224 : sha512-224 nist_hashalgs 6 : SHA512-256 : sha512-256 nist_hashalgs 7 : SHA3-224 : sha3-224 nist_hashalgs 8 : SHA3-256 : sha3-256 nist_hashalgs 9 : SHA3-384 : sha3-384 nist_hashalgs 10 : SHA3-512 : sha3-512 nist_hashalgs 11 : SHAKE128 : shake128 nist_hashalgs 12 : SHAKE256 : shake256 nist_hashalgs 13 : id-hmacWithSHA3-224 : hmac-sha3-224 nist_hashalgs 14 : id-hmacWithSHA3-256 : hmac-sha3-256 nist_hashalgs 15 : id-hmacWithSHA3-384 : hmac-sha3-384 nist_hashalgs 16 : id-hmacWithSHA3-512 : hmac-sha3-512 # Below two are incomplete OIDs, to be uncommented when we figure out # how to handle them... # nist_hashalgs 17 : id-shake128-len : shake128-len # nist_hashalgs 18 : id-shake256-len : shake256-len # OIDs for dsa-with-sha224 and dsa-with-sha256 !Alias dsa_with_sha2 nistAlgorithms 3 dsa_with_sha2 1 : dsa_with_SHA224 dsa_with_sha2 2 : dsa_with_SHA256 # Above two belong below, but kept as they are for backward compatibility !Alias sigAlgs nistAlgorithms 3 sigAlgs 3 : id-dsa-with-sha384 : dsa_with_SHA384 sigAlgs 4 : id-dsa-with-sha512 : dsa_with_SHA512 sigAlgs 5 : id-dsa-with-sha3-224 : dsa_with_SHA3-224 sigAlgs 6 : id-dsa-with-sha3-256 : dsa_with_SHA3-256 sigAlgs 7 : id-dsa-with-sha3-384 : dsa_with_SHA3-384 sigAlgs 8 : id-dsa-with-sha3-512 : dsa_with_SHA3-512 sigAlgs 9 : id-ecdsa-with-sha3-224 : ecdsa_with_SHA3-224 sigAlgs 10 : id-ecdsa-with-sha3-256 : ecdsa_with_SHA3-256 sigAlgs 11 : id-ecdsa-with-sha3-384 : ecdsa_with_SHA3-384 sigAlgs 12 : id-ecdsa-with-sha3-512 : ecdsa_with_SHA3-512 sigAlgs 13 : id-rsassa-pkcs1-v1_5-with-sha3-224 : RSA-SHA3-224 sigAlgs 14 : id-rsassa-pkcs1-v1_5-with-sha3-256 : RSA-SHA3-256 sigAlgs 15 : id-rsassa-pkcs1-v1_5-with-sha3-384 : RSA-SHA3-284 sigAlgs 16 : id-rsassa-pkcs1-v1_5-with-sha3-512 : RSA-SHA3-512 # Hold instruction CRL entry extension !Cname hold-instruction-code id-ce 23 : holdInstructionCode : Hold Instruction Code !Alias holdInstruction X9-57 2 !Cname hold-instruction-none holdInstruction 1 : holdInstructionNone : Hold Instruction None !Cname hold-instruction-call-issuer holdInstruction 2 : holdInstructionCallIssuer : Hold Instruction Call Issuer !Cname hold-instruction-reject holdInstruction 3 : holdInstructionReject : Hold Instruction Reject # OID

Kuznechik

HMAC

Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

-1 for everything

Unsolved problem: if a type is actually a pointer type, like nid_triple is, then its impossible to get a const where you need it. Consider: typedef int nid_triple[3]; const void a_; const nid_triple const a = a_; The assignment discards a const because what you really want is: const int const const a = a_; But if you do that, you lose the fact that a is an array of 3 ints, which breaks comparison functions. Thus we end up having to cast, sadly, or unpack the declarations. Or, as I finally did in this case, declare nid_triple to be a struct, which it should have been in the first place. Ben, August 2008. Also, strictly speaking not all types need be const, but handling the non-constness means a lot of complication, and in practice comparison routines do always not touch their arguments.

www.openssl.org/source/license.html

License

C

0x00

0x01

0x02

0x03

0x04

0x05

0x8000

0x01

0x02

0x10100000L

