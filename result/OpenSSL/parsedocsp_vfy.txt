Copyright 2001-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Verify a basic response message

At this point we have a valid certificate chain need to verify it against the OCSP issuer criteria.

If fatal error or valid match then finish

Easy case: explicitly trusted. Get root CA and check for explicit trust

Maybe lookup from store if by subject name

Easy if lookup by name

Lookup by key hash

If key hash isn't SHA1 length then forget it

Calculate hash of each key and compare

See if the issuer IDs match.

If ID mismatch or other error then return

Check to see if OCSP responder CA matches request CA

We have a match, if extensions OK then success

Otherwise check if OCSP request signed directly by request CA

Check the issuer certificate IDs for equality. If there is a mismatch with the same algorithm then there's no point trying to match any certificates against the issuer. If the issuer IDs all match then we just need to check equality against one of them.

Check to see if IDs match

If algorithm mismatch let caller deal with it

Else mismatch

All IDs match: only need to check one ID

If only one ID to match then do it

We have to match the whole lot

Verify an OCSP request. This is fortunately much easier than OCSP response verify. Just find the signers certificate and verify it against a given trust value.

www.openssl.org/source/license.html

License

ocsp_lcl.h

Verify error:

t SHA1 length then forget it */ if (id->value.byKey->length != SHA_DIGEST_LENGTH) return NULL; keyhash = id->value.byKey->data; /* Calculate hash of each key and compare */ for (i = 0; i < sk_X509_num(certs); i++) { x = sk_X509_value(certs, i); X509_pubkey_digest(x, EVP_sha1(), tmphash, NULL); if (!memcmp(keyhash, tmphash, SHA_DIGEST_LENGTH)) return x; } return NULL; } static int ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain) { STACK_OF(OCSP_SINGLERESP) *sresp; X509 *signer, *sca; OCSP_CERTID *caid = NULL; int i; sresp = bs->tbsResponseData.responses; if (sk_X509_num(chain) <= 0) { OCSPerr(OCSP_F_OCSP_CHECK_ISSUER, OCSP_R_NO_CERTIFICATES_IN_CHAIN); return -1; } /* See if the issuer IDs match. */ i = ocsp_check_ids(sresp, &caid); /* If ID mismatch or other error then return */ if (i <= 0) return i; signer = sk_X509_value(chain, 0); /* Check to see if OCSP responder CA matches request CA */ if (sk_X509_num(chain) > 1) { sca = sk_X509_value(chain, 1); i = ocsp_match_issuerid(sca, caid, sresp); if (i < 0) return i; if (i) { /* We have a match, if extensions OK then success */ if (ocsp_check_delegated(signer)) return 1; return 0; } } /* Otherwise check if OCSP request signed directly by request CA */ return ocsp_match_issuerid(signer, caid, sresp); } /* * Check the issuer certificate IDs for equality. If there is a mismatch with * the same algorithm then there

Verify error:

