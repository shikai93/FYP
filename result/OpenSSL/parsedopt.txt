Copyright 2015-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Our state

Return the simple name of the program; removing various platform gunk.

find the last '/', '\' or ':'

Strip off trailing nonsense.

Copy over the name, in lowercase.

Find last special character sys:[foo.bar]openssl

Could use strchr, but this is like the ones above.

Set up the arg parsing.

Store state.

Make sure options are legit.

Make sure there are no duplicates.

Some compilers inline strcmp and the assert string is too long.

Print an error message about a failed format parse.

Parse a format string, put it into result; return 0 on failure, else 1.

Parse a cipher name, put it in EVP_CIPHER; return 0 on failure, else 1.

Parse message digest name, put it in EVP_MD; return 0 on failure, else 1.

Look through a list of name/value pairs.

Parse an int, put it into result; return 0 on failure, else 1.

Parse a long, put it into result; return 0 on failure, else 1.

Parse an intmax_t, put it into result; return 0 on failure, else 1.

Parse a uintmax_t, put it into result; return 0 on failure, else 1.

Parse an unsigned long, put it into result; return 0 on failure, else 1.

We pass opt as an int but cast it to "enum range" so that all the items in the OPT_V_ENUM enumeration are caught; this makes -Wswitch in gcc do the right thing.

purpose name -> purpose index

purpose index -> purpose object

purpose object -> purpose value

NOP, deprecated

Parse the next flag (and value if specified), return 0 if done, -1 on error, otherwise the flag's retval.

Look at current arg; at end of the list?

If word doesn't start with a -, we're done.

Hit "--" ? We're done.

Allow -nnn and --nnn

If we have --flag=foo, snip it off

If not this option, move on to the next one.

If it doesn't take a value, make sure none was given.

Want a value; get the next param if =foo not used.

Syntax-check value.

Just a string.

Input file.

Output file.

Return the flag value.

Return the most recent flag parameter.

Return the most recent flag.

Return the unknown option.

Return the rest of the arguments after parsing flags.

How many items in remaining args?

Return a string describing the parameter type.

Starts with its own help message?

Find the widest help.

Now let's print.

Pad out prefix

Continuation of previous line; pad and print.

Build up the "-flag [param]" part.

www.openssl.org/source/license.html

License

apps.h

--

---

/

\' or

*/ for (p = argv0 + strlen(argv0); --p > argv0;) if (*p ==

|| *p ==

|| *p ==

) { p++; break; } /* Strip off trailing nonsense. */ n = strlen(p); if (n > 4 && (strcmp(&p[n - 4], ".exe") == 0 || strcmp(&p[n - 4], ".EXE") == 0)) n -= 4; /* Copy over the name, in lowercase. */ if (n > sizeof prog - 1) n = sizeof prog - 1; for (q = prog, i = 0; i < n; i++, p++) *q++ = tolower((unsigned char)*p); *q =

; return prog; } #elif defined(OPENSSL_SYS_VMS) char *opt_progname(const char *argv0) { const char *p, *q; /* Find last special character sys:[foo.bar]openssl */ for (p = argv0 + strlen(argv0); --p > argv0;) if (*p ==

|| *p ==

|| *p ==

) { p++; break; } q = strrchr(p,

); strncpy(prog, p, sizeof prog - 1); prog[sizeof prog - 1] =

; if (q != NULL && q - p < sizeof prog) prog[q - p] =

; return prog; } #else char *opt_progname(const char *argv0) { const char *p; /* Could use strchr, but this is like the ones above. */ for (p = argv0 + strlen(argv0); --p > argv0;) if (*p ==

) { p++; break; } strncpy(prog, p, sizeof prog - 1); prog[sizeof prog - 1] =

; return prog; } #endif char *opt_getprog(void) { return prog; } /* Set up the arg parsing. */ char *opt_init(int ac, char **av, const OPTIONS *o) { /* Store state. */ argc = ac; argv = av; opt_index = 1; opts = o; opt_progname(av[0]); unknown = NULL; for (; o->name; ++o) { #ifndef NDEBUG const OPTIONS *next; int duplicated, i; #endif if (o->name == OPT_HELP_STR || o->name == OPT_MORE_STR) continue; #ifndef NDEBUG i = o->valtype; /* Make sure options are legit. */ assert(o->name[0] !=

); assert(o->retval > 0); switch (i) { case 0: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: case

: break; default: assert(0); } /* Make sure there are no duplicates. */ for (next = o + 1; next->name; ++next) { /* * Some compilers inline strcmp and the assert string is too long. */ duplicated = strcmp(o->name, next->name) == 0; assert(!duplicated); } #endif if (o->name[0] ==

) { assert(unknown == NULL); unknown = o; assert(unknown->valtype == 0 || unknown->valtype ==

); } } return prog; } static OPT_PAIR formats[] = { {"PEM/DER", OPT_FMT_PEMDER}, {"pkcs12", OPT_FMT_PKCS12}, {"smime", OPT_FMT_SMIME}, {"engine", OPT_FMT_ENGINE}, {"msblob", OPT_FMT_MSBLOB}, {"netscape", OPT_FMT_NETSCAPE}, {"nss", OPT_FMT_NSS}, {"text", OPT_FMT_TEXT}, {"http", OPT_FMT_HTTP}, {"pvk", OPT_FMT_PVK}, {NULL} }; /* Print an error message about a failed format parse. */ int opt_format_error(const char *s, unsigned long flags) { OPT_PAIR *ap; if (flags == OPT_FMT_PEMDER) { BIO_printf(bio_err, "%s: Bad format \"%s\"; must be pem or der\n", prog, s); } else { BIO_printf(bio_err, "%s: Bad format \"%s\"; must be one of:\n", prog, s); for (ap = formats; ap->name; ap++) if (flags & ap->retval) BIO_printf(bio_err, " %s\n", ap->name); } return 0; } /* Parse a format string, put it into *result; return 0 on failure, else 1. */ int opt_format(const char *s, unsigned long flags, int *result) { switch (*s) { default: return 0; case

: case

: if ((flags & OPT_FMT_PEMDER) == 0) return opt_format_error(s, flags); *result = FORMAT_ASN1; break; case

: case

: if ((flags & OPT_FMT_TEXT) == 0) return opt_format_error(s, flags); *result = FORMAT_TEXT; break; case

: case

: if ((flags & OPT_FMT_NSS) == 0) return opt_format_error(s, flags); if (strcmp(s, "NSS") != 0 && strcmp(s, "nss") != 0) return opt_format_error(s, flags); *result = FORMAT_NSS; break; case

: case

: if ((flags & OPT_FMT_SMIME) == 0) return opt_format_error(s, flags); *result = FORMAT_SMIME; break; case

: case

: if ((flags & OPT_FMT_MSBLOB) == 0) return opt_format_error(s, flags); *result = FORMAT_MSBLOB; break; case

: case

: if ((flags & OPT_FMT_ENGINE) == 0) return opt_format_error(s, flags); *result = FORMAT_ENGINE; break; case

: case

: if ((flags & OPT_FMT_HTTP) == 0) return opt_format_error(s, flags); *result = FORMAT_HTTP; break; case

: if ((flags & OPT_FMT_PKCS12) == 0) return opt_format_error(s, flags); *result = FORMAT_PKCS12; break; case

: case

: if (s[1] ==

|| strcmp(s, "PEM") == 0 || strcmp(s, "pem") == 0) { if ((flags & OPT_FMT_PEMDER) == 0) return opt_format_error(s, flags); *result = FORMAT_PEM; } else if (strcmp(s, "PVK") == 0 || strcmp(s, "pvk") == 0) { if ((flags & OPT_FMT_PVK) == 0) return opt_format_error(s, flags); *result = FORMAT_PVK; } else if (strcmp(s, "P12") == 0 || strcmp(s, "p12") == 0 || strcmp(s, "PKCS12") == 0 || strcmp(s, "pkcs12") == 0) { if ((flags & OPT_FMT_PKCS12) == 0) return opt_format_error(s, flags); *result = FORMAT_PKCS12; } else { return 0; } break; } return 1; } /* Parse a cipher name, put it in *EVP_CIPHER; return 0 on failure, else 1. */ int opt_cipher(const char *name, const EVP_CIPHER **cipherp) { *cipherp = EVP_get_cipherbyname(name); if (*cipherp != NULL) return 1; BIO_printf(bio_err, "%s: Unknown cipher %s\n", prog, name); return 0; } /* * Parse message digest name, put it in *EVP_MD; return 0 on failure, else 1. */ int opt_md(const char *name, const EVP_MD **mdp) { *mdp = EVP_get_digestbyname(name); if (*mdp != NULL) return 1; BIO_printf(bio_err, "%s: Unknown digest %s\n", prog, name); return 0; } /* Look through a list of name/value pairs. */ int opt_pair(const char *name, const OPT_PAIR* pairs, int *result) { const OPT_PAIR *pp; for (pp = pairs; pp->name; pp++) if (strcmp(pp->name, name) == 0) { *result = pp->retval; return 1; } BIO_printf(bio_err, "%s: Value must be one of:\n", prog); for (pp = pairs; pp->name; pp++) BIO_printf(bio_err, "\t%s\n", pp->name); return 0; } /* Parse an int, put it into *result; return 0 on failure, else 1. */ int opt_int(const char *value, int *result) { long l; if (!opt_long(value, &l)) return 0; *result = (int)l; if (*result != l) { BIO_printf(bio_err, "%s: Value \"%s\" outside integer range\n", prog, value); return 0; } return 1; } static void opt_number_error(const char *v) { size_t i = 0; struct strstr_pair_st { char *prefix; char *name; } b[] = { {"0x", "a hexadecimal"}, {"0X", "a hexadecimal"}, {"0", "an octal"} }; for (i = 0; i < OSSL_NELEM(b); i++) { if (strncmp(v, b[i].prefix, strlen(b[i].prefix)) == 0) { BIO_printf(bio_err, "%s: Can

%s\" as %s number\n

%s: Can't parse \"%s\" as a number\n

enum range

%s: Invalid Policy %s\n

%s: Invalid purpose %s\n

%s: Internal error setting purpose %s\n

%s: Invalid verify name %s\n

%s: epoch time out of range %s\n

s retval. */ int opt_next(void) { char *p; const OPTIONS *o; int ival; long lval; unsigned long ulval; ossl_intmax_t imval; ossl_uintmax_t umval; /* Look at current arg; at end of the list? */ arg = NULL; p = argv[opt_index]; if (p == NULL) return 0; /* If word doesn

re done. */ if (*p !=

) return 0; /* Hit "--" ? We

--

-

=

\0

t take a value, make sure none was given. */ if (o->valtype == 0 || o->valtype ==

) { if (arg) { BIO_printf(bio_err, "%s: Option -%s does not take a value\n", prog, p); return -1; } return o->retval; } /* Want a value; get the next param if =foo not used. */ if (arg == NULL) { if (argv[opt_index] == NULL) { BIO_printf(bio_err, "%s: Option -%s needs a value\n", prog, o->name); return -1; } arg = argv[opt_index++]; } /* Syntax-check value. */ switch (o->valtype) { default: case

: /* Just a string. */ break; case

: if (app_isdir(arg) >= 0) break; BIO_printf(bio_err, "%s: Not a directory: %s\n", prog, arg); return -1; case

: /* Input file. */ if (strcmp(arg, "-") == 0 || app_access(arg, R_OK) >= 0) break; BIO_printf(bio_err, "%s: Cannot open input file %s, %s\n", prog, arg, strerror(errno)); return -1; case

: /* Output file. */ if (strcmp(arg, "-") == 0 || app_access(arg, W_OK) >= 0 || errno == ENOENT) break; BIO_printf(bio_err, "%s: Cannot open output file %s, %s\n", prog, arg, strerror(errno)); return -1; case

: case

: if (!opt_int(arg, &ival) || (o->valtype ==

&& ival <= 0)) { BIO_printf(bio_err, "%s: Non-positive number \"%s\" for -%s\n", prog, arg, o->name); return -1; } break; case

: if (!opt_imax(arg, &imval)) { BIO_printf(bio_err, "%s: Invalid number \"%s\" for -%s\n", prog, arg, o->name); return -1; } break; case

: if (!opt_umax(arg, &umval)) { BIO_printf(bio_err, "%s: Invalid number \"%s\" for -%s\n", prog, arg, o->name); return -1; } break; case

: if (!opt_long(arg, &lval)) { BIO_printf(bio_err, "%s: Invalid number \"%s\" for -%s\n", prog, arg, o->name); return -1; } break; case

: if (!opt_ulong(arg, &ulval)) { BIO_printf(bio_err, "%s: Invalid number \"%s\" for -%s\n", prog, arg, o->name); return -1; } break; case

: case

: case

: case

: if (opt_format(arg, o->valtype ==

? OPT_FMT_PDS : o->valtype ==

? OPT_FMT_PDE : o->valtype ==

? OPT_FMT_PEMDER : OPT_FMT_ANY, &ival)) break; BIO_printf(bio_err, "%s: Invalid format \"%s\" for -%s\n", prog, arg, o->name); return -1; } /* Return the flag value. */ return o->retval; } if (unknown != NULL) { dunno = p; return unknown->retval; } BIO_printf(bio_err, "%s: Option unknown option -%s\n", prog, p); return -1; } /* Return the most recent flag parameter. */ char *opt_arg(void) { return arg; } /* Return the most recent flag. */ char *opt_flag(void) { return flag; } /* Return the unknown option. */ char *opt_unknown(void) { return dunno; } /* Return the rest of the arguments after parsing flags. */ char **opt_rest(void) { return &argv[opt_index]; } /* How many items in remaining args? */ int opt_num_rest(void) { int i = 0; char **pp; for (pp = opt_rest(); *pp; pp++, i++) continue; return i; } /* Return a string describing the parameter type. */ static const char *valtype2param(const OPTIONS *o) { switch (o->valtype) { case 0: case

: return ""; case

: return "val"; case

: return "dir"; case

: return "infile"; case

: return "outfile"; case

: return "+int"; case

: return "int"; case

: return "long"; case

: return "ulong"; case

: return "PEM|DER|ENGINE"; case

: return "PEM|DER"; case

: return "format"; case

: return "intmax"; case

: return "uintmax"; } return "parm"; } void opt_help(const OPTIONS *list) { const OPTIONS *o; int i; int standard_prolog; int width = 5; char start[80 + 1]; char *p; const char *help; /* Starts with its own help message? */ standard_prolog = list[0].name != OPT_HELP_STR; /* Find the widest help. */ for (o = list; o->name; o++) { if (o->name == OPT_MORE_STR) continue; i = 2 + (int)strlen(o->name); if (o->valtype !=

) i += 1 + strlen(valtype2param(o)); if (i < MAX_OPT_HELP_WIDTH && i > width) width = i; assert(i < (int)sizeof start); } if (standard_prolog) BIO_printf(bio_err, "Usage: %s [options]\nValid options are:\n", prog); /* Now let

(No additional info)



\0

\0

%s %s\n

-flag [param]



-

*

-





\0

%s\n



\0

%s %s\n

0x",

0X",

