Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Internal API, so should not fail

Internal API, so should not fail

Internal API, so should not fail

Internal API, so should not fail

Store the |value| of length |len| at location |data|

Check whether we could fit the value in the assigned number of bytes

Internal helper function used by WPACKET_close(), WPACKET_finish() and WPACKET_fill_lengths() to close a sub-packet and write out its length if necessary. If |doclose| is 0 then it goes through the motions of closing (i.e. it fills in all the lengths), but doesn't actually close anything.

We can't handle this case. Return an error

Deallocate any bytes allocated for the length of the WPACKET

Don't write out the packet length

Write out the WPACKET length if needed

Internal API, so should not fail - but we do negative testing of this so no assert (otherwise the tests fail)

Internal API, so should not fail - but we do negative testing of this so no assert (otherwise the tests fail)

Internal API, so should not fail

Convert to an offset in case the underlying BUF_MEM gets realloc'd

Internal API, so should not fail

Internal API, so should not fail

Find the WPACKET_SUB for the top level

Internal API, so should not fail

Internal API, so should not fail

www.openssl.org/source/license.html

License

internal/cryptlib.h

packet_locl.h

t actually close anything. */ static int wpacket_intern_close(WPACKET *pkt, WPACKET_SUB *sub, int doclose) { size_t packlen = pkt->written - sub->pwritten; if (packlen == 0 && (sub->flags & WPACKET_FLAGS_NON_ZERO_LENGTH) != 0) return 0; if (packlen == 0 && sub->flags & WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH) { /* We can

t write out the packet length */ sub->packet_len = 0; sub->lenbytes = 0; } /* Write out the WPACKET length if needed */ if (sub->lenbytes > 0 && !put_value(&GETBUF(pkt)[sub->packet_len], packlen, sub->lenbytes)) return 0; if (doclose) { pkt->subs = sub->parent; OPENSSL_free(sub); } return 1; } int WPACKET_fill_lengths(WPACKET *pkt) { WPACKET_SUB *sub; if (!ossl_assert(pkt->subs != NULL)) return 0; for (sub = pkt->subs; sub != NULL; sub = sub->parent) { if (!wpacket_intern_close(pkt, sub, 0)) return 0; } return 1; } int WPACKET_close(WPACKET *pkt) { /* * Internal API, so should not fail - but we do negative testing of this * so no assert (otherwise the tests fail) */ if (pkt->subs == NULL || pkt->subs->parent == NULL) return 0; return wpacket_intern_close(pkt, pkt->subs, 1); } int WPACKET_finish(WPACKET *pkt) { int ret; /* * Internal API, so should not fail - but we do negative testing of this * so no assert (otherwise the tests fail) */ if (pkt->subs == NULL || pkt->subs->parent != NULL) return 0; ret = wpacket_intern_close(pkt, pkt->subs, 1); if (ret) { OPENSSL_free(pkt->subs); pkt->subs = NULL; } return ret; } int WPACKET_start_sub_packet_len__(WPACKET *pkt, size_t lenbytes) { WPACKET_SUB *sub; unsigned char *lenchars; /* Internal API, so should not fail */ if (!ossl_assert(pkt->subs != NULL)) return 0; sub = OPENSSL_zalloc(sizeof(*sub)); if (sub == NULL) return 0; sub->parent = pkt->subs; pkt->subs = sub; sub->pwritten = pkt->written + lenbytes; sub->lenbytes = lenbytes; if (lenbytes == 0) { sub->packet_len = 0; return 1; } if (!WPACKET_allocate_bytes(pkt, lenbytes, &lenchars)) return 0; /* Convert to an offset in case the underlying BUF_MEM gets realloc

0xff);

