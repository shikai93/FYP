Copyright 2000-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

from crypto/des/fcrypt.c

arbitrary limit, should be enough for most passwords

use default

If in_stdin is true, we know that infile is NULL, and that bio_open_default() will give us back an alias for stdin.

no passwords on the command line

longer than necessary so that we can warn about truncation

we use the following method to make sure what in the 'else' section is always compiled, to avoid rot of not-frequently-used code.

build a null-terminated list

loop over list of passwords

in != NULL

truncate at newline

ignore rest of line

MD5-based password algorithm (should probably be available as a library function; then the static buffer would not be acceptable). For magic string "1", this should be compatible to the MD5-based BSD password algorithm. For 'magic' string "apr1", this is compatible to the MD5-based Apache password algorithm. (Apparently, the Apache password algorithm is identical except that the 'magic' string was changed -- the laziest application of the NIH principle I've ever encountered.)

"$apr1$..salt..$.......md5hash..........\0"

"apr1" plus '\0'

Max 8 chars plus '\0'

High bit is 1 in EBCDIC alnums

The salt gets truncated to 8 chars

assert it's "1" or "apr1"

assert "$apr1$..salt.."

transform buf into output string

silly output permutation

Unfortunately, this generates a "no effect" warning

SHA based password algorithm, describe by Ulrich Drepper here: https://www.akkadia.org/drepper/SHA-crypt.txt (note that it's in the public domain)

Prefix for optional rounds specification.

Maximum salt string length.

Default number of rounds if not explicitly specified.

Minimum number of rounds.

Maximum number of rounds.

"$6$rounds=<N>$......salt......$...shahash(up to 86 chars)...\0"

Max 16 chars plus '\0'

Default

assert it's "5" or "6"

High bit is 1 in EBCDIC alnums

The salt gets truncated to 16 chars

"rounds=999999999"

In case we're really on a ASCII based platform and just pretend

ASCII 'r'

assert "$5$rounds=999999999$......salt......"

P sequence

S sequence

first make sure we have a salt

!OPENSSL_NO_DES

6 bits

The password encryption funtion will convert back to ASCII

truncate password if necessary

XXX: really we should know how to print a size_t, not cast it

now compute password hash

www.openssl.org/source/license.html

www.akkadia.org/drepper/SHA-crypt.txt

License

apps.h

help

-

Display this summary

in

<

Read passwords from file

noverify

-

Never verify when reading password from terminal

quiet

-

No warnings

table

-

Format output as table

reverse

-

Switch table columns

salt

s

Use provided salt

stdin

-

Read passwords from stdin

6

-

SHA512-based password algorithm

5

-

SHA256-based password algorithm

apr1

-

MD5-based password algorithm, Apache variant

1

-

MD5-based password algorithm

aixmd5

-

AIX MD5-based password algorithm

crypt

-

Standard Unix password algorithm (default)

%s: Use -help for summary.\n

%s: Can't combine -in and -stdin\n

r

password buffer

else

Password:

password required\n

\n

\n

1

magic

apr1

magic

ve ever encountered.) */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) { /* "$apr1$..salt..$.......md5hash..........\0" */ static char out_buf[6 + 9 + 24 + 2]; unsigned char buf[MD5_DIGEST_LENGTH]; char ascii_magic[5]; /* "apr1" plus

*/ char ascii_salt[9]; /* Max 8 chars plus

*/ char *ascii_passwd = NULL; char *salt_out; int n; unsigned int i; EVP_MD_CTX *md = NULL, *md2 = NULL; size_t passwd_len, salt_len, magic_len; passwd_len = strlen(passwd); out_buf[0] = 0; magic_len = strlen(magic); OPENSSL_strlcpy(ascii_magic, magic, sizeof ascii_magic); #ifdef CHARSET_EBCDIC if ((magic[0] & 0x80) != 0) /* High bit is 1 in EBCDIC alnums */ ebcdic2ascii(ascii_magic, ascii_magic, magic_len); #endif /* The salt gets truncated to 8 chars */ OPENSSL_strlcpy(ascii_salt, salt, sizeof ascii_salt); salt_len = strlen(ascii_salt); #ifdef CHARSET_EBCDIC ebcdic2ascii(ascii_salt, ascii_salt, salt_len); #endif #ifdef CHARSET_EBCDIC ascii_passwd = OPENSSL_strdup(passwd); if (ascii_passwd == NULL) return NULL; ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len); passwd = ascii_passwd; #endif if (magic_len > 0) { OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf); if (magic_len > 4) /* assert it

1

apr1

$apr1$..salt..

\0

no * effect

s in the public domain) */ static char *shacrypt(const char *passwd, const char *magic, const char *salt) { /* Prefix for optional rounds specification. */ static const char rounds_prefix[] = "rounds="; /* Maximum salt string length. */ # define SALT_LEN_MAX 16 /* Default number of rounds if not explicitly specified. */ # define ROUNDS_DEFAULT 5000 /* Minimum number of rounds. */ # define ROUNDS_MIN 1000 /* Maximum number of rounds. */ # define ROUNDS_MAX 999999999 /* "$6$rounds=<N>$......salt......$...shahash(up to 86 chars)...\0" */ static char out_buf[3 + 17 + 17 + 86 + 1]; unsigned char buf[SHA512_DIGEST_LENGTH]; unsigned char temp_buf[SHA512_DIGEST_LENGTH]; size_t buf_size = 0; char ascii_magic[2]; char ascii_salt[17]; /* Max 16 chars plus

*/ char *ascii_passwd = NULL; size_t n; EVP_MD_CTX *md = NULL, *md2 = NULL; const EVP_MD *sha = NULL; size_t passwd_len, salt_len, magic_len; unsigned int rounds = 5000; /* Default */ char rounds_custom = 0; char *p_bytes = NULL; char *s_bytes = NULL; char *cp = NULL; passwd_len = strlen(passwd); magic_len = strlen(magic); /* assert it

5

6

5

6

$

rounds=999999999

rounds=%u

re really on a ASCII based platform and just pretend */ if (tmp_buf[0] != 0x72) /* ASCII

*/ ebcdic2ascii(tmp_buf, tmp_buf, strlen(tmp_buf)); #endif OPENSSL_strlcat(out_buf, tmp_buf, sizeof out_buf); OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf); } OPENSSL_strlcat(out_buf, ascii_salt, sizeof out_buf); /* assert "$5$rounds=999999999$......salt......" */ if (strlen(out_buf) > 3 + 17 * rounds_custom + salt_len ) goto err; md = EVP_MD_CTX_new(); if (md == NULL || !EVP_DigestInit_ex(md, sha, NULL) || !EVP_DigestUpdate(md, passwd, passwd_len) || !EVP_DigestUpdate(md, ascii_salt, salt_len)) goto err; md2 = EVP_MD_CTX_new(); if (md2 == NULL || !EVP_DigestInit_ex(md2, sha, NULL) || !EVP_DigestUpdate(md2, passwd, passwd_len) || !EVP_DigestUpdate(md2, ascii_salt, salt_len) || !EVP_DigestUpdate(md2, passwd, passwd_len) || !EVP_DigestFinal_ex(md2, buf, NULL)) goto err; for (n = passwd_len; n > buf_size; n -= buf_size) { if (!EVP_DigestUpdate(md, buf, buf_size)) goto err; } if (!EVP_DigestUpdate(md, buf, n)) goto err; n = passwd_len; while (n) { if (!EVP_DigestUpdate(md, (n & 1) ? buf : (unsigned const char *)passwd, (n & 1) ? buf_size : passwd_len)) goto err; n >>= 1; } if (!EVP_DigestFinal_ex(md, buf, NULL)) return NULL; /* P sequence */ if (!EVP_DigestInit_ex(md2, sha, NULL)) goto err; for (n = passwd_len; n > 0; n--) if (!EVP_DigestUpdate(md2, passwd, passwd_len)) goto err; if (!EVP_DigestFinal_ex(md2, temp_buf, NULL)) return NULL; if ((p_bytes = OPENSSL_zalloc(passwd_len)) == NULL) goto err; for (cp = p_bytes, n = passwd_len; n > buf_size; n -= buf_size, cp += buf_size) memcpy(cp, temp_buf, buf_size); memcpy(cp, temp_buf, n); /* S sequence */ if (!EVP_DigestInit_ex(md2, sha, NULL)) goto err; for (n = 16 + buf[0]; n > 0; n--) if (!EVP_DigestUpdate(md2, ascii_salt, salt_len)) goto err; if (!EVP_DigestFinal_ex(md2, temp_buf, NULL)) return NULL; if ((s_bytes = OPENSSL_zalloc(salt_len)) == NULL) goto err; for (cp = s_bytes, n = salt_len; n > buf_size; n -= buf_size, cp += buf_size) memcpy(cp, temp_buf, buf_size); memcpy(cp, temp_buf, n); for (n = 0; n < rounds; n++) { if (!EVP_DigestInit_ex(md2, sha, NULL)) goto err; if (!EVP_DigestUpdate(md2, (n & 1) ? (unsigned const char *)p_bytes : buf, (n & 1) ? passwd_len : buf_size)) goto err; if (n % 3) { if (!EVP_DigestUpdate(md2, s_bytes, salt_len)) goto err; } if (n % 7) { if (!EVP_DigestUpdate(md2, p_bytes, passwd_len)) goto err; } if (!EVP_DigestUpdate(md2, (n & 1) ? buf : (unsigned const char *)p_bytes, (n & 1) ? buf_size : passwd_len)) goto err; if (!EVP_DigestFinal_ex(md2, buf, NULL)) goto err; } EVP_MD_CTX_free(md2); EVP_MD_CTX_free(md); md2 = NULL; md = NULL; OPENSSL_free(p_bytes); OPENSSL_free(s_bytes); p_bytes = NULL; s_bytes = NULL; cp = out_buf + strlen(out_buf); *cp++ = ascii_dollar[0]; # define b64_from_24bit(B2, B1, B0, N) \ do { \ unsigned int w = ((B2) << 16) | ((B1) << 8) | (B0); \ int i = (N); \ while (i-- > 0) \ { \ *cp++ = cov_2char[w & 0x3f]; \ w >>= 6; \ } \ } while (0) switch (magic[0]) { case

: b64_from_24bit (buf[0], buf[10], buf[20], 4); b64_from_24bit (buf[21], buf[1], buf[11], 4); b64_from_24bit (buf[12], buf[22], buf[2], 4); b64_from_24bit (buf[3], buf[13], buf[23], 4); b64_from_24bit (buf[24], buf[4], buf[14], 4); b64_from_24bit (buf[15], buf[25], buf[5], 4); b64_from_24bit (buf[6], buf[16], buf[26], 4); b64_from_24bit (buf[27], buf[7], buf[17], 4); b64_from_24bit (buf[18], buf[28], buf[8], 4); b64_from_24bit (buf[9], buf[19], buf[29], 4); b64_from_24bit (0, buf[31], buf[30], 3); break; case

: b64_from_24bit (buf[0], buf[21], buf[42], 4); b64_from_24bit (buf[22], buf[43], buf[1], 4); b64_from_24bit (buf[44], buf[2], buf[23], 4); b64_from_24bit (buf[3], buf[24], buf[45], 4); b64_from_24bit (buf[25], buf[46], buf[4], 4); b64_from_24bit (buf[47], buf[5], buf[26], 4); b64_from_24bit (buf[6], buf[27], buf[48], 4); b64_from_24bit (buf[28], buf[49], buf[7], 4); b64_from_24bit (buf[50], buf[8], buf[29], 4); b64_from_24bit (buf[9], buf[30], buf[51], 4); b64_from_24bit (buf[31], buf[52], buf[10], 4); b64_from_24bit (buf[53], buf[11], buf[32], 4); b64_from_24bit (buf[12], buf[33], buf[54], 4); b64_from_24bit (buf[34], buf[55], buf[13], 4); b64_from_24bit (buf[56], buf[14], buf[35], 4); b64_from_24bit (buf[15], buf[36], buf[57], 4); b64_from_24bit (buf[37], buf[58], buf[16], 4); b64_from_24bit (buf[59], buf[17], buf[38], 4); b64_from_24bit (buf[18], buf[39], buf[60], 4); b64_from_24bit (buf[40], buf[61], buf[19], 4); b64_from_24bit (buf[62], buf[20], buf[41], 4); b64_from_24bit (0, 0, buf[63], 2); break; default: goto err; } *cp =

salt buffer

Warning: truncating password to %u characters\n

1

apr1



5

6

%s\t%s\n

%s\t%s\n

%s\n

0x2E,

0x2F,

0x30,

0x31,

0x32,

0x33,

0x34,

0x35,

0x36,

0x37,

0x38,

0x39,

0x41,

0x42,

0x43,

0x44,

0x45,

0x46,

0x47,

0x48,

0x49,

0x4A,

0x4B,

0x4C,

0x4D,

0x4E,

0x4F,

0x50,

0x51,

0x52,

0x53,

0x54,

0x55,

0x56,

0x57,

0x58,

0x59,

0x5A,

0x61,

0x62,

0x63,

0x64,

0x65,

0x66,

0x67,

0x68,

0x69,

0x6A,

0x6B,

0x6C,

0x6D,

0x6E,

0x6F,

0x70,

0x71,

0x72,

0x73,

0x74,

0x75,

0x76,

0x77,

0x78,

0x79,

0x7A

0x24,

0x00

0x80)

0x3f];

0xf)

0x3f];

0x80)

0x72)

0x3f];

0x3f];

