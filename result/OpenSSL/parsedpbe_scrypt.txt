Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Convert from little endian input

Convert output to little endian

Maximum power of two that will fit in uint64_t: this should work on most (all?) platforms.

Maximum value of p r: p <= ((2^32-1) hLen) / MFLen => p <= ((2^32-1) 32) / (128 r) => p r <= (2^30-1)

Maximum permitted memory allow this to be overridden with Configuration option: e.g. -DSCRYPT_MAX_MEM=0 for maximum possible.

Although we could theoretically allocate SIZE_MAX memory that would leave no memory available for anything else so set limit as half that.

Default memory limit: 32 MB

Sanity check parameters

initial check, r,p must be non zero, N >= 2 and a power of 2

Check p r < SCRYPT_PR_MAX avoiding overflow

Need to check N: if 2^(128 r / 8) overflows limit this is automatically satisfied since N <= UINT64_MAX.

Memory checks: check total allocated buffer size fits in uint64_t

B size in section 5 step 1.S Note: we know p 128 r < UINT64_MAX because we already checked p r < SCRYPT_PR_MAX

Check 32 r (N + 2) sizeof(uint32_t) fits in uint64_t and also size_t (their sizes are unrelated). This is combined size V, X and T (section 4)

check total allocated size fits in uint64_t

check total allocated size fits in size_t

If no key return to indicate parameters are OK

www.openssl.org/source/license.html

License

internal/numbers.h

0xff;

0xff;

0xff;

0xff;

