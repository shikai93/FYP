Copyright 2004-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Enable this to print out the complete policy tree at various point during evaluation.

#define OPENSSL_POLICY_DEBUG

Return value: <= 0 on error, or positive bit mask: X509_PCY_TREE_VALID: valid tree X509_PCY_TREE_EMPTY: empty tree (including bare TA case) X509_PCY_TREE_EXPLICIT: explicit policy required

RFC5280 paths omit the TA

Can't do anything with just a trust anchor

First setup the policy cache in all n non-TA certificates, this will be used in X509_verify_cert() which will invoke the verify callback for all certificates with invalid policy extensions.

Call for side-effect of computing hash and caching extensions

If cache is NULL, likely ENOMEM: return immediately

At this point check for invalid policies and required explicit policy. Note that the explicit_policy counter is a count-down to zero, with the requirement kicking in if and once it does that. The counter is decremented for every non-self-issued certificate in the path, but may be further reduced by policy constraints in a non-leaf certificate. The ultimate policy set is the intersection of all the policies along the path, if we hit a certificate with an empty policy set, and explicit policy is required we're done.

All the policies are already cached, we can return early

Access the cache which we now know exists

If we get this far initialize the tree

http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3. The top level is implicitly for the trust anchor with valid expected policies of anyPolicy. (RFC 5280 has the TA at depth 0 and the leaf at depth n, we have the leaf at depth 0 and the TA at depth n).

In this pass initialize all the tree levels and whether anyPolicy and policy mapping are inhibited at each level.

Access the cache which we now know exists

Determine inhibit any and inhibit map flags

Any matching allowed only if certificate is self issued and not the last in the chain.

Return value: 1 on success, 0 otherwise

Iterate through all in nodes linking matches

This corresponds to RFC3280 6.1.3(d)(1): link any data from CertificatePolicies onto matching parent or anyPolicy if no match. Return value: 1 on success, 0 otherwise.

Look for matching nodes in previous level

This corresponds to RFC3280 6.1.3(d)(2): Create new data for any unmatched policies in the parent and link to anyPolicy. Return value: 1 on success, 0 otherwise.

Create a new node with qualifiers from anyPolicy and id from unmatched node.

Curr may not have anyPolicy

Return value: 1 on success, 0 otherwise.

If no policy mapping: matched if one child present

Add it

If mapping: matched if one child per expected policy set

Locate unmatched nodes

Return value: 1 on success, 0 otherwise

Finally add link to anyPolicy

Prune the tree: delete any child mapped child data on the current level then proceed up the tree deleting any data with no children. If we ever have no data on a level we can halt because the tree will be empty. Return value: <= 0 error, otherwise one of: X509_PCY_TREE_VALID: valid tree X509_PCY_TREE_EMPTY: empty tree

Delete any mapped data: see RFC3280 XXXX

If we zapped anyPolicy at top then tree is empty

Return value: 1 on success, 0 otherwise.

Calculate the authority set based on policy tree. The 'pnodes' parameter is used as a store for the set of policy nodes used to calculate the user set. If the authority set is not anyPolicy then pnodes will just point to the authority set. If however the authority set is anyPolicy then the set of valid policies (other than anyPolicy) is store in pnodes. Return value: TREE_CALC_FAILURE on failure, TREE_CALC_OK_NOFREE on success and pnodes need not be freed, TREE_CALC_OK_DOFREE on success and pnodes needs to be freed

If last level contains anyPolicy set is anyPolicy

Add policies to authority set

If no anyPolicy node on this this level it can't appear on lower levels so end search.

Return value: 1 on success, 0 otherwise.

Check if anyPolicy present in authority constrained policy set: this will happen if it is a leaf node.

Create a new node with policy ID from user set and qualifiers from anyPolicy.

Return value: <= 0 error, otherwise one of: X509_PCY_TREE_VALID: valid tree X509_PCY_TREE_EMPTY: empty tree (see tree_prune()).

Application policy checking function. Return codes: X509_PCY_TREE_FAILURE: Failure to satisfy explicit policy X509_PCY_TREE_INVALID: Inconsistent or invalid extensions X509_PCY_TREE_INTERNAL: Internal error, most likely malloc X509_PCY_TREE_VALID: Success (null tree if empty or bare TA)

Tree empty and requireExplicit True: Error

Tree is not empty: continue

www.openssl.org/source/license.html

tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.

License

internal/cryptlib.h

pcy_int.h

Not Mapped\n

Expected:

,

\n

Level print after %s\n

Printing Up to Level %ld\n

Level %ld, flags = %x\n

Flags: %x\n

t do anything with just a trust anchor */ if (n == 0) return X509_PCY_TREE_EMPTY; /* * First setup the policy cache in all n non-TA certificates, this will be * used in X509_verify_cert() which will invoke the verify callback for all * certificates with invalid policy extensions. */ for (i = n - 1; i >= 0; i--) { X509 *x = sk_X509_value(certs, i); /* Call for side-effect of computing hash and caching extensions */ X509_check_purpose(x, -1, 0); /* If cache is NULL, likely ENOMEM: return immediately */ if (policy_cache_set(x) == NULL) return X509_PCY_TREE_INTERNAL; } /* * At this point check for invalid policies and required explicit policy. * Note that the explicit_policy counter is a count-down to zero, with the * requirement kicking in if and once it does that. The counter is * decremented for every non-self-issued certificate in the path, but may * be further reduced by policy constraints in a non-leaf certificate. * * The ultimate policy set is the intersection of all the policies along * the path, if we hit a certificate with an empty policy set, and explicit * policy is required we

pnodes

before tree_prune()

tree_evaluate()

