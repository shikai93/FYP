Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

assume encrypted

assume encrypted

assume encrypted

encrypted RSA data

unknown

if the last one hasn't been pushed yet and there is anything in it then add it to the stack ...

A TJH addition

Check "Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n" fits into buf

now for the fun part ... if we have a private key then we have to be able to handle a not-yet-decrypted key being written out correctly ... if it is decrypted or it is non-encrypted then we use the base code

copy from weirdo names into more normal things

we take the encryption data from the internal stuff rather than what the user has passed us ... as we have to match exactly for some strange reason

Create the right magic header stuff

use the normal code to write things out

Add DSA/DH

normal optionally encrypted stuff

if we have a certificate then write it out now

we are ignoring anything else that is loaded into the X509_INFO structure for the moment ... as I don't need it so I'm not coding it here and Eric can do it when this makes it into the base library --tjh

www.openssl.org/source/license.html

License

internal/cryptlib.h

t been pushed yet and there is anything in it * then add it to the stack ... */ if ((xi->x509 != NULL) || (xi->crl != NULL) || (xi->x_pkey != NULL) || (xi->enc_data != NULL)) { if (!sk_X509_INFO_push(ret, xi)) goto err; xi = NULL; } ok = 1; err: X509_INFO_free(xi); if (!ok) { for (i = 0; ((int)i) < sk_X509_INFO_num(ret); i++) { xi = sk_X509_INFO_value(ret, i); X509_INFO_free(xi); } if (ret != sk) sk_X509_INFO_free(ret); ret = NULL; } OPENSSL_free(name); OPENSSL_free(header); OPENSSL_free(data); return (ret); } /* A TJH addition */ int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u) { int i, ret = 0; unsigned char *data = NULL; const char *objstr = NULL; char buf[PEM_BUFSIZE]; unsigned char *iv = NULL; if (enc != NULL) { objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc)); if (objstr == NULL /* * Check "Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n" * fits into buf */ || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13) > sizeof(buf)) { PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER); goto err; } } /* * now for the fun part ... if we have a private key then we have to be * able to handle a not-yet-decrypted key being written out correctly ... * if it is decrypted or it is non-encrypted then we use the base code */ if (xi->x_pkey != NULL) { if ((xi->enc_data != NULL) && (xi->enc_len > 0)) { if (enc == NULL) { PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO, PEM_R_CIPHER_IS_NULL); goto err; } /* copy from weirdo names into more normal things */ iv = xi->enc_cipher.iv; data = (unsigned char *)xi->enc_data; i = xi->enc_len; /* * we take the encryption data from the internal stuff rather * than what the user has passed us ... as we have to match * exactly for some strange reason */ objstr = OBJ_nid2sn(EVP_CIPHER_nid(xi->enc_cipher.cipher)); if (objstr == NULL) { PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER); goto err; } /* Create the right magic header stuff */ buf[0] =

; PEM_proc_type(buf, PEM_TYPE_ENCRYPTED); PEM_dek_info(buf, objstr, EVP_CIPHER_iv_length(enc), (char *)iv); /* use the normal code to write things out */ i = PEM_write_bio(bp, PEM_STRING_RSA, buf, data, i); if (i <= 0) goto err; } else { /* Add DSA/DH */ #ifndef OPENSSL_NO_RSA /* normal optionally encrypted stuff */ if (PEM_write_bio_RSAPrivateKey(bp, EVP_PKEY_get0_RSA(xi->x_pkey->dec_pkey), enc, kstr, klen, cb, u) <= 0) goto err; #endif } } /* if we have a certificate then write it out now */ if ((xi->x509 != NULL) && (PEM_write_bio_X509(bp, xi->x509) <= 0)) goto err; /* * we are ignoring anything else that is loaded into the X509_INFO * structure for the moment ... as I don

