Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

We assume that w == 0 means decryption, while w == 1 means encryption

Normal matching nm and name

Make PEM_STRING_EVP_PKEY match any private key

NB: ENGINE implementations won't contain a deprecated old private key decode function so don't look for them.

If reading DH parameters handle X9.42 DH format too

Permit older strings

Allow normal certs to be read as trusted certs

Some CAs use PKCS#7 with CERTIFICATE headers

Allow CMS to be read from PKCS#7 headers

Check "Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n" fits into buf

dsize + 8 bytes are needed

actually it needs the cipher block size extra...

Convert the pass phrase from EBCDIC

Generate a salt

The 'iv' is used as the iv and as a salt. It is NOT taken from the BytesToKey function

k=strlen(buf);

EVP_DecryptUpdate etc. take int lengths

Check that we did not truncate the length

Convert the pass phrase from EBCDIC

Squirrel away the length of data decrypted so far.

This implements a very limited PEM header parser that does not support the full grammar of rfc1421. In particular, folded headers are not supported, nor is additional whitespace. A robust implementation would make use of a library that turns the headers into a BIO from which one folded line is read at a time, and is then split into a header label and content. We would then parse the content of the headers we care about. This is overkill for just this limited use-case, but presumably we also parse rfc822-style headers for S/MIME, so a common abstraction might well be more generally useful.

We expect "ENCRYPTED" followed by optional white-space + line break

https://tools.ietf.org/html/rfc1421#section-4.6.1.3 We expect "DEK-Info: algo[,hex-parameters]"

DEK-INFO is a comma-separated combination of algorithm name and optional parameters.

Some helpers for PEM_read_bio_ex().

Strip trailing whitespace

Go back to whitespace before applying uniform line ending.

EVP_DecodeBlock strips leading and trailing whitespace, so just strip control characters in-place and let everything through.

The caller allocated LINESIZE+1, so this is safe.

Note trailing spaces for begin and end.

Need to hold trailing NUL (accounted for by BIO_gets() and the newline that will be added by sanitize_line() (the extra '1').

Strip trailing garbage and standardize ending.

Allow leading empty or non-matching lines.

Keep track of how much of a header we've seen.

Extract the optional PEM header, with details on the type of content and any encryption used on the contents, and the bulk of the data from the bio. The end of the header is marked by a blank line; if the end-of-input marker is reached prior to a blank line, there is no header. The header and data arguments are BIO since we may have to swap them if there is no header, for efficiency. We need the name of the PEM-encoded type to verify the end string.

0 if not seen (yet), 1 if reading header, 2 if finished header

Need to hold trailing NUL (accounted for by BIO_gets() and the newline that will be added by sanitize_line() (the extra '1').

Check for end of header.

Another blank line is an error.

Check for end of stream (which means there is no header).

Malformed input; short line not at end of data.

Else, a line of text -- could be header or data; we don't know yet. Just pass it through.

Only encrypted files need the line length check applied.

65 includes the trailing newline

Read in PEM-formatted data from the given BIO. By nature of the PEM format, all content must be printable ASCII (except for line endings). Other characters, or lines that are longer than 80 characters, are malformed input and will be rejected.

These two are mutually incompatible; bail out.

There was no data in the PEM file; avoid malloc(0).

Check pem string and return prefix length. If for example the pem_str == "RSA PRIVATE KEY" and suffix = "PRIVATE KEY" the return value is 3 for the string "RSA".

www.openssl.org/source/license.html

tools.ietf.org/html/rfc1421#section-4.6.1.3

License

internal/ctype.h

internal/cryptlib.h

internal/asn1_int.h

Enter PEM pass phrase:

phrase is too short, needs to be at least %d chars\n

ENCRYPTED

MIC-CLEAR

MIC-ONLY

BAD-TYPE

Proc-Type: 4,%s\n

DEK-Info: %s,

%02X

\n

PRIVATE KEY

t contain a deprecated old * private key decode function so don

PARAMETERS

Expecting:

Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n

iv

\0

\0

Proc-Type:

ENCRYPTED

DEK-Info:

\0

\n

\t

4

,

\t

ENCRYPTED

\t\r\n

\t\r

\n

DEK-Info: algo[,hex-parameters]

\t

\t,

\0

\t

,

,

-----BEGIN

-----\n

\n

-----END

-----\n



\n

\r

\n

\r



\n

\0

-----BEGIN

-----END

-----\n

1

\0

ve seen. */ enum header_status { MAYBE_HEADER, IN_HEADER, POST_HEADER }; /** * Extract the optional PEM header, with details on the type of content and * any encryption used on the contents, and the bulk of the data from the bio. * The end of the header is marked by a blank line; if the end-of-input marker * is reached prior to a blank line, there is no header. * * The header and data arguments are BIO** since we may have to swap them * if there is no header, for efficiency. * * We need the name of the PEM-encoded type to verify the end string. */ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name, unsigned int flags) { BIO *tmp = *header; char *linebuf, *p; int len, line, ret = 0, end = 0; /* 0 if not seen (yet), 1 if reading header, 2 if finished header */ enum header_status got_header = MAYBE_HEADER; unsigned int flags_mask; size_t namelen; /* Need to hold trailing NUL (accounted for by BIO_gets() and the newline * that will be added by sanitize_line() (the extra

). */ linebuf = pem_malloc(LINESIZE + 1, flags); if (linebuf == NULL) { PEMerr(PEM_F_GET_HEADER_AND_DATA, ERR_R_MALLOC_FAILURE); return 0; } for (line = 0; ; line++) { flags_mask = ~0u; len = BIO_gets(bp, linebuf, LINESIZE); if (len <= 0) { PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_SHORT_HEADER); goto err; } if (got_header == MAYBE_HEADER) { if (memchr(linebuf,

, len) != NULL) got_header = IN_HEADER; } if (!strncmp(linebuf, endstr, ENDLEN) || got_header == IN_HEADER) flags_mask &= ~PEM_FLAG_ONLY_B64; len = sanitize_line(linebuf, len, flags & flags_mask); /* Check for end of header. */ if (linebuf[0] ==

) { if (got_header == POST_HEADER) { /* Another blank line is an error. */ PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE); goto err; } got_header = POST_HEADER; tmp = *data; continue; } /* Check for end of stream (which means there is no header). */ if (strncmp(linebuf, endstr, ENDLEN) == 0) { p = linebuf + ENDLEN; namelen = strlen(name); if (strncmp(p, name, namelen) != 0 || strncmp(p + namelen, tailstr, TAILLEN) != 0) { PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE); goto err; } if (got_header == MAYBE_HEADER) { *header = *data; *data = tmp; } break; } else if (end) { /* Malformed input; short line not at end of data. */ PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE); goto err; } /* * Else, a line of text -- could be header or data; we don

\0

RSA PRIVATE KEY

PRIVATE KEY

RSA



0xff

