Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The content field in the PKCS7 ContentInfo is optional, but that really only applies to inner content (precisely, detached signatures). When reading content, missing outer content is therefore treated as an error. When creating content, PKCS7_content_new() must be called before calling this method, so a NULL p7->d is always an error.

Lets do the pub key stuff :-)

int

p7->d.sign->contents is a PKCS7 structure consisting of a contentType field and optional content. data_body is NULL if that structure has no (=detached) content or if the contentType is wrong (i.e., not "data").

data_body is NULL if the optional EncryptedContent is missing.

data_body is NULL if the optional EncryptedContent is missing.

Detached content must be supplied via in_bio instead.

We will be checking the signature

It was encrypted, we need to decrypt the secret key with the private key

Find the recipientInfo which matches the passed certificate (if any)

If we haven't got a certificate try each ri in turn

Always attempt to decrypt all rinfo even after success as a defence against MMA timing attacks.

Only exit on fatal errors, not decrypt failure

Generate random key as MMA defence

Some S/MIME clients don't use the same key and effective key length. The key length is determined by the size of the decrypted RSA key.

Use random key as MMA defence

Clear errors so we don't leak information useful in MMA

Add signing time if not already present

Add digest

Now sign the attributes

XXXXXXXXXXXXXXXX

XXXXXXXXXXXXXXXX

If detached data then the content is excluded

If detached data then the content is excluded

We now have the EVP_MD_CTX, lets do the signing.

If there are attributes, we add the digest attribute and only sign the attributes

NOTE(emilia): I think we only reach os == NULL here because detached digested data support is broken.

Mark the BIO read only then we can use its copy of the data instead of making an extra copy.

XXXXXXXXXXXXXXXXXXXXXXX

were we able to find the cert in passed to us

Lets verify

Workaround for some broken clients that put the signature OID instead of the digest OID in digest_alg->algorithm

mdc is the digest ctx that we want, unless there are attributes, in which case the digest is the signed attributes

www.openssl.org/source/license.html

License

internal/cryptlib.h

data

t got a certificate try each ri in turn */ if (pcert == NULL) { /* * Always attempt to decrypt all rinfo even after success as a * defence against MMA timing attacks. */ for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) { ri = sk_PKCS7_RECIP_INFO_value(rsk, i); if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } } else { /* Only exit on fatal errors, not decrypt failure */ if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } evp_ctx = NULL; BIO_get_cipher_ctx(etmp, &evp_ctx); if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0) goto err; if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0) goto err; /* Generate random key as MMA defence */ tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx); tkey = OPENSSL_malloc(tkeylen); if (tkey == NULL) goto err; if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0) goto err; if (ek == NULL) { ek = tkey; eklen = tkeylen; tkey = NULL; } if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) { /* * Some S/MIME clients don

