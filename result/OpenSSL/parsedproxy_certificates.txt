In this example, I will use a view of granted rights as a bit array, one bit for each possible right.

The following procedure will create an index for the ex_data store in the X509 validation context the first time it's called. Subsequent calls will return the same index.

Callback to be given to the X509 validation procedure.

It's REALLY important you keep the proxy policy check within this section. It's important to know that when ok is 1, the certificates are checked from top to bottom. You get the CA root first, followed by the possible chain of intermediate CAs, followed by the EE certificate, followed by the possible proxy certificates.

Do whatever you need to grant explicit rights to this particular proxy certificate, usually by pulling them from some database. If there are none to be found, clear all rights (making this and any subsequent proxy certificate void of any rights).

This is basically a NOP, we simply let the current rights stand as they are.

This is usually the most complex section of code. You really do whatever you want as long as you follow RFC 3820. In the example we use here, the simplest thing to do is to build another, temporary bit array and fill it with the rights granted by the current proxy certificate, then use it as a mask on the accumulated rights bit array, and voilà, you now have a new accumulated rights bit array.

process_rights() is supposed to be a procedure that takes a string and it's length, interprets it and sets the bits in the YOUR_RIGHTS pointed at by the third argument.

We have an EE certificate, let's use it to set default!

The following procedure finds out what rights the owner of the current certificate has, and sets them in the YOUR_RIGHTS structure pointed at by the second argument.

www.ietf.org/rfc/rfc3820.txt for more information.

openssl x509

s also possible to specify the proxy extension in a separate section: proxyCertInfo=critical,@proxy_ext [ proxy_ext ] language=id-ppl-anyLanguage pathlen=0 policy=text:BC The policy value has a specific syntax, {syntag}:{string}, where the syntag determines what will be done with the string. The following syntags are recognised: text indicates that the string is simply bytes, without any encoding: policy=text:räksmörgås Previous versions of this design had a specific tag for UTF-8 text. However, since the bytes are copied as-is anyway, there is no need for such a specific tag. hex indicates the string is encoded in hex, with colons between each byte (every second hex digit): policy=hex:72:E4:6B:73:6D:F6:72:67:E5:73 Previous versions of this design had a tag to insert a complete DER blob. However, the only legal use for this would be to surround the bytes that would go with the hex: tag with whatever is needed to construct a correct OCTET STRING. The DER tag therefore felt superfluous, and was removed. file indicates that the text of the policy should really be taken from a file. The string is then really a file name. This is useful for policies that are large (more than a few lines, e.g. XML documents). The

setting can be split up in multiple lines like this: 0.policy=This is 1.policy= a multi- 2.policy=line policy. NOTE: the proxy policy value is the part which determines the rights granted to the process using the proxy certificate. The value is completely dependent on the application reading and interpreting it! Now that you have created an extension section for your proxy certificate, you can easily create a proxy certificate by doing: openssl req -new -config openssl.cnf -out proxy.req -keyout proxy.key openssl x509 -req -CAcreateserial -in proxy.req -days 7 -out proxy.crt \ -CA user.crt -CAkey user.key -extfile openssl.cnf -extensions v3_proxy You can also create a proxy certificate using another proxy certificate as issuer (note: I

s called. * Subsequent calls will return the same index. */ static int get_proxy_auth_ex_data_idx(X509_STORE_CTX *ctx) { static volatile int idx = -1; if (idx < 0) { X509_STORE_lock(X509_STORE_CTX_get0_store(ctx)); if (idx < 0) { idx = X509_STORE_CTX_get_ex_new_index(0, "for verify callback", NULL,NULL,NULL); } X509_STORE_unlock(X509_STORE_CTX_get0_store(ctx)); } return idx; } /* Callback to be given to the X509 validation procedure. */ static int verify_callback(int ok, X509_STORE_CTX *ctx) { if (ok == 1) { /* * It

s important to know * that when ok is 1, the certificates are checked * from top to bottom. You get the CA root first, * followed by the possible chain of intermediate * CAs, followed by the EE certificate, followed by * the possible proxy certificates. */ X509 *xs = X509_STORE_CTX_get_current_cert(ctx); if (X509_get_extension_flags(xs) & EXFLAG_PROXY) { YOUR_RIGHTS *rights = (YOUR_RIGHTS *)X509_STORE_CTX_get_ex_data(ctx, get_proxy_auth_ex_data_idx(ctx)); PROXY_CERT_INFO_EXTENSION *pci = X509_get_ext_d2i(xs, NID_proxyCertInfo, NULL, NULL); switch (OBJ_obj2nid(pci->proxyPolicy->policyLanguage)) { case NID_Independent: /* * Do whatever you need to grant explicit rights to * this particular proxy certificate, usually by * pulling them from some database. If there are none * to be found, clear all rights (making this and any * subsequent proxy certificate void of any rights). */ memset(rights->rights, 0, sizeof(rights->rights)); break; case NID_id_ppl_inheritAll: /* * This is basically a NOP, we simply let the current * rights stand as they are. */ break; default: /* This is usually the most complex section of code. * You really do whatever you want as long as you * follow RFC 3820. In the example we use here, the * simplest thing to do is to build another, temporary * bit array and fill it with the rights granted by * the current proxy certificate, then use it as a * mask on the accumulated rights bit array, and * voilà, you now have a new accumulated rights bit * array. */ { int i; YOUR_RIGHTS tmp_rights; memset(tmp_rights.rights, 0, sizeof(tmp_rights.rights)); /* * process_rights() is supposed to be a procedure * that takes a string and it

