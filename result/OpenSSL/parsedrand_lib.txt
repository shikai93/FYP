Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

non-NULL if default_RAND_meth is ENGINE-provided

IMPORTANT NOTE: It is not currently possible to use this code because we are not sure about the amount of randomness it provides. Some SP900 tests have been run, but there is internal skepticism. So for now this code is not used.

Since we get some randomness from the low-order bits of the high-speec clock, it can help. But don't return a status since it's not sufficient to indicate whether or not the seeding was done.

If RDSEED is available, use that.

Second choice is RDRAND.

DRBG has two sets of callbacks; we only discuss the "entropy" one here. When the DRBG needs additional randomness bits (called entropy in the NIST document), it calls the get_entropy callback which fills in a pointer and returns the number of bytes. When the DRBG is finished with the buffer, it calls the cleanup_entropy callback, with the value of the buffer that the get_entropy callback filled in. Get entropy from the system, via RAND_poll if needed. The |entropy| is the bits of randomness required, and is expected to fit into a buffer of |min_len|..|max__len| size. We assume we're getting high-quality randomness from the system, and that |min_len| bytes will do.

Should not happen. See comment near RANDOMNESS_NEEDED.

If we don't have enough, try to get more.

Get desired amount, but no more than we have.

Update amount left and shift it down.

Should not happen. See comment near RANDOMNESS_NEEDED.

Get random from parent, include our state as additional input.

RAND_poll_ex() gets a function pointer to call when it has random bytes. RAND_poll() sets the function pointer to be a wrapper that calls RAND_add().

If we have an engine that can do RAND, use it.

This function releases any prior ENGINE so call it first

This function is not part of RAND_METHOD, so if we're not using the default method, then just call RAND_bytes(). Otherwise make sure we're instantiated and use the private DRBG.

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/rand_int.h

internal/thread_once.h

rand_lcl.h

RDTSC enabled? Should not be possible!

t return a status since * it

entropy

re getting high-quality * randomness from the system, and that |min_len| bytes will do. */ size_t drbg_entropy_from_system(RAND_DRBG *drbg, unsigned char **pout, int entropy, size_t min_len, size_t max_len) { int i; unsigned char *randomness; if (min_len > (size_t)drbg->size) { /* Should not happen. See comment near RANDOMNESS_NEEDED. */ min_len = drbg->size; } randomness = drbg->secure ? OPENSSL_secure_malloc(drbg->size) : OPENSSL_malloc(drbg->size); /* If we don

re not using * the default method, then just call RAND_bytes(). Otherwise make * sure we

0xFF);

0x10100000L

