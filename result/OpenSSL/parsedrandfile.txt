Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Following should not be needed, and we could have been stricter and demand S_IS. But some systems just don't comply... Formally below macros are "anatomically incorrect", because normally they would look like ((m) & MASK == TYPE), but since MASK availability is as questionable, we settle for this poor-man fallback...

__FILE_ptr32 is a type provided by DEC C headers (types.h specifically) to make sure the FILE is a 32-bit pointer no matter what. We know that stdio functions return this type (a study of stdio.h proves it). This declaration is a nasty hack to get around vms' extension to fopen for passing in sharing options being disabled by /STANDARD=ANSI89

Note that these functions are intended for seed files only. Entropy devices and EGD sockets are handled in rand_unix.c If |bytes| is -1 read the complete file; otherwise read the specified amount.

If given a bytecount, and we did it, break.

Collect enough random data.

chmod(..., 0600) is too late to protect the file, permissions should be restrictive from the start

VMS NOTE: Prior versions of this routine created a _new_ version of the rand file for each call into this routine, then deleted all existing versions named ;-1, and finally renamed the current version as ';1'. Under concurrent usage, this resulted in an RMS race condition in rename() which could orphan files (see vms message help for RMS$_REENT). With the fopen() calls below, openssl/VMS now shares the top-level version of the rand file. Note that there may still be conditions where the top-level rand file is locked. If so, this code will then create a new version of the rand file. Without the delete and rename code, this can result in ascending file versions that stop at version 32767, and this routine will then return an error. The remedy for this is to recode the calling application to avoid concurrent use of the rand file, or synchronize usage at the application level. Also consider whether or not you NEED a persistent rand file in a concurrent use situation.

Yes it's late to do this (see above comment), but better than nothing.

Look up various environment variables.

If we got a value, allocate space to hold it and then get it.

www.openssl.org/source/license.html

License

internal/cryptlib.h

t comply... Formally * below macros are "anatomically incorrect", because normally they * would look like ((m) & MASK == TYPE), but since MASK availability * is as questionable, we settle for this poor-man fallback... */ # if !defined(S_ISREG) # define S_ISREG(m) ((m) & S_IFREG) # endif #ifdef _WIN32 # define stat _stat # define chmod _chmod # define open _open # define fdopen _fdopen #endif #define RAND_FILE_SIZE 1024 #define RFILE ".rnd" #ifdef OPENSSL_SYS_VMS /* * __FILE_ptr32 is a type provided by DEC C headers (types.h specifically) * to make sure the FILE* is a 32-bit pointer no matter what. We know that * stdio functions return this type (a study of stdio.h proves it). * * This declaration is a nasty hack to get around vms

shr=get,put,upd,del

ctx=bin,stm

rfm=stm

rat=none

mrs=0

Filename=

rb

Filename=

Filename=

wb

;1

rb+

wb

Filename=

s late to do this (see above comment), but better than nothing. */ chmod(file, 0600); #endif ret = fwrite(buf, 1, RAND_FILE_SIZE, out); fclose(out); OPENSSL_cleanse(buf, RAND_FILE_SIZE); return ret; } const char *RAND_file_name(char *buf, size_t size) { char *s = NULL; size_t len; int use_randfile = 1; #if defined(_WIN32) && defined(CP_UTF8) DWORD envlen; WCHAR *var; /* Look up various environment variables. */ if ((envlen = GetEnvironmentVariableW(var = L"RANDFILE", NULL, 0)) == 0) { use_randfile = 0; if ((envlen = GetEnvironmentVariableW(var = L"HOME", NULL, 0)) == 0 && (envlen = GetEnvironmentVariableW(var = L"USERPROFILE", NULL, 0)) == 0) envlen = GetEnvironmentVariableW(var = L"SYSTEMROOT", NULL, 0); } /* If we got a value, allocate space to hold it and then get it. */ if (envlen != 0) { int sz; WCHAR *val = _alloca(envlen * sizeof(WCHAR)); if (GetEnvironmentVariableW(var, val, envlen) < envlen && (sz = WideCharToMultiByte(CP_UTF8, 0, val, -1, NULL, 0, NULL, NULL)) != 0) { s = _alloca(sz); if (WideCharToMultiByte(CP_UTF8, 0, val, -1, s, sz, NULL, NULL) == 0) s = NULL; } } #else if (OPENSSL_issetugid() != 0) { use_randfile = 0; } else if ((s = getenv("RANDFILE")) == NULL || *s ==

) { use_randfile = 0; s = getenv("HOME"); } #endif #ifdef DEFAULT_HOME if (!use_randfile && s == NULL) s = DEFAULT_HOME; #endif if (s == NULL || *s ==

/

