Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Private Key BT (Block Type)

pad out with 0xff data

The format is 00 || 01 || PS || 00 || D PS - padding string, at least 8 bytes of FF D - data.

Accept inputs with and without the leading 0-byte.

scan over padding data

one for type.

should decrypt to 0xff

Skip over the '\0'

Public Key BT (Block Type)

pad out with non-zero random data

|em| is the encoded message, zero-padded to exactly |num| bytes

PKCS#1 v1.5 decryption. See "PKCS #1 v2.2: RSA Cryptography Standard", section 7.2.2.

Always do this zero-padding copy (even when num == flen) to avoid leaking that information. The copy still leaks some side-channel information, but it's impossible to have a fixed memory access pattern since we can't read out of the bounds of |from|. TODO(emilia): Consider porting BN_bn2bin_padded from BoringSSL.

PS must be at least 8 bytes long, and it starts two bytes into |em|. If we never found a 0-byte, then |zero_index| is 0 and the check also fails.

Skip the zero byte. This is incorrect if we never found a zero-byte but in this case we also do not copy the message out.

For good measure, do this check in constant time as well; it could leak something if |tlen| was assuming valid padding.

We can't continue in constant-time because we need to copy the result and we cannot fake its length. This unavoidably leaks timing information at the API boundary.

www.openssl.org/source/license.html

License

internal/constant_time_locl.h

internal/cryptlib.h

\0

\0

\0

\0

\0

PKCS #1 v2.2: RSA Cryptography Standard

s impossible to have a fixed memory access * pattern since we can

0xff

0xff,

0x00)

0x01))

0xff)

0xff

