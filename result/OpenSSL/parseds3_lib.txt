Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Copyright 2005 Nokia. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

TLSv1.3 downgrade protection sentinel values

The list of available ciphers, mostly organized into the following groups: Always there EC PSK SRP (within that: RSA EC PSK) Cipher families: Chacha/poly, Camellia, Gost, IDEA, SEED Weak ciphers

OPENSSL_NO_EC

OPENSSL_NO_EC

OPENSSL_NO_PSK

OPENSSL_NO_SRP

OPENSSL_NO_RSA

OPENSSL_NO_EC

OPENSSL_NO_PSK

!defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)

OPENSSL_NO_EC

OPENSSL_NO_PSK

OPENSSL_NO_CAMELLIA

OPENSSL_NO_GOST

OPENSSL_NO_SEED

OPENSSL_NO_EC

OPENSSL_NO_PSK

OPENSSL_NO_WEAK_SSL_CIPHERS

OPENSSL_NO_ARIA

The list of known Signalling Cipher-Suite Value "ciphers", non-valid values stuffed into the ciphers field of the wire protocol for signalling purposes.

2 hours, the 24 hours mentioned in the SSLv3 spec is way too long for http, the cache would over fill

No header in the event of a CCS

Set the content type and 3 bytes for the message len

!OPENSSL_NO_EC

NULL/zero-out everything in the s3 struct

!OPENSSL_NO_EC

No certificate for unauthenticated ciphersuites or using SRP authentication

TODO(TLS1.3): Handle DH groups here

!OPENSSL_NO_EC

A Thawte special :-)

this is not efficient, necessary to optimize this?

This function needs to check if the ciphers required are actually available

ssl3_choose_cipher - choose a cipher from those offered by the client @s: SSL connection @clnt: ciphers offered by the client @srvr: ciphers enabled on the server? Returns the selected cipher or NULL when no common ciphers.

Let's see which ciphers we can support

Do not set the compare functions, because this may lead to a reordering by "id". We want to keep the original ordering. We may pay a price in performance during sk_SSL_CIPHER_find(), but would have to pay with the price of sk_SSL_CIPHER_dup().

Skip ciphers not supported by the protocol version

Since TLS 1.3 ciphersuites can be used with any auth or key exchange scheme skip tests.

with PSK there must be server callback set

OPENSSL_NO_PSK

if we are considering an ECC cipher suite that uses an ephemeral EC key check it

OPENSSL_NO_EC

Check security callback permits this cipher

If we have custom certificate types set, use them

Get mask of algorithms disabled by signature list

!OPENSSL_NO_DH

ECDSA certs can be used with RSA cipher suites too so we don't need to check for SSL_kECDH or SSL_kECDHE

Don't do anything much if we have not done the handshake or we don't want to send messages :-)

our shutdown alert has been sent now, and if it still needs to be written, s->s3->alert_dispatch will be true

return WANT_WRITE

resend it if not sent

we only get to return -1 here the 2nd/Nth invocation, we must have already signalled return 0 upon a previous invocation, return WANT_WRITE

If we are waiting for a close from our peer, we are closed

return WANT_READ

ssl3_read_bytes decided to call s->handshake_func, which called ssl3_read_bytes to read handshake data. However, ssl3_read_bytes actually found application data and thinks that application data makes sense here; so disable handshake processing and try to read application data again.

Check if we are waiting to do a renegotiation and if so whether now is a good time to do it. If |initok| is true then we are being called from inside the state machine so ignore the result of SSL_in_init(s). Otherwise we should not do a renegotiation if SSL_in_init(s) is true. Returns 1 if we should do a renegotiation now and sets up the state machine for it. Otherwise returns 0.

if we are the server, and we have sent a 'RENEGOTIATE' message, we need to set the state machine into the renegotiate state.

If we are using default SHA1+MD5 algorithms switch to new SHA256 PRF and handshake macs if required. If PSK and using SHA384 for TLS < 1.2 switch to default.

Fill a ClientRandom or ServerRandom field of length len. Returns <= 0 on failure, 1 on success.

create PSK premaster_secret

For plain PSK "other_secret" is psklen zeroes

Should never happen

Generate a private key from parameters

Generate a private key a curve ID

Derive secrets for ECDH/DH

If we are resuming then we already generated the early secret when we created the ClientHello, so don't recreate it.

Save premaster secret

www.openssl.org/source/license.html

License

internal/nelem.h

ssl_locl.h

internal/cryptlib.h

GOST2001-GOST89-GOST89

TLS_GOSTR341001_WITH_28147_CNT_IMIT

GOST2001-NULL-GOST94

TLS_GOSTR341001_WITH_NULL_GOSTR3411

GOST2012-GOST8912-GOST8912

GOST2012-NULL-GOST12

ciphers

TLS_EMPTY_RENEGOTIATION_INFO_SCSV

TLS_EMPTY_RENEGOTIATION_INFO_SCSV

TLS_FALLBACK_SCSV

TLS_FALLBACK_SCSV

s see which ciphers we can support */ /* * Do not set the compare functions, because this may lead to a * reordering by "id". We want to keep the original ordering. We may pay * a price in performance during sk_SSL_CIPHER_find(), but would have to * pay with the price of sk_SSL_CIPHER_dup(). */ #ifdef CIPHER_DEBUG fprintf(stderr, "Server has %d from %p:\n", sk_SSL_CIPHER_num(srvr), (void *)srvr); for (i = 0; i < sk_SSL_CIPHER_num(srvr); ++i) { c = sk_SSL_CIPHER_value(srvr, i); fprintf(stderr, "%p:%s\n", (void *)c, c->name); } fprintf(stderr, "Client sent %d from %p:\n", sk_SSL_CIPHER_num(clnt), (void *)clnt); for (i = 0; i < sk_SSL_CIPHER_num(clnt); ++i) { c = sk_SSL_CIPHER_value(clnt, i); fprintf(stderr, "%p:%s\n", (void *)c, c->name); } #endif if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE || tls1_suiteb(s)) { prio = srvr; allow = clnt; } else { prio = clnt; allow = srvr; } if (!SSL_IS_TLS13(s)) { tls1_set_cert_validity(s); ssl_set_masks(s); } for (i = 0; i < sk_SSL_CIPHER_num(prio); i++) { c = sk_SSL_CIPHER_value(prio, i); /* Skip ciphers not supported by the protocol version */ if (!SSL_IS_DTLS(s) && ((s->version < c->min_tls) || (s->version > c->max_tls))) continue; if (SSL_IS_DTLS(s) && (DTLS_VERSION_LT(s->version, c->min_dtls) || DTLS_VERSION_GT(s->version, c->max_dtls))) continue; /* * Since TLS 1.3 ciphersuites can be used with any auth or * key exchange scheme skip tests. */ if (!SSL_IS_TLS13(s)) { mask_k = s->s3->tmp.mask_k; mask_a = s->s3->tmp.mask_a; #ifndef OPENSSL_NO_SRP if (s->srp_ctx.srp_Mask & SSL_kSRP) { mask_k |= SSL_kSRP; mask_a |= SSL_aSRP; } #endif alg_k = c->algorithm_mkey; alg_a = c->algorithm_auth; #ifndef OPENSSL_NO_PSK /* with PSK there must be server callback set */ if ((alg_k & SSL_PSK) && s->psk_server_callback == NULL) continue; #endif /* OPENSSL_NO_PSK */ ok = (alg_k & mask_k) && (alg_a & mask_a); #ifdef CIPHER_DEBUG fprintf(stderr, "%d:[%08lX:%08lX:%08lX:%08lX]%p:%s\n", ok, alg_k, alg_a, mask_k, mask_a, (void *)c, c->name); #endif #ifndef OPENSSL_NO_EC /* * if we are considering an ECC cipher suite that uses an ephemeral * EC key check it */ if (alg_k & SSL_kECDHE) ok = ok && tls1_check_ec_tmp_key(s, c->id); #endif /* OPENSSL_NO_EC */ if (!ok) continue; } ii = sk_SSL_CIPHER_find(allow, c); if (ii >= 0) { /* Check security callback permits this cipher */ if (!ssl_security(s, SSL_SECOP_CIPHER_SHARED, c->strength_bits, 0, (void *)c)) continue; #if !defined(OPENSSL_NO_EC) if ((alg_k & SSL_kECDHE) && (alg_a & SSL_aECDSA) && s->s3->is_probably_safari) { if (!ret) ret = sk_SSL_CIPHER_value(allow, ii); continue; } #endif ret = sk_SSL_CIPHER_value(allow, ii); break; } } return (ret); } int ssl3_get_req_cert_type(SSL *s, WPACKET *pkt) { uint32_t alg_k, alg_a = 0; /* If we have custom certificate types set, use them */ if (s->cert->ctype) return WPACKET_memcpy(pkt, s->cert->ctype, s->cert->ctype_len); /* Get mask of algorithms disabled by signature list */ ssl_set_sig_mask(&alg_a, s, SSL_SECOP_SIGALG_MASK); alg_k = s->s3->tmp.new_cipher->algorithm_mkey; #ifndef OPENSSL_NO_GOST if (s->version >= TLS1_VERSION && (alg_k & SSL_kGOST)) return WPACKET_put_bytes_u8(pkt, TLS_CT_GOST01_SIGN) && WPACKET_put_bytes_u8(pkt, TLS_CT_GOST12_SIGN) && WPACKET_put_bytes_u8(pkt, TLS_CT_GOST12_512_SIGN); #endif if ((s->version == SSL3_VERSION) && (alg_k & SSL_kDHE)) { #ifndef OPENSSL_NO_DH # ifndef OPENSSL_NO_RSA if (!WPACKET_put_bytes_u8(pkt, SSL3_CT_RSA_EPHEMERAL_DH)) return 0; # endif # ifndef OPENSSL_NO_DSA if (!WPACKET_put_bytes_u8(pkt, SSL3_CT_DSS_EPHEMERAL_DH)) return 0; # endif #endif /* !OPENSSL_NO_DH */ } #ifndef OPENSSL_NO_RSA if (!(alg_a & SSL_aRSA) && !WPACKET_put_bytes_u8(pkt, SSL3_CT_RSA_SIGN)) return 0; #endif #ifndef OPENSSL_NO_DSA if (!(alg_a & SSL_aDSS) && !WPACKET_put_bytes_u8(pkt, SSL3_CT_DSS_SIGN)) return 0; #endif #ifndef OPENSSL_NO_EC /* * ECDSA certs can be used with RSA cipher suites too so we don

t do anything much if we have not done the handshake or we don

RENEGOTIATE

other_secret

0x44,

0x4f,

0x57,

0x4e,

0x47,

0x52,

0x44,

0x00

0x44,

0x4f,

0x57,

0x4e,

0x47,

0x52,

0x44,

0x01

0x3000081,

0x3000083,

0x0300ff85,

0x0300ff87,

0xff000000)

0xffff))

0xff)

