Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

callback functions used by s_client, s_server, and s_time

for memcpy() and strcmp()

If we are using DSA, we can copy the parameters from the private key

Now we know that a key and cert have been set against the SSL context

Now we know that a key and cert have been set against the SSL context

If unrecognised print out hex version

TODO(TLS1.3): Get group name here

Use NIST name for curve if it exists

TODO(TLS1.3): Convert for DH groups

Initialize a random secret

Read peer information

Create buffer with peer's address and port

Calculate HMAC of buffer using the secret

Note: we check cookie_initialized because if it's not, it cannot be valid

Example of extended certificate handling. Where the standard support of one certificate per algorithm is not sufficient an application can decide which certificate(s) to use at runtime based on whatever criteria it deems appropriate.

Linked list of certificates, keys and chains

Very basic selection callback: just use any certificate chain reported as valid. More sophisticated could prioritise according to local policy.

Go to end of list and traverse backwards since we prepend newer entries this retains the original order.

NB: we wouldn't normally do this as it is not efficient building chains on each connection better to cache the chain in advance.

If nothing in list, free and set to NULL

Hex encoder for TLSA RRdata, not ':' delimited.

The TLSA data field can be quite long when it is a certificate, public key or even a SHA2-512 digest. Because the initial octets of ASN.1 certificates and public keys contain mostly boilerplate OIDs and lengths, we show the last 12 bytes of the data instead, as these are more likely to distinguish distinct TLSA records.

Verbose print out of security callback

There might be concurrent writers to the keylog file, so we must ensure that the given line is written at once.

Close any open files

Keylogging is disabled, OK.

Append rather than write in order to allow concurrent modification. Furthermore, this preserves existing keylog files which is useful when the tool is run multiple times.

Write a header for seekable, empty files (this excludes pipes).

www.openssl.org/source/license.html

License

apps.h

s_apps.h

depth=%d

\n

<no cert>\n

verify error:num=%d:%s\n

issuer=

\n

notBefore=

\n

notAfter=

\n

verify return:%d\n

unable to get certificate from '%s'\n

unable to get private key from '%s'\n

Private key does not match the certificate public key\n

error setting certificate\n

error setting private key\n

Private key does not match the certificate public key\n

error setting certificate chain\n

error building certificate chain\n

RSA sign

DSA sign

RSA fixed DH

DSS fixed DH

ECDSA sign

RSA fixed ECDH

ECDSA fixed ECDH

GOST01 Sign

Client Certificate Types:

,

UNKNOWN (%d),

\n

RSA

RSA-PSS

DSA

ECDSA

Ed25519

Shared

Requested

Signature Algorithms:

:

%s

0x%02X

+%s

+0x%02X

\n

Peer signing digest: %s\n

Peer signature type: %s\n

Supported Elliptic Curve Point Formats:

:

uncompressed

ansiX962_compressed_prime

ansiX962_compressed_char2

unknown(%d)

\n

groups to print

Supported Elliptic Groups:

:

0x%04X

%s

\n

\nShared Elliptic groups:

:

%s

NONE

\n

Server Temp Key:

RSA, %d bits\n

DH, %d bits\n

ECDH, %s, %d bits\n

%s, %d bits\n

read from %p [%p] (%lu bytes => %ld (0x%lX))\n

write to %p [%p] (%lu bytes => %ld (0x%lX))\n

SSL_connect

SSL_accept

undefined

%s:%s\n

read

write

SSL3 alert %s:%s:%s\n

%s:failed in %s\n

%s:error in %s\n

SSL 3.0

TLS 1.0

TLS 1.1

TLS 1.2

TLS 1.3

DTLS 1.0

DTLS 1.0 (bad)

close_notify

end_of_early_data

unexpected_message

bad_record_mac

decryption_failed

record_overflow

decompression_failure

handshake_failure

bad_certificate

unsupported_certificate

certificate_revoked

certificate_expired

certificate_unknown

illegal_parameter

unknown_ca

access_denied

decode_error

decrypt_error

export_restriction

protocol_version

insufficient_security

internal_error

inappropriate_fallback

user_canceled

no_renegotiation

missing_extension

unsupported_extension

certificate_unobtainable

unrecognized_name

bad_certificate_status_response

bad_certificate_hash_value

unknown_psk_identity

certificate_required

, HelloRequest

, ClientHello

, ServerHello

, HelloVerifyRequest

, NewSessionTicket

, EndOfEarlyData

, HelloRetryRequest

, EncryptedExtensions

, Certificate

, ServerKeyExchange

, CertificateRequest

, ServerHelloDone

, CertificateVerify

, ClientKeyExchange

, Finished

, CertificateUrl

, CertificateStatus

, SupplementalData

, KeyUpdate

, NextProto

, MessageHash

>>>

<<<

???







, ChangeCipherSpec

, Alert

, ???

, warning

, fatal

???

, Handshake

???

???

, ApplicationData

, Heartbeat

, HeartbeatRequest

, HeartbeatResponse

%s %s%s [length %04lx]%s%s\n



\n

%02x

...

\n

server name

max fragment length

client certificate URL

trusted CA keys

truncated HMAC

status request

user mapping

client authz

server authz

cert type

supported_groups

EC point formats

SRP

signature algorithms

use SRTP

heartbeat

session ticket

renegotiation info

signed certificate timestamps

TLS padding

next protocol

encrypt-then-mac

application layer protocol negotiation

extended master secret

key share

supported versions

psk

psk kex modes

certificate authorities

unknown

TLS %s extension \"%s\" (id=%d), len=%d\n

server

client

error setting random cookie secret\n

memory full\n

s address and port */ BIO_ADDR_rawaddress(peer, NULL, &length); OPENSSL_assert(length != 0); port = BIO_ADDR_rawport(peer); length += sizeof(port); buffer = app_malloc(length, "cookie generate buffer"); memcpy(buffer, &port, sizeof(port)); BIO_ADDR_rawaddress(peer, buffer + sizeof(port), NULL); /* Calculate HMAC of buffer using the secret */ HMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH, buffer, length, cookie, cookie_len); OPENSSL_free(buffer); BIO_ADDR_free(peer); return 1; } int verify_cookie_callback(SSL *ssl, const unsigned char *cookie, unsigned int cookie_len) { unsigned char result[EVP_MAX_MD_SIZE]; unsigned int resultlength; /* Note: we check cookie_initialized because if it

Overall Validity

Sign with EE key

EE signature

CA signature

EE key parameters

CA key parameters

Explicitly sign with EE key

Issuer Name

Certificate Type

\t%s: %s\n

OK

NOT OK

\tSuite B:

OK\n

NOT OK\n

not tested\n

Certificate callback retry test: count %d\n

Checking cert chain %d:\nSubject:

\n

t normally do this as it is not efficient * building chains on each connection better to cache the chain * in advance. */ if (exc->build_chain) { if (!SSL_build_cert_chain(ssl, 0)) return 0; } else if (exc->chain != NULL) { SSL_set1_chain(ssl, exc->chain); } } exc = exc->prev; } return 1; } void ssl_ctx_set_excert(SSL_CTX *ctx, SSL_EXCERT *exc) { SSL_CTX_set_cert_cb(ctx, set_cert_cb, exc); } static int ssl_excert_prepend(SSL_EXCERT **pexc) { SSL_EXCERT *exc = app_malloc(sizeof(*exc), "prepend cert"); memset(exc, 0, sizeof(*exc)); exc->next = *pexc; *pexc = exc; if (exc->next) { exc->certform = exc->next->certform; exc->keyform = exc->next->keyform; exc->next->prev = exc; } else { exc->certform = FORMAT_PEM; exc->keyform = FORMAT_PEM; } return 1; } void ssl_excert_free(SSL_EXCERT *exc) { SSL_EXCERT *curr; if (exc == NULL) return; while (exc) { X509_free(exc->cert); EVP_PKEY_free(exc->key); sk_X509_pop_free(exc->chain, X509_free); curr = exc; exc = exc->next; OPENSSL_free(curr); } } int load_excert(SSL_EXCERT **pexc) { SSL_EXCERT *exc = *pexc; if (exc == NULL) return 1; /* If nothing in list, free and set to NULL */ if (exc->certfile == NULL && exc->next == NULL) { ssl_excert_free(exc); *pexc = NULL; return 1; } for (; exc; exc = exc->next) { if (exc->certfile == NULL) { BIO_printf(bio_err, "Missing filename\n"); return 0; } exc->cert = load_cert(exc->certfile, exc->certform, "Server Certificate"); if (exc->cert == NULL) return 0; if (exc->keyfile != NULL) { exc->key = load_key(exc->keyfile, exc->keyform, 0, NULL, NULL, "Server Key"); } else { exc->key = load_key(exc->certfile, exc->certform, 0, NULL, NULL, "Server Key"); } if (exc->key == NULL) return 0; if (exc->chainfile != NULL) { if (!load_certs(exc->chainfile, &exc->chain, FORMAT_PEM, NULL, "Server Chain")) return 0; } } return 1; } enum range { OPT_X_ENUM }; int args_excert(int opt, SSL_EXCERT **pexc) { SSL_EXCERT *exc = *pexc; assert(opt > OPT_X__FIRST); assert(opt < OPT_X__LAST); if (exc == NULL) { if (!ssl_excert_prepend(&exc)) { BIO_printf(bio_err, " %s: Error initialising xcert\n", opt_getprog()); goto err; } *pexc = exc; } switch ((enum range)opt) { case OPT_X__FIRST: case OPT_X__LAST: return 0; case OPT_X_CERT: if (exc->certfile != NULL && !ssl_excert_prepend(&exc)) { BIO_printf(bio_err, "%s: Error adding xcert\n", opt_getprog()); goto err; } *pexc = exc; exc->certfile = opt_arg(); break; case OPT_X_KEY: if (exc->keyfile != NULL) { BIO_printf(bio_err, "%s: Key already specified\n", opt_getprog()); goto err; } exc->keyfile = opt_arg(); break; case OPT_X_CHAIN: if (exc->chainfile != NULL) { BIO_printf(bio_err, "%s: Chain already specified\n", opt_getprog()); goto err; } exc->chainfile = opt_arg(); break; case OPT_X_CHAIN_BUILD: exc->build_chain = 1; break; case OPT_X_CERTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &exc->certform)) return 0; break; case OPT_X_KEYFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &exc->keyform)) return 0; break; } return 1; err: ERR_print_errors(bio_err); ssl_excert_free(exc); *pexc = NULL; return 0; } static void print_raw_cipherlist(SSL *s) { const unsigned char *rlist; static const unsigned char scsv_id[] = { 0, 0xFF }; size_t i, rlistlen, num; if (!SSL_is_server(s)) return; num = SSL_get0_raw_cipherlist(s, NULL); OPENSSL_assert(num == 2); rlistlen = SSL_get0_raw_cipherlist(s, &rlist); BIO_puts(bio_err, "Client cipher list: "); for (i = 0; i < rlistlen; i += num, rlist += num) { const SSL_CIPHER *c = SSL_CIPHER_find(s, rlist); if (i) BIO_puts(bio_err, ":"); if (c != NULL) { BIO_puts(bio_err, SSL_CIPHER_get_name(c)); } else if (memcmp(rlist, scsv_id, num) == 0) { BIO_puts(bio_err, "SCSV"); } else { size_t j; BIO_puts(bio_err, "0x"); for (j = 0; j < num; j++) BIO_printf(bio_err, "%02X", rlist[j]); } } BIO_puts(bio_err, "\n"); } /* * Hex encoder for TLSA RRdata, not

delimited. */ static char *hexencode(const unsigned char *data, size_t len) { static const char *hex = "0123456789abcdef"; char *out; char *cp; size_t outlen = 2 * len + 1; int ilen = (int) outlen; if (outlen < len || ilen < 0 || outlen != (size_t)ilen) { BIO_printf(bio_err, "%s: %zu-byte buffer too large to hexencode\n", opt_getprog(), len); exit(1); } cp = out = app_malloc(ilen, "TLSA hex data buffer"); while (len-- > 0) { *cp++ = hex[(*data >> 4) & 0x0f]; *cp++ = hex[*data++ & 0x0f]; } *cp =

Verification: OK\n

Verified peername: %s\n

Verification error: %s\n

DANE TLSA %d %d %d %s%s %s at depth %d\n

...



signed the certificate

matched TA certificate

matched EE certificate

Protocol version: %s\n

Ciphersuite: %s\n

Peer certificate:

\n

Hash used: %s\n

Signature type: %s\n

No peer certificate\n

Error with command: \"%s %s\"\n

Error with command: \"%s\"\n

Error finishing context\n

Supported Ciphersuite

Shared Ciphersuite

Check Ciphersuite

Temp DH key bits

Supported Curve

Shared Curve

Check Curve

Supported Signature Algorithm digest

Shared Signature Algorithm digest

Check Signature Algorithm digest

Signature Algorithm mask

Certificate chain EE key

Certificate chain CA key

Peer Chain EE key

Peer Chain CA key

Certificate chain CA digest

Peer chain CA digest

SSL compression

Session ticket

Security callback:

Version=%s

???

%s=

%d



%s, bits=%d

anonymous

RSA

DSA

ECDSA

, algorithm=%s

, algid=%d

, security bits=%d

: %s\n

yes

no

Keylog callback is invoked without valid file!\n

%s\n

a

Error writing keylog file %s\n

# SSL/TLS secrets log file, generated by OpenSSL\n

server

client

---\nNo %s certificate CA names sent\n

---\nAcceptable %s certificate CA names\n

\n

0x%02X",

0x%02X",

0x%04X",

0xFFFF);

0x%lX))\n",

0x%lX))\n",

0xFF

0x");

0x0f];

0x0f];

