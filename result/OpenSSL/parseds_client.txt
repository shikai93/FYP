Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright 2005 Nokia. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

With IPv6, it looks like Digital has mixed up the proper order of recursive header file inclusion, resulting in the compiler complaining that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which is needed to have fileno() declared correctly... So let's define u_int

We only do unidirectional shutdown

We just do busy waiting. Nothing clever

Default PSK identity and key

no ServerKeyExchange message

lookup PSK identity and PSK key based on the given identity hint here

convert the PSK key to binary

Doesn't look like a suitable TLSv1.3 key. Ignore it

PSK not usable, ignore it

This is a context that we pass to callbacks

This is a context that we pass to all callbacks

copy from c_msg

copy from c_debug

allow more groups

minimal size for N

p = (N-1)/2

verify g^((N-1)/2) == -1 (mod N)

This callback is used here for two purposes: - extended debugging - making some primality tests for unknown groups The callback is only called for a non default group. An application does not need the call back at all if only the standard groups are used. In real life situations, client and server already share well known groups, thus there is no need to verify them. Furthermore, in case that a server actually proposes a group that is not one of those defined in RFC 5054, it is more appropriate to add the group to a static list and then compare since primality tests are rather cpu consuming.

The srp_moregroups is a real debugging feature. Implementors should rather add the value to the known ones. The minimal size has already been tested.

This the context that we pass to next_proto_cb

We can assume that |in| is syntactically valid.

ndef OPENSSL_NO_NEXTPROTONEG

Reconstruct the type/len fields prior to extension data

Hex decoder that tolerates optional whitespace. Returns number of bytes produced, advances inptr to end of input string.

Decode unsigned 0..255, returns 1 on success, <= 0 on failure. Advances inptr to next field skipping leading whitespace.

Not necessary to re-init these values; the "parsers" do that.

Returns number of bytes produced, advances cp to next field

The data field is last, so len is its length

Free |dest| and optionally set it to a copy of |source|.

We always return a "fail" response so that the session gets freed again because we haven't used the reference.

Known false-positive of MemorySanitizer.

Check for intermixing flags.

If there's a positional argument, it's the equivalent of OPT_CONNECT. Don't allow -connect and a separate argument.

SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol

Returns 0 on success!

Returns 0 on success!

Enable SCT processing, without early connection termination

If CT validation is not enabled, the log list isn't needed so don't show errors or abort. We try to load it regardless because then we can show the names of the logs any SCTs came from (SCTs may be seen even with validation disabled).

In TLSv1.3 NewSessionTicket messages arrive after the handshake and can come at any time. Therefore we use a callback to write out the session when we know about it. This approach works for < TLSv1.3 as well.

want to do MTU discovery

OPENSSL_NO_DTLS

ok, lets connect

This is an ugly hack that does a lot of assumptions. We do have to handle multi-line responses which may come in a single packet or not. We therefore have to use BIO_gets() which does need a buffering BIO. So during the initial chitchat we do push a buffering BIO into the chain that is removed again later on to not disturb the rest of the s_client operation.

Wait for multi-line response to end from LMTP or SMTP

Wait for multi-line response to end LHLO LMTP or EHLO SMTP response.

STARTTLS command requires CAPABILITY...

wait for multi-line CAPABILITY response

wait for multi-line response to end from FTP

IAC DO START_TLS

IAC WILL START_TLS

IAC SB START_TLS FOLLOWS IAC SE

Telnet server should demand we issue START_TLS

Agree to issue START_TLS and send the FOLLOWS sub-command

Telnet server also sent the FOLLOWS sub-command

Wrong protocol, not even HTTP

CONNECT failed

The first line is the HTTP response. According to RFC 7230, it's formated exactly like this: HTTP/d.d ddd Reason text\r\n

Read past all following headers

If the IRCd doesn't respond within S_CLIENT_IRC_READ_TIMEOUT seconds, assume it doesn't support STARTTLS. Many IRCds will not give _any_ sort of response to a STARTTLS command when it's not supported.

:example.net 451 STARTTLS :You have not registered

:example.net 421 STARTTLS :Unknown command

SSL request packet

payload_length, sequence_id

payload

capability flags, CLIENT_SSL always set

max-packet size

character set

string[23] reserved (all [0])

Receiving Initial Handshake packet.

Packet length[3], Packet number[1] + minimum payload[17]

protocol version[1]

server version[string+NULL]

make sure we have at least 15 bytes left in the packet

skip over conn id[4] + SALT[8]

verify filler

capability flags[2]

Sending SSL Handshake packet.

Length SSLRequest

Send SSLRequest packet

Reply will be a single S if SSL is enabled

STARTTLS command requires CAPABILITIES...

wait for multi-line CAPABILITIES response

wait for multi-line response to end from Sieve

According to RFC 5804 ยง 1.7, capability is case-insensitive, make it uppercase

According to RFC 5804 ยง 2.2, response codes are case- insensitive, make it uppercase but preserve the response.

StartTLS Operation according to RFC 4511

Send SSLRequest packet

Just keep trying - busy waiting

We don't need to know any more

Note that select() returns when read _would not block_, and EOF satisfies that. To avoid a CPU-hogging loop, set the flag so we exit.

Note: under VMS with SOCKETSHR the second parameter is currently of type (int ) whereas under other systems it is (void ) if you don't have a cast it will choke the compiler: if you do have a cast then you can either go for (int ) or (void ).

Under Windows/DOS we make the assumption that we can always write to the tty: therefore if we need to write to the tty we just fall through. Otherwise we timeout the select every second and see if there are any keypresses. Note: this is a hack, in a proper Windows application we wouldn't do this.

we have done a write(con,NULL,0);

if (cbuf_len > 0)

This shouldn't ever happen in s_client - treat as an error

Assume Windows/DOS/BeOS can always write

BUFSIZZ

This shouldn't ever happen in s_client. Treat as an error

OPENSSL_SYS_MSDOS includes OPENSSL_SYS_WINDOWS

both loops are skipped when i <= 0

Give the socket time to send its last data before we close it. No amount of setting SO_LINGER etc on the socket seems to persuade Windows to send the data before closing the socket...but sleeping for a short time seems to do it (units in ms) TODO: Find a better way to do this

Redundant if we showed the whole chain

When the SSL session is anonymous, or resumed via an abbreviated handshake, no SCTs are provided as part of the handshake. While in a resumed session SCTs may be present in the session's certificate, no callbacks are invoked to revalidate these, and in any case that set of SCTs may be incomplete. Thus it makes little sense to attempt to display SCTs from a resumed session's certificate, and of course none are associated with an anonymous peer.

Print out local port of connection: useful for debugging

flush, or debugging output gets mixed with http response

From RFC 4511: LDAPMessage ::= SEQUENCE { messageID MessageID, protocolOp CHOICE { ... extendedResp ExtendedResponse, ... }, controls [0] Controls OPTIONAL } ExtendedResponse ::= [APPLICATION 24] SEQUENCE { COMPONENTS OF LDAPResult, responseName [10] LDAPOID OPTIONAL, responseValue [11] OCTET STRING OPTIONAL } LDAPResult ::= SEQUENCE { resultCode ENUMERATED { success (0), ... other (80), ... }, matchedDN LDAPDN, diagnosticMessage LDAPString, referral [3] Referral OPTIONAL }

pull SEQUENCE

ensure that we don't overstep the SEQUENCE

pull MessageID

shall we check for MessageId match or just skip?

pull [APPLICATION 24]

pull resultCode

len should always be one, but just in case...

There is more data, but we don't care...

OPENSSL_NO_SOCK

www.openssl.org/source/license.html

etherx.jabber.org/streams' "

License

e_os.h

t defined, but only if _POSIX_C_SOURCE is defined, which is * needed to have fileno() declared correctly... So let

apps.h

s_apps.h

timeouts.h

internal/sockets.h

Client_identity

psk_client_cb\n

NULL received PSK identity hint, continuing anyway\n

Received PSK identity hint '%s'\n

%s

created identity '%s' len=%d\n

Could not convert PSK key '%s' to buffer\n

psk buffer of callback is too small (%d) for key (%ld)\n

created PSK len=%ld\n

Error in PSK client callback\n

Could not convert PSK key '%s' to buffer\n

t look like a suitable TLSv1.3 key. Ignore it */ OPENSSL_free(key); *id = NULL; *idlen = 0; *sess = NULL; return 0; } usesess = SSL_SESSION_new(); if (usesess == NULL || !SSL_SESSION_set1_master_key(usesess, key, key_len) || !SSL_SESSION_set_cipher(usesess, cipher) || !SSL_SESSION_set_protocol_version(usesess, TLS1_3_VERSION)) { OPENSSL_free(key); goto err; } OPENSSL_free(key); } cipher = SSL_SESSION_get0_cipher(usesess); if (cipher == NULL) goto err; if (md != NULL && SSL_CIPHER_get_handshake_digest(cipher) != md) { /* PSK not usable, ignore it */ *id = NULL; *idlen = 0; *sess = NULL; SSL_SESSION_free(usesess); } else { *sess = usesess; *id = (unsigned char *)psk_identity; *idlen = strlen(psk_identity); } return 1; err: SSL_SESSION_free(usesess); return 0; } /* This is a context that we pass to callbacks */ typedef struct tlsextctx_st { BIO *biodebug; int ack; } tlsextctx; static int ssl_servername_cb(SSL *s, int *ad, void *arg) { tlsextctx *p = (tlsextctx *) arg; const char *hn = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name); if (SSL_get_servername_type(s) != -1) p->ack = !SSL_session_reused(s) && hn != NULL; else BIO_printf(bio_err, "Can

); return SSL_TLSEXT_ERR_OK; } #ifndef OPENSSL_NO_SRP /* This is a context that we pass to all callbacks */ typedef struct srp_arg_st { char *srppassin; char *srplogin; int msg; /* copy from c_msg */ int debug; /* copy from c_debug */ int amp; /* allow more groups */ int strength; /* minimal size for N */ } SRP_ARG; # define SRP_NUMBER_ITERATIONS_FOR_PRIME 64 static int srp_Verify_N_and_g(const BIGNUM *N, const BIGNUM *g) { BN_CTX *bn_ctx = BN_CTX_new(); BIGNUM *p = BN_new(); BIGNUM *r = BN_new(); int ret = g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) && BN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) == 1 && p != NULL && BN_rshift1(p, N) && /* p = (N-1)/2 */ BN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) == 1 && r != NULL && /* verify g^((N-1)/2) == -1 (mod N) */ BN_mod_exp(r, g, p, N, bn_ctx) && BN_add_word(r, 1) && BN_cmp(r, N) == 0; BN_free(r); BN_free(p); BN_CTX_free(bn_ctx); return ret; } /*- * This callback is used here for two purposes: * - extended debugging * - making some primality tests for unknown groups * The callback is only called for a non default group. * * An application does not need the call back at all if * only the standard groups are used. In real life situations, * client and server already share well known groups, * thus there is no need to verify them. * Furthermore, in case that a server actually proposes a group that * is not one of those defined in RFC 5054, it is more appropriate * to add the group to a static list and then compare since * primality tests are rather cpu consuming. */ static int ssl_srp_verify_param_cb(SSL *s, void *arg) { SRP_ARG *srp_arg = (SRP_ARG *)arg; BIGNUM *N = NULL, *g = NULL; if (((N = SSL_get_srp_N(s)) == NULL) || ((g = SSL_get_srp_g(s)) == NULL)) return 0; if (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1) { BIO_printf(bio_err,

); BIO_printf(bio_err,

); BN_print(bio_err, N); BIO_printf(bio_err,

); BN_print(bio_err, g); BIO_printf(bio_err,

); } if (SRP_check_known_gN_param(g, N)) return 1; if (srp_arg->amp == 1) { if (srp_arg->debug) BIO_printf(bio_err,

); /* * The srp_moregroups is a real debugging feature. Implementors * should rather add the value to the known ones. The minimal size * has already been tested. */ if (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N, g)) return 1; } BIO_printf(bio_err,

); return 0; } # define PWD_STRLEN 1024 static char *ssl_give_srp_client_pwd_cb(SSL *s, void *arg) { SRP_ARG *srp_arg = (SRP_ARG *)arg; char *pass = app_malloc(PWD_STRLEN + 1,

); PW_CB_DATA cb_tmp; int l; cb_tmp.password = (char *)srp_arg->srppassin; cb_tmp.prompt_info =

; if ((l = password_callback(pass, PWD_STRLEN, 0, &cb_tmp)) < 0) { BIO_printf(bio_err,

t read Password\n"); OPENSSL_free(pass); return NULL; } *(pass + l) =

; return pass; } #endif static char *srtp_profiles = NULL; #ifndef OPENSSL_NO_NEXTPROTONEG /* This the context that we pass to next_proto_cb */ typedef struct tlsextnextprotoctx_st { unsigned char *data; size_t len; int status; } tlsextnextprotoctx; static tlsextnextprotoctx next_proto; static int next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg) { tlsextnextprotoctx *ctx = arg; if (!c_quiet) { /* We can assume that |in| is syntactically valid. */ unsigned i; BIO_printf(bio_c_out, "Protocols advertised by server: "); for (i = 0; i < inlen;) { if (i) BIO_write(bio_c_out, ", ", 2); BIO_write(bio_c_out, &in[i + 1], in[i]); i += in[i] + 1; } BIO_write(bio_c_out, "\n", 1); } ctx->status = SSL_select_next_proto(out, outlen, in, inlen, ctx->data, ctx->len); return SSL_TLSEXT_ERR_OK; } #endif /* ndef OPENSSL_NO_NEXTPROTONEG */ static int serverinfo_cli_parse_cb(SSL *s, unsigned int ext_type, const unsigned char *in, size_t inlen, int *al, void *arg) { char pem_name[100]; unsigned char ext_buf[4 + 65536]; /* Reconstruct the type/len fields prior to extension data */ ext_buf[0] = ext_type >> 8; ext_buf[1] = ext_type & 0xFF; ext_buf[2] = inlen >> 8; ext_buf[3] = inlen & 0xFF; memcpy(ext_buf + 4, in, inlen); BIO_snprintf(pem_name, sizeof(pem_name), "SERVERINFO FOR EXTENSION %d", ext_type); PEM_write_bio(bio_c_out, pem_name, "", ext_buf, 4 + inlen); return 1; } /* * Hex decoder that tolerates optional whitespace. Returns number of bytes * produced, advances inptr to end of input string. */ static ossl_ssize_t hexdecode(const char **inptr, void *result) { unsigned char **out = (unsigned char **)result; const char *in = *inptr; unsigned char *ret = app_malloc(strlen(in) / 2, "hexdecode"); unsigned char *cp = ret; uint8_t byte; int nibble = 0; if (ret == NULL) return -1; for (byte = 0; *in; ++in) { int x; if (isspace(_UC(*in))) continue; x = OPENSSL_hexchar2int(*in); if (x < 0) { OPENSSL_free(ret); return 0; } byte |= (char)x; if ((nibble ^= 1) == 0) { *cp++ = byte; byte = 0; } else { byte <<= 4; } } if (nibble != 0) { OPENSSL_free(ret); return 0; } *inptr = in; return cp - (*out = ret); } /* * Decode unsigned 0..255, returns 1 on success, <= 0 on failure. Advances * inptr to next field skipping leading whitespace. */ static ossl_ssize_t checked_uint8(const char **inptr, void *out) { uint8_t *result = (uint8_t *)out; const char *in = *inptr; char *endp; long v; int e; save_errno(); v = strtol(in, &endp, 10); e = restore_errno(); if (((v == LONG_MIN || v == LONG_MAX) && e == ERANGE) || endp == in || !isspace(_UC(*endp)) || v != (*result = (uint8_t) v)) { return -1; } for (in = endp; isspace(_UC(*in)); ++in) continue; *inptr = in; return 1; } struct tlsa_field { void *var; const char *name; ossl_ssize_t (*parser)(const char **, void *); }; static int tlsa_import_rr(SSL *con, const char *rrdata) { /* Not necessary to re-init these values; the "parsers" do that. */ static uint8_t usage; static uint8_t selector; static uint8_t mtype; static unsigned char *data; static struct tlsa_field tlsa_fields[] = { { &usage, "usage", checked_uint8 }, { &selector, "selector", checked_uint8 }, { &mtype, "mtype", checked_uint8 }, { &data, "data", hexdecode }, { NULL, } }; struct tlsa_field *f; int ret; const char *cp = rrdata; ossl_ssize_t len = 0; for (f = tlsa_fields; f->var; ++f) { /* Returns number of bytes produced, advances cp to next field */ if ((len = f->parser(&cp, f->var)) <= 0) { BIO_printf(bio_err, "%s: warning: bad TLSA %s field in: %s\n", prog, f->name, rrdata); return 0; } } /* The data field is last, so len is its length */ ret = SSL_dane_tlsa_add(con, usage, selector, mtype, data, len); OPENSSL_free(data); if (ret == 0) { ERR_print_errors(bio_err); BIO_printf(bio_err, "%s: warning: unusable TLSA rrdata: %s\n", prog, rrdata); return 0; } if (ret < 0) { ERR_print_errors(bio_err); BIO_printf(bio_err, "%s: warning: error loading TLSA rrdata: %s\n", prog, rrdata); return 0; } return ret; } static int tlsa_import_rrset(SSL *con, STACK_OF(OPENSSL_STRING) *rrset) { int num = sk_OPENSSL_STRING_num(rrset); int count = 0; int i; for (i = 0; i < num; ++i) { char *rrdata = sk_OPENSSL_STRING_value(rrset, i); if (tlsa_import_rr(con, rrdata) > 0) ++count; } return count > 0; } typedef enum OPTION_choice { OPT_ERR = -1, OPT_EOF = 0, OPT_HELP, OPT_4, OPT_6, OPT_HOST, OPT_PORT, OPT_CONNECT, OPT_UNIX, OPT_XMPPHOST, OPT_VERIFY, OPT_NAMEOPT, OPT_CERT, OPT_CRL, OPT_CRL_DOWNLOAD, OPT_SESS_OUT, OPT_SESS_IN, OPT_CERTFORM, OPT_CRLFORM, OPT_VERIFY_RET_ERROR, OPT_VERIFY_QUIET, OPT_BRIEF, OPT_PREXIT, OPT_CRLF, OPT_QUIET, OPT_NBIO, OPT_SSL_CLIENT_ENGINE, OPT_IGN_EOF, OPT_NO_IGN_EOF, OPT_DEBUG, OPT_TLSEXTDEBUG, OPT_STATUS, OPT_WDEBUG, OPT_MSG, OPT_MSGFILE, OPT_ENGINE, OPT_TRACE, OPT_SECURITY_DEBUG, OPT_SECURITY_DEBUG_VERBOSE, OPT_SHOWCERTS, OPT_NBIO_TEST, OPT_STATE, OPT_PSK_IDENTITY, OPT_PSK, OPT_PSK_SESS, #ifndef OPENSSL_NO_SRP OPT_SRPUSER, OPT_SRPPASS, OPT_SRP_STRENGTH, OPT_SRP_LATEUSER, OPT_SRP_MOREGROUPS, #endif OPT_SSL3, OPT_SSL_CONFIG, OPT_TLS1_3, OPT_TLS1_2, OPT_TLS1_1, OPT_TLS1, OPT_DTLS, OPT_DTLS1, OPT_DTLS1_2, OPT_SCTP, OPT_TIMEOUT, OPT_MTU, OPT_KEYFORM, OPT_PASS, OPT_CERT_CHAIN, OPT_CAPATH, OPT_NOCAPATH, OPT_CHAINCAPATH, OPT_VERIFYCAPATH, OPT_KEY, OPT_RECONNECT, OPT_BUILD_CHAIN, OPT_CAFILE, OPT_NOCAFILE, OPT_CHAINCAFILE, OPT_VERIFYCAFILE, OPT_NEXTPROTONEG, OPT_ALPN, OPT_SERVERINFO, OPT_STARTTLS, OPT_SERVERNAME, OPT_NOSERVERNAME, OPT_ASYNC, OPT_USE_SRTP, OPT_KEYMATEXPORT, OPT_KEYMATEXPORTLEN, OPT_SMTPHOST, OPT_MAX_SEND_FRAG, OPT_SPLIT_SEND_FRAG, OPT_MAX_PIPELINES, OPT_READ_BUF, OPT_KEYLOG_FILE, OPT_EARLY_DATA, OPT_REQCAFILE, OPT_V_ENUM, OPT_X_ENUM, OPT_S_ENUM, OPT_FALLBACKSCSV, OPT_NOCMDS, OPT_PROXY, OPT_DANE_TLSA_DOMAIN, #ifndef OPENSSL_NO_CT OPT_CT, OPT_NOCT, OPT_CTLOG_FILE, #endif OPT_DANE_TLSA_RRDATA, OPT_DANE_EE_NO_NAME, OPT_R_ENUM } OPTION_CHOICE; const OPTIONS s_client_options[] = { {"help", OPT_HELP,

, "Display this summary"}, {"host", OPT_HOST,

, "Use -connect instead"}, {"port", OPT_PORT,

, "Use -connect instead"}, {"connect", OPT_CONNECT,

, "TCP/IP where to connect (default is :" PORT ")"}, {"proxy", OPT_PROXY,

, "Connect to via specified proxy to the real server"}, #ifdef AF_UNIX {"unix", OPT_UNIX,

, "Connect over the specified Unix-domain socket"}, #endif {"4", OPT_4,

, "Use IPv4 only"}, #ifdef AF_INET6 {"6", OPT_6,

, "Use IPv6 only"}, #endif {"verify", OPT_VERIFY,

, "Turn on peer certificate verification"}, {"cert", OPT_CERT,

, "Certificate file to use, PEM format assumed"}, {"certform", OPT_CERTFORM,

, "Certificate format (PEM or DER) PEM default"}, {"nameopt", OPT_NAMEOPT,

, "Various certificate name options"}, {"key", OPT_KEY,

, "Private key file to use, if not in -cert file"}, {"keyform", OPT_KEYFORM,

, "Key format (PEM, DER or engine) PEM default"}, {"pass", OPT_PASS,

, "Private key file pass phrase source"}, {"CApath", OPT_CAPATH,

, "PEM format directory of CA

}, {

, OPT_CAFILE, '<',

s"}, {"no-CAfile", OPT_NOCAFILE,

, "Do not load the default certificates file"}, {"no-CApath", OPT_NOCAPATH,

, "Do not load certificates from the default certificates directory"}, {"requestCAfile", OPT_REQCAFILE,

, "PEM format file of CA names to send to the server"}, {"dane_tlsa_domain", OPT_DANE_TLSA_DOMAIN,

, "DANE TLSA base domain"}, {"dane_tlsa_rrdata", OPT_DANE_TLSA_RRDATA,

, "DANE TLSA rrdata presentation form"}, {"dane_ee_no_namechecks", OPT_DANE_EE_NO_NAME,

, "Disable name checks when matching DANE-EE(3) TLSA records"}, {"reconnect", OPT_RECONNECT,

, "Drop and re-make the connection with the same Session-ID"}, {"showcerts", OPT_SHOWCERTS,

, "Show all certificates in the chain"}, {"debug", OPT_DEBUG,

, "Extra output"}, {"msg", OPT_MSG,

, "Show protocol messages"}, {"msgfile", OPT_MSGFILE,

, "File to send output of -msg or -trace, instead of stdout"}, {"nbio_test", OPT_NBIO_TEST,

, "More ssl protocol testing"}, {"state", OPT_STATE,

, "Print the ssl states"}, {"crlf", OPT_CRLF,

, "Convert LF from terminal into CRLF"}, {"quiet", OPT_QUIET,

, "No s_client output"}, {"ign_eof", OPT_IGN_EOF,

, "Ignore input eof (default when -quiet)"}, {"no_ign_eof", OPT_NO_IGN_EOF,

, "Don

}, {

, OPT_STARTTLS, 's',

}, {

, OPT_XMPPHOST, 's',

-starttls xmpp[-server]\"

sess_out

>

File to write SSL session to

sess_in

<

File to read SSL session from

use_srtp

s

Offer SRTP key management with a colon-separated profile list

keymatexport

s

Export keying material using label

keymatexportlen

p

Export len bytes of keying material (default 20)

fallback_scsv

-

Send the fallback SCSV

name

s

Hostname to use for \"-starttls lmtp\" or \"-starttls smtp\"

CRL

<

CRL file to use

crl_download

-

Download CRL from distribution points

CRLform

F

CRL format (PEM or DER) PEM is default

verify_return_error

-

Close connection on verification error

verify_quiet

-

Restrict verify output to errors

brief

-

Restrict output to brief summary of connection parameters

prexit

-

Print session information when the program exits

security_debug

-

Enable security debug messages

security_debug_verbose

-

Output more security debug output

cert_chain

<

Certificate chain file (in PEM format)

chainCApath

/

Use dir as certificate store path to build CA certificate chain

verifyCApath

/

Use dir as certificate store path to verify CA certificate

build_chain

-

Build certificate chain

chainCAfile

<

CA file for certificate chain (PEM format)

verifyCAfile

<

CA file for certificate verification (PEM format)

nocommands

-

Do not use interactive command letters

servername

s

Set TLS extension servername (SNI) in ClientHello (default)

noservername

-

Do not send the server name (SNI) extension in the ClientHello

tlsextdebug

-

Hex dump of all TLS extensions received

status

-

Request certificate status from server

serverinfo

s

types Send empty ClientHello extensions (comma-separated numbers)

alpn

s

Enable ALPN extension, considering named protocols supported (comma-separated list)

async

-

Support asynchronous operation

ssl_config

s

Use specified configuration file

max_send_frag

p

Maximum Size of send frames

split_send_frag

p

Size used to split data for encrypt pipelines

max_pipelines

p

Maximum number of encrypt/decrypt pipelines to be used

read_buf

p

Default read buffer size to be used for connections

ssl3

-

Just use SSLv3

tls1

-

Just use TLSv1

tls1_1

-

Just use TLSv1.1

tls1_2

-

Just use TLSv1.2

tls1_3

-

Just use TLSv1.3

dtls

-

Use any version of DTLS

timeout

-

Enable send/receive timeout on DTLS connections

mtu

p

Set the link layer MTU

dtls1

-

Just use DTLSv1

dtls1_2

-

Just use DTLSv1.2

sctp

-

Use SCTP

trace

-

Show trace output of protocol messages

wdebug

-

WATT-32 tcp debugging

nbio

-

Use non-blocking IO

psk_identity

s

PSK identity

psk

s

PSK in hex (without 0x)

psk_session

<

File to read PSK SSL session from

srpuser

s

SRP authentication for 'user'

srppass

s

Password for 'user'

srp_lateuser

-

SRP username into second ClientHello message

srp_moregroups

-

Tolerate other than the known g N values.

srp_strength

p

Minimal length in bits for N

nextprotoneg

s

Enable NPN extension, considering named protocols supported (comma-separated list)

engine

s

Use engine, possibly a hardware device

ssl_client_engine

s

Specify engine to be used for client certificate operations

ct

-

Request and parse SCTs (also enables OCSP stapling)

noct

-

Do not request or parse SCTs (default)

ctlogfile

<

CT log list CONF file

keylogfile

>

Write TLS secrets to file

early_data

<

File to send as early data

smtp

pop3

imap

ftp

xmpp

xmpp-server

telnet

irc

mysql

postgres

lmtp

nntp

sieve

ldap

w

Error writing session file %s\n

fail

t used the reference. */ return 0; } int s_client_main(int argc, char **argv) { BIO *sbio; EVP_PKEY *key = NULL; SSL *con = NULL; SSL_CTX *ctx = NULL; STACK_OF(X509) *chain = NULL; X509 *cert = NULL; X509_VERIFY_PARAM *vpm = NULL; SSL_EXCERT *exc = NULL; SSL_CONF_CTX *cctx = NULL; STACK_OF(OPENSSL_STRING) *ssl_args = NULL; char *dane_tlsa_domain = NULL; STACK_OF(OPENSSL_STRING) *dane_tlsa_rrset = NULL; int dane_ee_no_name = 0; STACK_OF(X509_CRL) *crls = NULL; const SSL_METHOD *meth = TLS_client_method(); const char *CApath = NULL, *CAfile = NULL; char *cbuf = NULL, *sbuf = NULL; char *mbuf = NULL, *proxystr = NULL, *connectstr = NULL; char *cert_file = NULL, *key_file = NULL, *chain_file = NULL; char *chCApath = NULL, *chCAfile = NULL, *host = NULL; char *port = OPENSSL_strdup(PORT); char *passarg = NULL, *pass = NULL, *vfyCApath = NULL, *vfyCAfile = NULL; char *ReqCAfile = NULL; char *sess_in = NULL, *crl_file = NULL, *p; char *xmpphost = NULL; const char *ehlo = "mail.example.com"; struct timeval timeout, *timeoutp; fd_set readfds, writefds; int noCApath = 0, noCAfile = 0; int build_chain = 0, cbuf_len, cbuf_off, cert_format = FORMAT_PEM; int key_format = FORMAT_PEM, crlf = 0, full_log = 1, mbuf_len = 0; int prexit = 0; int sdebug = 0; int reconnect = 0, verify = SSL_VERIFY_NONE, vpmtouched = 0; int ret = 1, in_init = 1, i, nbio_test = 0, s = -1, k, width, state = 0; int sbuf_len, sbuf_off, cmdletters = 1; int socket_family = AF_UNSPEC, socket_type = SOCK_STREAM, protocol = 0; int starttls_proto = PROTO_OFF, crl_format = FORMAT_PEM, crl_download = 0; int write_tty, read_tty, write_ssl, read_ssl, tty_on, ssl_pending; #if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) int at_eof = 0; #endif int read_buf_len = 0; int fallback_scsv = 0; OPTION_CHOICE o; #ifndef OPENSSL_NO_DTLS int enable_timeouts = 0; long socket_mtu = 0; #endif #ifndef OPENSSL_NO_ENGINE ENGINE *ssl_client_engine = NULL; #endif ENGINE *e = NULL; #if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) struct timeval tv; #endif char *servername = NULL; int noservername = 0; const char *alpn_in = NULL; tlsextctx tlsextcbp = { NULL, 0 }; const char *ssl_config = NULL; #define MAX_SI_TYPES 100 unsigned short serverinfo_types[MAX_SI_TYPES]; int serverinfo_count = 0, start = 0, len; #ifndef OPENSSL_NO_NEXTPROTONEG const char *next_proto_neg_in = NULL; #endif #ifndef OPENSSL_NO_SRP char *srppass = NULL; int srp_lateuser = 0; SRP_ARG srp_arg = { NULL, NULL, 0, 0, 0, 1024 }; #endif #ifndef OPENSSL_NO_CT char *ctlog_file = NULL; int ct_validation = 0; #endif int min_version = 0, max_version = 0, prot_opt = 0, no_prot_opt = 0; int async = 0; unsigned int max_send_fragment = 0; unsigned int split_send_fragment = 0, max_pipelines = 0; enum { use_inet, use_unix, use_unknown } connect_type = use_unknown; int count4or6 = 0; int c_nbio = 0, c_msg = 0, c_ign_eof = 0, c_brief = 0; int c_tlsextdebug = 0; #ifndef OPENSSL_NO_OCSP int c_status_req = 0; #endif BIO *bio_c_msg = NULL; const char *keylog_file = NULL, *early_data_file = NULL; #ifndef OPENSSL_NO_DTLS int isdtls = 0; #endif char *psksessf = NULL; FD_ZERO(&readfds); FD_ZERO(&writefds); /* Known false-positive of MemorySanitizer. */ #if defined(__has_feature) # if __has_feature(memory_sanitizer) __msan_unpoison(&readfds, sizeof(readfds)); __msan_unpoison(&writefds, sizeof(writefds)); # endif #endif prog = opt_progname(argv[0]); c_quiet = 0; c_debug = 0; c_showcerts = 0; c_nbio = 0; vpm = X509_VERIFY_PARAM_new(); cctx = SSL_CONF_CTX_new(); if (vpm == NULL || cctx == NULL) { BIO_printf(bio_err, "%s: out of memory\n", prog); goto end; } cbuf = app_malloc(BUFSIZZ, "cbuf"); sbuf = app_malloc(BUFSIZZ, "sbuf"); mbuf = app_malloc(BUFSIZZ, "mbuf"); SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT | SSL_CONF_FLAG_CMDLINE); prog = opt_init(argc, argv, s_client_options); while ((o = opt_next()) != OPT_EOF) { /* Check for intermixing flags. */ if (connect_type == use_unix && IS_INET_FLAG(o)) { BIO_printf(bio_err, "%s: Intermixed protocol flags (unix and internet domains)\n", prog); goto end; } if (connect_type == use_inet && IS_UNIX_FLAG(o)) { BIO_printf(bio_err, "%s: Intermixed protocol flags (internet and unix domains)\n", prog); goto end; } if (IS_PROT_FLAG(o) && ++prot_opt > 1) { BIO_printf(bio_err, "Cannot supply multiple protocol flags\n"); goto end; } if (IS_NO_PROT_FLAG(o)) no_prot_opt++; if (prot_opt == 1 && no_prot_opt) { BIO_printf(bio_err, "Cannot supply both a protocol flag and

\n"); goto end; } switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, "%s: Use -help for summary.\n", prog); goto end; case OPT_HELP: opt_help(s_client_options); ret = 0; goto end; case OPT_4: connect_type = use_inet; socket_family = AF_INET; count4or6++; break; #ifdef AF_INET6 case OPT_6: connect_type = use_inet; socket_family = AF_INET6; count4or6++; break; #endif case OPT_HOST: connect_type = use_inet; freeandcopy(&host, opt_arg()); break; case OPT_PORT: connect_type = use_inet; freeandcopy(&port, opt_arg()); break; case OPT_CONNECT: connect_type = use_inet; freeandcopy(&connectstr, opt_arg()); break; case OPT_PROXY: proxystr = opt_arg(); starttls_proto = PROTO_CONNECT; break; #ifdef AF_UNIX case OPT_UNIX: connect_type = use_unix; socket_family = AF_UNIX; freeandcopy(&host, opt_arg()); break; #endif case OPT_XMPPHOST: xmpphost = opt_arg(); break; case OPT_SMTPHOST: ehlo = opt_arg(); break; case OPT_VERIFY: verify = SSL_VERIFY_PEER; verify_args.depth = atoi(opt_arg()); if (!c_quiet) BIO_printf(bio_err, "verify depth is %d\n", verify_args.depth); break; case OPT_CERT: cert_file = opt_arg(); break; case OPT_NAMEOPT: if (!set_nameopt(opt_arg())) goto end; break; case OPT_CRL: crl_file = opt_arg(); break; case OPT_CRL_DOWNLOAD: crl_download = 1; break; case OPT_SESS_OUT: sess_out = opt_arg(); break; case OPT_SESS_IN: sess_in = opt_arg(); break; case OPT_CERTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &cert_format)) goto opthelp; break; case OPT_CRLFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &crl_format)) goto opthelp; break; case OPT_VERIFY_RET_ERROR: verify_args.return_error = 1; break; case OPT_VERIFY_QUIET: verify_args.quiet = 1; break; case OPT_BRIEF: c_brief = verify_args.quiet = c_quiet = 1; break; case OPT_S_CASES: if (ssl_args == NULL) ssl_args = sk_OPENSSL_STRING_new_null(); if (ssl_args == NULL || !sk_OPENSSL_STRING_push(ssl_args, opt_flag()) || !sk_OPENSSL_STRING_push(ssl_args, opt_arg())) { BIO_printf(bio_err, "%s: Memory allocation failure\n", prog); goto end; } break; case OPT_V_CASES: if (!opt_verify(o, vpm)) goto end; vpmtouched++; break; case OPT_X_CASES: if (!args_excert(o, &exc)) goto end; break; case OPT_PREXIT: prexit = 1; break; case OPT_CRLF: crlf = 1; break; case OPT_QUIET: c_quiet = c_ign_eof = 1; break; case OPT_NBIO: c_nbio = 1; break; case OPT_NOCMDS: cmdletters = 0; break; case OPT_ENGINE: e = setup_engine(opt_arg(), 1); break; case OPT_SSL_CLIENT_ENGINE: #ifndef OPENSSL_NO_ENGINE ssl_client_engine = ENGINE_by_id(opt_arg()); if (ssl_client_engine == NULL) { BIO_printf(bio_err, "Error getting client auth engine\n"); goto opthelp; } #endif break; case OPT_R_CASES: if (!opt_rand(o)) goto end; break; case OPT_IGN_EOF: c_ign_eof = 1; break; case OPT_NO_IGN_EOF: c_ign_eof = 0; break; case OPT_DEBUG: c_debug = 1; break; case OPT_TLSEXTDEBUG: c_tlsextdebug = 1; break; case OPT_STATUS: #ifndef OPENSSL_NO_OCSP c_status_req = 1; #endif break; case OPT_WDEBUG: #ifdef WATT32 dbug_init(); #endif break; case OPT_MSG: c_msg = 1; break; case OPT_MSGFILE: bio_c_msg = BIO_new_file(opt_arg(), "w"); break; case OPT_TRACE: #ifndef OPENSSL_NO_SSL_TRACE c_msg = 2; #endif break; case OPT_SECURITY_DEBUG: sdebug = 1; break; case OPT_SECURITY_DEBUG_VERBOSE: sdebug = 2; break; case OPT_SHOWCERTS: c_showcerts = 1; break; case OPT_NBIO_TEST: nbio_test = 1; break; case OPT_STATE: state = 1; break; case OPT_PSK_IDENTITY: psk_identity = opt_arg(); break; case OPT_PSK: for (p = psk_key = opt_arg(); *p; p++) { if (isxdigit(_UC(*p))) continue; BIO_printf(bio_err, "Not a hex number

\n", psk_key); goto end; } break; case OPT_PSK_SESS: psksessf = opt_arg(); break; #ifndef OPENSSL_NO_SRP case OPT_SRPUSER: srp_arg.srplogin = opt_arg(); if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; break; case OPT_SRPPASS: srppass = opt_arg(); if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; break; case OPT_SRP_STRENGTH: srp_arg.strength = atoi(opt_arg()); BIO_printf(bio_err, "SRP minimal length for N is %d\n", srp_arg.strength); if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; break; case OPT_SRP_LATEUSER: srp_lateuser = 1; if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; break; case OPT_SRP_MOREGROUPS: srp_arg.amp = 1; if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; break; #endif case OPT_SSL_CONFIG: ssl_config = opt_arg(); break; case OPT_SSL3: min_version = SSL3_VERSION; max_version = SSL3_VERSION; break; case OPT_TLS1_3: min_version = TLS1_3_VERSION; max_version = TLS1_3_VERSION; break; case OPT_TLS1_2: min_version = TLS1_2_VERSION; max_version = TLS1_2_VERSION; break; case OPT_TLS1_1: min_version = TLS1_1_VERSION; max_version = TLS1_1_VERSION; break; case OPT_TLS1: min_version = TLS1_VERSION; max_version = TLS1_VERSION; break; case OPT_DTLS: #ifndef OPENSSL_NO_DTLS meth = DTLS_client_method(); socket_type = SOCK_DGRAM; isdtls = 1; #endif break; case OPT_DTLS1: #ifndef OPENSSL_NO_DTLS1 meth = DTLS_client_method(); min_version = DTLS1_VERSION; max_version = DTLS1_VERSION; socket_type = SOCK_DGRAM; isdtls = 1; #endif break; case OPT_DTLS1_2: #ifndef OPENSSL_NO_DTLS1_2 meth = DTLS_client_method(); min_version = DTLS1_2_VERSION; max_version = DTLS1_2_VERSION; socket_type = SOCK_DGRAM; isdtls = 1; #endif break; case OPT_SCTP: #ifndef OPENSSL_NO_SCTP protocol = IPPROTO_SCTP; #endif break; case OPT_TIMEOUT: #ifndef OPENSSL_NO_DTLS enable_timeouts = 1; #endif break; case OPT_MTU: #ifndef OPENSSL_NO_DTLS socket_mtu = atol(opt_arg()); #endif break; case OPT_FALLBACKSCSV: fallback_scsv = 1; break; case OPT_KEYFORM: if (!opt_format(opt_arg(), OPT_FMT_PDE, &key_format)) goto opthelp; break; case OPT_PASS: passarg = opt_arg(); break; case OPT_CERT_CHAIN: chain_file = opt_arg(); break; case OPT_KEY: key_file = opt_arg(); break; case OPT_RECONNECT: reconnect = 5; break; case OPT_CAPATH: CApath = opt_arg(); break; case OPT_NOCAPATH: noCApath = 1; break; case OPT_CHAINCAPATH: chCApath = opt_arg(); break; case OPT_VERIFYCAPATH: vfyCApath = opt_arg(); break; case OPT_BUILD_CHAIN: build_chain = 1; break; case OPT_REQCAFILE: ReqCAfile = opt_arg(); break; case OPT_CAFILE: CAfile = opt_arg(); break; case OPT_NOCAFILE: noCAfile = 1; break; #ifndef OPENSSL_NO_CT case OPT_NOCT: ct_validation = 0; break; case OPT_CT: ct_validation = 1; break; case OPT_CTLOG_FILE: ctlog_file = opt_arg(); break; #endif case OPT_CHAINCAFILE: chCAfile = opt_arg(); break; case OPT_VERIFYCAFILE: vfyCAfile = opt_arg(); break; case OPT_DANE_TLSA_DOMAIN: dane_tlsa_domain = opt_arg(); break; case OPT_DANE_TLSA_RRDATA: if (dane_tlsa_rrset == NULL) dane_tlsa_rrset = sk_OPENSSL_STRING_new_null(); if (dane_tlsa_rrset == NULL || !sk_OPENSSL_STRING_push(dane_tlsa_rrset, opt_arg())) { BIO_printf(bio_err, "%s: Memory allocation failure\n", prog); goto end; } break; case OPT_DANE_EE_NO_NAME: dane_ee_no_name = 1; break; case OPT_NEXTPROTONEG: #ifndef OPENSSL_NO_NEXTPROTONEG next_proto_neg_in = opt_arg(); #endif break; case OPT_ALPN: alpn_in = opt_arg(); break; case OPT_SERVERINFO: p = opt_arg(); len = strlen(p); for (start = 0, i = 0; i <= len; ++i) { if (i == len || p[i] ==

) { serverinfo_types[serverinfo_count] = atoi(p + start); if (++serverinfo_count == MAX_SI_TYPES) break; start = i + 1; } } break; case OPT_STARTTLS: if (!opt_pair(opt_arg(), services, &starttls_proto)) goto end; break; case OPT_SERVERNAME: servername = opt_arg(); break; case OPT_NOSERVERNAME: noservername = 1; break; case OPT_USE_SRTP: srtp_profiles = opt_arg(); break; case OPT_KEYMATEXPORT: keymatexportlabel = opt_arg(); break; case OPT_KEYMATEXPORTLEN: keymatexportlen = atoi(opt_arg()); break; case OPT_ASYNC: async = 1; break; case OPT_MAX_SEND_FRAG: max_send_fragment = atoi(opt_arg()); break; case OPT_SPLIT_SEND_FRAG: split_send_fragment = atoi(opt_arg()); break; case OPT_MAX_PIPELINES: max_pipelines = atoi(opt_arg()); break; case OPT_READ_BUF: read_buf_len = atoi(opt_arg()); break; case OPT_KEYLOG_FILE: keylog_file = opt_arg(); break; case OPT_EARLY_DATA: early_data_file = opt_arg(); break; } } if (count4or6 >= 2) { BIO_printf(bio_err, "%s: Can

, prog); goto opthelp; } if (noservername) { if (servername != NULL) { BIO_printf(bio_err,

t use -servername and -noservername together\n", prog); goto opthelp; } if (dane_tlsa_domain != NULL) { BIO_printf(bio_err, "%s: Can

, prog); goto opthelp; } } argc = opt_num_rest(); if (argc == 1) { /* If there's a positional argument, it's the equivalent of * OPT_CONNECT. * Don't allow -connect and a separate argument. */ if (connectstr != NULL) { BIO_printf(bio_err,

, prog); goto opthelp; } connect_type = use_inet; freeandcopy(&connectstr, *opt_rest()); } else if (argc != 0) { goto opthelp; } #ifndef OPENSSL_NO_NEXTPROTONEG if (min_version == TLS1_3_VERSION && next_proto_neg_in != NULL) { BIO_printf(bio_err,

); goto opthelp; } #endif if (proxystr != NULL) { int res; char *tmp_host = host, *tmp_port = port; if (connectstr == NULL) { BIO_printf(bio_err,

, prog); goto opthelp; } res = BIO_parse_hostserv(proxystr, &host, &port, BIO_PARSE_PRIO_HOST); if (tmp_host != host) OPENSSL_free(tmp_host); if (tmp_port != port) OPENSSL_free(tmp_port); if (!res) { BIO_printf(bio_err,

, prog); goto end; } } else { int res = 1; char *tmp_host = host, *tmp_port = port; if (connectstr != NULL) res = BIO_parse_hostserv(connectstr, &host, &port, BIO_PARSE_PRIO_HOST); if (tmp_host != host) OPENSSL_free(tmp_host); if (tmp_port != port) OPENSSL_free(tmp_port); if (!res) { BIO_printf(bio_err,

, prog); goto end; } } #ifdef AF_UNIX if (socket_family == AF_UNIX && socket_type != SOCK_STREAM) { BIO_printf(bio_err,

t use unix sockets and datagrams together\n"); goto end; } #endif #ifndef OPENSSL_NO_SCTP if (protocol == IPPROTO_SCTP) { if (socket_type != SOCK_DGRAM) { BIO_printf(bio_err, "Can

); goto end; } /* SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol */ socket_type = SOCK_STREAM; } #endif #if !defined(OPENSSL_NO_NEXTPROTONEG) next_proto.status = -1; if (next_proto_neg_in) { next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in); if (next_proto.data == NULL) { BIO_printf(bio_err,

); goto end; } } else next_proto.data = NULL; #endif if (!app_passwd(passarg, NULL, &pass, NULL)) { BIO_printf(bio_err,

); goto end; } if (key_file == NULL) key_file = cert_file; if (key_file != NULL) { key = load_key(key_file, key_format, 0, pass, e,

); if (key == NULL) { ERR_print_errors(bio_err); goto end; } } if (cert_file != NULL) { cert = load_cert(cert_file, cert_format,

); if (cert == NULL) { ERR_print_errors(bio_err); goto end; } } if (chain_file != NULL) { if (!load_certs(chain_file, &chain, FORMAT_PEM, NULL,

)) goto end; } if (crl_file != NULL) { X509_CRL *crl; crl = load_crl(crl_file, crl_format); if (crl == NULL) { BIO_puts(bio_err,

); ERR_print_errors(bio_err); goto end; } crls = sk_X509_CRL_new_null(); if (crls == NULL || !sk_X509_CRL_push(crls, crl)) { BIO_puts(bio_err,

); ERR_print_errors(bio_err); X509_CRL_free(crl); goto end; } } if (!load_excert(&exc)) goto end; if (bio_c_out == NULL) { if (c_quiet && !c_debug) { bio_c_out = BIO_new(BIO_s_null()); if (c_msg && bio_c_msg == NULL) bio_c_msg = dup_bio_out(FORMAT_TEXT); } else if (bio_c_out == NULL) bio_c_out = dup_bio_out(FORMAT_TEXT); } #ifndef OPENSSL_NO_SRP if (!app_passwd(srppass, NULL, &srp_arg.srppassin, NULL)) { BIO_printf(bio_err,

); goto end; } #endif ctx = SSL_CTX_new(meth); if (ctx == NULL) { ERR_print_errors(bio_err); goto end; } if (sdebug) ssl_ctx_security_debug(ctx, sdebug); if (ssl_config != NULL) { if (SSL_CTX_config(ctx, ssl_config) == 0) { BIO_printf(bio_err,

%s\"\n

Error setting verify params\n

%s: Max send fragment size %u is out of permitted range\n

%s: Split send fragment size %u is out of permitted range\n

%s: Max pipelines %u is out of permitted range\n

Error loading store locations\n

Error loading CA names\n

Error setting client auth engine\n

PSK key given, setting client callback\n

r

Can't open PSK session file %s\n

Can't read PSK session file %s\n

Error setting SRTP profile\n

Error parsing -alpn argument\n

Error setting ALPN\n

Warning: Unable to add custom extension %u, skipping\n

t needed so don

Unable to set SRP username\n

%s: Error enabling DANE TLSA authentication.\n

r

Can't open session file %s\n

Can't open session file %s\n

Can't set session\n

localhost

Unable to set TLS servername extension.\n

%s: Error enabling DANE TLSA

authentication.\n

%s: DANE TLSA authentication requires at

least one -dane_tlsa_rrdata option.\n

%s: Failed to import any TLSA

records.\n

%s: DANE TLSA authentication requires the

-dane_tlsa_domain option.\n

connect:errno=%d\n

CONNECTED(%08X)\n

Turned on non blocking io\n

memory allocation failure\n

getsockname:errno=%d\n

MTU too small. Must be at least %ld\n

Failed to set MTU\n

-

LHLO %s\r\n

EHLO %s\r\n

STARTTLS

-

Didn't find STARTTLS in server response,

trying anyway...\n

STARTTLS\r\n

STLS\r\n

BIO_read failed\n

. CAPABILITY\r\n

STARTTLS

.

Didn't find STARTTLS in server response,

trying anyway...\n

. STARTTLS\r\n

-

AUTH TLS\r\n

<stream:stream

xmlns:stream='http://etherx.jabber.org/streams'

xmlns='jabber:%s' to='%s' version='1.0'>

client

server

BIO_read failed\n

\0

<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'

<starttls xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"

\0

<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>

BIO_read failed\n

\0

<proceed

\0

CONNECT %s HTTP/1.0\r\n\r\n

s formated exactly like this: * * HTTP/d.d ddd Reason text\r\n */ mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ); if (mbuf_len < (int)strlen("HTTP/1.0 200")) { BIO_printf(bio_err, "%s: HTTP CONNECT failed, insufficient response " "from proxy (got %d octets)\n", prog, mbuf_len); (void)BIO_flush(fbio); BIO_pop(fbio); BIO_free(fbio); goto shut; } if (mbuf[8] !=

) { BIO_printf(bio_err, "%s: HTTP CONNECT failed, incorrect response " "from proxy\n", prog); foundit = error_proto; } else if (mbuf[9] !=

) { BIO_printf(bio_err, "%s: HTTP CONNECT failed: %s ", prog, &mbuf[9]); } else { foundit = success; } if (foundit != error_proto) { /* Read past all following headers */ do { mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ); } while (mbuf_len > 2); } (void)BIO_flush(fbio); BIO_pop(fbio); BIO_free(fbio); if (foundit != success) { goto shut; } } break; case PROTO_IRC: { int numeric; BIO *fbio = BIO_new(BIO_f_buffer()); BIO_push(fbio, sbio); BIO_printf(fbio, "STARTTLS\r\n"); (void)BIO_flush(fbio); width = SSL_get_fd(con) + 1; do { numeric = 0; FD_ZERO(&readfds); openssl_fdset(SSL_get_fd(con), &readfds); timeout.tv_sec = S_CLIENT_IRC_READ_TIMEOUT; timeout.tv_usec = 0; /* * If the IRCd doesn

t support STARTTLS. Many IRCds * will not give _any_ sort of response to a * STARTTLS command when it

Timeout waiting for response (%d seconds).\n

%*s %d

STARTTLS

STARTTLS not supported: %s

STARTTLS negotiation failed:

Server does not support STARTTLS.\n

BIO_read failed\n

MySQL packet too short.\n

MySQL packet length does not match.\n

Only MySQL protocol version 10 is supported.\n

Cannot confirm server version.

\0

MySQL server handshake packet is broken.\n

\0

MySQL packet is broken.\n

MySQL server does not support SSL.\n

S

CAPABILITIES\r\n

STARTTLS

.

Didn't find STARTTLS in server response,

trying anyway...\n

STARTTLS\r\n

BIO_read failed\n

\0

382

STARTTLS failed: %s

"

\"STARTTLS\"

"

Didn't find STARTTLS in server response,

trying anyway...\n

STARTTLS\r\n

BIO_read failed\n

\0

STARTTLS failed: %s

OK

STARTTLS not supported: %s

asn1=SEQUENCE:LDAPMessage\n

[LDAPMessage]\n

messageID=INTEGER:1\n

extendedReq=EXPLICIT:23A,IMPLICIT:0C,

FORMAT:ASCII,OCT:1.3.6.1.4.1.1466.20037\n

NCONF_load_bio failed\n

Error on line %ld\n

default

asn1

NCONF_get_string failed\n

ASN1_generate_nconf failed\n

BIO_read failed\n

ldap_ExtendedResponse_parse failed\n

STARTTLS failed, LDAP Result Code: %i\n

r

Cannot open early data file\n

Error writing early data\n

CONNECTION ESTABLISHED\n

t need to know any more */ if (!reconnect) starttls_proto = PROTO_OFF; } if (reconnect) { reconnect--; BIO_printf(bio_c_out, "drop connection and then reconnect\n"); do_ssl_shutdown(con); SSL_set_connect_state(con); BIO_closesocket(SSL_get_fd(con)); goto re_start; } } } ssl_pending = read_ssl && SSL_has_pending(con); if (!ssl_pending) { #if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) if (tty_on) { /* * Note that select() returns when read _would not block_, * and EOF satisfies that. To avoid a CPU-hogging loop, * set the flag so we exit. */ if (read_tty && !at_eof) openssl_fdset(fileno_stdin(), &readfds); #if !defined(OPENSSL_SYS_VMS) if (write_tty) openssl_fdset(fileno_stdout(), &writefds); #endif } if (read_ssl) openssl_fdset(SSL_get_fd(con), &readfds); if (write_ssl) openssl_fdset(SSL_get_fd(con), &writefds); #else if (!tty_on || !write_tty) { if (read_ssl) openssl_fdset(SSL_get_fd(con), &readfds); if (write_ssl) openssl_fdset(SSL_get_fd(con), &writefds); } #endif /* * Note: under VMS with SOCKETSHR the second parameter is * currently of type (int *) whereas under other systems it is * (void *) if you don

t do this. */ i = 0; if (!write_tty) { if (read_tty) { tv.tv_sec = 1; tv.tv_usec = 0; i = select(width, (void *)&readfds, (void *)&writefds, NULL, &tv); if (!i && (!has_stdin_waiting() || !read_tty)) continue; } else i = select(width, (void *)&readfds, (void *)&writefds, NULL, timeoutp); } #else i = select(width, (void *)&readfds, (void *)&writefds, NULL, timeoutp); #endif if (i < 0) { BIO_printf(bio_err, "bad select %d\n", get_last_socket_error()); goto shut; } } if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0) { BIO_printf(bio_err, "TIMEOUT occurred\n"); } if (!ssl_pending && FD_ISSET(SSL_get_fd(con), &writefds)) { k = SSL_write(con, &(cbuf[cbuf_off]), (unsigned int)cbuf_len); switch (SSL_get_error(con, k)) { case SSL_ERROR_NONE: cbuf_off += k; cbuf_len -= k; if (k <= 0) goto end; /* we have done a write(con,NULL,0); */ if (cbuf_len <= 0) { read_tty = 1; write_ssl = 0; } else { /* if (cbuf_len > 0) */ read_tty = 0; write_ssl = 1; } break; case SSL_ERROR_WANT_WRITE: BIO_printf(bio_c_out, "write W BLOCK\n"); write_ssl = 1; read_tty = 0; break; case SSL_ERROR_WANT_ASYNC: BIO_printf(bio_c_out, "write A BLOCK\n"); wait_for_async(con); write_ssl = 1; read_tty = 0; break; case SSL_ERROR_WANT_READ: BIO_printf(bio_c_out, "write R BLOCK\n"); write_tty = 0; read_ssl = 1; write_ssl = 0; break; case SSL_ERROR_WANT_X509_LOOKUP: BIO_printf(bio_c_out, "write X BLOCK\n"); break; case SSL_ERROR_ZERO_RETURN: if (cbuf_len != 0) { BIO_printf(bio_c_out, "shutdown\n"); ret = 0; goto shut; } else { read_tty = 1; write_ssl = 0; break; } case SSL_ERROR_SYSCALL: if ((k != 0) || (cbuf_len != 0)) { BIO_printf(bio_err, "write:errno=%d\n", get_last_socket_error()); goto shut; } else { read_tty = 1; write_ssl = 0; } break; case SSL_ERROR_WANT_ASYNC_JOB: /* This shouldn

DONE\n

read A BLOCK\n

read W BLOCK\n

read R BLOCK\n

read X BLOCK\n

CONNECTION CLOSED BY SERVER\n

read:errno=%d\n

closed\n

t ever happen in s_client. Treat as an error */ case SSL_ERROR_SSL: ERR_print_errors(bio_err); goto shut; } } /* OPENSSL_SYS_MSDOS includes OPENSSL_SYS_WINDOWS */ #if defined(OPENSSL_SYS_MSDOS) else if (has_stdin_waiting()) #else else if (FD_ISSET(fileno_stdin(), &readfds)) #endif { if (crlf) { int j, lf_num; i = raw_read_stdin(cbuf, BUFSIZZ / 2); lf_num = 0; /* both loops are skipped when i <= 0 */ for (j = 0; j < i; j++) if (cbuf[j] ==

) lf_num++; for (j = i - 1; j >= 0; j--) { cbuf[j + lf_num] = cbuf[j]; if (cbuf[j] ==

) { lf_num--; i++; cbuf[j + lf_num] =

; } } assert(lf_num == 0); } else i = raw_read_stdin(cbuf, BUFSIZZ); #if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) if (i == 0) at_eof = 1; #endif if ((!c_ign_eof) && ((i <= 0) || (cbuf[0] ==

&& cmdletters))) { BIO_printf(bio_err, "DONE\n"); ret = 0; goto shut; } if ((!c_ign_eof) && (cbuf[0] ==

&& cmdletters)) { BIO_printf(bio_err, "RENEGOTIATING\n"); SSL_renegotiate(con); cbuf_len = 0; } if (!c_ign_eof && (cbuf[0] ==

|| cbuf[0] ==

) && cmdletters) { BIO_printf(bio_err, "KEYUPDATE\n"); SSL_key_update(con, cbuf[0] ==

? SSL_KEY_UPDATE_REQUESTED : SSL_KEY_UPDATE_NOT_REQUESTED); cbuf_len = 0; } #ifndef OPENSSL_NO_HEARTBEATS else if ((!c_ign_eof) && (cbuf[0] ==

&& cmdletters)) { BIO_printf(bio_err, "HEARTBEATING\n"); SSL_heartbeat(con); cbuf_len = 0; } #endif else { cbuf_len = i; cbuf_off = 0; #ifdef CHARSET_EBCDIC ebcdic2ascii(cbuf, cbuf, i); #endif } write_ssl = 1; read_tty = 0; } } ret = 0; shut: if (in_init) print_stuff(bio_c_out, con, full_log); do_ssl_shutdown(con); #if defined(OPENSSL_SYS_WINDOWS) /* * Give the socket time to send its last data before we close it. * No amount of setting SO_LINGER etc on the socket seems to persuade * Windows to send the data before closing the socket...but sleeping * for a short time seems to do it (units in ms) * TODO: Find a better way to do this */ Sleep(50); #endif BIO_closesocket(SSL_get_fd(con)); end: if (con != NULL) { if (prexit != 0) print_stuff(bio_c_out, con, 1); SSL_free(con); } SSL_SESSION_free(psksess); #if !defined(OPENSSL_NO_NEXTPROTONEG) OPENSSL_free(next_proto.data); #endif SSL_CTX_free(ctx); set_keylog_file(NULL, NULL); X509_free(cert); sk_X509_CRL_pop_free(crls, X509_CRL_free); EVP_PKEY_free(key); sk_X509_pop_free(chain, X509_free); OPENSSL_free(pass); #ifndef OPENSSL_NO_SRP OPENSSL_free(srp_arg.srppassin); #endif OPENSSL_free(connectstr); OPENSSL_free(host); OPENSSL_free(port); X509_VERIFY_PARAM_free(vpm); ssl_excert_free(exc); sk_OPENSSL_STRING_free(ssl_args); sk_OPENSSL_STRING_free(dane_tlsa_rrset); SSL_CONF_CTX_free(cctx); OPENSSL_clear_free(cbuf, BUFSIZZ); OPENSSL_clear_free(sbuf, BUFSIZZ); OPENSSL_clear_free(mbuf, BUFSIZZ); release_engine(e); BIO_free(bio_c_out); bio_c_out = NULL; BIO_free(bio_c_msg); bio_c_msg = NULL; return (ret); } static void print_stuff(BIO *bio, SSL *s, int full) { X509 *peer = NULL; STACK_OF(X509) *sk; const SSL_CIPHER *c; int i; #ifndef OPENSSL_NO_COMP const COMP_METHOD *comp, *expansion; #endif unsigned char *exportedkeymat; #ifndef OPENSSL_NO_CT const SSL_CTX *ctx = SSL_get_SSL_CTX(s); #endif if (full) { int got_a_chain = 0; sk = SSL_get_peer_cert_chain(s); if (sk != NULL) { got_a_chain = 1; BIO_printf(bio, "---\nCertificate chain\n"); for (i = 0; i < sk_X509_num(sk); i++) { BIO_printf(bio, "%2d s:", i); X509_NAME_print_ex(bio, X509_get_subject_name(sk_X509_value(sk, i)), 0, get_nameopt()); BIO_puts(bio, "\n"); BIO_printf(bio, " i:"); X509_NAME_print_ex(bio, X509_get_issuer_name(sk_X509_value(sk, i)), 0, get_nameopt()); BIO_puts(bio, "\n"); if (c_showcerts) PEM_write_bio_X509(bio, sk_X509_value(sk, i)); } } BIO_printf(bio, "---\n"); peer = SSL_get_peer_certificate(s); if (peer != NULL) { BIO_printf(bio, "Server certificate\n"); /* Redundant if we showed the whole chain */ if (!(c_showcerts && got_a_chain)) PEM_write_bio_X509(bio, peer); dump_cert_text(bio, peer); } else { BIO_printf(bio, "no peer certificate available\n"); } print_ca_names(bio, s); ssl_print_sigalgs(bio, s); ssl_print_tmp_key(bio, s); #ifndef OPENSSL_NO_CT /* * When the SSL session is anonymous, or resumed via an abbreviated * handshake, no SCTs are provided as part of the handshake. While in * a resumed session SCTs may be present in the session

s certificate, and of * course none are associated with an anonymous peer. */ if (peer != NULL && !SSL_session_reused(s) && SSL_ct_is_enabled(s)) { const STACK_OF(SCT) *scts = SSL_get0_peer_scts(s); int sct_count = scts != NULL ? sk_SCT_num(scts) : 0; BIO_printf(bio, "---\nSCTs present (%i)\n", sct_count); if (sct_count > 0) { const CTLOG_STORE *log_store = SSL_CTX_get0_ctlog_store(ctx); BIO_printf(bio, "---\n"); for (i = 0; i < sct_count; ++i) { SCT *sct = sk_SCT_value(scts, i); BIO_printf(bio, "SCT validation status: %s\n", SCT_validation_status_string(sct)); SCT_print(sct, bio, 0, log_store); if (i < sct_count - 1) BIO_printf(bio, "\n---\n"); } BIO_printf(bio, "\n"); } } #endif BIO_printf(bio, "---\nSSL handshake has read %ju bytes " "and written %ju bytes\n", BIO_number_read(SSL_get_rbio(s)), BIO_number_written(SSL_get_wbio(s))); } print_verify_detail(s, bio); BIO_printf(bio, (SSL_session_reused(s) ? "---\nReused, " : "---\nNew, ")); c = SSL_get_current_cipher(s); BIO_printf(bio, "%s, Cipher is %s\n", SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c)); if (peer != NULL) { EVP_PKEY *pktmp; pktmp = X509_get0_pubkey(peer); BIO_printf(bio, "Server public key is %d bit\n", EVP_PKEY_bits(pktmp)); } BIO_printf(bio, "Secure Renegotiation IS%s supported\n", SSL_get_secure_renegotiation_support(s) ? "" : " NOT"); #ifndef OPENSSL_NO_COMP comp = SSL_get_current_compression(s); expansion = SSL_get_current_expansion(s); BIO_printf(bio, "Compression: %s\n", comp ? SSL_COMP_get_name(comp) : "NONE"); BIO_printf(bio, "Expansion: %s\n", expansion ? SSL_COMP_get_name(expansion) : "NONE"); #endif #ifdef SSL_DEBUG { /* Print out local port of connection: useful for debugging */ int sock; union BIO_sock_info_u info; sock = SSL_get_fd(s); if ((info.addr = BIO_ADDR_new()) != NULL && BIO_sock_info(sock, BIO_SOCK_INFO_ADDRESS, &info)) { BIO_printf(bio_c_out, "LOCAL PORT is %u\n", ntohs(BIO_ADDR_rawport(info.addr))); } BIO_ADDR_free(info.addr); } #endif #if !defined(OPENSSL_NO_NEXTPROTONEG) if (next_proto.status != -1) { const unsigned char *proto; unsigned int proto_len; SSL_get0_next_proto_negotiated(s, &proto, &proto_len); BIO_printf(bio, "Next protocol: (%d) ", next_proto.status); BIO_write(bio, proto, proto_len); BIO_write(bio, "\n", 1); } #endif { const unsigned char *proto; unsigned int proto_len; SSL_get0_alpn_selected(s, &proto, &proto_len); if (proto_len > 0) { BIO_printf(bio, "ALPN protocol: "); BIO_write(bio, proto, proto_len); BIO_write(bio, "\n", 1); } else BIO_printf(bio, "No ALPN negotiated\n"); } #ifndef OPENSSL_NO_SRTP { SRTP_PROTECTION_PROFILE *srtp_profile = SSL_get_selected_srtp_profile(s); if (srtp_profile) BIO_printf(bio, "SRTP Extension negotiated, profile=%s\n", srtp_profile->name); } #endif if (SSL_version(s) == TLS1_3_VERSION) { switch (SSL_get_early_data_status(s)) { case SSL_EARLY_DATA_NOT_SENT: BIO_printf(bio, "Early data was not sent\n"); break; case SSL_EARLY_DATA_REJECTED: BIO_printf(bio, "Early data was rejected\n"); break; case SSL_EARLY_DATA_ACCEPTED: BIO_printf(bio, "Early data was accepted\n"); break; } } SSL_SESSION_print(bio, SSL_get_session(s)); if (SSL_get_session(s) != NULL && keymatexportlabel != NULL) { BIO_printf(bio, "Keying material exporter:\n"); BIO_printf(bio, " Label:

\n", keymatexportlabel); BIO_printf(bio, " Length: %i bytes\n", keymatexportlen); exportedkeymat = app_malloc(keymatexportlen, "export key"); if (!SSL_export_keying_material(s, exportedkeymat, keymatexportlen, keymatexportlabel, strlen(keymatexportlabel), NULL, 0, 0)) { BIO_printf(bio, " Error\n"); } else { BIO_printf(bio, " Keying material: "); for (i = 0; i < keymatexportlen; i++) BIO_printf(bio, "%02X", exportedkeymat[i]); BIO_printf(bio, "\n"); } OPENSSL_free(exportedkeymat); } BIO_printf(bio, "---\n"); X509_free(peer); /* flush, or debugging output gets mixed with http response */ (void)BIO_flush(bio); } # ifndef OPENSSL_NO_OCSP static int ocsp_resp_cb(SSL *s, void *arg) { const unsigned char *p; int len; OCSP_RESPONSE *rsp; len = SSL_get_tlsext_status_ocsp_resp(s, &p); BIO_puts(arg, "OCSP response: "); if (p == NULL) { BIO_puts(arg, "no response sent\n"); return 1; } rsp = d2i_OCSP_RESPONSE(NULL, &p, len); if (rsp == NULL) { BIO_puts(arg, "response parse error\n"); BIO_dump_indent(arg, (char *)p, len, 4); return 0; } BIO_puts(arg, "\n======================================\n"); OCSP_RESPONSE_print(arg, rsp, 0); BIO_puts(arg, "======================================\n"); OCSP_RESPONSE_free(rsp); return 1; } # endif static int ldap_ExtendedResponse_parse(const char *buf, long rem) { const unsigned char *cur, *end; long len; int tag, xclass, inf, ret = -1; cur = (const unsigned char *)buf; end = cur + rem; /* * From RFC 4511: * * LDAPMessage ::= SEQUENCE { * messageID MessageID, * protocolOp CHOICE { * ... * extendedResp ExtendedResponse, * ... }, * controls [0] Controls OPTIONAL } * * ExtendedResponse ::= [APPLICATION 24] SEQUENCE { * COMPONENTS OF LDAPResult, * responseName [10] LDAPOID OPTIONAL, * responseValue [11] OCTET STRING OPTIONAL } * * LDAPResult ::= SEQUENCE { * resultCode ENUMERATED { * success (0), * ... * other (80), * ... }, * matchedDN LDAPDN, * diagnosticMessage LDAPString, * referral [3] Referral OPTIONAL } */ /* pull SEQUENCE */ inf = ASN1_get_object(&cur, &len, &tag, &xclass, rem); if (inf != V_ASN1_CONSTRUCTED || tag != V_ASN1_SEQUENCE || (rem = end - cur, len > rem)) { BIO_printf(bio_err, "Unexpected LDAP response\n"); goto end; } rem = len; /* ensure that we don

No MessageID\n

Not ExtendedResponse\n

Not LDAPResult\n

0x13,

0x01

0x13,

0x02

0xFF;

0xFF;

0x)"},

0x00,

0x20,

0x00,

0x00,

0x01,

0x85,

0xae,

0x7f,

0x00,

0x00,

0x00,

0x00,

0x01,

0x21,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00,

0x00

0x800;

0xA)

