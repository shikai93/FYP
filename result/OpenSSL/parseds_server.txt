Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Copyright 2005 Nokia. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Included before async.h to avoid some warnings

With IPv6, it looks like Digital has mixed up the proper order of recursive header file inclusion, resulting in the compiler complaining that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which is needed to have fileno() declared correctly... So let's define u_int

We define this but make it always be 0 in no-dtls builds to simplify the code.

by default PSK is not used

here we could lookup the given identity e.g. from a database

convert the PSK key to binary

Doesn't look like a suitable TLSv1.3 key. Ignore it

This is a context that we pass to callbacks

This callback pretends to require some asynchronous logic in order to obtain a verifier. When the callback is called for a new connection we return with a negative value. This will provoke the accept etc to return with an LOOKUP_X509. The main logic of the reinvokes the suspended call (which would normally occur after a worker has finished) and we set the user parameters.

This struct is "unwarranted chumminess with the compiler."

double the size

return(BIO_gets(bp->next_bio,buf,size))

This is a context that we pass to callbacks

Structure passed to cert status callback

File to load OCSP Response from (or NULL if no file)

Default responder to use

Helper function to get an OCSP_RESPONSE from a responder. This is a simplified version. It examines certificates each time and makes one OCSP responder query for each request. A full version would store details such as the OCSP certificate IDs and minimise the number of OCSP responses by caching them until they were considered "expired".

Build up OCSP query from server certificate

Add any extensions to the request

If we parsed aia we need to free; otherwise they were copied and we don't

Certificate Status callback. This is called when a client includes a certificate status request extension. The response is either obtained from a file, or from an OCSP responder.

This is the context that we pass to next_proto_cb

ndef OPENSSL_NO_NEXTPROTONEG

This the context that we pass to alpn_cb

We can assume that |in| is syntactically valid.

disable resumption for sessions with forward secure ciphers

by default do not send a PSK identity hint

anything will do

Init of few remaining global variables

SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol

Returns 0 on success!

Set DTLS cookie generation and verification callbacks

want to do MTU discovery

Turn on cookie exchange. Not necessary for SCTP

SSL_set_fd(con,s);

Just keep trying - busy waiting

Note: under VMS with SOCKETSHR the second parameter is currently of type (int ) whereas under other systems it is (void ) if you don't have a cast it will choke the compiler: if you do have a cast then you can either go for (int ) or (void ).

Under DOS (non-djgpp) and Windows we can't select on stdin: only on sockets. As a workaround we timeout the select every second and check for any keypress. In a proper Windows application we wouldn't do this because it is inefficient.

both loops are skipped when i <= 0

close_accept_socket(); ret= -11;

13;

strcpy(buf,"server side RE-NEGOTIATE\n");

13;

strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n");

strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n");

should do a select for the write

This shouldn't ever happen in s_server. Treat as an error

break;

init_ssl_connection handles all async events itself so if we're waiting for async then we shouldn't go back into init_ssl_connection

This shouldn't ever happen in s_server. Treat as an error

If it's not a fatal error, it must be retryable

Always print any error messages

Set width for a select call if needed

lets make the output buffer a reasonable size

SSL_set_fd(con,s);

error

end of input

else we have data

Send the HelloRequest

Wait for a ClientHello to come back

We're not actually expecting any data here and we ignore any that is sent. This is just to force the handshake that we're expecting to come from the client. If they haven't sent one there's not much we can do.

BIO_puts(io, OpenSSL_version(OPENSSL_VERSION));

The following is evil and should not really be done

skip the '/'

filename contains ".." component

if a directory, do the index thang

send the file

make sure we re-use sessions

lets make the output buffer a reasonable size

error

end of input

make sure we re-use sessions

Prefix the session_id with the required prefix. NB: If our prefix is too long, clip it - but there will be worse effects anyway, eg. the server could only possibly create 1 session ID (ie. the prefix!) so all future session negotiations will fail due to conflicts.

By default s_server uses an in-memory cache which caches SSL_SESSION structures without any serialisation. This hides some bugs which only become apparent in deployed servers. By implementing a basic external session cache some issues can be debugged using s_server.

Assume it still works.

OPENSSL_NO_SOCK

www.openssl.org/source/license.html

License

t defined, but only if _POSIX_C_SOURCE is defined, which is * needed to have fileno() declared correctly... So let

apps.h

s_apps.h

timeouts.h

internal/sockets.h

server.pem

server2.pem

Client_identity

psk_server_cb\n

Error: client did not send PSK identity\n

identity_len=%d identity=%s\n

PSK warning: client identity not what we expected

(got '%s' expected '%s')\n

PSK client identity found\n

Could not convert PSK key '%s' to buffer\n

psk buffer of callback is too small (%d) for key (%ld)\n

fetched PSK len=%ld\n

Error in PSK server callback\n

\x13\x01

\x13\x02

Could not convert PSK key '%s' to buffer\n

t look like a suitable TLSv1.3 key. Ignore it */ OPENSSL_free(key); return 0; } tmpsess = SSL_SESSION_new(); if (tmpsess == NULL || !SSL_SESSION_set1_master_key(tmpsess, key, key_len) || !SSL_SESSION_set_cipher(tmpsess, cipher) || !SSL_SESSION_set_protocol_version(tmpsess, SSL_version(ssl))) { OPENSSL_free(key); return 0; } OPENSSL_free(key); *sess = tmpsess; return 1; } #ifndef OPENSSL_NO_SRP /* This is a context that we pass to callbacks */ typedef struct srpsrvparm_st { char *login; SRP_VBASE *vb; SRP_user_pwd *user; } srpsrvparm; /* * This callback pretends to require some asynchronous logic in order to * obtain a verifier. When the callback is called for a new connection we * return with a negative value. This will provoke the accept etc to return * with an LOOKUP_X509. The main logic of the reinvokes the suspended call * (which would normally occur after a worker has finished) and we set the * user parameters. */ static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg) { srpsrvparm *p = (srpsrvparm *) arg; int ret = SSL3_AL_FATAL; if (p->login == NULL && p->user == NULL) { p->login = SSL_get_srp_username(s); BIO_printf(bio_err, "SRP username = \"%s\"\n", p->login); return (-1); } if (p->user == NULL) { BIO_printf(bio_err, "User %s doesn

, p->login); goto err; } if (SSL_set_srp_server_param (s, p->user->N, p->user->g, p->user->s, p->user->v, p->user->info) < 0) { *ad = SSL_AD_INTERNAL_ERROR; goto err; } BIO_printf(bio_err,

%s\" info=\"%s\" \n

unwarranted chumminess with the compiler.

EBCDIC/ASCII filter

ebcdic wbuf

\0

grow ebcdic wbuf

\0

\n

\0

Hostname in TLS extension: \"

%c

\\x%02x

\"\n

Switching server context.\n

expired

cert_status: can't parse AIA URL\n

cert_status: AIA URL: %s\n

cert_status: no AIA and no default responder URL\n

cert_status: Can't retrieve issuer certificate.\n

cert_status: error querying responder\n

t */ if (aia != NULL) { OPENSSL_free(host); OPENSSL_free(path); OPENSSL_free(port); X509_email_free(aia); } OCSP_CERTID_free(id); OCSP_REQUEST_free(req); X509_STORE_CTX_free(inctx); return ret; } /* * Certificate Status callback. This is called when a client includes a * certificate status request extension. The response is either obtained from a * file, or from an OCSP responder. */ static int cert_status_cb(SSL *s, void *arg) { tlsextstatusctx *srctx = arg; OCSP_RESPONSE *resp = NULL; unsigned char *rspder = NULL; int rspderlen; int ret = SSL_TLSEXT_ERR_ALERT_FATAL; if (srctx->verbose) BIO_puts(bio_err, "cert_status: callback called\n"); if (srctx->respin != NULL) { BIO *derbio = bio_open_default(srctx->respin,

, FORMAT_ASN1); if (derbio == NULL) { BIO_puts(bio_err, "cert_status: Cannot open OCSP response file\n"); goto err; } resp = d2i_OCSP_RESPONSE_bio(derbio, NULL); BIO_free(derbio); if (resp == NULL) { BIO_puts(bio_err, "cert_status: Error reading OCSP response\n"); goto err; } } else { ret = get_ocsp_resp_from_responder(s, srctx, &resp); if (ret != SSL_TLSEXT_ERR_OK) goto err; } rspderlen = i2d_OCSP_RESPONSE(resp, &rspder); if (rspderlen <= 0) goto err; SSL_set_tlsext_status_ocsp_resp(s, rspder, rspderlen); if (srctx->verbose) { BIO_puts(bio_err, "cert_status: ocsp response sent:\n"); OCSP_RESPONSE_print(bio_err, resp, 2); } ret = SSL_TLSEXT_ERR_OK; err: if (ret != SSL_TLSEXT_ERR_OK) ERR_print_errors(bio_err); OCSP_RESPONSE_free(resp); return ret; } #endif #ifndef OPENSSL_NO_NEXTPROTONEG /* This is the context that we pass to next_proto_cb */ typedef struct tlsextnextprotoctx_st { unsigned char *data; size_t len; } tlsextnextprotoctx; static int next_proto_cb(SSL *s, const unsigned char **data, unsigned int *len, void *arg) { tlsextnextprotoctx *next_proto = arg; *data = next_proto->data; *len = next_proto->len; return SSL_TLSEXT_ERR_OK; } #endif /* ndef OPENSSL_NO_NEXTPROTONEG */ /* This the context that we pass to alpn_cb */ typedef struct tlsextalpnctx_st { unsigned char *data; size_t len; } tlsextalpnctx; static int alpn_cb(SSL *s, const unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg) { tlsextalpnctx *alpn_ctx = arg; if (!s_quiet) { /* We can assume that |in| is syntactically valid. */ unsigned int i; BIO_printf(bio_s_out, "ALPN protocols advertised by the client: "); for (i = 0; i < inlen;) { if (i) BIO_write(bio_s_out, ", ", 2); BIO_write(bio_s_out, &in[i + 1], in[i]); i += in[i] + 1; } BIO_write(bio_s_out, "\n", 1); } if (SSL_select_next_proto ((unsigned char **)out, outlen, alpn_ctx->data, alpn_ctx->len, in, inlen) != OPENSSL_NPN_NEGOTIATED) { return SSL_TLSEXT_ERR_NOACK; } if (!s_quiet) { BIO_printf(bio_s_out, "ALPN protocols selected: "); BIO_write(bio_s_out, *out, *outlen); BIO_write(bio_s_out, "\n", 1); } return SSL_TLSEXT_ERR_OK; } static int not_resumable_sess_cb(SSL *s, int is_forward_secure) { /* disable resumption for sessions with forward secure ciphers */ return is_forward_secure; } #ifndef OPENSSL_NO_SRP static srpsrvparm srp_callback_parm; #endif #ifndef OPENSSL_NO_SRTP static char *srtp_profiles = NULL; #endif typedef enum OPTION_choice { OPT_ERR = -1, OPT_EOF = 0, OPT_HELP, OPT_ENGINE, OPT_4, OPT_6, OPT_ACCEPT, OPT_PORT, OPT_UNIX, OPT_UNLINK, OPT_NACCEPT, OPT_VERIFY, OPT_NAMEOPT, OPT_UPPER_V_VERIFY, OPT_CONTEXT, OPT_CERT, OPT_CRL, OPT_CRL_DOWNLOAD, OPT_SERVERINFO, OPT_CERTFORM, OPT_KEY, OPT_KEYFORM, OPT_PASS, OPT_CERT_CHAIN, OPT_DHPARAM, OPT_DCERTFORM, OPT_DCERT, OPT_DKEYFORM, OPT_DPASS, OPT_DKEY, OPT_DCERT_CHAIN, OPT_NOCERT, OPT_CAPATH, OPT_NOCAPATH, OPT_CHAINCAPATH, OPT_VERIFYCAPATH, OPT_NO_CACHE, OPT_EXT_CACHE, OPT_CRLFORM, OPT_VERIFY_RET_ERROR, OPT_VERIFY_QUIET, OPT_BUILD_CHAIN, OPT_CAFILE, OPT_NOCAFILE, OPT_CHAINCAFILE, OPT_VERIFYCAFILE, OPT_NBIO, OPT_NBIO_TEST, OPT_IGN_EOF, OPT_NO_IGN_EOF, OPT_DEBUG, OPT_TLSEXTDEBUG, OPT_STATUS, OPT_STATUS_VERBOSE, OPT_STATUS_TIMEOUT, OPT_STATUS_URL, OPT_STATUS_FILE, OPT_MSG, OPT_MSGFILE, OPT_TRACE, OPT_SECURITY_DEBUG, OPT_SECURITY_DEBUG_VERBOSE, OPT_STATE, OPT_CRLF, OPT_QUIET, OPT_BRIEF, OPT_NO_DHE, OPT_NO_RESUME_EPHEMERAL, OPT_PSK_IDENTITY, OPT_PSK_HINT, OPT_PSK, OPT_PSK_SESS, OPT_SRPVFILE, OPT_SRPUSERSEED, OPT_REV, OPT_WWW, OPT_UPPER_WWW, OPT_HTTP, OPT_ASYNC, OPT_SSL_CONFIG, OPT_MAX_SEND_FRAG, OPT_SPLIT_SEND_FRAG, OPT_MAX_PIPELINES, OPT_READ_BUF, OPT_SSL3, OPT_TLS1_3, OPT_TLS1_2, OPT_TLS1_1, OPT_TLS1, OPT_DTLS, OPT_DTLS1, OPT_DTLS1_2, OPT_SCTP, OPT_TIMEOUT, OPT_MTU, OPT_LISTEN, OPT_ID_PREFIX, OPT_SERVERNAME, OPT_SERVERNAME_FATAL, OPT_CERT2, OPT_KEY2, OPT_NEXTPROTONEG, OPT_ALPN, OPT_SRTP_PROFILES, OPT_KEYMATEXPORT, OPT_KEYMATEXPORTLEN, OPT_KEYLOG_FILE, OPT_MAX_EARLY, OPT_EARLY_DATA, OPT_R_ENUM, OPT_S_ENUM, OPT_V_ENUM, OPT_X_ENUM } OPTION_CHOICE; const OPTIONS s_server_options[] = { {"help", OPT_HELP,

, "Display this summary"}, {"port", OPT_PORT,

, "TCP/IP port to listen on for connections (default is " PORT ")"}, {"accept", OPT_ACCEPT,

, "TCP/IP optional host and port to listen on for connections (default is *:" PORT ")"}, #ifdef AF_UNIX {"unix", OPT_UNIX,

, "Unix domain socket to accept on"}, #endif {"4", OPT_4,

, "Use IPv4 only"}, {"6", OPT_6,

, "Use IPv6 only"}, #ifdef AF_UNIX {"unlink", OPT_UNLINK,

, "For -unix, unlink existing socket first"}, #endif {"context", OPT_CONTEXT,

, "Set session ID context"}, {"verify", OPT_VERIFY,

, "Turn on peer certificate verification"}, {"Verify", OPT_UPPER_V_VERIFY,

, "Turn on peer certificate verification, must have a cert"}, {"cert", OPT_CERT,

, "Certificate file to use; default is " TEST_CERT}, {"nameopt", OPT_NAMEOPT,

, "Various certificate name options"}, {"naccept", OPT_NACCEPT,

, "Terminate after #num connections"}, {"serverinfo", OPT_SERVERINFO,

, "PEM serverinfo file for certificate"}, {"certform", OPT_CERTFORM,

, "Certificate format (PEM or DER) PEM default"}, {"key", OPT_KEY,

, "Private Key if not in -cert; default is " TEST_CERT}, {"keyform", OPT_KEYFORM,

, "Key format (PEM, DER or ENGINE) PEM default"}, {"pass", OPT_PASS,

, "Private key file pass phrase source"}, {"dcert", OPT_DCERT,

, "Second certificate file to use (usually for DSA)"}, {"dcertform", OPT_DCERTFORM,

, "Second certificate format (PEM or DER) PEM default"}, {"dkey", OPT_DKEY,

, "Second private key file to use (usually for DSA)"}, {"dkeyform", OPT_DKEYFORM,

, "Second key format (PEM, DER or ENGINE) PEM default"}, {"dpass", OPT_DPASS,

, "Second private key file pass phrase source"}, {"nbio_test", OPT_NBIO_TEST,

, "Test with the non-blocking test bio"}, {"crlf", OPT_CRLF,

, "Convert LF from terminal into CRLF"}, {"debug", OPT_DEBUG,

, "Print more output"}, {"msg", OPT_MSG,

, "Show protocol messages"}, {"msgfile", OPT_MSGFILE,

, "File to send output of -msg or -trace, instead of stdout"}, {"state", OPT_STATE,

, "Print the SSL states"}, {"CAfile", OPT_CAFILE,

, "PEM format file of CA

}, {

, OPT_CAPATH, '/',

s"}, {"no-CAfile", OPT_NOCAFILE,

, "Do not load the default certificates file"}, {"no-CApath", OPT_NOCAPATH,

, "Do not load certificates from the default certificates directory"}, {"nocert", OPT_NOCERT,

, "Don

}, {

, OPT_QUIET, '-',

}, {

, OPT_NO_RESUME_EPHEMERAL, '-',

}, {

, OPT_WWW, '-',

GET /

}, {

, OPT_UPPER_WWW, '-',

GET with the file ./path"}, {"servername", OPT_SERVERNAME,

, "Servername for HostName TLS extension"}, {"servername_fatal", OPT_SERVERNAME_FATAL,

, "mismatch send fatal alert (default warning alert)"}, {"cert2", OPT_CERT2,

, "Certificate file to use for servername; default is" TEST_CERT2}, {"key2", OPT_KEY2,

, "-Private Key file to use for servername if not in -cert2"}, {"tlsextdebug", OPT_TLSEXTDEBUG,

, "Hex dump of all TLS extensions received"}, {"HTTP", OPT_HTTP,

, "Like -WWW but ./path includes HTTP headers"}, {"id_prefix", OPT_ID_PREFIX,

, "Generate SSL/TLS session IDs prefixed by arg"}, OPT_R_OPTIONS, {"keymatexport", OPT_KEYMATEXPORT,

, "Export keying material using label"}, {"keymatexportlen", OPT_KEYMATEXPORTLEN,

, "Export len bytes of keying material (default 20)"}, {"CRL", OPT_CRL,

, "CRL file to use"}, {"crl_download", OPT_CRL_DOWNLOAD,

, "Download CRL from distribution points"}, {"cert_chain", OPT_CERT_CHAIN,

, "certificate chain file in PEM format"}, {"dcert_chain", OPT_DCERT_CHAIN,

, "second certificate chain file in PEM format"}, {"chainCApath", OPT_CHAINCAPATH,

, "use dir as certificate store path to build CA certificate chain"}, {"verifyCApath", OPT_VERIFYCAPATH,

, "use dir as certificate store path to verify CA certificate"}, {"no_cache", OPT_NO_CACHE,

, "Disable session cache"}, {"ext_cache", OPT_EXT_CACHE,

, "Disable internal cache, setup and use external cache"}, {"CRLform", OPT_CRLFORM,

, "CRL format (PEM or DER) PEM is default"}, {"verify_return_error", OPT_VERIFY_RET_ERROR,

, "Close connection on verification error"}, {"verify_quiet", OPT_VERIFY_QUIET,

, "No verify output except verify errors"}, {"build_chain", OPT_BUILD_CHAIN,

, "Build certificate chain"}, {"chainCAfile", OPT_CHAINCAFILE,

, "CA file for certificate chain (PEM format)"}, {"verifyCAfile", OPT_VERIFYCAFILE,

, "CA file for certificate verification (PEM format)"}, {"ign_eof", OPT_IGN_EOF,

, "ignore input eof (default when -quiet)"}, {"no_ign_eof", OPT_NO_IGN_EOF,

, "Do not ignore input eof"}, #ifndef OPENSSL_NO_OCSP {"status", OPT_STATUS,

, "Request certificate status from server"}, {"status_verbose", OPT_STATUS_VERBOSE,

, "Print more output in certificate status callback"}, {"status_timeout", OPT_STATUS_TIMEOUT,

, "Status request responder timeout"}, {"status_url", OPT_STATUS_URL,

, "Status request fallback URL"}, {"status_file", OPT_STATUS_FILE,

, "File containing DER encoded OCSP Response"}, #endif #ifndef OPENSSL_NO_SSL_TRACE {"trace", OPT_TRACE,

, "trace protocol messages"}, #endif {"security_debug", OPT_SECURITY_DEBUG,

, "Print output from SSL/TLS security framework"}, {"security_debug_verbose", OPT_SECURITY_DEBUG_VERBOSE,

, "Print more output from SSL/TLS security framework"}, {"brief", OPT_BRIEF,

, "Restrict output to brief summary of connection parameters"}, {"rev", OPT_REV,

, "act as a simple test server which just sends back with the received text reversed"}, {"async", OPT_ASYNC,

, "Operate in asynchronous mode"}, {"ssl_config", OPT_SSL_CONFIG,

, "Configure SSL_CTX using the configuration

"}, {"max_send_frag", OPT_MAX_SEND_FRAG,

, "Maximum Size of send frames "}, {"split_send_frag", OPT_SPLIT_SEND_FRAG,

, "Size used to split data for encrypt pipelines"}, {"max_pipelines", OPT_MAX_PIPELINES,

, "Maximum number of encrypt/decrypt pipelines to be used"}, {"read_buf", OPT_READ_BUF,

, "Default read buffer size to be used for connections"}, OPT_S_OPTIONS, OPT_V_OPTIONS, OPT_X_OPTIONS, {"nbio", OPT_NBIO,

, "Use non-blocking IO"}, {"psk_identity", OPT_PSK_IDENTITY,

, "PSK identity to expect"}, #ifndef OPENSSL_NO_PSK {"psk_hint", OPT_PSK_HINT,

, "PSK identity hint to use"}, #endif {"psk", OPT_PSK,

, "PSK in hex (without 0x)"}, {"psk_session", OPT_PSK_SESS,

, "File to read PSK SSL session from"}, #ifndef OPENSSL_NO_SRP {"srpvfile", OPT_SRPVFILE,

, "The verifier file for SRP"}, {"srpuserseed", OPT_SRPUSERSEED,

, "A seed string for a default user salt"}, #endif #ifndef OPENSSL_NO_SSL3 {"ssl3", OPT_SSL3,

, "Just talk SSLv3"}, #endif #ifndef OPENSSL_NO_TLS1 {"tls1", OPT_TLS1,

, "Just talk TLSv1"}, #endif #ifndef OPENSSL_NO_TLS1_1 {"tls1_1", OPT_TLS1_1,

, "Just talk TLSv1.1"}, #endif #ifndef OPENSSL_NO_TLS1_2 {"tls1_2", OPT_TLS1_2,

, "just talk TLSv1.2"}, #endif #ifndef OPENSSL_NO_TLS1_3 {"tls1_3", OPT_TLS1_3,

, "just talk TLSv1.3"}, #endif #ifndef OPENSSL_NO_DTLS {"dtls", OPT_DTLS,

, "Use any DTLS version"}, {"timeout", OPT_TIMEOUT,

, "Enable timeouts"}, {"mtu", OPT_MTU,

, "Set link layer MTU"}, {"listen", OPT_LISTEN,

, "Listen for a DTLS ClientHello with a cookie and then connect"}, #endif #ifndef OPENSSL_NO_DTLS1 {"dtls1", OPT_DTLS1,

, "Just talk DTLSv1"}, #endif #ifndef OPENSSL_NO_DTLS1_2 {"dtls1_2", OPT_DTLS1_2,

, "Just talk DTLSv1.2"}, #endif #ifndef OPENSSL_NO_SCTP {"sctp", OPT_SCTP,

, "Use SCTP"}, #endif #ifndef OPENSSL_NO_DH {"no_dhe", OPT_NO_DHE,

, "Disable ephemeral DH"}, #endif #ifndef OPENSSL_NO_NEXTPROTONEG {"nextprotoneg", OPT_NEXTPROTONEG,

, "Set the advertised protocols for the NPN extension (comma-separated list)"}, #endif #ifndef OPENSSL_NO_SRTP {"use_srtp", OPT_SRTP_PROFILES,

, "Offer SRTP key management with a colon-separated profile list"}, #endif {"alpn", OPT_ALPN,

, "Set the advertised protocols for the ALPN extension (comma-separated list)"}, #ifndef OPENSSL_NO_ENGINE {"engine", OPT_ENGINE,

, "Use engine, possibly a hardware device"}, #endif {"keylogfile", OPT_KEYLOG_FILE,

, "Write TLS secrets to file"}, {"max_early_data", OPT_MAX_EARLY,

, "The maximum number of bytes of early data"}, {"early_data", OPT_EARLY_DATA,

, "Attempt to read early data"}, {NULL, OPT_EOF, 0, NULL} }; #define IS_PROT_FLAG(o) \ (o == OPT_SSL3 || o == OPT_TLS1 || o == OPT_TLS1_1 || o == OPT_TLS1_2 \ || o == OPT_TLS1_3 || o == OPT_DTLS || o == OPT_DTLS1 || o == OPT_DTLS1_2) int s_server_main(int argc, char *argv[]) { ENGINE *engine = NULL; EVP_PKEY *s_key = NULL, *s_dkey = NULL; SSL_CONF_CTX *cctx = NULL; const SSL_METHOD *meth = TLS_server_method(); SSL_EXCERT *exc = NULL; STACK_OF(OPENSSL_STRING) *ssl_args = NULL; STACK_OF(X509) *s_chain = NULL, *s_dchain = NULL; STACK_OF(X509_CRL) *crls = NULL; X509 *s_cert = NULL, *s_dcert = NULL; X509_VERIFY_PARAM *vpm = NULL; const char *CApath = NULL, *CAfile = NULL, *chCApath = NULL, *chCAfile = NULL; char *dpassarg = NULL, *dpass = NULL; char *passarg = NULL, *pass = NULL, *vfyCApath = NULL, *vfyCAfile = NULL; char *crl_file = NULL, *prog; #ifdef AF_UNIX int unlink_unix_path = 0; #endif do_server_cb server_cb; int vpmtouched = 0, build_chain = 0, no_cache = 0, ext_cache = 0; #ifndef OPENSSL_NO_DH char *dhfile = NULL; int no_dhe = 0; #endif int nocert = 0, ret = 1; int noCApath = 0, noCAfile = 0; int s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM; int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM; int rev = 0, naccept = -1, sdebug = 0; int socket_family = AF_UNSPEC, socket_type = SOCK_STREAM, protocol = 0; int state = 0, crl_format = FORMAT_PEM, crl_download = 0; char *host = NULL; char *port = BUF_strdup(PORT); unsigned char *context = NULL; OPTION_CHOICE o; EVP_PKEY *s_key2 = NULL; X509 *s_cert2 = NULL; tlsextctx tlsextcbp = { NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING }; const char *ssl_config = NULL; int read_buf_len = 0; #ifndef OPENSSL_NO_NEXTPROTONEG const char *next_proto_neg_in = NULL; tlsextnextprotoctx next_proto = { NULL, 0 }; #endif const char *alpn_in = NULL; tlsextalpnctx alpn_ctx = { NULL, 0 }; #ifndef OPENSSL_NO_PSK /* by default do not send a PSK identity hint */ char *psk_identity_hint = NULL; #endif char *p; #ifndef OPENSSL_NO_SRP char *srpuserseed = NULL; char *srp_verifier_file = NULL; #endif int min_version = 0, max_version = 0, prot_opt = 0, no_prot_opt = 0; int s_server_verify = SSL_VERIFY_NONE; int s_server_session_id_context = 1; /* anything will do */ const char *s_cert_file = TEST_CERT, *s_key_file = NULL, *s_chain_file = NULL; const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL; char *s_dcert_file = NULL, *s_dkey_file = NULL, *s_dchain_file = NULL; #ifndef OPENSSL_NO_OCSP int s_tlsextstatus = 0; #endif int no_resume_ephemeral = 0; unsigned int max_send_fragment = 0; unsigned int split_send_fragment = 0, max_pipelines = 0; const char *s_serverinfo_file = NULL; const char *keylog_file = NULL; int max_early_data = -1; char *psksessf = NULL; /* Init of few remaining global variables */ local_argc = argc; local_argv = argv; ctx = ctx2 = NULL; s_nbio = s_nbio_test = 0; www = 0; bio_s_out = NULL; s_debug = 0; s_msg = 0; s_quiet = 0; s_brief = 0; async = 0; cctx = SSL_CONF_CTX_new(); vpm = X509_VERIFY_PARAM_new(); if (cctx == NULL || vpm == NULL) goto end; SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER | SSL_CONF_FLAG_CMDLINE); prog = opt_init(argc, argv, s_server_options); while ((o = opt_next()) != OPT_EOF) { if (IS_PROT_FLAG(o) && ++prot_opt > 1) { BIO_printf(bio_err, "Cannot supply multiple protocol flags\n"); goto end; } if (IS_NO_PROT_FLAG(o)) no_prot_opt++; if (prot_opt == 1 && no_prot_opt) { BIO_printf(bio_err, "Cannot supply both a protocol flag and

\n"); goto end; } switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, "%s: Use -help for summary.\n", prog); goto end; case OPT_HELP: opt_help(s_server_options); ret = 0; goto end; case OPT_4: #ifdef AF_UNIX if (socket_family == AF_UNIX) { OPENSSL_free(host); host = NULL; OPENSSL_free(port); port = NULL; } #endif socket_family = AF_INET; break; case OPT_6: if (1) { #ifdef AF_INET6 #ifdef AF_UNIX if (socket_family == AF_UNIX) { OPENSSL_free(host); host = NULL; OPENSSL_free(port); port = NULL; } #endif socket_family = AF_INET6; } else { #endif BIO_printf(bio_err, "%s: IPv6 domain sockets unsupported\n", prog); goto end; } break; case OPT_PORT: #ifdef AF_UNIX if (socket_family == AF_UNIX) { socket_family = AF_UNSPEC; } #endif OPENSSL_free(port); port = NULL; OPENSSL_free(host); host = NULL; if (BIO_parse_hostserv(opt_arg(), NULL, &port, BIO_PARSE_PRIO_SERV) < 1) { BIO_printf(bio_err, "%s: -port argument malformed or ambiguous\n", port); goto end; } break; case OPT_ACCEPT: #ifdef AF_UNIX if (socket_family == AF_UNIX) { socket_family = AF_UNSPEC; } #endif OPENSSL_free(port); port = NULL; OPENSSL_free(host); host = NULL; if (BIO_parse_hostserv(opt_arg(), &host, &port, BIO_PARSE_PRIO_SERV) < 1) { BIO_printf(bio_err, "%s: -accept argument malformed or ambiguous\n", port); goto end; } break; #ifdef AF_UNIX case OPT_UNIX: socket_family = AF_UNIX; OPENSSL_free(host); host = BUF_strdup(opt_arg()); OPENSSL_free(port); port = NULL; break; case OPT_UNLINK: unlink_unix_path = 1; break; #endif case OPT_NACCEPT: naccept = atol(opt_arg()); break; case OPT_VERIFY: s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE; verify_args.depth = atoi(opt_arg()); if (!s_quiet) BIO_printf(bio_err, "verify depth is %d\n", verify_args.depth); break; case OPT_UPPER_V_VERIFY: s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT | SSL_VERIFY_CLIENT_ONCE; verify_args.depth = atoi(opt_arg()); if (!s_quiet) BIO_printf(bio_err, "verify depth is %d, must return a certificate\n", verify_args.depth); break; case OPT_CONTEXT: context = (unsigned char *)opt_arg(); break; case OPT_CERT: s_cert_file = opt_arg(); break; case OPT_NAMEOPT: if (!set_nameopt(opt_arg())) goto end; break; case OPT_CRL: crl_file = opt_arg(); break; case OPT_CRL_DOWNLOAD: crl_download = 1; break; case OPT_SERVERINFO: s_serverinfo_file = opt_arg(); break; case OPT_CERTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &s_cert_format)) goto opthelp; break; case OPT_KEY: s_key_file = opt_arg(); break; case OPT_KEYFORM: if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_key_format)) goto opthelp; break; case OPT_PASS: passarg = opt_arg(); break; case OPT_CERT_CHAIN: s_chain_file = opt_arg(); break; case OPT_DHPARAM: #ifndef OPENSSL_NO_DH dhfile = opt_arg(); #endif break; case OPT_DCERTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &s_dcert_format)) goto opthelp; break; case OPT_DCERT: s_dcert_file = opt_arg(); break; case OPT_DKEYFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &s_dkey_format)) goto opthelp; break; case OPT_DPASS: dpassarg = opt_arg(); break; case OPT_DKEY: s_dkey_file = opt_arg(); break; case OPT_DCERT_CHAIN: s_dchain_file = opt_arg(); break; case OPT_NOCERT: nocert = 1; break; case OPT_CAPATH: CApath = opt_arg(); break; case OPT_NOCAPATH: noCApath = 1; break; case OPT_CHAINCAPATH: chCApath = opt_arg(); break; case OPT_VERIFYCAPATH: vfyCApath = opt_arg(); break; case OPT_NO_CACHE: no_cache = 1; break; case OPT_EXT_CACHE: ext_cache = 1; break; case OPT_CRLFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &crl_format)) goto opthelp; break; case OPT_S_CASES: if (ssl_args == NULL) ssl_args = sk_OPENSSL_STRING_new_null(); if (ssl_args == NULL || !sk_OPENSSL_STRING_push(ssl_args, opt_flag()) || !sk_OPENSSL_STRING_push(ssl_args, opt_arg())) { BIO_printf(bio_err, "%s: Memory allocation failure\n", prog); goto end; } break; case OPT_V_CASES: if (!opt_verify(o, vpm)) goto end; vpmtouched++; break; case OPT_X_CASES: if (!args_excert(o, &exc)) goto end; break; case OPT_VERIFY_RET_ERROR: verify_args.return_error = 1; break; case OPT_VERIFY_QUIET: verify_args.quiet = 1; break; case OPT_BUILD_CHAIN: build_chain = 1; break; case OPT_CAFILE: CAfile = opt_arg(); break; case OPT_NOCAFILE: noCAfile = 1; break; case OPT_CHAINCAFILE: chCAfile = opt_arg(); break; case OPT_VERIFYCAFILE: vfyCAfile = opt_arg(); break; case OPT_NBIO: s_nbio = 1; break; case OPT_NBIO_TEST: s_nbio = s_nbio_test = 1; break; case OPT_IGN_EOF: s_ign_eof = 1; break; case OPT_NO_IGN_EOF: s_ign_eof = 0; break; case OPT_DEBUG: s_debug = 1; break; case OPT_TLSEXTDEBUG: s_tlsextdebug = 1; break; case OPT_STATUS: #ifndef OPENSSL_NO_OCSP s_tlsextstatus = 1; #endif break; case OPT_STATUS_VERBOSE: #ifndef OPENSSL_NO_OCSP s_tlsextstatus = tlscstatp.verbose = 1; #endif break; case OPT_STATUS_TIMEOUT: #ifndef OPENSSL_NO_OCSP s_tlsextstatus = 1; tlscstatp.timeout = atoi(opt_arg()); #endif break; case OPT_STATUS_URL: #ifndef OPENSSL_NO_OCSP s_tlsextstatus = 1; if (!OCSP_parse_url(opt_arg(), &tlscstatp.host, &tlscstatp.port, &tlscstatp.path, &tlscstatp.use_ssl)) { BIO_printf(bio_err, "Error parsing URL\n"); goto end; } #endif break; case OPT_STATUS_FILE: #ifndef OPENSSL_NO_OCSP s_tlsextstatus = 1; tlscstatp.respin = opt_arg(); #endif break; case OPT_MSG: s_msg = 1; break; case OPT_MSGFILE: bio_s_msg = BIO_new_file(opt_arg(), "w"); break; case OPT_TRACE: #ifndef OPENSSL_NO_SSL_TRACE s_msg = 2; #endif break; case OPT_SECURITY_DEBUG: sdebug = 1; break; case OPT_SECURITY_DEBUG_VERBOSE: sdebug = 2; break; case OPT_STATE: state = 1; break; case OPT_CRLF: s_crlf = 1; break; case OPT_QUIET: s_quiet = 1; break; case OPT_BRIEF: s_quiet = s_brief = verify_args.quiet = 1; break; case OPT_NO_DHE: #ifndef OPENSSL_NO_DH no_dhe = 1; #endif break; case OPT_NO_RESUME_EPHEMERAL: no_resume_ephemeral = 1; break; case OPT_PSK_IDENTITY: psk_identity = opt_arg(); break; case OPT_PSK_HINT: #ifndef OPENSSL_NO_PSK psk_identity_hint = opt_arg(); #endif break; case OPT_PSK: for (p = psk_key = opt_arg(); *p; p++) { if (isxdigit(_UC(*p))) continue; BIO_printf(bio_err, "Not a hex number

\n", *argv); goto end; } break; case OPT_PSK_SESS: psksessf = opt_arg(); break; case OPT_SRPVFILE: #ifndef OPENSSL_NO_SRP srp_verifier_file = opt_arg(); if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; #endif break; case OPT_SRPUSERSEED: #ifndef OPENSSL_NO_SRP srpuserseed = opt_arg(); if (min_version < TLS1_VERSION) min_version = TLS1_VERSION; #endif break; case OPT_REV: rev = 1; break; case OPT_WWW: www = 1; break; case OPT_UPPER_WWW: www = 2; break; case OPT_HTTP: www = 3; break; case OPT_SSL_CONFIG: ssl_config = opt_arg(); break; case OPT_SSL3: min_version = SSL3_VERSION; max_version = SSL3_VERSION; break; case OPT_TLS1_3: min_version = TLS1_3_VERSION; max_version = TLS1_3_VERSION; break; case OPT_TLS1_2: min_version = TLS1_2_VERSION; max_version = TLS1_2_VERSION; break; case OPT_TLS1_1: min_version = TLS1_1_VERSION; max_version = TLS1_1_VERSION; break; case OPT_TLS1: min_version = TLS1_VERSION; max_version = TLS1_VERSION; break; case OPT_DTLS: #ifndef OPENSSL_NO_DTLS meth = DTLS_server_method(); socket_type = SOCK_DGRAM; #endif break; case OPT_DTLS1: #ifndef OPENSSL_NO_DTLS meth = DTLS_server_method(); min_version = DTLS1_VERSION; max_version = DTLS1_VERSION; socket_type = SOCK_DGRAM; #endif break; case OPT_DTLS1_2: #ifndef OPENSSL_NO_DTLS meth = DTLS_server_method(); min_version = DTLS1_2_VERSION; max_version = DTLS1_2_VERSION; socket_type = SOCK_DGRAM; #endif break; case OPT_SCTP: #ifndef OPENSSL_NO_SCTP protocol = IPPROTO_SCTP; #endif break; case OPT_TIMEOUT: #ifndef OPENSSL_NO_DTLS enable_timeouts = 1; #endif break; case OPT_MTU: #ifndef OPENSSL_NO_DTLS socket_mtu = atol(opt_arg()); #endif break; case OPT_LISTEN: #ifndef OPENSSL_NO_DTLS dtlslisten = 1; #endif break; case OPT_ID_PREFIX: session_id_prefix = opt_arg(); break; case OPT_ENGINE: engine = setup_engine(opt_arg(), 1); break; case OPT_R_CASES: if (!opt_rand(o)) goto end; break; case OPT_SERVERNAME: tlsextcbp.servername = opt_arg(); break; case OPT_SERVERNAME_FATAL: tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL; break; case OPT_CERT2: s_cert_file2 = opt_arg(); break; case OPT_KEY2: s_key_file2 = opt_arg(); break; case OPT_NEXTPROTONEG: # ifndef OPENSSL_NO_NEXTPROTONEG next_proto_neg_in = opt_arg(); #endif break; case OPT_ALPN: alpn_in = opt_arg(); break; case OPT_SRTP_PROFILES: #ifndef OPENSSL_NO_SRTP srtp_profiles = opt_arg(); #endif break; case OPT_KEYMATEXPORT: keymatexportlabel = opt_arg(); break; case OPT_KEYMATEXPORTLEN: keymatexportlen = atoi(opt_arg()); break; case OPT_ASYNC: async = 1; break; case OPT_MAX_SEND_FRAG: max_send_fragment = atoi(opt_arg()); break; case OPT_SPLIT_SEND_FRAG: split_send_fragment = atoi(opt_arg()); break; case OPT_MAX_PIPELINES: max_pipelines = atoi(opt_arg()); break; case OPT_READ_BUF: read_buf_len = atoi(opt_arg()); break; case OPT_KEYLOG_FILE: keylog_file = opt_arg(); break; case OPT_MAX_EARLY: max_early_data = atoi(opt_arg()); if (max_early_data < 0) { BIO_printf(bio_err, "Invalid value for max_early_data\n"); goto end; } break; case OPT_EARLY_DATA: early_data = 1; break; } } argc = opt_num_rest(); argv = opt_rest(); #ifndef OPENSSL_NO_NEXTPROTONEG if (min_version == TLS1_3_VERSION && next_proto_neg_in != NULL) { BIO_printf(bio_err, "Cannot supply -nextprotoneg with TLSv1.3\n"); goto opthelp; } #endif #ifndef OPENSSL_NO_DTLS if (www && socket_type == SOCK_DGRAM) { BIO_printf(bio_err, "Can

); goto end; } if (dtlslisten && socket_type != SOCK_DGRAM) { BIO_printf(bio_err,

); goto end; } #endif #ifdef AF_UNIX if (socket_family == AF_UNIX && socket_type != SOCK_STREAM) { BIO_printf(bio_err,

t use unix sockets and datagrams together\n"); goto end; } #endif #ifndef OPENSSL_NO_SCTP if (protocol == IPPROTO_SCTP) { if (socket_type != SOCK_DGRAM) { BIO_printf(bio_err, "Can

); goto end; } /* SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol */ socket_type = SOCK_STREAM; } #endif if (!app_passwd(passarg, dpassarg, &pass, &dpass)) { BIO_printf(bio_err,

); goto end; } if (s_key_file == NULL) s_key_file = s_cert_file; if (s_key_file2 == NULL) s_key_file2 = s_cert_file2; if (!load_excert(&exc)) goto end; if (nocert == 0) { s_key = load_key(s_key_file, s_key_format, 0, pass, engine,

); if (s_key == NULL) { ERR_print_errors(bio_err); goto end; } s_cert = load_cert(s_cert_file, s_cert_format,

); if (s_cert == NULL) { ERR_print_errors(bio_err); goto end; } if (s_chain_file != NULL) { if (!load_certs(s_chain_file, &s_chain, FORMAT_PEM, NULL,

)) goto end; } if (tlsextcbp.servername != NULL) { s_key2 = load_key(s_key_file2, s_key_format, 0, pass, engine,

); if (s_key2 == NULL) { ERR_print_errors(bio_err); goto end; } s_cert2 = load_cert(s_cert_file2, s_cert_format,

); if (s_cert2 == NULL) { ERR_print_errors(bio_err); goto end; } } } #if !defined(OPENSSL_NO_NEXTPROTONEG) if (next_proto_neg_in) { next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in); if (next_proto.data == NULL) goto end; } #endif alpn_ctx.data = NULL; if (alpn_in) { alpn_ctx.data = next_protos_parse(&alpn_ctx.len, alpn_in); if (alpn_ctx.data == NULL) goto end; } if (crl_file != NULL) { X509_CRL *crl; crl = load_crl(crl_file, crl_format); if (crl == NULL) { BIO_puts(bio_err,

); ERR_print_errors(bio_err); goto end; } crls = sk_X509_CRL_new_null(); if (crls == NULL || !sk_X509_CRL_push(crls, crl)) { BIO_puts(bio_err,

); ERR_print_errors(bio_err); X509_CRL_free(crl); goto end; } } if (s_dcert_file != NULL) { if (s_dkey_file == NULL) s_dkey_file = s_dcert_file; s_dkey = load_key(s_dkey_file, s_dkey_format, 0, dpass, engine,

); if (s_dkey == NULL) { ERR_print_errors(bio_err); goto end; } s_dcert = load_cert(s_dcert_file, s_dcert_format,

); if (s_dcert == NULL) { ERR_print_errors(bio_err); goto end; } if (s_dchain_file != NULL) { if (!load_certs(s_dchain_file, &s_dchain, FORMAT_PEM, NULL,

)) goto end; } } if (bio_s_out == NULL) { if (s_quiet && !s_debug) { bio_s_out = BIO_new(BIO_s_null()); if (s_msg && bio_s_msg == NULL) bio_s_msg = dup_bio_out(FORMAT_TEXT); } else { if (bio_s_out == NULL) bio_s_out = dup_bio_out(FORMAT_TEXT); } } #if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_EC) if (nocert) #endif { s_cert_file = NULL; s_key_file = NULL; s_dcert_file = NULL; s_dkey_file = NULL; s_cert_file2 = NULL; s_key_file2 = NULL; } ctx = SSL_CTX_new(meth); if (ctx == NULL) { ERR_print_errors(bio_err); goto end; } if (sdebug) ssl_ctx_security_debug(ctx, sdebug); if (ssl_config) { if (SSL_CTX_config(ctx, ssl_config) == 0) { BIO_printf(bio_err,

%s\"\n

warning: id_prefix is too long, only one new session will be possible\n

error setting 'id_prefix'\n

id_prefix '%s' set.\n

%s: Max send fragment size %u is out of permitted range\n

%s: Split send fragment size %u is out of permitted range\n

%s: Max pipelines %u is out of permitted range\n

Error setting SRTP profile\n

Error setting verify params\n

Error loading store locations\n

Setting secondary ctx parameters\n

warning: id_prefix is too long, only one new session will be possible\n

error setting 'id_prefix'\n

id_prefix '%s' set.\n

Error setting verify params\n

Setting temp DH parameters\n

Using default temp DH parameters\n

Error setting temp DH parameters\n

Setting temp DH parameters\n

Error setting temp DH parameters\n

PSK key given, setting server callback\n

error setting PSK identity hint to context\n

r

Can't open PSK session file %s\n

Can't read PSK session file %s\n

error setting session id context\n

error setting session id context\n

Cannot initialize SRP verifier file \"%s\":ret=%d\n

ACCEPT\n

%4ld items in the session cache\n

%4ld client connects (SSL_connect())\n

%4ld client renegotiates (SSL_connect())\n

%4ld client connects that finished\n

%4ld server accepts (SSL_accept())\n

%4ld server renegotiates (SSL_accept())\n

%4ld server accepts that finished\n

%4ld session cache hits\n

%4ld session cache misses\n

%4ld session cache timeouts\n

%4ld callback cache hits\n

%4ld cache full overflows (%ld allowed)\n

server buffer

Turned on non blocking io\n

Error setting session id context\n

Error clearing SSL connection\n

MTU too small. Must be at least %ld\n

Failed to set MTU\n

Unable to create BIO\n

Error reading early data\n

Early data received:\n

No early data received\n

\nEnd of early data\n

t have a cast it will choke the compiler: * if you do have a cast then you can either go for (int *) or * (void *). */ #if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) /* * Under DOS (non-djgpp) and Windows we can

t do this because it is inefficient. */ tv.tv_sec = 1; tv.tv_usec = 0; i = select(width, (void *)&readfds, NULL, NULL, &tv); if (has_stdin_waiting()) read_from_terminal = 1; if ((i < 0) || (!i && !read_from_terminal)) continue; #else if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_get_timeout(con, &timeout)) timeoutp = &timeout; else timeoutp = NULL; i = select(width, (void *)&readfds, NULL, NULL, timeoutp); if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0) { BIO_printf(bio_err, "TIMEOUT occurred\n"); } if (i <= 0) continue; if (FD_ISSET(fileno_stdin(), &readfds)) read_from_terminal = 1; #endif if (FD_ISSET(s, &readfds)) read_from_sslcon = 1; } if (read_from_terminal) { if (s_crlf) { int j, lf_num; i = raw_read_stdin(buf, bufsize / 2); lf_num = 0; /* both loops are skipped when i <= 0 */ for (j = 0; j < i; j++) if (buf[j] ==

) lf_num++; for (j = i - 1; j >= 0; j--) { buf[j + lf_num] = buf[j]; if (buf[j] ==

) { lf_num--; i++; buf[j + lf_num] =

; } } assert(lf_num == 0); } else { i = raw_read_stdin(buf, bufsize); } if (!s_quiet && !s_brief) { if ((i <= 0) || (buf[0] ==

)) { BIO_printf(bio_s_out, "DONE\n"); (void)BIO_flush(bio_s_out); BIO_closesocket(s); close_accept_socket(); ret = -11; goto err; } if ((i <= 0) || (buf[0] ==

)) { BIO_printf(bio_s_out, "DONE\n"); (void)BIO_flush(bio_s_out); if (SSL_version(con) != DTLS1_VERSION) BIO_closesocket(s); /* * close_accept_socket(); ret= -11; */ goto err; } #ifndef OPENSSL_NO_HEARTBEATS if ((buf[0] ==

) && ((buf[1] ==

) || (buf[1] ==

))) { BIO_printf(bio_err, "HEARTBEATING\n"); SSL_heartbeat(con); i = 0; continue; } #endif if ((buf[0] ==

) && ((buf[1] ==

) || (buf[1] ==

))) { SSL_renegotiate(con); i = SSL_do_handshake(con); printf("SSL_do_handshake -> %d\n", i); i = 0; /* 13; */ continue; /* * strcpy(buf,"server side RE-NEGOTIATE\n"); */ } if ((buf[0] ==

) && ((buf[1] ==

) || (buf[1] ==

))) { SSL_set_verify(con, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, NULL); SSL_renegotiate(con); i = SSL_do_handshake(con); printf("SSL_do_handshake -> %d\n", i); i = 0; /* 13; */ continue; /* * strcpy(buf,"server side RE-NEGOTIATE asking for client * cert\n"); */ } if ((buf[0] ==

|| buf[0] ==

) && ((buf[1] ==

) || (buf[1] ==

))) { SSL_key_update(con, buf[0] ==

? SSL_KEY_UPDATE_REQUESTED : SSL_KEY_UPDATE_NOT_REQUESTED); i = SSL_do_handshake(con); printf("SSL_do_handshake -> %d\n", i); i = 0; continue; /* * strcpy(buf,"server side RE-NEGOTIATE asking for client * cert\n"); */ } if (buf[0] ==

) { static const char *str = "Lets print some clear text\n"; BIO_write(SSL_get_wbio(con), str, strlen(str)); } if (buf[0] ==

) { print_stats(bio_s_out, SSL_get_SSL_CTX(con)); } } #ifdef CHARSET_EBCDIC ebcdic2ascii(buf, buf, i); #endif l = k = 0; for (;;) { /* should do a select for the write */ #ifdef RENEG static count = 0; if (++count == 100) { count = 0; SSL_renegotiate(con); } #endif k = SSL_write(con, &(buf[l]), (unsigned int)i); #ifndef OPENSSL_NO_SRP while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) { BIO_printf(bio_s_out, "LOOKUP renego during write\n"); SRP_user_pwd_free(srp_callback_parm.user); srp_callback_parm.user = SRP_VBASE_get1_by_user(srp_callback_parm.vb, srp_callback_parm.login); if (srp_callback_parm.user) BIO_printf(bio_s_out, "LOOKUP done %s\n", srp_callback_parm.user->info); else BIO_printf(bio_s_out, "LOOKUP not successful\n"); k = SSL_write(con, &(buf[l]), (unsigned int)i); } #endif switch (SSL_get_error(con, k)) { case SSL_ERROR_NONE: break; case SSL_ERROR_WANT_ASYNC: BIO_printf(bio_s_out, "Write BLOCK (Async)\n"); (void)BIO_flush(bio_s_out); wait_for_async(con); break; case SSL_ERROR_WANT_WRITE: case SSL_ERROR_WANT_READ: case SSL_ERROR_WANT_X509_LOOKUP: BIO_printf(bio_s_out, "Write BLOCK\n"); (void)BIO_flush(bio_s_out); break; case SSL_ERROR_WANT_ASYNC_JOB: /* * This shouldn

ERROR\n

DONE\n

re * waiting for async then we shouldn

LOOKUP renego during read\n

LOOKUP done %s\n

LOOKUP not successful\n

Read BLOCK (Async)\n

Read BLOCK\n

t ever happen in s_server. Treat as an error */ case SSL_ERROR_SYSCALL: case SSL_ERROR_SSL: BIO_printf(bio_s_out, "ERROR\n"); (void)BIO_flush(bio_s_out); ERR_print_errors(bio_err); ret = 1; goto err; case SSL_ERROR_ZERO_RETURN: BIO_printf(bio_s_out, "DONE\n"); (void)BIO_flush(bio_s_out); ret = 1; goto err; } } } } err: if (con != NULL) { BIO_printf(bio_s_out, "shutting down SSL\n"); SSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN); SSL_free(con); } BIO_printf(bio_s_out, "CONNECTION CLOSED\n"); OPENSSL_clear_free(buf, bufsize); if (ret >= 0) BIO_printf(bio_s_out, "ACCEPT\n"); (void)BIO_flush(bio_s_out); return (ret); } static void close_accept_socket(void) { BIO_printf(bio_err, "shutdown accept socket\n"); if (accept_socket >= 0) { BIO_closesocket(accept_socket); } } static int is_retryable(SSL *con, int i) { int err = SSL_get_error(con, i); /* If it

ERROR - memory\n

ERROR - unable to connect\n

LOOKUP from certificate callback during accept\n

LOOKUP during accept %s\n

LOOKUP done %s\n

LOOKUP not successful\n

DELAY\n

ERROR\n

verify error:%s\n

Client certificate\n

Shared ciphers:%s\n

CIPHER is %s\n

(NONE)

NEXTPROTO is

\n

SRTP Extension negotiated, profile=%s\n

Reused session-id\n

Secure Renegotiation IS%s supported\n



NOT

Renegotiation is DISABLED\n

Keying material exporter:\n

Label: '%s'\n

Length: %i bytes\n

export key

Error\n

Keying material:

%02X

\n

r

server www buffer

Turned on non blocking io\n

read R BLOCK\n

LOOKUP renego during read\n

LOOKUP done %s\n

LOOKUP not successful\n

GET

GET /stats



GET /reneg

GET /renegcert

SSL_renegotiate -> %d\n

SSL_do_handshake() Retval %d\n

Error waiting for client response\n

re not actually expecting any data here and we ignore * any that is sent. This is just to force the handshake that * we

t * sent one there

HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n

<HTML><BODY BGCOLOR=\"#ffffff\">\n

<pre>\n

\n

<

&lt;

>

&gt;

&

&amp;



\n

Secure Renegotiation IS%s supported\n



NOT

Ciphers supported in s_server binary\n

%-11s:%-25s

\n

\n

---\nCiphers common between both SSL end points:\n

:



\n

\n

---\nReused,

---\nNew,

%s, Cipher is %s\n

---\n

---\n

Client certificate\n

no client certificate available\n

</pre></BODY></HTML>\r\n\r\n

GET /

HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n

/

\0



.

.

/

/

..

\0

'%s' is an invalid file name\r\n

\0

'%s' contains '..' reference\r\n

/

'%s' is an invalid path\r\n

'%s' is a directory\r\n

r

Error opening '%s'\r\n

FILE:%s\n

.html

.php

.htm

HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n

HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n

%d\n

RENEGOTIATE\n

rwrite W BLOCK\n

ACCEPT\n

server rev buffer

CONNECTION FAILURE\n

LOOKUP renego during accept\n

LOOKUP done %s\n

LOOKUP not successful\n

CONNECTION ESTABLISHED\n

read R BLOCK\n

LOOKUP renego during read\n

LOOKUP done %s\n

LOOKUP not successful\n

CONNECTION CLOSED\n

\n

\r

CLOSE

CONNECTION CLOSED\n

\n

get session

Error encoding session\n

get session buffer

Out of memory adding to external cache\n

Unexpected session encoding length\n

New session added to external cache\n

Lookup session: cache hit\n

Lookup session: cache miss\n

0x0200)

0x)"},

