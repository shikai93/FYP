Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

socket-related functions used by s_client and s_server

With IPv6, it looks like Digital has mixed up the proper order of recursive header file inclusion, resulting in the compiler complaining that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which is needed to have fileno() declared correctly... So let's define u_int

init_client - helper routine to set up socket communication @sock: pointer to storage of resulting socket. @host: the host name or path (for AF_UNIX) to connect to. @port: the port to connect to (ignored for AF_UNIX). @family: desired socket family, may be AF_INET, AF_INET6, AF_UNIX or AF_UNSPEC @type: socket type, must be SOCK_STREAM or SOCK_DGRAM @protocol: socket protocol, e.g. IPPROTO_TCP or IPPROTO_UDP (or 0 for any) This will create a socket and use it to connect to a host:port, or if family == AF_UNIX, to the path found in host. If the host has more than one address, it will try them one by one until a successful connection is established. The resulting socket will be found in sock on success, it will be given INVALID_SOCKET otherwise. Returns 1 on success, 0 on failure.

Admittedly, these checks are quite paranoid, we should not get anything in the BIO_ADDRINFO chain that we haven't asked for.

Maybe the kernel doesn't support the socket family, even if BIO_lookup() added it in the returned result...

For SCTP we have to set various options on the socket prior to connecting. This is done automatically by BIO_new_dgram_sctp(). We don't actually need the created BIO though so we free it again immediately.

Success, don't try any more addresses

Remove any stale errors from previous connection attempts

do_server - helper routine to perform a server operation @accept_sock: pointer to storage of resulting socket. @host: the host name or path (for AF_UNIX) to connect to. @port: the port to connect to (ignored for AF_UNIX). @family: desired socket family, may be AF_INET, AF_INET6, AF_UNIX or AF_UNSPEC @type: socket type, must be SOCK_STREAM or SOCK_DGRAM @cb: pointer to a function that receives the accepted socket and should perform the communication with the connecting client. @context: pointer to memory that's passed verbatim to the cb function. @naccept: number of times an incoming connect should be accepted. If -1, unlimited number. This will create a socket and use it to listen to a host:port, or if family == AF_UNIX, to the path found in host, then start accepting incoming connections and run cb on the resulting socket. 0 on failure, something other on success.

Admittedly, these checks are quite paranoid, we should not get anything in the BIO_ADDRINFO chain that we haven't asked for

For SCTP we have to set various options on the socket prior to accepting. This is done automatically by BIO_new_dgram_sctp(). We don't actually need the created BIO though so we free it again immediately.

OPENSSL_NO_SOCK

www.openssl.org/source/license.html

License

t defined, but only if _POSIX_C_SOURCE is defined, which is * needed to have fileno() declared correctly... So let

apps.h

s_apps.h

internal/sockets.h

t * asked for. */ OPENSSL_assert((family == AF_UNSPEC || family == BIO_ADDRINFO_family(ai)) && (type == 0 || type == BIO_ADDRINFO_socktype(ai)) && (protocol == 0 || protocol == BIO_ADDRINFO_protocol(ai))); *sock = BIO_socket(BIO_ADDRINFO_family(ai), BIO_ADDRINFO_socktype(ai), BIO_ADDRINFO_protocol(ai), 0); if (*sock == INVALID_SOCKET) { /* Maybe the kernel doesn

t actually need the created BIO though so we free it again * immediately. */ BIO *tmpbio = BIO_new_dgram_sctp(*sock, BIO_NOCLOSE); if (tmpbio == NULL) { ERR_print_errors(bio_err); return 0; } BIO_free(tmpbio); } #endif if (!BIO_connect(*sock, BIO_ADDRINFO_address(ai), 0)) { BIO_closesocket(*sock); *sock = INVALID_SOCKET; continue; } /* Success, don

s passed verbatim to the cb function. * @naccept: number of times an incoming connect should be accepted. If -1, * unlimited number. * * This will create a socket and use it to listen to a host:port, or if * family == AF_UNIX, to the path found in host, then start accepting * incoming connections and run cb on the resulting socket. * * 0 on failure, something other on success. */ int do_server(int *accept_sock, const char *host, const char *port, int family, int type, int protocol, do_server_cb cb, unsigned char *context, int naccept) { int asock = 0; int sock; int i; BIO_ADDRINFO *res = NULL; int ret = 0; if (BIO_sock_init() != 1) return 0; if (!BIO_lookup_ex(host, port, BIO_LOOKUP_SERVER, family, type, protocol, &res)) { ERR_print_errors(bio_err); return 0; } /* Admittedly, these checks are quite paranoid, we should not get * anything in the BIO_ADDRINFO chain that we haven

