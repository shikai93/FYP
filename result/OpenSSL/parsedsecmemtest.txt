Copyright 2015-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

s = non-secure 20

r = non-secure 20, s = non-secure 20

r = non-secure 20, p = secure 20, s = non-secure 20

20 secure -> 32-byte minimum allocation unit

r = non-secure 20, p = secure 20, q = non-secure 20, s = non-secure 20

r = non-secure 20, p = secure 20, q = non-secure 20, s = secure 20

2 20 secure -> 64 bytes allocated

20 secure -> 32 bytes allocated

should not complete, as secure memory is still allocated

secure memory should now be 0, so done should complete

If init fails, then initialized should be false, if not, this could cause an infinite loop secure_malloc, but we don't test it

There was also a possible infinite loop when the number of elements was 1<<31, as |int i| was set to that, which is a negative number. However, it requires minimum input values: CRYPTO_secure_malloc_init((size_t)1<<34, (size_t)1<<4); Which really only works on 64-bit systems, since it took 16 GB secure memory arena to trigger the problem. It naturally takes corresponding amount of available virtual and physical memory for test to be feasible/representative. Since we can't assume that every system is equipped with that much memory, the test remains disabled. If the reader of this comment really wants to make sure that infinite loop is fixed, they can enable the code below.

On Linux and BSD this test has a chance to complete in minimal time and with minimum side effects, because mlock is likely to fail because of RLIMIT_MEMLOCK, which is customarily [much] smaller than 16GB. In other words Linux and BSD users can be limited by virtual space alone...

this can complete - it was not really secure

Should fail.

www.openssl.org/source/license.html

License

testutil.h

Possible infinite loop: allocate more than available

t test it */ if (TEST_false(CRYPTO_secure_malloc_init(16, 16)) && !TEST_false(CRYPTO_secure_malloc_initialized())) { TEST_true(CRYPTO_secure_malloc_done()); goto end; } /*- * There was also a possible infinite loop when the number of * elements was 1<<31, as |int i| was set to that, which is a * negative number. However, it requires minimum input values: * * CRYPTO_secure_malloc_init((size_t)1<<34, (size_t)1<<4); * * Which really only works on 64-bit systems, since it took 16 GB * secure memory arena to trigger the problem. It naturally takes * corresponding amount of available virtual and physical memory * for test to be feasible/representative. Since we can

Possible infinite loop: 1<<31 limit

