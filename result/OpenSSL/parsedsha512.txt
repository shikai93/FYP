Copyright 2004-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

IMPLEMENTATION NOTES. As you might have noticed 32-bit hash algorithms: - permit SHA_LONG to be wider than 32-bit - optimized versions implement two transform functions: one operating on [aligned] data in host byte order and one - on data in input stream byte order; - share common byte-order neutral collector and padding function implementations, ../md32_common.h; Neither of the above applies to this SHA-512 implementations. Reasons [in reverse order] are: - it's the only 64-bit hash algorithm for the moment of this writing, there is no need for common collector/padding implementation [yet]; - by supporting only one transform function [which operates on aligned data in input stream byte order, big-endian in this case] we minimize burden of maintenance in two ways: a) collector/padding function is simpler; b) only one transform function to stare at; - SHA_LONG64 is required to be exactly 64-bit in order to be able to apply a number of optimizations to mitigate potential performance penalties caused by previous design decision; Caveat lector. Implementation relies on the fact that "long long" is 64-bit on both 32- and 64-bit platforms. If some compiler vendor comes up with 128-bit long long, adjustment to sha.h would be required. As this implementation relies on 64-bit integer type, it's totally inappropriate for platforms which don't support it, most notably 16-bit platforms. <appro@fy.chalmers.se>

There always is a room for one

Let compiler decide if it's appropriate to unroll...

... as well as make sure md_len is not abused.

applies to both IA-64 and AMD64

This code should give better results on 32-bit CPU with less than ~24 registers, both size and performance wise...

SHA512_ASM

www.openssl.org/source/license.html

License

s the only 64-bit hash algorithm for the moment of this writing, * there is no need for common collector/padding implementation [yet]; * - by supporting only one transform function [which operates on * *aligned* data in input stream byte order, big-endian in this case] * we minimize burden of maintenance in two ways: a) collector/padding * function is simpler; b) only one transform function to stare at; * - SHA_LONG64 is required to be exactly 64-bit in order to be able to * apply a number of optimizations to mitigate potential performance * penalties caused by previous design decision; * * Caveat lector. * * Implementation relies on the fact that "long long" is 64-bit on * both 32- and 64-bit platforms. If some compiler vendor comes up * with 128-bit long long, adjustment to sha.h would be required. * As this implementation relies on 64-bit integer type, it

t support it, most notably * 16-bit platforms. * <appro@fy.chalmers.se> */ #include <stdlib.h> #include <string.h> #include <openssl/crypto.h> #include <openssl/sha.h> #include <openssl/opensslv.h> #include "internal/cryptlib.h" #if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \ defined(__x86_64) || defined(_M_AMD64) || defined(_M_X64) || \ defined(__s390__) || defined(__s390x__) || \ defined(__aarch64__) || \ defined(SHA512_ASM) # define SHA512_BLOCK_CAN_MANAGE_UNALIGNED_DATA #endif int SHA384_Init(SHA512_CTX *c) { c->h[0] = U64(0xcbbb9d5dc1059ed8); c->h[1] = U64(0x629a292a367cd507); c->h[2] = U64(0x9159015a3070dd17); c->h[3] = U64(0x152fecd8f70e5939); c->h[4] = U64(0x67332667ffc00b31); c->h[5] = U64(0x8eb44a8768581511); c->h[6] = U64(0xdb0c2e0d64f98fa7); c->h[7] = U64(0x47b5481dbefa4fa4); c->Nl = 0; c->Nh = 0; c->num = 0; c->md_len = SHA384_DIGEST_LENGTH; return 1; } int SHA512_Init(SHA512_CTX *c) { c->h[0] = U64(0x6a09e667f3bcc908); c->h[1] = U64(0xbb67ae8584caa73b); c->h[2] = U64(0x3c6ef372fe94f82b); c->h[3] = U64(0xa54ff53a5f1d36f1); c->h[4] = U64(0x510e527fade682d1); c->h[5] = U64(0x9b05688c2b3e6c1f); c->h[6] = U64(0x1f83d9abfb41bd6b); c->h[7] = U64(0x5be0cd19137e2179); c->Nl = 0; c->Nh = 0; c->num = 0; c->md_len = SHA512_DIGEST_LENGTH; return 1; } #ifndef SHA512_ASM static #endif void sha512_block_data_order(SHA512_CTX *ctx, const void *in, size_t num); int SHA512_Final(unsigned char *md, SHA512_CTX *c) { unsigned char *p = (unsigned char *)c->u.p; size_t n = c->num; p[n] = 0x80; /* There always is a room for one */ n++; if (n > (sizeof(c->u) - 16)) { memset(p + n, 0, sizeof(c->u) - n); n = 0; sha512_block_data_order(c, p, 1); } memset(p + n, 0, sizeof(c->u) - 16 - n); #ifdef B_ENDIAN c->u.d[SHA_LBLOCK - 2] = c->Nh; c->u.d[SHA_LBLOCK - 1] = c->Nl; #else p[sizeof(c->u) - 1] = (unsigned char)(c->Nl); p[sizeof(c->u) - 2] = (unsigned char)(c->Nl >> 8); p[sizeof(c->u) - 3] = (unsigned char)(c->Nl >> 16); p[sizeof(c->u) - 4] = (unsigned char)(c->Nl >> 24); p[sizeof(c->u) - 5] = (unsigned char)(c->Nl >> 32); p[sizeof(c->u) - 6] = (unsigned char)(c->Nl >> 40); p[sizeof(c->u) - 7] = (unsigned char)(c->Nl >> 48); p[sizeof(c->u) - 8] = (unsigned char)(c->Nl >> 56); p[sizeof(c->u) - 9] = (unsigned char)(c->Nh); p[sizeof(c->u) - 10] = (unsigned char)(c->Nh >> 8); p[sizeof(c->u) - 11] = (unsigned char)(c->Nh >> 16); p[sizeof(c->u) - 12] = (unsigned char)(c->Nh >> 24); p[sizeof(c->u) - 13] = (unsigned char)(c->Nh >> 32); p[sizeof(c->u) - 14] = (unsigned char)(c->Nh >> 40); p[sizeof(c->u) - 15] = (unsigned char)(c->Nh >> 48); p[sizeof(c->u) - 16] = (unsigned char)(c->Nh >> 56); #endif sha512_block_data_order(c, p, 1); if (md == 0) return 0; switch (c->md_len) { /* Let compiler decide if it

rorq %1,%0

=r

J

0

cc

bswapq %0

=r

0

xchgb %%ah,%%al;xchgb %%dh,%%dl;

roll $16,%%eax; roll $16,%%edx;

xchgb %%ah,%%al;xchgb %%dh,%%dl;

=a

=d

0

1

cc

bswapl %0; bswapl %1;

=r

=r

0

1

rotrdi %0,%1,%2

=r

r

K

ror %0,%1,%2

=r

r

I

rev %0,%1

=r

r

0x__)

0xcbbb9d5dc1059ed8);

0x629a292a367cd507);

0x9159015a3070dd17);

0x152fecd8f70e5939);

0x67332667ffc00b31);

0x8eb44a8768581511);

0xdb0c2e0d64f98fa7);

0x47b5481dbefa4fa4);

0x6a09e667f3bcc908);

0xbb67ae8584caa73b);

0x3c6ef372fe94f82b);

0xa54ff53a5f1d36f1);

0x510e527fade682d1);

0x9b05688c2b3e6c1f);

0x1f83d9abfb41bd6b);

0x5be0cd19137e2179);

0x80;

0xffffffffffffffff);

0x428a2f98d728ae22),

0x7137449123ef65cd),

0xb5c0fbcfec4d3b2f),

0xe9b5dba58189dbbc),

0x3956c25bf348b538),

0x59f111f1b605d019),

0x923f82a4af194f9b),

0xab1c5ed5da6d8118),

0xd807aa98a3030242),

0x12835b0145706fbe),

0x243185be4ee4b28c),

0x550c7dc3d5ffb4e2),

0x72be5d74f27b896f),

0x80deb1fe3b1696b1),

0x9bdc06a725c71235),

0xc19bf174cf692694),

0xe49b69c19ef14ad2),

0xefbe4786384f25e3),

0x0fc19dc68b8cd5b5),

0x240ca1cc77ac9c65),

0x2de92c6f592b0275),

0x4a7484aa6ea6e483),

0x5cb0a9dcbd41fbd4),

0x76f988da831153b5),

0x983e5152ee66dfab),

0xa831c66d2db43210),

0xb00327c898fb213f),

0xbf597fc7beef0ee4),

0xc6e00bf33da88fc2),

0xd5a79147930aa725),

0x06ca6351e003826f),

0x142929670a0e6e70),

0x27b70a8546d22ffc),

0x2e1b21385c26c926),

0x4d2c6dfc5ac42aed),

0x53380d139d95b3df),

0x650a73548baf63de),

0x766a0abb3c77b2a8),

0x81c2c92e47edaee6),

0x92722c851482353b),

0xa2bfe8a14cf10364),

0xa81a664bbc423001),

0xc24b8b70d0f89791),

0xc76c51a30654be30),

0xd192e819d6ef5218),

0xd69906245565a910),

0xf40e35855771202a),

0x106aa07032bbd1b8),

0x19a4c116b8d2d0c8),

0x1e376c085141ab53),

0x2748774cdf8eeb99),

0x34b0bcb5e19b48a8),

0x391c0cb3c5c95a63),

0x4ed8aa4ae3418acb),

0x5b9cca4f7763e373),

0x682e6ff3d6b2b8a3),

0x748f82ee5defb2fc),

0x78a5636f43172f60),

0x84c87814a1f0ab72),

0x8cc702081a6439ec),

0x90befffa23631e28),

0xa4506cebde82bde9),

0xbef9a3f7b2c67915),

0xc67178f2e372532b),

0xca273eceea26619c),

0xd186b8c721c0c207),

0xeada7dd6cde0eb1e),

0xf57d4f7fee6ed178),

0x06f067aa72176fba),

0x0a637dc5a2c898a6),

0x113f9804bef90dae),

0x1b710b35131c471b),

0x28db77f523047d84),

0x32caab7b40c72493),

0x3c9ebe0a15c9bebc),

0x431d67c49c100d4c),

0x4cc5d4becb3e42b6),

0x597f299cfc657e2a),

0x5fcb6fab3ad6faec),

0x6c44198c4a475817)

0x0f];

0x0f];

0xf]

0xf];

0x0f];

0x0f];

0x0f]

0x0f];

