Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

retry once and fall back

bn_mul_mont_fpu doesn't use FMADD, we just use the flag to detect when FPU path is preferable in cases when current heuristics is unreliable. [it works out because FMADD-capable processors where FPU code path is undesirable are also VIS3-capable and VIS3 code path takes precedence.]

reconstruct %cfr copy

Some heuristics

all known VIS2-capable CPUs have unprivileged tick counter

detect UltraSPARC-Tx, see sparccpud.S for details...

Initial value, fits UltraSPARC-I&II...

T1 fails 16-bit ldda [on Linux]

detect UltraSPARC-Tx, see sparccpud.S for details...

VIS3 flag is tested independently from VIS1, unlike VIS2 that is, because VIS3 defines even integer instructions.

In wait for better solution _sparcv9_rdcfr is masked by VIS3 flag, because it goes to uninterruptable endless loop on UltraSPARC II running Solaris. Things might be different on Linux...

www.openssl.org/source/license.html

License

sparc_arch.h

hidden

t use FMADD, we just use the * flag to detect when FPU path is preferable in cases * when current heuristics is unreliable. [it works * out because FMADD-capable processors where FPU * code path is undesirable are also VIS3-capable and * VIS3 code path takes precedence.] */ ( (OPENSSL_sparcv9cap_P[0] & SPARCV9_FMADD) || (OPENSSL_sparcv9cap_P[0] & (SPARCV9_PREFER_FPU | SPARCV9_VIS1)) == (SPARCV9_PREFER_FPU | SPARCV9_VIS1) )) return bn_mul_mont_fpu(rp, ap, bp, np, n0, num); } return bn_mul_mont_int(rp, ap, bp, np, n0, num); } unsigned long _sparcv9_rdtick(void); void _sparcv9_vis1_probe(void); unsigned long _sparcv9_vis1_instrument(void); void _sparcv9_vis2_probe(void); void _sparcv9_fmadd_probe(void); unsigned long _sparcv9_rdcfr(void); void _sparcv9_vis3_probe(void); void _sparcv9_fjaesx_probe(void); unsigned long _sparcv9_random(void); size_t _sparcv9_vis1_instrument_bus(unsigned int *, size_t); size_t _sparcv9_vis1_instrument_bus2(unsigned int *, size_t, size_t); unsigned long OPENSSL_rdtsc(void) { if (OPENSSL_sparcv9cap_P[0] & SPARCV9_TICK_PRIVILEGED) #if defined(__sun) && defined(__SVR4) return gethrtime(); #else return 0; #endif else return _sparcv9_rdtick(); } size_t OPENSSL_instrument_bus(unsigned int *out, size_t cnt) { if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) == SPARCV9_BLK) return _sparcv9_vis1_instrument_bus(out, cnt); else return 0; } size_t OPENSSL_instrument_bus2(unsigned int *out, size_t cnt, size_t max) { if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) == SPARCV9_BLK) return _sparcv9_vis1_instrument_bus2(out, cnt, max); else return 0; } static sigjmp_buf common_jmp; static void common_handler(int sig) { siglongjmp(common_jmp, sig); } #if defined(__sun) && defined(__SVR4) # if defined(__GNUC__) && __GNUC__>=2 extern unsigned int getisax(unsigned int vec[], unsigned int sz) __attribute__ ((weak)); # elif defined(__SUNPRO_C) #pragma weak getisax extern unsigned int getisax(unsigned int vec[], unsigned int sz); # else static unsigned int (*getisax) (unsigned int vec[], unsigned int sz) = NULL; # endif #endif void OPENSSL_cpuid_setup(void) { char *e; struct sigaction common_act, ill_oact, bus_oact; sigset_t all_masked, oset; static int trigger = 0; if (trigger) return; trigger = 1; if ((e = getenv("OPENSSL_sparcv9cap"))) { OPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0); if ((e = strchr(e,

0x00020)

0x00040)

0x00080)

0x00100)

0x00400)

0x01000)

0x02000)

0x08000)

0x10000)

0x00008)

0x3ff;

0x20000000)

0x00000020)

0x00000040)

