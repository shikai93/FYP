Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

scheduler spinlock

SIGALRM

Nb of iterations to do per algorithm and key-size

# RSA iteration test



OPENSSL_NO_EC

Copy pointer content (looparg_t item address) into async context

What follows are the buffers and key material.

We only test over the following curves as they are representative, To add tests over more curves, simply add the curve NID and curve name to the following arrays and increase the EC_NUM value accordingly.

Prime Curves

Binary Curves

Other

Prime Curves

Binary Curves

Other

X25519

ndef OPENSSL_NO_EC

In a forked execution, an engine might need to be initialised by each child process, not by the parent. So store the name here and run setup_engine() later on.

Remaining arguments are algorithms.

Initialize the job pool if async mode is enabled

Align the start of buffers on a 64 byte boundary

Initialize the engine after the fork

No parameters; turn on everything.

Set minimum iteration Nb to 1.

Set minimum iteration Nb to 1.

not worth fixing

OPENSSL_NO_DES

SIGALRM

-O3 -fschedule-insns messes up an optimization here! names[D_EVP] somehow becomes NULL

RSA_blinding_on(rsa_key[testnum],NULL);

if longer than 10s, don't do any more

OPENSSL_NO_RSA

DSA_generate_key(dsa_key[testnum]);

DSA_sign_setup(dsa_key[testnum],NULL);

if longer than 10s, don't do any more

OPENSSL_NO_DSA

Ignore Curve

Perform ECDSA signature test

Perform ECDSA verification test

if longer than 10s, don't do any more

Ensure that the error queue is empty

Let's try to create a ctx directly from the NID: this works for curves like Curve25519 that are not implemented through the low level EC interface. If this fails we try creating a EVP_PKEY_EC generic param ctx, then we set the curve by NID before deriving the actual keygen ctx for that specific curve.

keygen ctx from NID

If we reach this code EVP_PKEY_CTX_new_id() failed and a "int_ctx_new:unsupported algorithm" error was added to the error queue. We remove it from the error queue as we are handling it.

peek the latest error in the queue

oldest and latest errors match

check that the error origin matches

pop error from queue

Create the context for parameter generation

Initialise the parameter generation

Set the curve by NID

Create the parameter object params

Create the context for the key generation

keygen ctx is not null

init keygen ctx

generate secret key A

generate secret key B

derivation ctx from skeyA

init derivation ctx

set peer pubkey in ctx

determine max length

ensure outlen is a valid size

avoid buffer overflow

Here we perform a test run, comparing the output of aB and bA; we try this here and assume that further EVP_PKEY_derive calls never fail, so we can skip checks in the actually benchmarked code, for maximum performance.

test ctx from skeyB

init derivation test_ctx

set peer pubkey in test_ctx

determine max length

compute aB

compute bA

compare output length

Compare the computation results: CRYPTO_memcmp() returns 0 if equal

if longer than 10s, don't do any more

OPENSSL_NO_EC

for now, assume the pipe is long enough to take all the output

avoid uninitialized values

SSL3_RT_APPLICATION_DATA

version

length

www.openssl.org/source/license.html

License

apps.h

./testrsa.h

./testdsa.h

md2

mdc2

md4

md5

hmac(md5)

sha1

rmd160

rc4

des cbc

des ede3

idea cbc

seed cbc

rc2 cbc

rc5-32/12 cbc

blowfish cbc

cast cbc

aes-128 cbc

aes-192 cbc

aes-256 cbc

camellia-128 cbc

camellia-192 cbc

camellia-256 cbc

evp

sha256

sha512

whirlpool

aes-128 ige

aes-192 ige

aes-256 ige

ghash

unable to CreateThread (%lu)

-

Usage: %s [options] ciphers...\n

-

Valid options are:\n

help

-

Display this summary

evp

s

Use specified EVP cipher

decrypt

-

Time decryption instead of encryption (only EVP)

mr

-

Produce machine readable output

mb

-

Enable (tls1.1) multi-block mode on evp_cipher requested with -evp

misalign

n

Amount to mis-align buffers

elapsed

-

Measure time in real time instead of CPU user time

multi

p

Run benchmarks in parallel

async_jobs

p

Enable async mode and start pnum jobs

engine

s

Use engine, possibly a hardware device

md2

mdc2

md4

md5

hmac

sha1

sha256

sha512

whirlpool

ripemd

rmd160

ripemd160

rc4

des-cbc

des-ede3

aes-128-cbc

aes-192-cbc

aes-256-cbc

aes-128-ige

aes-192-ige

aes-256-ige

rc2-cbc

rc2

rc5-cbc

rc5

idea-cbc

idea

seed-cbc

seed

bf-cbc

blowfish

bf

cast-cbc

cast

cast5

ghash

dsa512

dsa1024

dsa2048

rsa512

rsa1024

rsa2048

rsa3072

rsa4096

rsa7680

rsa15360

ecdsap160

ecdsap192

ecdsap224

ecdsap256

ecdsap384

ecdsap521

ecdsak163

ecdsak233

ecdsak283

ecdsak409

ecdsak571

ecdsab163

ecdsab233

ecdsab283

ecdsab409

ecdsab571

ecdhp160

ecdhp192

ecdhp224

ecdhp256

ecdhp384

ecdhp521

ecdhk163

ecdhk233

ecdhk283

ecdhk409

ecdhk571

ecdhb163

ecdhb233

ecdhb283

ecdhb409

ecdhb571

ecdhx25519

RSA sign failure\n

RSA verify failure\n

DSA sign failure\n

DSA verify failure\n

ECDSA sign failure\n

ECDSA verify failure\n

Failure in the job\n

Too many fds in ASYNC_WAIT_CTX\n

Error: max_fd (%d) must be smaller than FD_SETSIZE (%d).

Decrease the value of async_jobs\n

Failure in the select\n

Too many fds in ASYNC_WAIT_CTX\n

Failure in the job\n

secp160r1

nistp192

nistp224

nistp256

nistp384

nistp521

nistk163

nistk233

nistk283

nistk409

nistk571

nistb163

nistb233

nistb283

nistb409

nistb571

X25519

%s: Use -help for summary.\n

%s: %s is an unknown cipher or digest\n

%s: async_jobs specified but async not supported\n

%s: too many async_jobs\n

%s: Maximum offset is %d\n

%s: -mb specified but multi-block support is disabled\n

des

sha

openssl

rsa

dsa

aes

camellia

ecdsa

ecdh

%s: Unknown algorithm %s\n

Error creating the ASYNC job pool\n

array of loopargs

Error creating the ASYNC_WAIT_CTX\n

input buffer

input buffer

ECDH secret a

ECDH secret b

You have chosen to measure elapsed time

instead of user CPU time.\n

internal error loading RSA key number %d\n

First we calculate the approximate speed ...\n

You cannot disable DES on systems without SIGALRM.

This is a key...

HMAC malloc failure, exiting...

0123456789ab

Async mode is not supported with %s\n

Async mode is not supported with %s\n

Async mode is not supported, exiting...

Async mode is not supported with %s\n

Async mode is not supported with %s\n

Async mode is not supported with %s\n

Async mode is not supported with %s\n

Async mode is not supported, exiting...

Async mode is not supported with %s\n

Async mode is not supported, exiting...

Async mode is not supported with %s\n

Async mode is not supported with %s\n

%s is not multi-block capable\n

Async mode is not supported, exiting...

RSA sign failure. No RSA sign will be done.\n

private

rsa

+R1:%ld:%d:%.2f\n

%ld %d bit private RSA's in %.2fs\n

RSA verify failure. No RSA verify will be done.\n

public

rsa

+R2:%ld:%d:%.2f\n

%ld %d bit public RSA's in %.2fs\n

t do any more */ for (testnum++; testnum < RSA_NUM; testnum++) rsa_doit[testnum] = 0; } } #endif /* OPENSSL_NO_RSA */ for (i = 0; i < loopargs_len; i++) RAND_bytes(loopargs[i].buf, 36); #ifndef OPENSSL_NO_DSA for (testnum = 0; testnum < DSA_NUM; testnum++) { int st = 0; if (!dsa_doit[testnum]) continue; /* DSA_generate_key(dsa_key[testnum]); */ /* DSA_sign_setup(dsa_key[testnum],NULL); */ for (i = 0; i < loopargs_len; i++) { st = DSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2, &loopargs[i].siglen, loopargs[i].dsa_key[testnum]); if (st == 0) break; } if (st == 0) { BIO_printf(bio_err, "DSA sign failure. No DSA sign will be done.\n"); ERR_print_errors(bio_err); rsa_count = 1; } else { pkey_print_message("sign", "dsa", dsa_c[testnum][0], dsa_bits[testnum], DSA_SECONDS); Time_F(START); count = run_benchmark(async_jobs, DSA_sign_loop, loopargs); d = Time_F(STOP); BIO_printf(bio_err, mr ? "+R3:%ld:%d:%.2f\n" : "%ld %d bit DSA signs in %.2fs\n", count, dsa_bits[testnum], d); dsa_results[testnum][0] = (double)count / d; rsa_count = count; } for (i = 0; i < loopargs_len; i++) { st = DSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2, loopargs[i].siglen, loopargs[i].dsa_key[testnum]); if (st <= 0) break; } if (st <= 0) { BIO_printf(bio_err, "DSA verify failure. No DSA verify will be done.\n"); ERR_print_errors(bio_err); dsa_doit[testnum] = 0; } else { pkey_print_message("verify", "dsa", dsa_c[testnum][1], dsa_bits[testnum], DSA_SECONDS); Time_F(START); count = run_benchmark(async_jobs, DSA_verify_loop, loopargs); d = Time_F(STOP); BIO_printf(bio_err, mr ? "+R4:%ld:%d:%.2f\n" : "%ld %d bit DSA verify in %.2fs\n", count, dsa_bits[testnum], d); dsa_results[testnum][1] = (double)count / d; } if (rsa_count <= 1) { /* if longer than 10s, don

ECDSA failure.\n

ECDSA sign failure. No ECDSA sign will be done.\n

sign

ecdsa

+R5:%ld:%d:%.2f\n

%ld %d bit ECDSA signs in %.2fs \n

ECDSA verify failure. No ECDSA verify will be done.\n

verify

ecdsa

+R6:%ld:%d:%.2f\n

%ld %d bit ECDSA verify in %.2fs\n

t do any more */ for (testnum++; testnum < EC_NUM; testnum++) ecdsa_doit[testnum] = 0; } } } for (testnum = 0; testnum < EC_NUM; testnum++) { int ecdh_checks = 1; if (!ecdh_doit[testnum]) continue; for (i = 0; i < loopargs_len; i++) { EVP_PKEY_CTX *kctx = NULL; EVP_PKEY_CTX *test_ctx = NULL; EVP_PKEY_CTX *ctx = NULL; EVP_PKEY *key_A = NULL; EVP_PKEY *key_B = NULL; size_t outlen; size_t test_outlen; /* Ensure that the error queue is empty */ if (ERR_peek_error()) { BIO_printf(bio_err, "WARNING: the error queue contains previous unhandled errors.\n"); ERR_print_errors(bio_err); } /* Let

int_ctx_new:unsupported algorithm

Unhandled error in the error queue during ECDH init.\n

ECDH EC params init failure.\n

ECDH keygen failure.\n

ECDH key generation failure.\n

ECDH computation failure.\n

ECDH computations don't match.\n



ecdh

+R7:%ld:%d:%.2f\n

%ld %d-bit ECDH ops in %.2fs\n

t do any more */ for (testnum++; testnum < EC_NUM; testnum++) ecdh_doit[testnum] = 0; } } #endif /* OPENSSL_NO_EC */ #ifndef NO_FORK show_res: #endif if (!mr) { printf("%s\n", OpenSSL_version(OPENSSL_VERSION)); printf("%s\n", OpenSSL_version(OPENSSL_BUILT_ON)); printf("options:"); printf("%s ", BN_options()); #ifndef OPENSSL_NO_MD2 printf("%s ", MD2_options()); #endif #ifndef OPENSSL_NO_RC4 printf("%s ", RC4_options()); #endif #ifndef OPENSSL_NO_DES printf("%s ", DES_options()); #endif printf("%s ", AES_options()); #ifndef OPENSSL_NO_IDEA printf("%s ", IDEA_options()); #endif #ifndef OPENSSL_NO_BF printf("%s ", BF_options()); #endif printf("\n%s\n", OpenSSL_version(OPENSSL_CFLAGS)); } if (pr_header) { if (mr) printf("+H"); else { printf ("The

are in 1000s of bytes per second processed.\n"); printf("type "); } for (testnum = 0; testnum < SIZE_NUM; testnum++) printf(mr ? ":%d" : "%7d bytes", lengths[testnum]); printf("\n"); } for (k = 0; k < ALGOR_NUM; k++) { if (!doit[k]) continue; if (mr) printf("+F:%d:%s", k, names[k]); else printf("%-13s", names[k]); for (testnum = 0; testnum < SIZE_NUM; testnum++) { if (results[k][testnum] > 10000 && !mr) printf(" %11.2fk", results[k][testnum] / 1e3); else printf(mr ? ":%.2f" : " %11.2f ", results[k][testnum]); } printf("\n"); } #ifndef OPENSSL_NO_RSA testnum = 1; for (k = 0; k < RSA_NUM; k++) { if (!rsa_doit[k]) continue; if (testnum && !mr) { printf("%18ssign verify sign/s verify/s\n", " "); testnum = 0; } if (mr) printf("+F2:%u:%u:%f:%f\n", k, rsa_bits[k], rsa_results[k][0], rsa_results[k][1]); else printf("rsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n", rsa_bits[k], 1.0 / rsa_results[k][0], 1.0 / rsa_results[k][1], rsa_results[k][0], rsa_results[k][1]); } #endif #ifndef OPENSSL_NO_DSA testnum = 1; for (k = 0; k < DSA_NUM; k++) { if (!dsa_doit[k]) continue; if (testnum && !mr) { printf("%18ssign verify sign/s verify/s\n", " "); testnum = 0; } if (mr) printf("+F3:%u:%u:%f:%f\n", k, dsa_bits[k], dsa_results[k][0], dsa_results[k][1]); else printf("dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n", dsa_bits[k], 1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1], dsa_results[k][0], dsa_results[k][1]); } #endif #ifndef OPENSSL_NO_EC testnum = 1; for (k = 0; k < EC_NUM; k++) { if (!ecdsa_doit[k]) continue; if (testnum && !mr) { printf("%30ssign verify sign/s verify/s\n", " "); testnum = 0; } if (mr) printf("+F4:%u:%u:%f:%f\n", k, test_curves_bits[k], ecdsa_results[k][0], ecdsa_results[k][1]); else printf("%4u bit ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\n", test_curves_bits[k], test_curves_names[k], 1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1], ecdsa_results[k][0], ecdsa_results[k][1]); } testnum = 1; for (k = 0; k < EC_NUM; k++) { if (!ecdh_doit[k]) continue; if (testnum && !mr) { printf("%30sop op/s\n", " "); testnum = 0; } if (mr) printf("+F5:%u:%u:%f:%f\n", k, test_curves_bits[k], ecdh_results[k][0], 1.0 / ecdh_results[k][0]); else printf("%4u bit ecdh (%s) %8.4fs %8.1f\n", test_curves_bits[k], test_curves_names[k], 1.0 / ecdh_results[k][0], ecdh_results[k][0]); } #endif ret = 0; end: ERR_print_errors(bio_err); for (i = 0; i < loopargs_len; i++) { OPENSSL_free(loopargs[i].buf_malloc); OPENSSL_free(loopargs[i].buf2_malloc); #ifndef OPENSSL_NO_RSA for (k = 0; k < RSA_NUM; k++) RSA_free(loopargs[i].rsa_key[k]); #endif #ifndef OPENSSL_NO_DSA for (k = 0; k < DSA_NUM; k++) DSA_free(loopargs[i].dsa_key[k]); #endif #ifndef OPENSSL_NO_EC for (k = 0; k < EC_NUM; k++) { EC_KEY_free(loopargs[i].ecdsa[k]); EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]); } OPENSSL_free(loopargs[i].secret_a); OPENSSL_free(loopargs[i].secret_b); #endif } if (async_jobs > 0) { for (i = 0; i < loopargs_len; i++) ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx); } if (async_init) { ASYNC_cleanup_thread(); } OPENSSL_free(loopargs); release_engine(e); return (ret); } static void print_message(const char *s, long num, int length) { #ifdef SIGALRM BIO_printf(bio_err, mr ? "+DT:%s:%d:%d\n" : "Doing %s for %ds on %d size blocks: ", s, SECONDS, length); (void)BIO_flush(bio_err); alarm(SECONDS); #else BIO_printf(bio_err, mr ? "+DN:%s:%ld:%d\n" : "Doing %s %ld times on %d size blocks: ", s, num, length); (void)BIO_flush(bio_err); #endif } static void pkey_print_message(const char *str, const char *str2, long num, int bits, int tm) { #ifdef SIGALRM BIO_printf(bio_err, mr ? "+DTP:%d:%s:%s:%d\n" : "Doing %d bit %s %s

, bits, str, str2, tm); (void)BIO_flush(bio_err); alarm(tm); #else BIO_printf(bio_err, mr ?

:

s: ", num, bits, str, str2); (void)BIO_flush(bio_err); #endif } static void print_result(int alg, int run_no, int count, double time_used) { if (count == -1) { BIO_puts(bio_err, "EVP error!\n"); exit(1); } BIO_printf(bio_err, mr ? "+R:%d:%s:%f\n" : "%d %s

, count, names[alg], time_used); results[alg][run_no] = ((double)count) / time_used * lengths[run_no]; } #ifndef NO_FORK static char *sstrsep(char **string, const char *delim) { char isdelim[256]; char *token = *string; if (**string == 0) return NULL; memset(isdelim, 0, sizeof isdelim); isdelim[0] = 1; while (*delim) { isdelim[(unsigned char)(*delim)] = 1; delim++; } while (!isdelim[(unsigned char)(**string)]) { (*string)++; } if (**string) { **string = 0; (*string)++; } return token; } static int do_multi(int multi) { int n; int fd[2]; int *fds; static char sep[] =

; fds = malloc(sizeof(*fds) * multi); for (n = 0; n < multi; ++n) { if (pipe(fd) == -1) { BIO_printf(bio_err,

); exit(1); } fflush(stdout); (void)BIO_flush(bio_err); if (fork()) { close(fd[1]); fds[n] = fd[0]; } else { close(fd[0]); close(1); if (dup(fd[1]) == -1) { BIO_printf(bio_err,

); exit(1); } close(fd[1]); mr = 1; usertime = 0; free(fds); return 0; } printf(

, n); } /* for now, assume the pipe is long enough to take all the output */ for (n = 0; n < multi; ++n) { FILE *f; char buf[1024]; char *p; f = fdopen(fds[n],

); while (fgets(buf, sizeof buf, f)) { p = strchr(buf, '\n'); if (p) *p = '\0'; if (buf[0] != '+') { BIO_printf(bio_err,

t understand line

from child %d\n", buf, n); continue; } printf("Got: %s from %d\n", buf, n); if (strncmp(buf, "+F:", 3) == 0) { int alg; int j; p = buf + 3; alg = atoi(sstrsep(&p, sep)); sstrsep(&p, sep); for (j = 0; j < SIZE_NUM; ++j) results[alg][j] += atof(sstrsep(&p, sep)); } else if (strncmp(buf, "+F2:", 4) == 0) { int k; double d; p = buf + 4; k = atoi(sstrsep(&p, sep)); sstrsep(&p, sep); d = atof(sstrsep(&p, sep)); rsa_results[k][0] += d; d = atof(sstrsep(&p, sep)); rsa_results[k][1] += d; } # ifndef OPENSSL_NO_DSA else if (strncmp(buf, "+F3:", 4) == 0) { int k; double d; p = buf + 4; k = atoi(sstrsep(&p, sep)); sstrsep(&p, sep); d = atof(sstrsep(&p, sep)); dsa_results[k][0] += d; d = atof(sstrsep(&p, sep)); dsa_results[k][1] += d; } # endif # ifndef OPENSSL_NO_EC else if (strncmp(buf, "+F4:", 4) == 0) { int k; double d; p = buf + 4; k = atoi(sstrsep(&p, sep)); sstrsep(&p, sep); d = atof(sstrsep(&p, sep)); ecdsa_results[k][0] += d; d = atof(sstrsep(&p, sep)); ecdsa_results[k][1] += d; } else if (strncmp(buf, "+F5:", 4) == 0) { int k; double d; p = buf + 4; k = atoi(sstrsep(&p, sep)); sstrsep(&p, sep); d = atof(sstrsep(&p, sep)); ecdh_results[k][0] += d; } # endif else if (strncmp(buf, "+H:", 3) == 0) { ; } else BIO_printf(bio_err, "Unknown type

from child %d\n", buf, n); } fclose(f); } free(fds); return 1; } #endif static void multiblock_speed(const EVP_CIPHER *evp_cipher) { static int mblengths[] = { 8 * 1024, 2 * 8 * 1024, 4 * 8 * 1024, 8 * 8 * 1024, 8 * 16 * 1024 }; int j, count, num = OSSL_NELEM(mblengths); const char *alg_name; unsigned char *inp, *out, no_key[32], no_iv[16]; EVP_CIPHER_CTX *ctx; double d = 0.0; inp = app_malloc(mblengths[num - 1], "multiblock input buffer"); out = app_malloc(mblengths[num - 1] + 1024, "multiblock output buffer"); ctx = EVP_CIPHER_CTX_new(); EVP_EncryptInit_ex(ctx, evp_cipher, NULL, no_key, no_iv); EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY, sizeof(no_key), no_key); alg_name = OBJ_nid2ln(EVP_CIPHER_nid(evp_cipher)); for (j = 0; j < num; j++) { print_message(alg_name, 0, mblengths[j]); Time_F(START); for (count = 0, run = 1; run && count < 0x7fffffff; count++) { unsigned char aad[EVP_AEAD_TLS1_AAD_LEN]; EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param; size_t len = mblengths[j]; int packlen; memset(aad, 0, 8); /* avoid uninitialized values */ aad[8] = 23; /* SSL3_RT_APPLICATION_DATA */ aad[9] = 3; /* version */ aad[10] = 2; aad[11] = 0; /* length */ aad[12] = 0; mb_param.out = NULL; mb_param.inp = aad; mb_param.len = len; mb_param.interleave = 8; packlen = EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_TLS1_1_MULTIBLOCK_AAD, sizeof(mb_param), &mb_param); if (packlen > 0) { mb_param.out = out; mb_param.inp = inp; mb_param.len = len; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT, sizeof(mb_param), &mb_param); } else { int pad; RAND_bytes(out, 16); len += 16; aad[11] = len >> 8; aad[12] = len; pad = EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_TLS1_AAD, EVP_AEAD_TLS1_AAD_LEN, aad); EVP_Cipher(ctx, out, inp, len + pad); } } d = Time_F(STOP); BIO_printf(bio_err, mr ? "+R:%d:%s:%f\n" : "%d %s

, count,

, d); results[D_EVP][j] = ((double)count) / d * mblengths[j]; } if (mr) { fprintf(stdout,

); for (j = 0; j < num; j++) fprintf(stdout,

, mblengths[j]); fprintf(stdout,

); fprintf(stdout,

, D_EVP, alg_name); for (j = 0; j < num; j++) fprintf(stdout,

, results[D_EVP][j]); fprintf(stdout,

); } else { fprintf(stdout,

numbers

); fprintf(stdout,

); for (j = 0; j < num; j++) fprintf(stdout,

, mblengths[j]); fprintf(stdout,

); fprintf(stdout,

, alg_name); for (j = 0; j < num; j++) { if (results[D_EVP][j] > 10000) fprintf(stdout,

, results[D_EVP][j] / 1e3); else fprintf(stdout,

, results[D_EVP][j]); } fprintf(stdout,

0x7fffffff)

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34,

0x56

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34,

0x56

0x12,

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0

0x34,

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12

0x56,

0x78,

0x9a,

0xbc,

0xde,

0xf0,

0x12,

0x34

0x7fffffff;

