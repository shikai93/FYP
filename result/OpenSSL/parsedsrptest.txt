Copyright 2011-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

use 256 bits on each side

use builtin 1024-bit params

Set up server's password entry

Server random

Server's first message

Client random

Client's response

Both sides calculate u

Client's key

Server's key

SRP test vectors from RFC5054

use builtin 1024-bit params

Set up server's password entry

Server random

Server's first message

Client random

Client's response

Both sides calculate u

Client's key

Server's key

"Negative" test, expect a mismatch

"Positive" test, should pass

www.openssl.org/source/license.html

License

testutil.h

1024

s password entry */ if (!TEST_true(SRP_create_verifier_BN(username, server_pass, &s, &v, GN->N, GN->g))) goto end; test_output_bignum("N", GN->N); test_output_bignum("g", GN->g); test_output_bignum("Salt", s); test_output_bignum("Verifier", v); /* Server random */ RAND_bytes(rand_tmp, sizeof(rand_tmp)); b = BN_bin2bn(rand_tmp, sizeof(rand_tmp), NULL); if (!TEST_BN_ne_zero(b)) goto end; test_output_bignum("b", b); /* Server

B

a

s response */ Apub = SRP_Calc_A(a, GN->N, GN->g); test_output_bignum("A", Apub); if (!TEST_true(SRP_Verify_A_mod_N(Apub, GN->N))) goto end; /* Both sides calculate u */ u = SRP_Calc_u(Apub, Bpub, GN->N); /* Client

Client's key

s key */ Kserver = SRP_Calc_server_key(Apub, v, u, b, GN->N); test_output_bignum("Server

, Kserver); if (!TEST_BN_eq(Kclient, Kserver)) goto end; ret = 1; end: BN_clear_free(Kclient); BN_clear_free(Kserver); BN_clear_free(x); BN_free(u); BN_free(Apub); BN_clear_free(a); BN_free(Bpub); BN_clear_free(b); BN_free(s); BN_clear_free(v); return ret; } static int check_bn(const char *name, const BIGNUM *bn, const char *hexbn) { BIGNUM *tmp = NULL; int r; if (!TEST_true(BN_hex2bn(&tmp, hexbn))) return 0; if (BN_cmp(bn, tmp) != 0) TEST_error(

, name); r = TEST_BN_eq(bn, tmp); BN_free(tmp); return r; } /* SRP test vectors from RFC5054 */ static int run_srp_kat(void) { int ret = 0; BIGNUM *s = NULL; BIGNUM *v = NULL; BIGNUM *a = NULL; BIGNUM *b = NULL; BIGNUM *u = NULL; BIGNUM *x = NULL; BIGNUM *Apub = NULL; BIGNUM *Bpub = NULL; BIGNUM *Kclient = NULL; BIGNUM *Kserver = NULL; /* use builtin 1024-bit params */ const SRP_gN *GN; if (!TEST_ptr(GN = SRP_get_default_gN(

))) goto err; BN_hex2bn(&s,

); /* Set up server's password entry */ if (!TEST_true(SRP_create_verifier_BN(

,

, &s, &v, GN->N, GN->g))) goto err; TEST_info(

); if (!TEST_true(check_bn(

, v,









))) goto err; TEST_note(

); /* Server random */ BN_hex2bn(&b,



); /* Server's first message */ Bpub = SRP_Calc_B(b, GN->N, GN->g, v); if (!TEST_true(SRP_Verify_B_mod_N(Bpub, GN->N))) goto err; TEST_info(

); if (!TEST_true(check_bn(

, Bpub,









))) goto err; TEST_note(

); /* Client random */ BN_hex2bn(&a,



); /* Client's response */ Apub = SRP_Calc_A(a, GN->N, GN->g); if (!TEST_true(SRP_Verify_A_mod_N(Apub, GN->N))) goto err; TEST_info(

); if (!TEST_true(check_bn(

, Apub,









))) goto err; TEST_note(

); /* Both sides calculate u */ u = SRP_Calc_u(Apub, Bpub, GN->N); if (!TEST_true(check_bn(

, u,

))) goto err; /* Client's key */ x = SRP_Calc_x(s,

,

); Kclient = SRP_Calc_client_key(GN->N, Bpub, GN->g, x, a, u); TEST_info(

s key"); if (!TEST_true(check_bn("Client

, Kclient,









))) goto err; TEST_note(

); /* Server's key */ Kserver = SRP_Calc_server_key(Apub, v, u, b, GN->N); TEST_info(

s key"); if (!TEST_true(check_bn("Server

, Kserver,









))) goto err; TEST_note(

); ret = 1; err: BN_clear_free(Kclient); BN_clear_free(Kserver); BN_clear_free(x); BN_free(u); BN_free(Apub); BN_clear_free(a); BN_free(Bpub); BN_clear_free(b); BN_free(s); BN_clear_free(v); return ret; } static int run_srp_tests(void) { /*

test, expect a mismatch */ TEST_info(

); if (!TEST_false(run_srp(

,

,

))) return 0; /*

test, should pass */ TEST_info(

); if (!TEST_true(run_srp(

,

,

))) return 0; return 1; } #endif int setup_tests(void) { #ifdef OPENSSL_NO_SRP printf(

