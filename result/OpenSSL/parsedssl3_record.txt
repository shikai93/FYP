Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Clear the contents of an SSL3_RECORD but retain any memory allocated

Peeks ahead into "read_ahead" data to see if we have a whole record waiting for us in the buffer.

We only check the type and record length, we will sanity check version etc later

If we are a client then we always use the max_early_data from the session. Otherwise we go with the lowest out of the max early data set in the session and the configured max_early_data.

If we are dealing with ciphertext we need to allow for the overhead

MAX_EMPTY_RECORDS defines the number of consecutive, empty records that will be processed per call to ssl3_get_record. Without this limit an attacker could send empty records at a faster rate than we can process and cause ssl3_get_record to loop forever.

Call this to get new input records. It will return <= 0 if more data is needed, normally due to an error or non-blocking IO. When it finishes, |numrpipes| records have been decoded. For each record 'i': rr[i].type - is the type of record rr[i].data, - data rr[i].length, - number of bytes Multiple records will only be returned if the record types are all SSL3_RT_APPLICATION_DATA. The number of records returned will always be <= |max_pipelines|

used only by ssl3_read_bytes

check if we have the header

error or non-blocking

The first record received by the server may be a V2ClientHello.

SSLv2 style record |num_recs| here will actually always be 0 because |num_recs > 0| only ever occurs when we are processing multiple app data records - which we know isn't the case here because it is an SSLv2ClientHello. We keep it using |num_recs| for the sake of consistency

SSLv3+ style record

Pull apart the header into the SSL3_RECORD

Lets check version. In TLSv1.3 we ignore this field

The record is using an incorrect version number, but what we've got appears to be an alert. We haven't read the body yet to check whether its a fatal or not - but chances are it is. We probably shouldn't send a fatal alert back. We'll just end.

Send back error using their minor version number :-)

Go back to start of packet, look at the five bytes that we have.

Doesn't look like TLS - don't send an alert

now s->rlayer.rstate == SSL_ST_READ_BODY

If OPENSSL_NO_COMP is defined then SSL3_RT_MAX_ENCRYPTED_LENGTH does not include the compression overhead anyway.

s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data. Calculate how much more data we need to read for the rest of the record

now s->packet_length == SSL3_RT_HEADER_LENGTH

error or non-blocking io

set state for later operations

At this point, s->packet_length == SSL3_RT_HEADER_LENGTH + thisrr->length, or s->packet_length == SSL2_RT_HEADER_LENGTH + thisrr->length and we have that many bytes in s->packet

ok, we can now read from 's->packet' data into 'thisrr' thisrr->input points at thisrr->length bytes, which need to be copied into thisrr->data by either the decryption or by the decompression When the data is 'copied' into the thisrr->data buffer, thisrr->input will be pointed at the new buffer

We now have - encrypted [ MAC [ compressed [ plain ] ] ] thisrr->length bytes of encrypted compressed stuff.

decrypt in place in 'thisrr->input'

Mark this record as not read by upper layers yet

we have pulled in a full packet so zero things

If in encrypt-then-mac mode calculate mac from encrypted record. All the details below are public so no timing details can leak.

TODO(size_t): convert this to do size_t properly

not send

enc_err is: 0: (in non-constant time) if the record is publicly invalid. 1: if the padding is valid -1: if the padding is invalid

Valid early_data that we cannot decrypt might fail here as publicly invalid. We treat it like an empty record.

r->length is now the compressed data plus mac

s->read_hash != NULL => mac_size != -1

orig_len is the length of the record before any padding was removed. This is public information, as is the MAC in use, therefore we can safely process the record in a different amount of time if it's too short to possibly contain a MAC.

CBC records must have a padding length byte too.

We update the length so that the TLS header bytes can be constructed correctly but we need to extract the MAC in constant time from within the record, without leaking the contents of the padding bytes.

In this case there's no padding, so |rec->orig_len| equals |rec->length| and we checked that there's enough bytes for |mac_size| above.

not send

We assume this is unreadable early_data - we treat it like an empty record

The record length may have been modified by the mac check above so we use the previously saved value

A separate 'decryption_failed' alert was introduced with TLS 1.0, SSL 3.0 only has 'bad_record_mac'. But unless a decryption failure is directly visible from the ciphertext anyway, we should not reveal which kind of error occurred -- this might become visible to an attacker (e.g. via a logfile)

thisrr->length is now just compressed

Strip trailing padding

TLSv1.3 alert and handshake records are required to be non-zero in length.

So at this point the following is true thisrr->type is the type of record thisrr->length == number of bytes in record thisrr->off == offset to first valid byte thisrr->data == where to take bytes from, increment after use :-).

just read a 0 length packet

TODO(size_t): Convert this call

TODO(size_t): Convert this call

ssl3_enc encrypts/decrypts |n_recs| records in |inrecs| Returns: 0: (in non-constant time) if the record is publically invalid (i.e. too short etc). 1: if the record's padding is valid / the encryption was successful. -1: if the record's padding is invalid or, if sending, an internal error occurred.

We shouldn't ever be called with more than one record in the SSLv3 case

TODO(size_t): Convert this call

COMPRESS

we need to add 'i-1' padding bytes

the last of these zero bytes will be overwritten with the padding length.

otherwise, rec->length >= bs

TODO(size_t): Convert this call

TODO(size_t): convert me

tls1_enc encrypts/decrypts |n_recs| in |recs|. Returns: 0: (in non-constant time) if the record is publically invalid (i.e. too short etc). 1: if the record's padding is valid / the encryption was successful. -1: if the record's padding/AEAD-authenticator is invalid or, if sending, an internal error occurred.

For TLSv1.1 and later explicit IV

we can't write into the input stream: Can this ever happen?? (steve)

We shouldn't have been called with pipeline data if the cipher doesn't support pipelining

DTLS does not support pipelining

increment

Add weird padding of upto 256 bytes

we need to add 'padnum' padding bytes of value padval

Set the output buffers

Set the input buffers

TODO(size_t): Convert this call

AEAD can fail to verify MAC

If tmpret == 0 then this means publicly invalid so we can short circuit things here. Otherwise we must respect constant time behaviour.

This is a CBC-encrypted record. We must avoid leaking any timing-side channel information about how many blocks of data we are hashing because that gives an attacker a timing-oracle.

npad is, at most, 48 bytes and that's with MD5: 16 + 48 + 8 (sequence bytes) + 1 + 2 = 75. With SHA-1 (the largest hash speced for SSLv3) the hash size goes up 4, but npad goes down by 8, resulting in a smaller total size.

Final param == is SSLv3

Chop the digest off the end :-)

I should fix this up TLS TLS TLS TLS TLS XXXXXXXX

This is a CBC-encrypted record. We must avoid leaking any timing-side channel information about how many blocks of data we are hashing because that gives an attacker a timing-oracle.

Final param == not SSLv3

TODO(size_t): Convert these calls

ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC record in |rec| by updating |rec->length| in constant time. block_size: the block size of the cipher used to encrypt the record. returns: 0: (in non-constant time) if the record is publicly invalid. 1: if the padding was valid -1: otherwise.

padding length byte

These lengths are all public so we can test them in non-constant time.

SSLv3 requires that the padding is minimal.

tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC record in |rec| in constant time and returns 1 if the padding is valid and -1 otherwise. It also removes any explicit IV from the start of the record without leaking any timing about whether there was enough space after the padding was removed. block_size: the block size of the cipher used to encrypt the record. returns: 0: (in non-constant time) if the record is publicly invalid. 1: if the padding was valid -1: otherwise.

padding length byte

Check if version requires explicit IV

These lengths are all public so we can test them in non-constant time.

We can now safely skip explicit IV

padding is already verified

The padding consists of a length byte at the end of the record and then that many bytes of padding, all with the same value as the length byte. Thus, with the length byte included, there are i+1 bytes of padding. We can't check just |padding_length+1| bytes because that leaks decrypted information. Therefore we always have to check the maximum amount of padding possible. (Again, the length of the record is public information so we can use it.)

maximum amount of padding, inc length byte.

The final |padding_length+1| bytes should all have the value |padding_length|. Therefore the XOR should be zero.

If any of the final |padding_length+1| bytes had the wrong value, one or more of the lower eight bits of |good| will be cleared.

ssl3_cbc_copy_mac copies |md_size| bytes from the end of |rec| to |out| in constant time (independent of the concrete value of rec->length, which may vary within a 256-byte window). ssl3_cbc_remove_padding or tls1_cbc_remove_padding must be called prior to this function. On entry: rec->orig_len >= md_size md_size <= EVP_MAX_MD_SIZE If CBC_MAC_ROTATE_IN_PLACE is defined then the rotation is performed with variable accesses in a 64-byte-aligned buffer. Assuming that this fits into a single or pair of cache-lines, then the variable memory accesses don't actually affect the timing. CPUs with smaller cache-lines [if any] are not multi-core and are not considered vulnerable to cache-timing attacks.

mac_end is the index of |rec->data| just after the end of the MAC.

scan_start contains the number of bytes that we can ignore because the MAC's position can only vary by 255 bytes.

This information is public so it's safe to branch based on it.

Now rotate the MAC

in case cache-line is 32 bytes, touch second line

At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length, and we have that many bytes in s->packet

ok, we can now read from 's->packet' data into 'rr' rr->input points at rr->length bytes, which need to be copied into rr->data by either the decryption or by the decompression When the data is 'copied' into the rr->data buffer, rr->input will be pointed at the new buffer

We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length bytes of encrypted compressed stuff.

check is not needed I believe

decrypt in place in 'rr->input'

not send

enc_err is: 0: (in non-constant time) if the record is publically invalid. 1: if the padding is valid -1: if the padding is invalid

For DTLS we simply ignore bad packets.

r->length is now the compressed data plus mac

s->read_hash != NULL => mac_size != -1

TODO(size_t): Convert this to do size_t properly

orig_len is the length of the record before any padding was removed. This is public information, as is the MAC in use, therefore we can safely process the record in a different amount of time if it's too short to possibly contain a MAC.

CBC records must have a padding length byte too.

We update the length so that the TLS header bytes can be constructed correctly but we need to extract the MAC in constant time from within the record, without leaking the contents of the padding bytes.

In this case there's no padding, so |rec->orig_len| equals |rec->length| and we checked that there's enough bytes for |mac_size| above.

not send

decryption failed, silently discard message

r->length is now just compressed

So at this point the following is true ssl->s3->rrec.type is the type of record ssl->s3->rrec.length == number of bytes in record ssl->s3->rrec.off == offset to first valid byte ssl->s3->rrec.data == where to take bytes from, increment after use :-).

we have pulled in a full packet so zero things

Mark receipt of record.

Retrieve a buffered record that belongs to the current epoch, i.e. processed

Call this to get a new input record. It will return <= 0 if more data is needed, normally due to an error or non-blocking IO. When it finishes, one packet has been decoded and can be found in ssl->s3->rrec.type - is the type of record ssl->s3->rrec.data, - data ssl->s3->rrec.length, - number of bytes

used only by dtls1_read_bytes

The epoch may have changed. If so, process all the pending records. This is a non-blocking operation.

if we're renegotiating, then there may be buffered records

get something from the wire

check if we have the header

read timeout is handled by dtls1_read_bytes

error or non-blocking

this packet contained a partial record, dump it

Pull apart the header into the DTLS1_RECORD

sequence number is 64 bits, with top 2 bytes = epoch

Lets check version

unexpected version, silently discard

wrong version, silently discard record

record too long, silently discard it

now s->rlayer.rstate == SSL_ST_READ_BODY

s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data

now s->packet_length == DTLS1_RT_HEADER_LENGTH

this packet contained a partial record, dump it

now n == rr->length, and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length

set state for later operations

match epochs. NULL means the packet is dropped on the floor

dump this record

get another record

Only do replay check if no SCTP bio

Check whether this is a repeat, or aged record.

TODO: Does it make sense to have replay protection in epoch 0 where we have no integrity negotiated yet?

dump this record

get another record

just read a 0 length packet

If this record is from the next epoch (either HM or ALERT), and a handshake is currently in progress, buffer it since it cannot be processed at this time.

dump this record

get another record

www.openssl.org/source/license.html

License

../ssl_locl.h

internal/constant_time_locl.h

record_locl.h

internal/cryptlib.h

read_ahead

i

t the case here * because it is an SSLv2ClientHello. We keep it using * |num_recs| for the sake of consistency */ thisrr->type = SSL3_RT_HANDSHAKE; thisrr->rec_version = SSL2_VERSION; thisrr->length = sslv2len & 0x7fff; if (thisrr->length > SSL3_BUFFER_get_len(rbuf) - SSL2_RT_HEADER_LENGTH) { al = SSL_AD_RECORD_OVERFLOW; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG); goto f_err; } if (thisrr->length < MIN_SSL2_RECORD_LEN) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT); goto f_err; } } else { /* SSLv3+ style record */ if (s->msg_callback) s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s, s->msg_callback_arg); /* Pull apart the header into the SSL3_RECORD */ if (!PACKET_get_1(&pkt, &type) || !PACKET_get_net_2(&pkt, &version) || !PACKET_get_net_2_len(&pkt, &thisrr->length)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR); goto f_err; } thisrr->type = type; thisrr->rec_version = version; /* Lets check version. In TLSv1.3 we ignore this field */ if (!s->first_packet && !SSL_IS_TLS13(s) && version != (unsigned int)s->version) { SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER); if ((s->version & 0xFF00) == (version & 0xFF00) && !s->enc_write_ctx && !s->write_hash) { if (thisrr->type == SSL3_RT_ALERT) { /* * The record is using an incorrect version number, * but what we

t read the body yet to check whether its a * fatal or not - but chances are it is. We probably * shouldn

ll just * end. */ goto err; } /* * Send back error using their minor version number :-) */ s->version = (unsigned short)version; } al = SSL_AD_PROTOCOL_VERSION; goto f_err; } if ((version >> 8) != SSL3_VERSION_MAJOR) { if (RECORD_LAYER_is_first_record(&s->rlayer)) { /* Go back to start of packet, look at the five bytes * that we have. */ p = RECORD_LAYER_get_packet(&s->rlayer); if (strncmp((char *)p, "GET ", 4) == 0 || strncmp((char *)p, "POST ", 5) == 0 || strncmp((char *)p, "HEAD ", 5) == 0 || strncmp((char *)p, "PUT ", 4) == 0) { SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST); goto err; } else if (strncmp((char *)p, "CONNE", 5) == 0) { SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTPS_PROXY_REQUEST); goto err; } /* Doesn

t send an alert */ SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER); goto err; } else { SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER); al = SSL_AD_PROTOCOL_VERSION; goto f_err; } } if (SSL_IS_TLS13(s) && s->enc_read_ctx != NULL && thisrr->type != SSL3_RT_APPLICATION_DATA) { SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_RECORD_TYPE); al = SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } if (thisrr->length > SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) { al = SSL_AD_RECORD_OVERFLOW; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG); goto f_err; } } /* now s->rlayer.rstate == SSL_ST_READ_BODY */ } if (SSL_IS_TLS13(s)) { if (thisrr->length > SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH) { al = SSL_AD_RECORD_OVERFLOW; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG); goto f_err; } } else { size_t len = SSL3_RT_MAX_ENCRYPTED_LENGTH; #ifndef OPENSSL_NO_COMP /* * If OPENSSL_NO_COMP is defined then SSL3_RT_MAX_ENCRYPTED_LENGTH * does not include the compression overhead anyway. */ if (s->expand == NULL) len -= SSL3_RT_MAX_COMPRESSED_OVERHEAD; #endif if (thisrr->length > len) { al = SSL_AD_RECORD_OVERFLOW; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG); goto f_err; } } /* * s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data. * Calculate how much more data we need to read for the rest of the * record */ if (thisrr->rec_version == SSL2_VERSION) { more = thisrr->length + SSL2_RT_HEADER_LENGTH - SSL3_RT_HEADER_LENGTH; } else { more = thisrr->length; } if (more > 0) { /* now s->packet_length == SSL3_RT_HEADER_LENGTH */ rret = ssl3_read_n(s, more, more, 1, 0, &n); if (rret <= 0) return rret; /* error or non-blocking io */ } /* set state for later operations */ RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER); /* * At this point, s->packet_length == SSL3_RT_HEADER_LENGTH * + thisrr->length, or s->packet_length == SSL2_RT_HEADER_LENGTH * + thisrr->length and we have that many bytes in s->packet */ if (thisrr->rec_version == SSL2_VERSION) { thisrr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]); } else { thisrr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]); } /* * ok, we can now read from

data into

thisrr->input * points at thisrr->length bytes, which need to be copied into * thisrr->data by either the decryption or by the decompression When * the data is

into the thisrr->data buffer, thisrr->input will * be pointed at the new buffer */ /* * We now have - encrypted [ MAC [ compressed [ plain ] ] ] * thisrr->length bytes of encrypted compressed stuff. */ /* decrypt in place in

*/ thisrr->data = thisrr->input; thisrr->orig_len = thisrr->length; /* Mark this record as not read by upper layers yet */ thisrr->read = 0; num_recs++; /* we have pulled in a full packet so zero things */ RECORD_LAYER_reset_packet_length(&s->rlayer); RECORD_LAYER_clear_first_record(&s->rlayer); } while (num_recs < max_recs && thisrr->type == SSL3_RT_APPLICATION_DATA && SSL_USE_EXPLICIT_IV(s) && s->enc_read_ctx != NULL && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx)) & EVP_CIPH_FLAG_PIPELINE) && ssl3_record_app_data_waiting(s)); /* * If in encrypt-then-mac mode calculate mac from encrypted record. All * the details below are public so no timing details can leak. */ if (SSL_READ_ETM(s) && s->read_hash) { unsigned char *mac; /* TODO(size_t): convert this to do size_t properly */ imac_size = EVP_MD_CTX_size(s->read_hash); if (!ossl_assert(imac_size >= 0 && imac_size <= EVP_MAX_MD_SIZE)) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_SSL3_GET_RECORD, ERR_LIB_EVP); goto f_err; } mac_size = (size_t)imac_size; for (j = 0; j < num_recs; j++) { thisrr = &rr[j]; if (thisrr->length < mac_size) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT); goto f_err; } thisrr->length -= mac_size; mac = thisrr->data + thisrr->length; i = s->method->ssl3_enc->mac(s, thisrr, md, 0 /* not send */ ); if (i == 0 || CRYPTO_memcmp(md, mac, mac_size) != 0) { al = SSL_AD_BAD_RECORD_MAC; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC); goto f_err; } } } first_rec_len = rr[0].length; enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0); /*- * enc_err is: * 0: (in non-constant time) if the record is publicly invalid. * 1: if the padding is valid * -1: if the padding is invalid */ if (enc_err == 0) { if (num_recs == 1 && ossl_statem_skip_early_data(s)) { /* * Valid early_data that we cannot decrypt might fail here as * publicly invalid. We treat it like an empty record. */ thisrr = &rr[0]; if (!early_data_count_ok(s, thisrr->length, EARLY_DATA_CIPHERTEXT_OVERHEAD, &al)) goto f_err; thisrr->length = 0; thisrr->read = 1; RECORD_LAYER_set_numrpipes(&s->rlayer, 1); RECORD_LAYER_reset_read_sequence(&s->rlayer); return 1; } al = SSL_AD_DECRYPTION_FAILED; SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG); goto f_err; } #ifdef SSL_DEBUG printf("dec %"OSSLzu"\n", rr[0].length); { size_t z; for (z = 0; z < rr[0].length; z++) printf("%02X%c", rr[0].data[z], ((z + 1) % 16) ?

:

); } printf("\n"); #endif /* r->length is now the compressed data plus mac */ if ((sess != NULL) && (s->enc_read_ctx != NULL) && (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) { /* s->read_hash != NULL => mac_size != -1 */ unsigned char *mac = NULL; unsigned char mac_tmp[EVP_MAX_MD_SIZE]; mac_size = EVP_MD_CTX_size(s->read_hash); if (!ossl_assert(mac_size <= EVP_MAX_MD_SIZE)) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR); goto f_err; } for (j = 0; j < num_recs; j++) { thisrr = &rr[j]; /* * orig_len is the length of the record before any padding was * removed. This is public information, as is the MAC in use, * therefore we can safely process the record in a different amount * of time if it

s no padding, so |rec->orig_len| equals * |rec->length| and we checked that there

decryption_failed

bad_record_mac

s padding is valid / the encryption was successful. * -1: if the record

t ever be called with more than one record in the SSLv3 case */ if (n_recs != 1) return 0; if (sending) { ds = s->enc_write_ctx; if (s->enc_write_ctx == NULL) enc = NULL; else enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx); } else { ds = s->enc_read_ctx; if (s->enc_read_ctx == NULL) enc = NULL; else enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx); } if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) { memmove(rec->data, rec->input, rec->length); rec->input = rec->data; } else { l = rec->length; /* TODO(size_t): Convert this call */ bs = EVP_CIPHER_CTX_block_size(ds); /* COMPRESS */ if ((bs != 1) && sending) { i = bs - (l % bs); /* we need to add

padding bytes */ l += i; /* * the last of these zero bytes will be overwritten with the * padding length. */ memset(&rec->input[rec->length], 0, i); rec->length += i; rec->input[l - 1] = (unsigned char)(i - 1); } if (!sending) { if (l == 0 || l % bs != 0) return 0; /* otherwise, rec->length >= bs */ } /* TODO(size_t): Convert this call */ if (EVP_Cipher(ds, rec->data, rec->input, (unsigned int)l) < 1) return -1; if (EVP_MD_CTX_md(s->read_hash) != NULL) { /* TODO(size_t): convert me */ imac_size = EVP_MD_CTX_size(s->read_hash); if (imac_size < 0) return -1; mac_size = (size_t)imac_size; } if ((bs != 1) && !sending) return ssl3_cbc_remove_padding(rec, bs, mac_size); } return (1); } #define MAX_PADDING 256 /*- * tls1_enc encrypts/decrypts |n_recs| in |recs|. * * Returns: * 0: (in non-constant time) if the record is publically invalid (i.e. too * short etc). * 1: if the record

s padding/AEAD-authenticator is invalid or, if sending, * an internal error occurred. */ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending) { EVP_CIPHER_CTX *ds; size_t reclen[SSL_MAX_PIPELINES]; unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN]; int i, pad = 0, ret, tmpr; size_t bs, mac_size = 0, ctr, padnum, loop; unsigned char padval; int imac_size; const EVP_CIPHER *enc; if (n_recs == 0) return 0; if (sending) { if (EVP_MD_CTX_md(s->write_hash)) { int n = EVP_MD_CTX_size(s->write_hash); if (!ossl_assert(n >= 0)) { SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR); return -1; } } ds = s->enc_write_ctx; if (s->enc_write_ctx == NULL) enc = NULL; else { int ivlen; enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx); /* For TLSv1.1 and later explicit IV */ if (SSL_USE_EXPLICIT_IV(s) && EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE) ivlen = EVP_CIPHER_iv_length(enc); else ivlen = 0; if (ivlen > 1) { for (ctr = 0; ctr < n_recs; ctr++) { if (recs[ctr].data != recs[ctr].input) { /* * we can

t have been called with pipeline data if the * cipher doesn

padnum

s with MD5: * 16 + 48 + 8 (sequence bytes) + 1 + 2 = 75. * * With SHA-1 (the largest hash speced for SSLv3) the hash size * goes up 4, but npad goes down by 8, resulting in a smaller * total size. */ unsigned char header[75]; size_t j = 0; memcpy(header + j, mac_sec, md_size); j += md_size; memcpy(header + j, ssl3_pad_1, npad); j += npad; memcpy(header + j, seq, 8); j += 8; header[j++] = rec->type; header[j++] = (unsigned char)(rec->length >> 8); header[j++] = (unsigned char)(rec->length & 0xff); /* Final param == is SSLv3 */ if (ssl3_cbc_digest_record(hash, md, &md_size, header, rec->input, rec->length + md_size, rec->orig_len, mac_sec, md_size, 1) <= 0) return 0; } else { unsigned int md_size_u; /* Chop the digest off the end :-) */ EVP_MD_CTX *md_ctx = EVP_MD_CTX_new(); if (md_ctx == NULL) return 0; rec_char = rec->type; p = md; s2n(rec->length, p); if (EVP_MD_CTX_copy_ex(md_ctx, hash) <= 0 || EVP_DigestUpdate(md_ctx, mac_sec, md_size) <= 0 || EVP_DigestUpdate(md_ctx, ssl3_pad_1, npad) <= 0 || EVP_DigestUpdate(md_ctx, seq, 8) <= 0 || EVP_DigestUpdate(md_ctx, &rec_char, 1) <= 0 || EVP_DigestUpdate(md_ctx, md, 2) <= 0 || EVP_DigestUpdate(md_ctx, rec->input, rec->length) <= 0 || EVP_DigestFinal_ex(md_ctx, md, NULL) <= 0 || EVP_MD_CTX_copy_ex(md_ctx, hash) <= 0 || EVP_DigestUpdate(md_ctx, mac_sec, md_size) <= 0 || EVP_DigestUpdate(md_ctx, ssl3_pad_2, npad) <= 0 || EVP_DigestUpdate(md_ctx, md, md_size) <= 0 || EVP_DigestFinal_ex(md_ctx, md, &md_size_u) <= 0) { EVP_MD_CTX_reset(md_ctx); return 0; } EVP_MD_CTX_free(md_ctx); } ssl3_record_sequence_update(seq); return 1; } int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending) { unsigned char *seq; EVP_MD_CTX *hash; size_t md_size; int i; EVP_MD_CTX *hmac = NULL, *mac_ctx; unsigned char header[13]; int stream_mac = (sending ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM) : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM)); int t; if (sending) { seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer); hash = ssl->write_hash; } else { seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer); hash = ssl->read_hash; } t = EVP_MD_CTX_size(hash); if (!ossl_assert(t >= 0)) return 0; md_size = t; /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */ if (stream_mac) { mac_ctx = hash; } else { hmac = EVP_MD_CTX_new(); if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash)) return 0; mac_ctx = hmac; } if (SSL_IS_DTLS(ssl)) { unsigned char dtlsseq[8], *p = dtlsseq; s2n(sending ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) : DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p); memcpy(p, &seq[2], 6); memcpy(header, dtlsseq, 8); } else memcpy(header, seq, 8); header[8] = rec->type; header[9] = (unsigned char)(ssl->version >> 8); header[10] = (unsigned char)(ssl->version); header[11] = (unsigned char)(rec->length >> 8); header[12] = (unsigned char)(rec->length & 0xff); if (!sending && !SSL_READ_ETM(ssl) && EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported(mac_ctx)) { /* * This is a CBC-encrypted record. We must avoid leaking any * timing-side channel information about how many blocks of data we * are hashing because that gives an attacker a timing-oracle. */ /* Final param == not SSLv3 */ if (ssl3_cbc_digest_record(mac_ctx, md, &md_size, header, rec->input, rec->length + md_size, rec->orig_len, ssl->s3->read_mac_secret, ssl->s3->read_mac_secret_size, 0) <= 0) { EVP_MD_CTX_free(hmac); return 0; } } else { /* TODO(size_t): Convert these calls */ if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0 || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0 || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) { EVP_MD_CTX_free(hmac); return 0; } } EVP_MD_CTX_free(hmac); #ifdef SSL_DEBUG fprintf(stderr, "seq="); { int z; for (z = 0; z < 8; z++) fprintf(stderr, "%02X ", seq[z]); fprintf(stderr, "\n"); } fprintf(stderr, "rec="); { size_t z; for (z = 0; z < rec->length; z++) fprintf(stderr, "%02X ", rec->data[z]); fprintf(stderr, "\n"); } #endif if (!SSL_IS_DTLS(ssl)) { for (i = 7; i >= 0; i--) { ++seq[i]; if (seq[i] != 0) break; } } #ifdef SSL_DEBUG { unsigned int z; for (z = 0; z < md_size; z++) fprintf(stderr, "%02X ", md[z]); fprintf(stderr, "\n"); } #endif return 1; } /*- * ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC * record in |rec| by updating |rec->length| in constant time. * * block_size: the block size of the cipher used to encrypt the record. * returns: * 0: (in non-constant time) if the record is publicly invalid. * 1: if the padding was valid * -1: otherwise. */ int ssl3_cbc_remove_padding(SSL3_RECORD *rec, size_t block_size, size_t mac_size) { size_t padding_length; size_t good; const size_t overhead = 1 /* padding length byte */ + mac_size; /* * These lengths are all public so we can test them in non-constant time. */ if (overhead > rec->length) return 0; padding_length = rec->data[rec->length - 1]; good = constant_time_ge_s(rec->length, padding_length + overhead); /* SSLv3 requires that the padding is minimal. */ good &= constant_time_ge_s(block_size, padding_length + 1); rec->length -= good & (padding_length + 1); return constant_time_select_int_s(good, 1, -1); } /*- * tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC * record in |rec| in constant time and returns 1 if the padding is valid and * -1 otherwise. It also removes any explicit IV from the start of the record * without leaking any timing about whether there was enough space after the * padding was removed. * * block_size: the block size of the cipher used to encrypt the record. * returns: * 0: (in non-constant time) if the record is publicly invalid. * 1: if the padding was valid * -1: otherwise. */ int tls1_cbc_remove_padding(const SSL *s, SSL3_RECORD *rec, size_t block_size, size_t mac_size) { size_t good; size_t padding_length, to_check, i; const size_t overhead = 1 /* padding length byte */ + mac_size; /* Check if version requires explicit IV */ if (SSL_USE_EXPLICIT_IV(s)) { /* * These lengths are all public so we can test them in non-constant * time. */ if (overhead + block_size > rec->length) return 0; /* We can now safely skip explicit IV */ rec->data += block_size; rec->input += block_size; rec->length -= block_size; rec->orig_len -= block_size; } else if (overhead > rec->length) return 0; padding_length = rec->data[rec->length - 1]; if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx)) & EVP_CIPH_FLAG_AEAD_CIPHER) { /* padding is already verified */ rec->length -= padding_length + 1; return 1; } good = constant_time_ge_s(rec->length, overhead + padding_length); /* * The padding consists of a length byte at the end of the record and * then that many bytes of padding, all with the same value as the length * byte. Thus, with the length byte included, there are i+1 bytes of * padding. We can

t * actually affect the timing. CPUs with smaller cache-lines [if any] are * not multi-core and are not considered vulnerable to cache-timing attacks. */ #define CBC_MAC_ROTATE_IN_PLACE int ssl3_cbc_copy_mac(unsigned char *out, const SSL3_RECORD *rec, size_t md_size) { #if defined(CBC_MAC_ROTATE_IN_PLACE) unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE]; unsigned char *rotated_mac; #else unsigned char rotated_mac[EVP_MAX_MD_SIZE]; #endif /* * mac_end is the index of |rec->data| just after the end of the MAC. */ size_t mac_end = rec->length; size_t mac_start = mac_end - md_size; size_t in_mac; /* * scan_start contains the number of bytes that we can ignore because the * MAC

s safe to branch based on it. */ if (rec->orig_len > md_size + 255 + 1) scan_start = rec->orig_len - (md_size + 255 + 1); in_mac = 0; rotate_offset = 0; memset(rotated_mac, 0, md_size); for (i = scan_start, j = 0; i < rec->orig_len; i++) { size_t mac_started = constant_time_eq_s(i, mac_start); size_t mac_ended = constant_time_lt_s(i, mac_end); unsigned char b = rec->data[i]; in_mac |= mac_started; in_mac &= mac_ended; rotate_offset |= j & mac_started; rotated_mac[j++] |= b & in_mac; j &= constant_time_lt_s(j, md_size); } /* Now rotate the MAC */ #if defined(CBC_MAC_ROTATE_IN_PLACE) j = 0; for (i = 0; i < md_size; i++) { /* in case cache-line is 32 bytes, touch second line */ ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32]; out[j++] = rotated_mac[rotate_offset++]; rotate_offset &= constant_time_lt_s(rotate_offset, md_size); } #else memset(out, 0, md_size); rotate_offset = md_size - rotate_offset; rotate_offset &= constant_time_lt_s(rotate_offset, md_size); for (i = 0; i < md_size; i++) { for (j = 0; j < md_size; j++) out[j] |= rotated_mac[i] & constant_time_eq_8_s(j, rotate_offset); rotate_offset++; rotate_offset &= constant_time_lt_s(rotate_offset, md_size); } #endif return 1; } int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap) { int i, al; int enc_err; SSL_SESSION *sess; SSL3_RECORD *rr; int imac_size; size_t mac_size; unsigned char md[EVP_MAX_MD_SIZE]; rr = RECORD_LAYER_get_rrec(&s->rlayer); sess = s->session; /* * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length, * and we have that many bytes in s->packet */ rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]); /* * ok, we can now read from

data into

rr->input points * at rr->length bytes, which need to be copied into rr->data by either * the decryption or by the decompression When the data is

into * the rr->data buffer, rr->input will be pointed at the new buffer */ /* * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length * bytes of encrypted compressed stuff. */ /* check is not needed I believe */ if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) { al = SSL_AD_RECORD_OVERFLOW; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG); goto f_err; } /* decrypt in place in

*/ rr->data = rr->input; rr->orig_len = rr->length; if (SSL_READ_ETM(s) && s->read_hash) { unsigned char *mac; mac_size = EVP_MD_CTX_size(s->read_hash); if (!ossl_assert(mac_size <= EVP_MAX_MD_SIZE)) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_R_INTERNAL_ERROR); goto f_err; } if (rr->orig_len < mac_size) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT); goto f_err; } rr->length -= mac_size; mac = rr->data + rr->length; i = s->method->ssl3_enc->mac(s, rr, md, 0 /* not send */ ); if (i == 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) { al = SSL_AD_BAD_RECORD_MAC; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC); goto f_err; } } enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0); /*- * enc_err is: * 0: (in non-constant time) if the record is publically invalid. * 1: if the padding is valid * -1: if the padding is invalid */ if (enc_err == 0) { /* For DTLS we simply ignore bad packets. */ rr->length = 0; RECORD_LAYER_reset_packet_length(&s->rlayer); goto err; } #ifdef SSL_DEBUG printf("dec %ld\n", rr->length); { size_t z; for (z = 0; z < rr->length; z++) printf("%02X%c", rr->data[z], ((z + 1) % 16) ?

:

); } printf("\n"); #endif /* r->length is now the compressed data plus mac */ if ((sess != NULL) && !SSL_READ_ETM(s) && (s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) { /* s->read_hash != NULL => mac_size != -1 */ unsigned char *mac = NULL; unsigned char mac_tmp[EVP_MAX_MD_SIZE]; /* TODO(size_t): Convert this to do size_t properly */ imac_size = EVP_MD_CTX_size(s->read_hash); if (imac_size < 0) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_LIB_EVP); goto f_err; } mac_size = (size_t)imac_size; if (!ossl_assert(mac_size <= EVP_MAX_MD_SIZE)) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_R_INTERNAL_ERROR); goto f_err; } /* * orig_len is the length of the record before any padding was * removed. This is public information, as is the MAC in use, * therefore we can safely process the record in a different amount * of time if it

s no padding, so |rec->orig_len| equals * |rec->length| and we checked that there

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36,

0x36

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c,

0x5c

0x8000)

0x7fff;

0xFF00)

0xFF00)

0xff);

0xff);

0xff);

0xff,

0xff);

0xff00)

0xff00))

