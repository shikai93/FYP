Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Copyright 2005 Nokia. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

NB: make sure indices in these tables match values above

Table of NIDs for each cipher

SSL_ENC_DES_IDX 0

SSL_ENC_3DES_IDX 1

SSL_ENC_RC4_IDX 2

SSL_ENC_RC2_IDX 3

SSL_ENC_IDEA_IDX 4

SSL_ENC_NULL_IDX 5

SSL_ENC_AES128_IDX 6

SSL_ENC_AES256_IDX 7

SSL_ENC_CAMELLIA128_IDX 8

SSL_ENC_CAMELLIA256_IDX 9

SSL_ENC_GOST89_IDX 10

SSL_ENC_SEED_IDX 11

SSL_ENC_AES128GCM_IDX 12

SSL_ENC_AES256GCM_IDX 13

SSL_ENC_AES128CCM_IDX 14

SSL_ENC_AES256CCM_IDX 15

SSL_ENC_AES128CCM8_IDX 16

SSL_ENC_AES256CCM8_IDX 17

SSL_ENC_GOST8912_IDX 18

SSL_ENC_CHACHA_IDX 19

SSL_ENC_ARIA128GCM_IDX 20

SSL_ENC_ARIA256GCM_IDX 21

Constant SSL_MAX_DIGEST equal to size of digests array should be defined in the ssl_locl.h

NB: make sure indices in this table matches values above

SSL_MD_MD5_IDX 0

SSL_MD_SHA1_IDX 1

SSL_MD_GOST94_IDX 2

SSL_MD_GOST89MAC_IDX 3

SSL_MD_SHA256_IDX 4

SSL_MD_SHA384_IDX 5

SSL_MD_GOST12_256_IDX 6

SSL_MD_GOST89MAC12_IDX 7

SSL_MD_GOST12_512_IDX 8

SSL_MD_MD5_SHA1_IDX 9

SSL_MD_SHA224_IDX 10

SSL_MD_SHA512_IDX 11

INDENT-OFF

INDENT-ON

Utility function for table lookup

PKEY_TYPE for GOST89MAC is known in advance, but, because implementation is engine-provided, we'll fill it only if corresponding EVP_PKEY_METHOD is found

MD5, SHA, GOST94, MAC89

SHA256, SHA384, GOST2012_256, MAC89-12

GOST2012_512

Bump the ciphers to the top of the list. This rule isn't currently supported by the public cipherstring API.

"ALL" doesn't include eNULL (must be specifically enabled)

"COMPLEMENTOFALL"

"COMPLEMENTOFDEFAULT" (does not include ciphersuites not found in ALL!)

key exchange aliases (some of those using only a single bit here combine multiple key exchange algs according to the RFCs, e.g. kDHE combines DHE_DSS and DHE_RSA)

server authentication aliases

aliases combining key exchange and server authentication

symmetric encryption aliases

MAC aliases

protocol version aliases

strength classes

FIPS 140-2 approved ciphersuite

"EDH-" aliases to "DHE-" labels (for backward compatibility)

Search for public key algorithm with given name and return its pkey_id if it is available. Otherwise return 0

masks of disabled algorithms

Make sure we can access MD5 and SHA1

Check for presence of GOST 34.10 algorithms, and if they are not present, disable appropriate auth and key exchange

Disable GOST key exchange if no GOST signature algs are available

Currently don't care, since a failure only means that ssl_comp_methods is NULL, which is perfectly OK

If were only interested in comp then return success

We have num_of_ciphers descriptions compiled in, depending on the method selected (SSLv3, TLSv1 etc). These will later be sorted in a linked list with at most num entries.

Get the initial list of ciphers

actual count of ciphers

drop those that use any of that is not available

Prepare linked list from list entries

First, add the real ciphers as already collected

Now we add the available ones from the cipher_aliases[] table. They represent either one or more algorithms, some of which in any affected category must be supported (set in enabled_mask), or represent a cipher strength value (will be added in any case because algorithms=0).

end of list

needed to maintain sorting between currently deleted ciphers

Selection criteria is either the value of strength_bits or the algorithms used.

add the cipher if it has not been added yet.

reverse == 0

Move the added cipher to this location

reverse == 0

reverse == 1

most recently deleted ciphersuites get best positions for any future CIPHER_ADD (note that the CIPHER_DEL loop works in reverse to maintain the order)

reverse == 0

This routine sorts the ciphers with descending strength. The sorting must keep the pre-sorted sequence, so we apply the normal sorting routine as '+' movement to the end of the list.

Now find the strength_bits values actually used

Go through the list of used strength_bits values in descending order.

done

We hit something we cannot deal with, it is no command or separator nor alphanumeric, so we call this an error.

unused -- avoid compiler warning

special treatment

check for multi-part specification

Now search for the cipher alias in the ca_list. Be careful with the strncmp, because the "buflen" limitation will make the rule "ADH:SOME" and the cipher "ADH-MY-CIPHER" look like a match for buflen=3. So additionally check whether the cipher name found has the correct length. We can save a strlen() call: just checking for the '\0' at the right place is sufficient, we have to strncmp() anyway. (We cannot use strcmp(), because buf is not '\0' terminated.)

ignore this entry

explicit ciphersuite found; its protocol version does not become part of the search pattern!

not an explicit ciphersuite; only in this case, the protocol version is considered part of the search pattern

Ok, we have the rule, now apply it

special command

We do not support any "multi" options together with "@", so throw away the rest of the command, if any left, until end or ':' is found.

done

Check version: if TLS 1.2 ciphers allowed we can use Suite B

Return with error if nothing to do.

To reduce the work to do we only want to process the compiled in algorithms, so we first get the mask of disabled ciphers.

Now we have to collect the available ciphers from the compiled in ciphers. We cannot get more than the number compiled in, so it is used for allocation.

Failure

Now arrange all ciphers by preference.

Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms. For consistency, prefer ECDSA over RSA (though this only matters if the server has both certificates, and is using the DEFAULT, or a client preference).

Within each strength group, we prefer GCM over CHACHA...

...and generally, our preferred cipher is AES. Note that AEADs will be bumped to take preference after sorting by strength.

Temporarily enable everything else for sorting

Low priority for MD5

Move anonymous ciphers to the end. Usually, these will remain disabled. (For applications that allow them, they aren't too bad, but we prefer authenticated ciphers.)

ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

RC4 is sort-of broken -- move to the end

Now sort by symmetric encryption strength. The above ordering remains in force within each class

Partially overrule strength sort to prefer TLS 1.2 ciphers/PRFs. TODO(openssl-team): is there an easier way to accomplish all this?

Irrespective of strength, enforce the following order: (EC)DHE + AEAD > (EC)DHE > rest of AEAD > rest. Within each group, ciphers remain sorted by strength and previous preference, i.e., 1) ECDHE > DHE 2) GCM > CHACHA 3) AES > rest 4) TLS 1.2 > legacy Because we now bump ciphers to the top of the list, we proceed in reverse order of preference.

Now disable everything (maintaining the ordering!)

We also need cipher aliases for selecting based on the rule_str. There might be two types of entries in the rule_str: 1) names of ciphers themselves 2) aliases for groups of ciphers. For 1) we need the available ciphers and for 2) the cipher groups of cipher_aliases added together in one list (otherwise we would be happy with just the cipher_aliases table).

Failure

If the rule_string begins with DEFAULT, apply the default rule before using the (possibly available) additional rules.

Not needed anymore

Rule processing failure

Allocate new "cipherstack" for the result, return with error if we cannot get one.

The cipher selection for the list is done. The ciphers are added to the resulting precedence to the STACK_OF(SSL_CIPHER).

Not needed any longer

New GOST ciphersuites have both SSL_aGOST12 and SSL_aGOST01 bits

Backwards-compatibility crutch. In almost all contexts we report TLS 1.0 as "TLSv1", but for ciphers we report "TLSv1.0".

return the actual cipher being used

return the actual cipher being used in RFC standard name

return the OpenSSL name based on given RFC standard name

number of bits for symmetric cipher

According to draft-ietf-tls-compression-04.txt, the compression number ranges should be the following: 0 to 63: methods defined by the IETF 64 to 192: external party methods assigned by IANA 193 to 255: reserved for private use

Some hard-coded numbers for the CCM/Poly1305 MAC overhead because there are no handy #defines for those.

We're supposed to have handled all the AEAD modes above

Non-AEAD modes. Calculate MAC/cipher overhead separately

If it wasn't AEAD or SSL_eNULL, we expect it to be a known CBC cipher.

padding length byte

www.openssl.org/source/license.html

License

internal/nelem.h

ssl_locl.h

internal/thread_once.h

internal/cryptlib.h

ll fill it only if corresponding EVP_PKEY_METHOD is * found */ static int ssl_mac_pkey_id[SSL_MD_NUM_IDX] = { /* MD5, SHA, GOST94, MAC89 */ EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC, NID_undef, /* SHA256, SHA384, GOST2012_256, MAC89-12 */ EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC, NID_undef, /* GOST2012_512 */ EVP_PKEY_HMAC, }; static size_t ssl_mac_secret_size[SSL_MD_NUM_IDX]; #define CIPHER_ADD 1 #define CIPHER_KILL 2 #define CIPHER_DEL 3 #define CIPHER_ORD 4 #define CIPHER_SPECIAL 5 /* * Bump the ciphers to the top of the list. * This rule isn

ALL

t include eNULL (must be specifically enabled) */ {0, SSL_TXT_ALL, NULL, 0, 0, 0, ~SSL_eNULL}, /* "COMPLEMENTOFALL" */ {0, SSL_TXT_CMPALL, NULL, 0, 0, 0, SSL_eNULL}, /* * "COMPLEMENTOFDEFAULT" (does *not* include ciphersuites not found in * ALL!) */ {0, SSL_TXT_CMPDEF, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, SSL_NOT_DEFAULT}, /* * key exchange aliases (some of those using only a single bit here * combine multiple key exchange algs according to the RFCs, e.g. kDHE * combines DHE_DSS and DHE_RSA) */ {0, SSL_TXT_kRSA, NULL, 0, SSL_kRSA}, {0, SSL_TXT_kEDH, NULL, 0, SSL_kDHE}, {0, SSL_TXT_kDHE, NULL, 0, SSL_kDHE}, {0, SSL_TXT_DH, NULL, 0, SSL_kDHE}, {0, SSL_TXT_kEECDH, NULL, 0, SSL_kECDHE}, {0, SSL_TXT_kECDHE, NULL, 0, SSL_kECDHE}, {0, SSL_TXT_ECDH, NULL, 0, SSL_kECDHE}, {0, SSL_TXT_kPSK, NULL, 0, SSL_kPSK}, {0, SSL_TXT_kRSAPSK, NULL, 0, SSL_kRSAPSK}, {0, SSL_TXT_kECDHEPSK, NULL, 0, SSL_kECDHEPSK}, {0, SSL_TXT_kDHEPSK, NULL, 0, SSL_kDHEPSK}, {0, SSL_TXT_kSRP, NULL, 0, SSL_kSRP}, {0, SSL_TXT_kGOST, NULL, 0, SSL_kGOST}, /* server authentication aliases */ {0, SSL_TXT_aRSA, NULL, 0, 0, SSL_aRSA}, {0, SSL_TXT_aDSS, NULL, 0, 0, SSL_aDSS}, {0, SSL_TXT_DSS, NULL, 0, 0, SSL_aDSS}, {0, SSL_TXT_aNULL, NULL, 0, 0, SSL_aNULL}, {0, SSL_TXT_aECDSA, NULL, 0, 0, SSL_aECDSA}, {0, SSL_TXT_ECDSA, NULL, 0, 0, SSL_aECDSA}, {0, SSL_TXT_aPSK, NULL, 0, 0, SSL_aPSK}, {0, SSL_TXT_aGOST01, NULL, 0, 0, SSL_aGOST01}, {0, SSL_TXT_aGOST12, NULL, 0, 0, SSL_aGOST12}, {0, SSL_TXT_aGOST, NULL, 0, 0, SSL_aGOST01 | SSL_aGOST12}, {0, SSL_TXT_aSRP, NULL, 0, 0, SSL_aSRP}, /* aliases combining key exchange and server authentication */ {0, SSL_TXT_EDH, NULL, 0, SSL_kDHE, ~SSL_aNULL}, {0, SSL_TXT_DHE, NULL, 0, SSL_kDHE, ~SSL_aNULL}, {0, SSL_TXT_EECDH, NULL, 0, SSL_kECDHE, ~SSL_aNULL}, {0, SSL_TXT_ECDHE, NULL, 0, SSL_kECDHE, ~SSL_aNULL}, {0, SSL_TXT_NULL, NULL, 0, 0, 0, SSL_eNULL}, {0, SSL_TXT_RSA, NULL, 0, SSL_kRSA, SSL_aRSA}, {0, SSL_TXT_ADH, NULL, 0, SSL_kDHE, SSL_aNULL}, {0, SSL_TXT_AECDH, NULL, 0, SSL_kECDHE, SSL_aNULL}, {0, SSL_TXT_PSK, NULL, 0, SSL_PSK}, {0, SSL_TXT_SRP, NULL, 0, SSL_kSRP}, /* symmetric encryption aliases */ {0, SSL_TXT_3DES, NULL, 0, 0, 0, SSL_3DES}, {0, SSL_TXT_RC4, NULL, 0, 0, 0, SSL_RC4}, {0, SSL_TXT_RC2, NULL, 0, 0, 0, SSL_RC2}, {0, SSL_TXT_IDEA, NULL, 0, 0, 0, SSL_IDEA}, {0, SSL_TXT_SEED, NULL, 0, 0, 0, SSL_SEED}, {0, SSL_TXT_eNULL, NULL, 0, 0, 0, SSL_eNULL}, {0, SSL_TXT_GOST, NULL, 0, 0, 0, SSL_eGOST2814789CNT | SSL_eGOST2814789CNT12}, {0, SSL_TXT_AES128, NULL, 0, 0, 0, SSL_AES128 | SSL_AES128GCM | SSL_AES128CCM | SSL_AES128CCM8}, {0, SSL_TXT_AES256, NULL, 0, 0, 0, SSL_AES256 | SSL_AES256GCM | SSL_AES256CCM | SSL_AES256CCM8}, {0, SSL_TXT_AES, NULL, 0, 0, 0, SSL_AES}, {0, SSL_TXT_AES_GCM, NULL, 0, 0, 0, SSL_AES128GCM | SSL_AES256GCM}, {0, SSL_TXT_AES_CCM, NULL, 0, 0, 0, SSL_AES128CCM | SSL_AES256CCM | SSL_AES128CCM8 | SSL_AES256CCM8}, {0, SSL_TXT_AES_CCM_8, NULL, 0, 0, 0, SSL_AES128CCM8 | SSL_AES256CCM8}, {0, SSL_TXT_CAMELLIA128, NULL, 0, 0, 0, SSL_CAMELLIA128}, {0, SSL_TXT_CAMELLIA256, NULL, 0, 0, 0, SSL_CAMELLIA256}, {0, SSL_TXT_CAMELLIA, NULL, 0, 0, 0, SSL_CAMELLIA}, {0, SSL_TXT_CHACHA20, NULL, 0, 0, 0, SSL_CHACHA20}, {0, SSL_TXT_ARIA_GCM, NULL, 0, 0, 0, SSL_ARIA128GCM | SSL_ARIA256GCM}, {0, SSL_TXT_ARIA128, NULL, 0, 0, 0, SSL_ARIA128GCM}, {0, SSL_TXT_ARIA256, NULL, 0, 0, 0, SSL_ARIA256GCM}, /* MAC aliases */ {0, SSL_TXT_MD5, NULL, 0, 0, 0, 0, SSL_MD5}, {0, SSL_TXT_SHA1, NULL, 0, 0, 0, 0, SSL_SHA1}, {0, SSL_TXT_SHA, NULL, 0, 0, 0, 0, SSL_SHA1}, {0, SSL_TXT_GOST94, NULL, 0, 0, 0, 0, SSL_GOST94}, {0, SSL_TXT_GOST89MAC, NULL, 0, 0, 0, 0, SSL_GOST89MAC | SSL_GOST89MAC12}, {0, SSL_TXT_SHA256, NULL, 0, 0, 0, 0, SSL_SHA256}, {0, SSL_TXT_SHA384, NULL, 0, 0, 0, 0, SSL_SHA384}, {0, SSL_TXT_GOST12, NULL, 0, 0, 0, 0, SSL_GOST12_256}, /* protocol version aliases */ {0, SSL_TXT_SSLV3, NULL, 0, 0, 0, 0, 0, SSL3_VERSION}, {0, SSL_TXT_TLSV1, NULL, 0, 0, 0, 0, 0, TLS1_VERSION}, {0, "TLSv1.0", NULL, 0, 0, 0, 0, 0, TLS1_VERSION}, {0, SSL_TXT_TLSV1_2, NULL, 0, 0, 0, 0, 0, TLS1_2_VERSION}, /* strength classes */ {0, SSL_TXT_LOW, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, SSL_LOW}, {0, SSL_TXT_MEDIUM, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, SSL_MEDIUM}, {0, SSL_TXT_HIGH, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, SSL_HIGH}, /* FIPS 140-2 approved ciphersuite */ {0, SSL_TXT_FIPS, NULL, 0, 0, 0, ~SSL_eNULL, 0, 0, 0, 0, 0, SSL_FIPS}, /* "EDH-" aliases to "DHE-" labels (for backward compatibility) */ {0, SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA, NULL, 0, SSL_kDHE, SSL_aDSS, SSL_3DES, SSL_SHA1, 0, 0, 0, 0, SSL_HIGH | SSL_FIPS}, {0, SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA, NULL, 0, SSL_kDHE, SSL_aRSA, SSL_3DES, SSL_SHA1, 0, 0, 0, 0, SSL_HIGH | SSL_FIPS}, }; /* * Search for public key algorithm with given name and return its pkey_id if * it is available. Otherwise return 0 */ #ifdef OPENSSL_NO_ENGINE static int get_optional_pkey_id(const char *pkey_name) { const EVP_PKEY_ASN1_METHOD *ameth; int pkey_id = 0; ameth = EVP_PKEY_asn1_find_str(NULL, pkey_name, -1); if (ameth && EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth) > 0) return pkey_id; return 0; } #else static int get_optional_pkey_id(const char *pkey_name) { const EVP_PKEY_ASN1_METHOD *ameth; ENGINE *tmpeng = NULL; int pkey_id = 0; ameth = EVP_PKEY_asn1_find_str(&tmpeng, pkey_name, -1); if (ameth) { if (EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth) <= 0) pkey_id = 0; } ENGINE_finish(tmpeng); return pkey_id; } #endif /* masks of disabled algorithms */ static uint32_t disabled_enc_mask; static uint32_t disabled_mac_mask; static uint32_t disabled_mkey_mask; static uint32_t disabled_auth_mask; int ssl_load_ciphers(void) { size_t i; const ssl_cipher_table *t; disabled_enc_mask = 0; ssl_sort_cipher_list(); for (i = 0, t = ssl_cipher_table_cipher; i < SSL_ENC_NUM_IDX; i++, t++) { if (t->nid == NID_undef) { ssl_cipher_methods[i] = NULL; } else { const EVP_CIPHER *cipher = EVP_get_cipherbynid(t->nid); ssl_cipher_methods[i] = cipher; if (cipher == NULL) disabled_enc_mask |= t->mask; } } disabled_mac_mask = 0; for (i = 0, t = ssl_cipher_table_mac; i < SSL_MD_NUM_IDX; i++, t++) { const EVP_MD *md = EVP_get_digestbynid(t->nid); ssl_digest_methods[i] = md; if (md == NULL) { disabled_mac_mask |= t->mask; } else { int tmpsize = EVP_MD_size(md); if (!ossl_assert(tmpsize >= 0)) return 0; ssl_mac_secret_size[i] = tmpsize; } } /* Make sure we can access MD5 and SHA1 */ if (!ossl_assert(ssl_digest_methods[SSL_MD_MD5_IDX] != NULL)) return 0; if (!ossl_assert(ssl_digest_methods[SSL_MD_SHA1_IDX] != NULL)) return 0; disabled_mkey_mask = 0; disabled_auth_mask = 0; #ifdef OPENSSL_NO_RSA disabled_mkey_mask |= SSL_kRSA | SSL_kRSAPSK; disabled_auth_mask |= SSL_aRSA; #endif #ifdef OPENSSL_NO_DSA disabled_auth_mask |= SSL_aDSS; #endif #ifdef OPENSSL_NO_DH disabled_mkey_mask |= SSL_kDHE | SSL_kDHEPSK; #endif #ifdef OPENSSL_NO_EC disabled_mkey_mask |= SSL_kECDHEPSK; disabled_auth_mask |= SSL_aECDSA; #endif #ifdef OPENSSL_NO_PSK disabled_mkey_mask |= SSL_PSK; disabled_auth_mask |= SSL_aPSK; #endif #ifdef OPENSSL_NO_SRP disabled_mkey_mask |= SSL_kSRP; #endif /* * Check for presence of GOST 34.10 algorithms, and if they are not * present, disable appropriate auth and key exchange */ ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac"); if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX] = 32; else disabled_mac_mask |= SSL_GOST89MAC; ssl_mac_pkey_id[SSL_MD_GOST89MAC12_IDX] = get_optional_pkey_id("gost-mac-12"); if (ssl_mac_pkey_id[SSL_MD_GOST89MAC12_IDX]) ssl_mac_secret_size[SSL_MD_GOST89MAC12_IDX] = 32; else disabled_mac_mask |= SSL_GOST89MAC12; if (!get_optional_pkey_id("gost2001")) disabled_auth_mask |= SSL_aGOST01 | SSL_aGOST12; if (!get_optional_pkey_id("gost2012_256")) disabled_auth_mask |= SSL_aGOST12; if (!get_optional_pkey_id("gost2012_512")) disabled_auth_mask |= SSL_aGOST12; /* * Disable GOST key exchange if no GOST signature algs are available * */ if ((disabled_auth_mask & (SSL_aGOST01 | SSL_aGOST12)) == (SSL_aGOST01 | SSL_aGOST12)) disabled_mkey_mask |= SSL_kGOST; return 1; } #ifndef OPENSSL_NO_COMP static int sk_comp_cmp(const SSL_COMP *const *a, const SSL_COMP *const *b) { return ((*a)->id - (*b)->id); } DEFINE_RUN_ONCE_STATIC(do_load_builtin_compressions) { SSL_COMP *comp = NULL; COMP_METHOD *method = COMP_zlib(); CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE); ssl_comp_methods = sk_SSL_COMP_new(sk_comp_cmp); if (COMP_get_type(method) != NID_undef && ssl_comp_methods != NULL) { comp = OPENSSL_malloc(sizeof(*comp)); if (comp != NULL) { comp->method = method; comp->id = SSL_COMP_ZLIB_IDX; comp->name = COMP_get_name(method); sk_SSL_COMP_push(ssl_comp_methods, comp); sk_SSL_COMP_sort(ssl_comp_methods); } } CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE); return 1; } static int load_builtin_compressions(void) { return RUN_ONCE(&ssl_load_builtin_comp_once, do_load_builtin_compressions); } #endif int ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc, const EVP_MD **md, int *mac_pkey_type, size_t *mac_secret_size, SSL_COMP **comp, int use_etm) { int i; const SSL_CIPHER *c; c = s->cipher; if (c == NULL) return 0; if (comp != NULL) { SSL_COMP ctmp; #ifndef OPENSSL_NO_COMP if (!load_builtin_compressions()) { /* * Currently don

RC4-HMAC-MD5

AES-128-CBC-HMAC-SHA1

AES-256-CBC-HMAC-SHA1

AES-128-CBC-HMAC-SHA256

AES-256-CBC-HMAC-SHA256

:



;

,

Applying rule %d with %08x/%08x/%08x/%08x/%08x %08x (%d)\n

\nName: %s:\nAlgo = %08x/%08x/%08x/%08x/%08x Algo_strength = %08x\n

Action = %d\n

+

\0

-

+

!

@

A

Z

0

9

a

z

-

.

=

-

.

=

+

buflen

ADH:SOME

ADH-MY-CIPHER

\0

\0

\0

STRENGTH

SECLEVEL=

0

multi

@

:

\0

\0

\0

SUITEB128ONLY

SUITEB128C2

SUITEB128

SUITEB192

ECDHE-ECDSA-AES256-GCM-SHA384

ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384

ECDHE-ECDSA-AES128-GCM-SHA256

ECDHE-ECDSA-AES256-GCM-SHA384

t too bad, but * we prefer authenticated ciphers.) */ ssl_cipher_apply_rule(0, 0, SSL_aNULL, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); /* * ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1, * &head, &tail); */ ssl_cipher_apply_rule(0, SSL_kRSA, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); ssl_cipher_apply_rule(0, SSL_kPSK, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); /* RC4 is sort-of broken -- move to the end */ ssl_cipher_apply_rule(0, 0, 0, SSL_RC4, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); /* * Now sort by symmetric encryption strength. The above ordering remains * in force within each class */ if (!ssl_cipher_strength_sort(&head, &tail)) { OPENSSL_free(co_list); return NULL; } /* * Partially overrule strength sort to prefer TLS 1.2 ciphers/PRFs. * TODO(openssl-team): is there an easier way to accomplish all this? */ ssl_cipher_apply_rule(0, 0, 0, 0, 0, TLS1_2_VERSION, 0, CIPHER_BUMP, -1, &head, &tail); /* * Irrespective of strength, enforce the following order: * (EC)DHE + AEAD > (EC)DHE > rest of AEAD > rest. * Within each group, ciphers remain sorted by strength and previous * preference, i.e., * 1) ECDHE > DHE * 2) GCM > CHACHA * 3) AES > rest * 4) TLS 1.2 > legacy * * Because we now bump ciphers to the top of the list, we proceed in * reverse order of preference. */ ssl_cipher_apply_rule(0, 0, 0, 0, SSL_AEAD, 0, 0, CIPHER_BUMP, -1, &head, &tail); ssl_cipher_apply_rule(0, SSL_kDHE | SSL_kECDHE, 0, 0, 0, 0, 0, CIPHER_BUMP, -1, &head, &tail); ssl_cipher_apply_rule(0, SSL_kDHE | SSL_kECDHE, 0, 0, SSL_AEAD, 0, 0, CIPHER_BUMP, -1, &head, &tail); /* Now disable everything (maintaining the ordering!) */ ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail); /* * We also need cipher aliases for selecting based on the rule_str. * There might be two types of entries in the rule_str: 1) names * of ciphers themselves 2) aliases for groups of ciphers. * For 1) we need the available ciphers and for 2) the cipher * groups of cipher_aliases added together in one list (otherwise * we would be happy with just the cipher_aliases table). */ num_of_group_aliases = OSSL_NELEM(cipher_aliases); num_of_alias_max = num_of_ciphers + num_of_group_aliases + 1; ca_list = OPENSSL_malloc(sizeof(*ca_list) * num_of_alias_max); if (ca_list == NULL) { OPENSSL_free(co_list); SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST, ERR_R_MALLOC_FAILURE); return NULL; /* Failure */ } ssl_cipher_collect_aliases(ca_list, num_of_group_aliases, disabled_mkey, disabled_auth, disabled_enc, disabled_mac, head); /* * If the rule_string begins with DEFAULT, apply the default rule * before using the (possibly available) additional rules. */ ok = 1; rule_p = rule_str; if (strncmp(rule_str, "DEFAULT", 7) == 0) { ok = ssl_cipher_process_rulestr(SSL_DEFAULT_CIPHER_LIST, &head, &tail, ca_list, c); rule_p += 7; if (*rule_p ==

) rule_p++; } if (ok && (strlen(rule_p) > 0)) ok = ssl_cipher_process_rulestr(rule_p, &head, &tail, ca_list, c); OPENSSL_free(ca_list); /* Not needed anymore */ if (!ok) { /* Rule processing failure */ OPENSSL_free(co_list); return NULL; } /* * Allocate new "cipherstack" for the result, return with error * if we cannot get one. */ if ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL) { OPENSSL_free(co_list); return NULL; } /* * The cipher selection for the list is done. The ciphers are added * to the resulting precedence to the STACK_OF(SSL_CIPHER). */ for (curr = head; curr != NULL; curr = curr->next) { if (curr->active) { if (!sk_SSL_CIPHER_push(cipherstack, curr->cipher)) { OPENSSL_free(co_list); sk_SSL_CIPHER_free(cipherstack); return NULL; } #ifdef CIPHER_DEBUG fprintf(stderr, "<%s>\n", curr->cipher->name); #endif } } OPENSSL_free(co_list); /* Not needed any longer */ tmp_cipher_list = sk_SSL_CIPHER_dup(cipherstack); if (tmp_cipher_list == NULL) { sk_SSL_CIPHER_free(cipherstack); return NULL; } sk_SSL_CIPHER_free(*cipher_list); *cipher_list = cipherstack; if (*cipher_list_by_id != NULL) sk_SSL_CIPHER_free(*cipher_list_by_id); *cipher_list_by_id = tmp_cipher_list; (void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id, ssl_cipher_ptr_id_cmp); sk_SSL_CIPHER_sort(*cipher_list_by_id); return cipherstack; } char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len) { const char *ver; const char *kx, *au, *enc, *mac; uint32_t alg_mkey, alg_auth, alg_enc, alg_mac; static const char *format = "%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s\n"; if (buf == NULL) { len = 128; buf = OPENSSL_malloc(len); if (buf == NULL) return NULL; } else if (len < 128) { return NULL; } alg_mkey = cipher->algorithm_mkey; alg_auth = cipher->algorithm_auth; alg_enc = cipher->algorithm_enc; alg_mac = cipher->algorithm_mac; ver = ssl_protocol_to_string(cipher->min_tls); switch (alg_mkey) { case SSL_kRSA: kx = "RSA"; break; case SSL_kDHE: kx = "DH"; break; case SSL_kECDHE: kx = "ECDH"; break; case SSL_kPSK: kx = "PSK"; break; case SSL_kRSAPSK: kx = "RSAPSK"; break; case SSL_kECDHEPSK: kx = "ECDHEPSK"; break; case SSL_kDHEPSK: kx = "DHEPSK"; break; case SSL_kSRP: kx = "SRP"; break; case SSL_kGOST: kx = "GOST"; break; case SSL_kANY: kx = "any"; break; default: kx = "unknown"; } switch (alg_auth) { case SSL_aRSA: au = "RSA"; break; case SSL_aDSS: au = "DSS"; break; case SSL_aNULL: au = "None"; break; case SSL_aECDSA: au = "ECDSA"; break; case SSL_aPSK: au = "PSK"; break; case SSL_aSRP: au = "SRP"; break; case SSL_aGOST01: au = "GOST01"; break; /* New GOST ciphersuites have both SSL_aGOST12 and SSL_aGOST01 bits */ case (SSL_aGOST12 | SSL_aGOST01): au = "GOST12"; break; case SSL_aANY: au = "any"; break; default: au = "unknown"; break; } switch (alg_enc) { case SSL_DES: enc = "DES(56)"; break; case SSL_3DES: enc = "3DES(168)"; break; case SSL_RC4: enc = "RC4(128)"; break; case SSL_RC2: enc = "RC2(128)"; break; case SSL_IDEA: enc = "IDEA(128)"; break; case SSL_eNULL: enc = "None"; break; case SSL_AES128: enc = "AES(128)"; break; case SSL_AES256: enc = "AES(256)"; break; case SSL_AES128GCM: enc = "AESGCM(128)"; break; case SSL_AES256GCM: enc = "AESGCM(256)"; break; case SSL_AES128CCM: enc = "AESCCM(128)"; break; case SSL_AES256CCM: enc = "AESCCM(256)"; break; case SSL_AES128CCM8: enc = "AESCCM8(128)"; break; case SSL_AES256CCM8: enc = "AESCCM8(256)"; break; case SSL_CAMELLIA128: enc = "Camellia(128)"; break; case SSL_CAMELLIA256: enc = "Camellia(256)"; break; case SSL_ARIA128GCM: enc = "ARIAGCM(128)"; break; case SSL_ARIA256GCM: enc = "ARIAGCM(256)"; break; case SSL_SEED: enc = "SEED(128)"; break; case SSL_eGOST2814789CNT: case SSL_eGOST2814789CNT12: enc = "GOST89(256)"; break; case SSL_CHACHA20POLY1305: enc = "CHACHA20/POLY1305(256)"; break; default: enc = "unknown"; break; } switch (alg_mac) { case SSL_MD5: mac = "MD5"; break; case SSL_SHA1: mac = "SHA1"; break; case SSL_SHA256: mac = "SHA256"; break; case SSL_SHA384: mac = "SHA384"; break; case SSL_AEAD: mac = "AEAD"; break; case SSL_GOST89MAC: case SSL_GOST89MAC12: mac = "GOST89"; break; case SSL_GOST94: mac = "GOST94"; break; case SSL_GOST12_256: case SSL_GOST12_512: mac = "GOST2012"; break; default: mac = "unknown"; break; } BIO_snprintf(buf, len, format, cipher->name, ver, kx, au, enc, mac); return buf; } const char *SSL_CIPHER_get_version(const SSL_CIPHER *c) { if (c == NULL) return "(NONE)"; /* * Backwards-compatibility crutch. In almost all contexts we report TLS * 1.0 as "TLSv1", but for ciphers we report "TLSv1.0". */ if (c->min_tls == TLS1_VERSION) return "TLSv1.0"; return ssl_protocol_to_string(c->min_tls); } /* return the actual cipher being used */ const char *SSL_CIPHER_get_name(const SSL_CIPHER *c) { if (c != NULL) return c->name; return "(NONE)"; } /* return the actual cipher being used in RFC standard name */ const char *SSL_CIPHER_standard_name(const SSL_CIPHER *c) { if (c != NULL) return c->stdname; return "(NONE)"; } /* return the OpenSSL name based on given RFC standard name */ const char *OPENSSL_cipher_name(const char *stdname) { const SSL_CIPHER *c; if (stdname == NULL) return "(NONE)"; c = ssl3_get_cipher_by_std_name(stdname); return SSL_CIPHER_get_name(c); } /* number of bits for symmetric cipher */ int SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits) { int ret = 0; if (c != NULL) { if (alg_bits != NULL) *alg_bits = (int)c->alg_bits; ret = (int)c->strength_bits; } return ret; } uint32_t SSL_CIPHER_get_id(const SSL_CIPHER *c) { return c->id; } SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n) { SSL_COMP *ctmp; int i, nn; if ((n == 0) || (sk == NULL)) return (NULL); nn = sk_SSL_COMP_num(sk); for (i = 0; i < nn; i++) { ctmp = sk_SSL_COMP_value(sk, i); if (ctmp->id == n) return ctmp; } return NULL; } #ifdef OPENSSL_NO_COMP STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void) { return NULL; } STACK_OF(SSL_COMP) *SSL_COMP_set0_compression_methods(STACK_OF(SSL_COMP) *meths) { return meths; } int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm) { return 1; } #else STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void) { load_builtin_compressions(); return ssl_comp_methods; } STACK_OF(SSL_COMP) *SSL_COMP_set0_compression_methods(STACK_OF(SSL_COMP) *meths) { STACK_OF(SSL_COMP) *old_meths = ssl_comp_methods; ssl_comp_methods = meths; return old_meths; } static void cmeth_free(SSL_COMP *cm) { OPENSSL_free(cm); } void ssl_comp_free_compression_methods_int(void) { STACK_OF(SSL_COMP) *old_meths = ssl_comp_methods; ssl_comp_methods = NULL; sk_SSL_COMP_pop_free(old_meths, cmeth_free); } int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm) { SSL_COMP *comp; if (cm == NULL || COMP_get_type(cm) == NID_undef) return 1; /*- * According to draft-ietf-tls-compression-04.txt, the * compression number ranges should be the following: * * 0 to 63: methods defined by the IETF * 64 to 192: external party methods assigned by IANA * 193 to 255: reserved for private use */ if (id < 193 || id > 255) { SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE); return 1; } CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE); comp = OPENSSL_malloc(sizeof(*comp)); if (comp == NULL) { CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE); SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, ERR_R_MALLOC_FAILURE); return 1; } comp->id = id; comp->method = cm; load_builtin_compressions(); if (ssl_comp_methods && sk_SSL_COMP_find(ssl_comp_methods, comp) >= 0) { OPENSSL_free(comp); CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE); SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, SSL_R_DUPLICATE_COMPRESSION_ID); return 1; } if (ssl_comp_methods == NULL || !sk_SSL_COMP_push(ssl_comp_methods, comp)) { OPENSSL_free(comp); CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE); SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, ERR_R_MALLOC_FAILURE); return 1; } CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE); return 0; } #endif const char *SSL_COMP_get_name(const COMP_METHOD *comp) { #ifndef OPENSSL_NO_COMP return comp ? COMP_get_name(comp) : NULL; #else return NULL; #endif } const char *SSL_COMP_get0_name(const SSL_COMP *comp) { #ifndef OPENSSL_NO_COMP return comp->name; #else return NULL; #endif } int SSL_COMP_get_id(const SSL_COMP *comp) { #ifndef OPENSSL_NO_COMP return comp->id; #else return -1; #endif } const SSL_CIPHER *ssl_get_cipher_by_char(SSL *ssl, const unsigned char *ptr, int all) { const SSL_CIPHER *c = ssl->method->get_cipher_by_char(ptr); if (c == NULL || (!all && c->valid == 0)) return NULL; return c; } const SSL_CIPHER *SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr) { return ssl->method->get_cipher_by_char(ptr); } int SSL_CIPHER_get_cipher_nid(const SSL_CIPHER *c) { int i; if (c == NULL) return NID_undef; i = ssl_cipher_info_lookup(ssl_cipher_table_cipher, c->algorithm_enc); if (i == -1) return NID_undef; return ssl_cipher_table_cipher[i].nid; } int SSL_CIPHER_get_digest_nid(const SSL_CIPHER *c) { int i = ssl_cipher_info_lookup(ssl_cipher_table_mac, c->algorithm_mac); if (i == -1) return NID_undef; return ssl_cipher_table_mac[i].nid; } int SSL_CIPHER_get_kx_nid(const SSL_CIPHER *c) { int i = ssl_cipher_info_lookup(ssl_cipher_table_kx, c->algorithm_mkey); if (i == -1) return NID_undef; return ssl_cipher_table_kx[i].nid; } int SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c) { int i = ssl_cipher_info_lookup(ssl_cipher_table_auth, c->algorithm_auth); if (i == -1) return NID_undef; return ssl_cipher_table_auth[i].nid; } const EVP_MD *SSL_CIPHER_get_handshake_digest(const SSL_CIPHER *c) { int idx = c->algorithm2 & SSL_HANDSHAKE_MAC_MASK; if (idx < 0 || idx >= SSL_MD_NUM_IDX) return NULL; return ssl_digest_methods[idx]; } int SSL_CIPHER_is_aead(const SSL_CIPHER *c) { return (c->algorithm_mac & SSL_AEAD) ? 1 : 0; } int ssl_cipher_get_overhead(const SSL_CIPHER *c, size_t *mac_overhead, size_t *int_overhead, size_t *blocksize, size_t *ext_overhead) { size_t mac = 0, in = 0, blk = 0, out = 0; /* Some hard-coded numbers for the CCM/Poly1305 MAC overhead * because there are no handy #defines for those. */ if (c->algorithm_enc & (SSL_AESGCM | SSL_ARIAGCM)) { out = EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN; } else if (c->algorithm_enc & (SSL_AES128CCM | SSL_AES256CCM)) { out = EVP_CCM_TLS_EXPLICIT_IV_LEN + 16; } else if (c->algorithm_enc & (SSL_AES128CCM8 | SSL_AES256CCM8)) { out = EVP_CCM_TLS_EXPLICIT_IV_LEN + 8; } else if (c->algorithm_enc & SSL_CHACHA20POLY1305) { out = 16; } else if (c->algorithm_mac & SSL_AEAD) { /* We

