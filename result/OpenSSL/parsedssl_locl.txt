Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved Copyright 2005 Nokia. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

struct timeval for Windows

struct timeval for DTLS

NOTE - c is not incremented as per c2l

NOTE - c is not incremented as per l2c

DTLS version numbers are strange because they're inverted. Except for DTLS1_BAD_VER, which should be considered "lower" than the rest.

Define the Bitmasks for SSL_CIPHER.algorithms. This bits are used packed as dense as possible. If new methods/ciphers etc will be added, the bits a likely to change, so this information is for internal library use only, even though SSL_CIPHER.algorithms can be publicly accessed. Use the according functions for cipher management instead. The bit mask handling in the selection and sorting scheme in ssl_create_cipher_list() has only limited capabilities, reflecting that the different entities within are mutually exclusive: ONLY ONE BIT PER MASK CAN BE SET AT A TIME.

Bits for algorithm_mkey (key exchange algorithm)

RSA key exchange

tmp DH key no DH cert

synonym

ephemeral ECDH

synonym

PSK

GOST key exchange

SRP

all PSK

Any appropriate key exchange algorithm (for TLS 1.3 ciphersuites)

Bits for algorithm_auth (server authentication)

RSA auth

DSS auth

no auth (i.e. use ADH or AECDH)

ECDSA aut

PSK auth

GOST R 34.10-2001 signature auth

SRP auth

GOST R 34.10-2012 signature auth

Any appropriate signature auth (for TLS 1.3 ciphersuites)

All bits requiring a certificate

Bits for algorithm_enc (symmetric encryption)

Bits for algorithm_mac (symmetric authentication)

Not a real MAC, just an indication it is part of cipher

When adding new digest in the ssl_ciph.c and increment SSL_MD_NUM_IDX make sure to update this constant too

Bits for algorithm2 (handshake digests and other extra flags)

Bits 0-7 are handshake MAC

Bits 8-15 bits are PRF

Stream MAC for GOST ciphersuites from cryptopro draft (currently this also goes into algorithm2)

we have used 0000003f - 26 bits left to go

Flag used on OpenSSL ciphersuite ids to indicate they are for SSLv3+

Check if an SSL structure is using DTLS

Check if we are using TLSv1.3

See if we need explicit IV

See if we use signature algorithms extension and signature algorithm before signatures.

Allow TLS 1.2 ciphersuites: applies to DTLS 1.2 as well as TLS 1.2: may apply to others in future.

Determine if a client can use TLS 1.2 ciphersuites: can't rely on method flags because it may not be set to correct version yet.

Determine if a client should send signature algorithms extension: as with TLS1.2 cipher we can't rely on method flags.

Mostly for SSLv3

Pseudo-constant. GOST cipher suites can use different certs for 1 SSL_CIPHER. So let's see which one we have in fact.

TODO(TLS1.3) for now use SSL_PKEY_RSA keys for PSS

SSL_kRSA <- RSA_ENC SSL_kDH <- DH_ENC & (RSA_ENC | RSA_SIGN | DSA_SIGN) SSL_kDHE <- RSA_ENC | RSA_SIGN | DSA_SIGN SSL_aRSA <- RSA_ENC | RSA_SIGN SSL_aDSS <- DSA_SIGN

#define CERT_INVALID 0 #define CERT_PUBLIC_KEY 1 #define CERT_PRIVATE_KEY 2

CipherSuite length. SSLv3 and all TLS versions.

used to hold info on the particular ciphers used

text name

RFC name

id, 4 bytes, first is version

changed in 1.0.0: these four used to be portions of a single value 'algorithms'

key exchange algorithm

server authentication

symmetric encryption

symmetric authentication

minimum SSL/TLS protocol version

maximum SSL/TLS protocol version

minimum DTLS protocol version

maximum DTLS protocol version

strength and export flags

Extra flags

Number of bits really used

Number of bits for algorithm

Used to hold SSL/TLS functions

Extra SSLv3/TLS stuff

Lets make this into an ASN.1 type structure as follows SSL_SESSION_ID ::= SEQUENCE { version INTEGER, -- structure version number SSLversion INTEGER, -- SSL version number Cipher OCTET STRING, -- the 3 byte cipher ID Session_ID OCTET STRING, -- the Session ID Master_key OCTET STRING, -- the master key Key_Arg [ 0 ] IMPLICIT OCTET STRING, -- the optional Key argument Time [ 1 ] EXPLICIT INTEGER, -- optional Start Time Timeout [ 2 ] EXPLICIT INTEGER, -- optional Timeout ins seconds Peer [ 3 ] EXPLICIT X509, -- optional Peer Certificate Session_ID_context [ 4 ] EXPLICIT OCTET STRING, -- the Session ID context Verify_result [ 5 ] EXPLICIT INTEGER, -- X509_V_... code for `Peer' HostName [ 6 ] EXPLICIT OCTET STRING, -- optional HostName from servername TLS extension PSK_identity_hint [ 7 ] EXPLICIT OCTET STRING, -- optional PSK identity hint PSK_identity [ 8 ] EXPLICIT OCTET STRING, -- optional PSK identity Ticket_lifetime_hint [9] EXPLICIT INTEGER, -- server's lifetime hint for session ticket Ticket [10] EXPLICIT OCTET STRING, -- session ticket (clients only) Compression_meth [11] EXPLICIT OCTET STRING, -- optional compression method SRP_username [ 12 ] EXPLICIT OCTET STRING -- optional SRP username flags [ 13 ] EXPLICIT INTEGER -- optional flags } Look in ssl/ssl_asn1.c for more details I'm using EXPLICIT tags so I can read the damn things using asn1parse :-).

what ssl version session info is being kept in here?

TLSv1.3 early_secret used for external PSKs

For <=TLS1.2 this is the master_key. For TLS1.3 this is the resumption master secret

session_id - valid?

this is used to determine whether the session is being reused in the appropriate context. It is up to the application to set this, via SSL_new

Used to indicate that session resumption is not allowed. Applications can also set this bit for a new session via not_resumable_session_cb to disable session caching and tickets.

This is the cert and type for the other end.

Certificate chain peer sent.

when app_verify_callback accepts a session where the peer's certificate is not ok, we must remember the error for session reuse:

only for servers

Need to lookup the method

when ASN.1 loaded, this needs to be used to load the 'cipher' structure

shared ciphers?

application specific data

These are used to make removal of session-ids more efficient and to implement a maximum cache size.

peer's list

peer's list

OPENSSL_NO_EC

RFC4507 info

Session ticket

Session ticket length

Session lifetime hint in seconds

Max number of bytes that can be sent as early data

The ALPN protocol selected for this session

Extended master secret support

param for all the callbacks

set client Hello login callback

set SRP N/g param callback for verification

set SRP client passwd callback

We check that the amount of unreadable early data doesn't exceed max_early_data. max_early_data is given in plaintext bytes. However if it is unreadable then we only know the number of ciphertext bytes. We also don't know how much the overhead should be because it depends on the ciphersuite. We make a small allowance. We assume 5 records of actual data plus the end of early data alert record. Each record has a tag and a content type byte. The longest tag length we know of is EVP_GCM_TLS_TAG_LEN. We don't count the content of the alert record either which is 2 bytes.

The allowance we have between the client's calculated ticket age and our own. We allow for 10 seconds (units are in ms). If a ticket is presented and the client's age calculation is different by more than this than our own then we do not allow that ticket for early_data.

Raw packet data for the extension

Set to 1 if the extension is present or 0 otherwise

Set to 1 if we have already parsed the extension or 0 otherwise

The type of this extension, i.e. a TLSEXT_TYPE_ value

Track what order extensions are received in (0-based).

Extension index values NOTE: Any updates to these defines should be mirrored with equivalent updates to ext_defs in extensions.c

Dummy index - must always be the last entry

Needed in ssl_cert.c

same as above but sorted for lookup

X509_STORE

Most session-ids that will be cached, default is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited.

This can have one of 2 values, ored together, SSL_SESS_CACHE_CLIENT, SSL_SESS_CACHE_SERVER, Default is SSL_SESSION_CACHE_SERVER, which means only SSL_accept which cache SSL_SESSIONS.

If timeout is not 0, it is the default timeout value set when SSL_new() is called. This has been put in to make life easier to set things up

If this callback is not null, it will be called each time a session id is added to the cache. If this function returns 1, it means that the callback will do a SSL_SESSION_free() when it has finished using it. Otherwise, on 0, it means the callback has finished with it. If remove_session_cb is not null, it will be called when a session-id is removed from the cache. After the call, OpenSSL will SSL_SESSION_free() it.

SSL new conn - started

SSL reneg - requested

SSL new conne/reneg - finished

SSL new accept - started

SSL reneg - requested

SSL accept/reneg - finished

session lookup misses

reuse attempt on timeouted session

session removed due to full cache

session reuse actually done

session-id that was not in the cache was passed back via the callback. This indicates that the application is supplying session-id's from other processes - spooky :-)

if defined, these override the X509_verify_cert() calls

before OpenSSL 0.9.7, 'app_verify_arg' was ignored ('app_verify_callback' was called with just one argument)

Default password callback.

Default password callback user data.

get client cert callback

cookie generate callback

verify cookie callback

For SSLv3/TLSv1 'ssl3-md5'

For SSLv3/TLSv1 'ssl3->sha1'

stack of SSL_COMP, SSLv3/TLSv1

Default values used when no per-SSL value is defined follow

used if SSL's info_callback is NULL

What we put in certificate_authorities extension for TLS 1.3 (ClientHello and CertificateRequest) or just client cert requests for earlier versions.

Default values to use in SSL structures follow (these are copied by SSL_new)

CERT

callback that allows applications to peek at protocol messages

called 'verify_callback' in the SSL

Default generate session ID callback.

CT Log Store

Validates that the SCTs (Signed Certificate Timestamps) are sufficient. If they are not, the connection should be aborted.

If we're using more than one pipeline how should we divide the data up between the pipes?

Maximum amount of data to send in one fragment. actual record size can be more than this due to padding and MAC overheads.

Up to how many pipelines should we use? If 0 then 1 is assumed

The default read buffer length to use (0 means not set)

Engine to pass requests for client certs to

Early callback. Mostly for extensions, but not entirely.

TLS extensions.

TLS extensions servername callback

RFC 4507 session ticket keys

Callback to support customisation of ticket key setting

certificate status request info

Callback for status request

ext status type used for CSR extension (OCSP Stapling)

EC extension values inherited by SSL structure

OPENSSL_NO_EC

ALPN information (we are in the process of transitioning from NPN to ALPN.)

For a server, this contains a callback function that allows the server to select the protocol for the connection. out: on successful return, this must point to the raw protocol name (without the length prefix). outlen: on successful return, this contains the length of |out|. in: points to the client's list of supported protocols in wire-format. inlen: the length of |in|.

For a client, this contains the list of supported protocols in wire format.

Next protocol negotiation information

For a server, this contains a callback function by which the set of advertised protocols can be provided.

For a client, this contains a callback function that selects the next protocol from the list provided by the server.

ctx for SRP authentication

Shared DANE context

SRTP profiles we are willing to do from RFC 5764

Callback for disabling session caching and ticket support on a session basis, depending on the chosen cipher.

Callback for logging key material for use with debugging tools like Wireshark. The callback should log `line` followed by a newline.

The maximum number of bytes that can be sent as early data

TLS1.3 padding callback

protocol version (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, DTLS1_VERSION)

SSLv3

There are 2 BIO's even though they are normally both the same. This is so data can be read and written to different handlers

used by SSL_read

used by SSL_write

used during session-id reuse to concatenate messages

This holds a variable that indicates what we were doing when a 0 or -1 is returned. This is needed for non-blocking IO so we know what request needs re-doing when in SSL_accept or SSL_connect

Imagine that here's a boolean member "init" that is switched as soon as SSL_set_{accept/connect}_state is called for the first time, so that "state" and "handshake_func" are properly initialized. But as handshake_func is == 0 until then, we use this test instead of an "init" member.

are we the server side?

Generate a new session or reuse an old one. NB: For servers, the 'new' session may actually be a previously cached session or even the previous session unless SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set

don't send shutdown packets

we have shut things down, 0x01 sent, 0x02 for received

where we are

buffer used during init

pointer to handshake message body, set by ssl3_get_message()

amount read/written

amount read/written

SSLv3 variables

DTLSv1 variables

callback that allows applications to peek at protocol messages

reusing a previous session

Per connection DANE state

crypto

These are the ones being used, the ones in SSL_SESSION are the ones to be 'copied' into these ones

The TLS1.3 secrets. The resumption master secret is stored in the session.

cryptographic state

TLSv1.3 static read IV

used for mac generation

compression

uncompress

cryptographic state

TLSv1.3 static write IV

used for mac generation

Count of how many KeyUpdate messages we have received

session info

client cert?

This is used to hold the server certificate used

CERT

The hash of all messages prior to the CertificateVerify, and the length of that hash.

Flag to indicate whether we should send a HelloRetryRequest or not

the session_id_context is used to ensure sessions are only reused in the appropriate context

This can also be in the session once a session is established

TLSv1.3 PSK session

Default generate session ID callback.

Used in SSL3

0 don't care about verify failure. 1 fail if verify fails

fail if callback returns 0

optional informational callback

error bytes to be written

actual code

Verified chain of peer

extra application data

for server side, keep the list of CA_dn we can use

protocol behaviour

API behaviour

What was passed in ClientHello.legacy_version. Used for RSA pre-master secret and SSLv3/TLS (<=1.2) rollback check

If we're using more than one pipeline how should we divide the data up between the pipes?

Maximum amount of data to send in one fragment. actual record size can be more than this due to padding and MAC overheads.

Up to how many pipelines should we use? If 0 then 1 is assumed

Built-in extension flags

TLS extension debug callback

certificate status request info

Status type or -1 if no status type

Raw extension data, if seen

Length of raw extension data, if seen

Expect OCSP CertificateStatus message

OCSP status request only

OCSP response received or to be sent

RFC4507 session ticket expected to be received or sent

our list

our list

OPENSSL_NO_EC

TLS Session Ticket extension override

TLS Session Ticket extension callback

TLS pre-shared secret session resumption

For a client, this contains the list of supported protocols in wire format.

Next protocol negotiation. For the client, this is the protocol that we sent in NextProtocol and is set when handling ServerHello extensions. For a server, this is the client's selected_protocol from NextProtocol and is set when handling the NextProtocol message, before the Finished message.

The available PSK key exchange modes

Set to one if we have negotiated ETM

Are we expecting to receive early data?

Is the session suitable for early data?

May be sent by a server in HRR. Must be echoed back in ClientHello

Parsed form of the ClientHello, kept around across early_cb calls.

no further mod of servername 0 : call the servername extension callback. 1 : prepare 2, allow last ack just after in server callback. 2 : don't call servername callback, no ack in server hello

Validates that the SCTs (Signed Certificate Timestamps) are sufficient. If they are not, the connection should be aborted.

User-supplied argument that is passed to the ct_validation_callback

Consolidated stack of SCTs from all sources. Lazily populated by CT_get_peer_scts(SSL)

Have we attempted to find/parse SCTs yet?

initial ctx, used to store sessions

What we'll do

What's been chosen

1 if we are renegotiating. 2 if we are a server and are inside a handshake (i.e. not just sending a HelloRequest)

If sending a KeyUpdate is pending

ctx for SRP authentication

Callback for disabling session caching and ticket support on a session basis, depending on the chosen cipher.

Default password callback.

Default password callback user data.

Async Job info

The maximum number of plaintext bytes that can be sent as early data

The number of bytes of early data received so far. If we accepted early data then this is a count of the plaintext bytes. If we rejected it then this is a count of the ciphertext bytes.

TLS1.3 padding callback

Structure containing table entry of values associated with the signature algorithms (signature scheme) extension

TLS 1.3 signature scheme name

Raw value used in extension

NID of hash algorithm or NID_undef if no hash

Index of hash algorithm or -1 if no hash algorithm

NID of signature algorithm

Index of signature algorithm

Combined hash and signature NID, if any

Required public key curve (ECDSA only)

Structure containing table entry of certificate info corresponding to CERT_PKEY entries

NID of pubic key algorithm

authmask corresponding to key type

flags for countermeasure against known-IV weakness

used during startup, digest all incoming/outgoing packets

When handshake digest is determined, buffer is hashed and freed and MD_CTX for the required digest is stored here.

Set whenever an expected ChangeCipherSpec message is processed. Unset when the peer's Finished message is received. Unexpected ChangeCipherSpec messages trigger a fatal alert.

we allow one fatal and one warning alert to be outstanding, send close alert via the warning alert

This flag is set when we should renegotiate ASAP, basically when there is no more data in the read or write buffers

actually only need to be 16+20 for SSLv3 and 12 for TLS

used to hold the new cipher we are going to use

holds short lived DH/ECDH key

used for certificate requests

Certificate types in certificate request message.

Certificate authorities list peer sent

Raw values of the cipher list from a client

Temporary storage for premaster secret

Temporary storage for PSK key

Signature algorithm we actually use

Pointer to certificate we use

signature algorithms peer reports: e.g. supported signature algorithms extension for server or as part of a certificate request for client.

Size of above array

Sigalg peer actualy uses

Set if corresponding CERT_PKEY can be used with current SSL session: e.g. appropriate curve, signature algorithms etc. If zero it can't be used at all.

For servers the following masks are for the key and auth algorithms that are supported by the certs below. For clients they are masks of disabled algorithms based on the current session.

The following are used by the client to see if a cipher is allowed or not. It contains the minimum and maximum version the client's using based on what it knows so far.

Connection binding to prevent renegotiation attacks

TODOEKR

Set if we saw the Next Protocol Negotiation extension from our peer.

ALPN information (we are in the process of transitioning from NPN to ALPN.)

In a server these point to the selected ALPN protocol after the ClientHello has been processed. In a client these contain the protocol that the server selected once the ServerHello has been processed.

used by the server to know what options were proposed

used by the client to know if it actually sent alpn

This is set to true if we believe that this is a version of Safari running on OS X 10.6 or newer. We wish to know this because Safari on 10.8 .. 10.8.3 has broken ECDHE-ECDSA support.

!OPENSSL_NO_EC

For clients: peer temporary key

The group_id for the DH/ECDH key

DTLS structures

Max MTU overhead we know about so far is 40 for IPv6 + 8 for UDP

Flag used in message reuse to indicate the buffer contains the record header as well as the the handshake message header.

cryptographic state

used for mac generation

compression

Number of read timeouts so far

Number of write timeouts so far

Number of alerts received so far

64-bit value in big-endian encoding

handshake message numbers

Buffered handshake messages

Buffered (sent) handshake records

max on-the-wire DTLS packet size

max DTLS packet size

Indicates when the last handshake msg sent will timeout

Timeout duration

From ECC-TLS draft, used in encoding the curve type in ECParameters

OPENSSL_NO_EC

Chain for this certificate

serverinfo data for this certificate. The data is in TLS Extension wire format, specifically it's a series of records like: uint16_t extension_type; // (RFC 5246, 7.4.1.4, Extension) uint16_t length; uint8_t data[length];

Retrieve Suite B flags

Uses to check strict mode: suite B modes are always strict

The context which this extension applies to

Per-connection flags relating to this extension type: not used if part of an SSL_CTX structure.

ext_flags values

Indicates an extension has been received. Used to check for unsolicited or duplicate extensions.

Indicates an extension has been sent: used to enable sending of corresponding ServerHello extension.

Current active set

ALWAYS points to an element of the pkeys array Probably it would make more sense to store an index, not a pointer.

Flags related to certificates

Custom certificate types sent in certificate request message.

supported signature algorithms. When set on a client this is sent in the client hello as the supported signature algorithms extension. For servers it represents the signature algorithms we are willing to use.

Size of above array

Client authentication signature algorithms, if not set then uses conf_sigalgs. On servers these will be the signature algorithms sent to the client in a certificate request for TLS 1.2. On a client this represents the signature algorithms we are willing to use for client authentication.

Size of above array

Signature algorithms shared by client and server: cached because these are used most often.

Certificate setup callback: if set is called whenever a certificate may be required (client or server). the callback can then examine any appropriate parameters and setup any certificates required. This allows advanced applications to select certificates on the fly: for example based on supported signature algorithms or curves.

Optional X509_STORE for chain building or certificate validation If NULL the parent SSL_CTX store is used instead.

Custom extensions

Security callback

Security level

If not NULL psk identity hint to use for servers

>1 only if SSL_copy_session_id is used

This is for the SSLv3/TLSv1.0 differences in crypto/hash stuff It is a bit of a mess of functions, but hell, think of it as an opaque structure :-)

Various flags indicating protocol version requirements

Set the handshake header

Close construction of the handshake message

Write out handshake message

Values for enc_flags

Uses explicit IV for CBC mode

Uses signature algorithms extension

Uses SHA256 default PRF

Is DTLS

Allow TLS 1.2 ciphersuites: applies to DTLS 1.2 as well as TLS 1.2: may apply to others in future.

Used for holding the relevant compression methods loaded into SSL_CTX

The identifier byte for this compression type

Text name used for the compression type

The method :-)

Dummy status type for the status_type extension. Indicates no status type set

Sigalgs values

Known PSK key exchange modes

Internal representations of key exchange modes

An invalid index into the TLSv1.3 PSK identities

A dummy signature value not valid for TLSv1.2 signature algs

TLSv1.3 downgrade protection sentinel values

Flags for SSL methods

Returns true if certificate and private key for 'idx' are present

Flags values from tls1_ec_curve_id2nid()

Mask for curve type

OPENSSL_NO_EC

Return codes for tls_get_ticket_from_client() and tls_decrypt_ticket()

fatal error, malloc failure

fatal error, either from parsing or decrypting the ticket

No ticket present

Empty ticket present

the ticket couldn't be decrypted

a ticket was successfully decrypted

same as above but the ticket needs to be renewed

ssl_log_rsa_client_key_exchange logs |premaster| to the SSL_CTX associated with |ssl|, if logging is enabled. It returns one on success and zero on failure. The entry is identified by the first 8 bytes of |encrypted_premaster|.

ssl_log_secret logs |secret| to the SSL_CTX associated with |ssl|, if logging is available. It returns one on success and zero on failure. It tags the entry with |label|.

s3_cbc.c

statem/extensions_cust.c

OPENSSL_UNIT_TEST

www.openssl.org/source/license.html

(RFC 5246, 7.4.1.4, Extension)

License

e_os.h

record/record.h

statem/statem.h

packet_locl.h

internal/dane.h

internal/refcount.h

re inverted. Except for * DTLS1_BAD_VER, which should be considered "lower" than the rest. */ # define dtls_ver_ordinal(v1) (((v1) == DTLS1_BAD_VER) ? 0xff00 : (v1)) # define DTLS_VERSION_GT(v1, v2) (dtls_ver_ordinal(v1) < dtls_ver_ordinal(v2)) # define DTLS_VERSION_GE(v1, v2) (dtls_ver_ordinal(v1) <= dtls_ver_ordinal(v2)) # define DTLS_VERSION_LT(v1, v2) (dtls_ver_ordinal(v1) > dtls_ver_ordinal(v2)) # define DTLS_VERSION_LE(v1, v2) (dtls_ver_ordinal(v1) >= dtls_ver_ordinal(v2)) /* * Define the Bitmasks for SSL_CIPHER.algorithms. * This bits are used packed as dense as possible. If new methods/ciphers * etc will be added, the bits a likely to change, so this information * is for internal library use only, even though SSL_CIPHER.algorithms * can be publicly accessed. * Use the according functions for cipher management instead. * * The bit mask handling in the selection and sorting scheme in * ssl_create_cipher_list() has only limited capabilities, reflecting * that the different entities within are mutually exclusive: * ONLY ONE BIT PER MASK CAN BE SET AT A TIME. */ /* Bits for algorithm_mkey (key exchange algorithm) */ /* RSA key exchange */ # define SSL_kRSA 0x00000001U /* tmp DH key no DH cert */ # define SSL_kDHE 0x00000002U /* synonym */ # define SSL_kEDH SSL_kDHE /* ephemeral ECDH */ # define SSL_kECDHE 0x00000004U /* synonym */ # define SSL_kEECDH SSL_kECDHE /* PSK */ # define SSL_kPSK 0x00000008U /* GOST key exchange */ # define SSL_kGOST 0x00000010U /* SRP */ # define SSL_kSRP 0x00000020U # define SSL_kRSAPSK 0x00000040U # define SSL_kECDHEPSK 0x00000080U # define SSL_kDHEPSK 0x00000100U /* all PSK */ # define SSL_PSK (SSL_kPSK | SSL_kRSAPSK | SSL_kECDHEPSK | SSL_kDHEPSK) /* Any appropriate key exchange algorithm (for TLS 1.3 ciphersuites) */ # define SSL_kANY 0x00000000U /* Bits for algorithm_auth (server authentication) */ /* RSA auth */ # define SSL_aRSA 0x00000001U /* DSS auth */ # define SSL_aDSS 0x00000002U /* no auth (i.e. use ADH or AECDH) */ # define SSL_aNULL 0x00000004U /* ECDSA auth*/ # define SSL_aECDSA 0x00000008U /* PSK auth */ # define SSL_aPSK 0x00000010U /* GOST R 34.10-2001 signature auth */ # define SSL_aGOST01 0x00000020U /* SRP auth */ # define SSL_aSRP 0x00000040U /* GOST R 34.10-2012 signature auth */ # define SSL_aGOST12 0x00000080U /* Any appropriate signature auth (for TLS 1.3 ciphersuites) */ # define SSL_aANY 0x00000000U /* All bits requiring a certificate */ #define SSL_aCERT \ (SSL_aRSA | SSL_aDSS | SSL_aECDSA | SSL_aGOST01 | SSL_aGOST12) /* Bits for algorithm_enc (symmetric encryption) */ # define SSL_DES 0x00000001U # define SSL_3DES 0x00000002U # define SSL_RC4 0x00000004U # define SSL_RC2 0x00000008U # define SSL_IDEA 0x00000010U # define SSL_eNULL 0x00000020U # define SSL_AES128 0x00000040U # define SSL_AES256 0x00000080U # define SSL_CAMELLIA128 0x00000100U # define SSL_CAMELLIA256 0x00000200U # define SSL_eGOST2814789CNT 0x00000400U # define SSL_SEED 0x00000800U # define SSL_AES128GCM 0x00001000U # define SSL_AES256GCM 0x00002000U # define SSL_AES128CCM 0x00004000U # define SSL_AES256CCM 0x00008000U # define SSL_AES128CCM8 0x00010000U # define SSL_AES256CCM8 0x00020000U # define SSL_eGOST2814789CNT12 0x00040000U # define SSL_CHACHA20POLY1305 0x00080000U # define SSL_ARIA128GCM 0x00100000U # define SSL_ARIA256GCM 0x00200000U # define SSL_AESGCM (SSL_AES128GCM | SSL_AES256GCM) # define SSL_AESCCM (SSL_AES128CCM | SSL_AES256CCM | SSL_AES128CCM8 | SSL_AES256CCM8) # define SSL_AES (SSL_AES128|SSL_AES256|SSL_AESGCM|SSL_AESCCM) # define SSL_CAMELLIA (SSL_CAMELLIA128|SSL_CAMELLIA256) # define SSL_CHACHA20 (SSL_CHACHA20POLY1305) # define SSL_ARIAGCM (SSL_ARIA128GCM | SSL_ARIA256GCM) # define SSL_ARIA (SSL_ARIAGCM) /* Bits for algorithm_mac (symmetric authentication) */ # define SSL_MD5 0x00000001U # define SSL_SHA1 0x00000002U # define SSL_GOST94 0x00000004U # define SSL_GOST89MAC 0x00000008U # define SSL_SHA256 0x00000010U # define SSL_SHA384 0x00000020U /* Not a real MAC, just an indication it is part of cipher */ # define SSL_AEAD 0x00000040U # define SSL_GOST12_256 0x00000080U # define SSL_GOST89MAC12 0x00000100U # define SSL_GOST12_512 0x00000200U /* * When adding new digest in the ssl_ciph.c and increment SSL_MD_NUM_IDX make * sure to update this constant too */ # define SSL_MD_MD5_IDX 0 # define SSL_MD_SHA1_IDX 1 # define SSL_MD_GOST94_IDX 2 # define SSL_MD_GOST89MAC_IDX 3 # define SSL_MD_SHA256_IDX 4 # define SSL_MD_SHA384_IDX 5 # define SSL_MD_GOST12_256_IDX 6 # define SSL_MD_GOST89MAC12_IDX 7 # define SSL_MD_GOST12_512_IDX 8 # define SSL_MD_MD5_SHA1_IDX 9 # define SSL_MD_SHA224_IDX 10 # define SSL_MD_SHA512_IDX 11 # define SSL_MAX_DIGEST 12 /* Bits for algorithm2 (handshake digests and other extra flags) */ /* Bits 0-7 are handshake MAC */ # define SSL_HANDSHAKE_MAC_MASK 0xFF # define SSL_HANDSHAKE_MAC_MD5_SHA1 SSL_MD_MD5_SHA1_IDX # define SSL_HANDSHAKE_MAC_SHA256 SSL_MD_SHA256_IDX # define SSL_HANDSHAKE_MAC_SHA384 SSL_MD_SHA384_IDX # define SSL_HANDSHAKE_MAC_GOST94 SSL_MD_GOST94_IDX # define SSL_HANDSHAKE_MAC_GOST12_256 SSL_MD_GOST12_256_IDX # define SSL_HANDSHAKE_MAC_GOST12_512 SSL_MD_GOST12_512_IDX # define SSL_HANDSHAKE_MAC_DEFAULT SSL_HANDSHAKE_MAC_MD5_SHA1 /* Bits 8-15 bits are PRF */ # define TLS1_PRF_DGST_SHIFT 8 # define TLS1_PRF_SHA1_MD5 (SSL_MD_MD5_SHA1_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF_SHA256 (SSL_MD_SHA256_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF_SHA384 (SSL_MD_SHA384_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF_GOST94 (SSL_MD_GOST94_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF_GOST12_256 (SSL_MD_GOST12_256_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF_GOST12_512 (SSL_MD_GOST12_512_IDX << TLS1_PRF_DGST_SHIFT) # define TLS1_PRF (SSL_MD_MD5_SHA1_IDX << TLS1_PRF_DGST_SHIFT) /* * Stream MAC for GOST ciphersuites from cryptopro draft (currently this also * goes into algorithm2) */ # define TLS1_STREAM_MAC 0x10000 # define SSL_STRONG_MASK 0x0000001FU # define SSL_DEFAULT_MASK 0X00000020U # define SSL_STRONG_NONE 0x00000001U # define SSL_LOW 0x00000002U # define SSL_MEDIUM 0x00000004U # define SSL_HIGH 0x00000008U # define SSL_FIPS 0x00000010U # define SSL_NOT_DEFAULT 0x00000020U /* we have used 0000003f - 26 bits left to go */ /* Flag used on OpenSSL ciphersuite ids to indicate they are for SSLv3+ */ # define SSL3_CK_CIPHERSUITE_FLAG 0x03000000 /* Check if an SSL structure is using DTLS */ # define SSL_IS_DTLS(s) (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS) /* Check if we are using TLSv1.3 */ # define SSL_IS_TLS13(s) (!SSL_IS_DTLS(s) \ && (s)->method->version >= TLS1_3_VERSION \ && (s)->method->version != TLS_ANY_VERSION) # define SSL_TREAT_AS_TLS13(s) \ (SSL_IS_TLS13(s) || (s)->early_data_state == SSL_EARLY_DATA_WRITING \ || (s)->early_data_state == SSL_EARLY_DATA_WRITE_RETRY) # define SSL_IS_FIRST_HANDSHAKE(S) ((s)->s3->tmp.finish_md_len == 0) /* See if we need explicit IV */ # define SSL_USE_EXPLICIT_IV(s) \ (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_EXPLICIT_IV) /* * See if we use signature algorithms extension and signature algorithm * before signatures. */ # define SSL_USE_SIGALGS(s) \ (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_SIGALGS) /* * Allow TLS 1.2 ciphersuites: applies to DTLS 1.2 as well as TLS 1.2: may * apply to others in future. */ # define SSL_USE_TLS1_2_CIPHERS(s) \ (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_TLS1_2_CIPHERS) /* * Determine if a client can use TLS 1.2 ciphersuites: can

t rely on method flags. */ # define SSL_CLIENT_USE_SIGALGS(s) \ SSL_CLIENT_USE_TLS1_2_CIPHERS(s) # define SSL_READ_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_READ) # define SSL_WRITE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE) /* Mostly for SSLv3 */ # define SSL_PKEY_RSA 0 # define SSL_PKEY_DSA_SIGN 1 # define SSL_PKEY_ECC 2 # define SSL_PKEY_GOST01 3 # define SSL_PKEY_GOST12_256 4 # define SSL_PKEY_GOST12_512 5 # define SSL_PKEY_ED25519 6 # define SSL_PKEY_NUM 7 /* * Pseudo-constant. GOST cipher suites can use different certs for 1 * SSL_CIPHER. So let

algorithms

* HostName [ 6 ] EXPLICIT OCTET STRING, -- optional HostName from servername TLS extension * PSK_identity_hint [ 7 ] EXPLICIT OCTET STRING, -- optional PSK identity hint * PSK_identity [ 8 ] EXPLICIT OCTET STRING, -- optional PSK identity * Ticket_lifetime_hint [9] EXPLICIT INTEGER, -- server

m using EXPLICIT tags so I can read the damn things using asn1parse :-). */ struct ssl_session_st { int ssl_version; /* what ssl version session info is being kept * in here? */ size_t master_key_length; /* TLSv1.3 early_secret used for external PSKs */ unsigned char early_secret[EVP_MAX_MD_SIZE]; /* * For <=TLS1.2 this is the master_key. For TLS1.3 this is the resumption * master secret */ unsigned char master_key[TLS13_MAX_RESUMPTION_MASTER_LENGTH]; /* session_id - valid? */ size_t session_id_length; unsigned char session_id[SSL_MAX_SSL_SESSION_ID_LENGTH]; /* * this is used to determine whether the session is being reused in the * appropriate context. It is up to the application to set this, via * SSL_new */ size_t sid_ctx_length; unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH]; # ifndef OPENSSL_NO_PSK char *psk_identity_hint; char *psk_identity; # endif /* * Used to indicate that session resumption is not allowed. Applications * can also set this bit for a new session via not_resumable_session_cb * to disable session caching and tickets. */ int not_resumable; /* This is the cert and type for the other end. */ X509 *peer; int peer_type; /* Certificate chain peer sent. */ STACK_OF(X509) *peer_chain; /* * when app_verify_callback accepts a session where the peer

cipher

s list */ size_t supportedgroups_len; unsigned char *supportedgroups; /* peer

t exceed * max_early_data. max_early_data is given in plaintext bytes. However if it is * unreadable then we only know the number of ciphertext bytes. We also don

t count the * content of the alert record either which is 2 bytes. */ # define EARLY_DATA_CIPHERTEXT_OVERHEAD ((6 * (EVP_GCM_TLS_TAG_LEN + 1)) + 2) /* * The allowance we have between the client

s age calculation is different by more than this than our own then we * do not allow that ticket for early_data. */ # define TICKET_AGE_ALLOWANCE (10 * 1000) #define MAX_COMPRESSIONS_SIZE 255 struct ssl_comp_st { int id; const char *name; COMP_METHOD *method; }; typedef struct raw_extension_st { /* Raw packet data for the extension */ PACKET data; /* Set to 1 if the extension is present or 0 otherwise */ int present; /* Set to 1 if we have already parsed the extension or 0 otherwise */ int parsed; /* The type of this extension, i.e. a TLSEXT_TYPE_* value */ unsigned int type; /* Track what order extensions are received in (0-based). */ size_t received_order; } RAW_EXTENSION; typedef struct { unsigned int isv2; unsigned int legacy_version; unsigned char random[SSL3_RANDOM_SIZE]; size_t session_id_len; unsigned char session_id[SSL_MAX_SSL_SESSION_ID_LENGTH]; size_t dtls_cookie_len; unsigned char dtls_cookie[DTLS1_COOKIE_LENGTH]; PACKET ciphersuites; size_t compressions_len; unsigned char compressions[MAX_COMPRESSIONS_SIZE]; PACKET extensions; size_t pre_proc_exts_len; RAW_EXTENSION *pre_proc_exts; } CLIENTHELLO_MSG; /* * Extension index values NOTE: Any updates to these defines should be mirrored * with equivalent updates to ext_defs in extensions.c */ typedef enum tlsext_index_en { TLSEXT_IDX_renegotiate, TLSEXT_IDX_server_name, TLSEXT_IDX_srp, TLSEXT_IDX_ec_point_formats, TLSEXT_IDX_supported_groups, TLSEXT_IDX_session_ticket, TLSEXT_IDX_status_request, TLSEXT_IDX_next_proto_neg, TLSEXT_IDX_application_layer_protocol_negotiation, TLSEXT_IDX_use_srtp, TLSEXT_IDX_encrypt_then_mac, TLSEXT_IDX_signed_certificate_timestamp, TLSEXT_IDX_extended_master_secret, TLSEXT_IDX_signature_algorithms, TLSEXT_IDX_supported_versions, TLSEXT_IDX_psk_kex_modes, TLSEXT_IDX_key_share, TLSEXT_IDX_cookie, TLSEXT_IDX_cryptopro_bug, TLSEXT_IDX_early_data, TLSEXT_IDX_certificate_authorities, TLSEXT_IDX_padding, TLSEXT_IDX_psk, /* Dummy index - must always be the last entry */ TLSEXT_IDX_num_builtins } TLSEXT_INDEX; DEFINE_LHASH_OF(SSL_SESSION); /* Needed in ssl_cert.c */ DEFINE_LHASH_OF(X509_NAME); # define TLSEXT_KEYNAME_LENGTH 16 struct ssl_ctx_st { const SSL_METHOD *method; STACK_OF(SSL_CIPHER) *cipher_list; /* same as above but sorted for lookup */ STACK_OF(SSL_CIPHER) *cipher_list_by_id; struct x509_store_st /* X509_STORE */ *cert_store; LHASH_OF(SSL_SESSION) *sessions; /* * Most session-ids that will be cached, default is * SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited. */ size_t session_cache_size; struct ssl_session_st *session_cache_head; struct ssl_session_st *session_cache_tail; /* * This can have one of 2 values, ored together, SSL_SESS_CACHE_CLIENT, * SSL_SESS_CACHE_SERVER, Default is SSL_SESSION_CACHE_SERVER, which * means only SSL_accept which cache SSL_SESSIONS. */ uint32_t session_cache_mode; /* * If timeout is not 0, it is the default timeout value set when * SSL_new() is called. This has been put in to make life easier to set * things up */ long session_timeout; /* * If this callback is not null, it will be called each time a session id * is added to the cache. If this function returns 1, it means that the * callback will do a SSL_SESSION_free() when it has finished using it. * Otherwise, on 0, it means the callback has finished with it. If * remove_session_cb is not null, it will be called when a session-id is * removed from the cache. After the call, OpenSSL will * SSL_SESSION_free() it. */ int (*new_session_cb) (struct ssl_st *ssl, SSL_SESSION *sess); void (*remove_session_cb) (struct ssl_ctx_st *ctx, SSL_SESSION *sess); SSL_SESSION *(*get_session_cb) (struct ssl_st *ssl, const unsigned char *data, int len, int *copy); struct { int sess_connect; /* SSL new conn - started */ int sess_connect_renegotiate; /* SSL reneg - requested */ int sess_connect_good; /* SSL new conne/reneg - finished */ int sess_accept; /* SSL new accept - started */ int sess_accept_renegotiate; /* SSL reneg - requested */ int sess_accept_good; /* SSL accept/reneg - finished */ int sess_miss; /* session lookup misses */ int sess_timeout; /* reuse attempt on timeouted session */ int sess_cache_full; /* session removed due to full cache */ int sess_hit; /* session reuse actually done */ int sess_cb_hit; /* session-id that was not in the cache was * passed back via the callback. This * indicates that the application is supplying * session-id

app_verify_arg

app_verify_callback

ssl3-md5

ssl3->sha1

s info_callback is NULL */ void (*info_callback) (const SSL *ssl, int type, int val); /* * What we put in certificate_authorities extension for TLS 1.3 * (ClientHello and CertificateRequest) or just client cert requests for * earlier versions. */ STACK_OF(X509_NAME) *ca_names; /* * Default values to use in SSL structures follow (these are copied by * SSL_new) */ uint32_t options; uint32_t mode; int min_proto_version; int max_proto_version; size_t max_cert_list; struct cert_st /* CERT */ *cert; int read_ahead; /* callback that allows applications to peek at protocol messages */ void (*msg_callback) (int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg); void *msg_callback_arg; uint32_t verify_mode; size_t sid_ctx_length; unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH]; /* called

in the SSL */ int (*default_verify_callback) (int ok, X509_STORE_CTX *ctx); /* Default generate session ID callback. */ GEN_SESSION_CB generate_session_id; X509_VERIFY_PARAM *param; int quiet_shutdown; # ifndef OPENSSL_NO_CT CTLOG_STORE *ctlog_store; /* CT Log Store */ /* * Validates that the SCTs (Signed Certificate Timestamps) are sufficient. * If they are not, the connection should be aborted. */ ssl_ct_validation_cb ct_validation_callback; void *ct_validation_callback_arg; # endif /* * If we

s list of supported protocols in * wire-format. * inlen: the length of |in|. */ int (*alpn_select_cb) (SSL *s, const unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg); void *alpn_select_cb_arg; /* * For a client, this contains the list of supported protocols in wire * format. */ unsigned char *alpn; size_t alpn_len; # ifndef OPENSSL_NO_NEXTPROTONEG /* Next protocol negotiation information */ /* * For a server, this contains a callback function by which the set of * advertised protocols can be provided. */ SSL_CTX_npn_advertised_cb_func npn_advertised_cb; void *npn_advertised_cb_arg; /* * For a client, this contains a callback function that selects the next * protocol from the list provided by the server. */ SSL_CTX_npn_select_cb_func npn_select_cb; void *npn_select_cb_arg; # endif } ext; # ifndef OPENSSL_NO_PSK SSL_psk_client_cb_func psk_client_callback; SSL_psk_server_cb_func psk_server_callback; # endif SSL_psk_find_session_cb_func psk_find_session_cb; SSL_psk_use_session_cb_func psk_use_session_cb; # ifndef OPENSSL_NO_SRP SRP_CTX srp_ctx; /* ctx for SRP authentication */ # endif /* Shared DANE context */ struct dane_ctx_st dane; /* SRTP profiles we are willing to do from RFC 5764 */ STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles; /* * Callback for disabling session caching and ticket support on a session * basis, depending on the chosen cipher. */ int (*not_resumable_session_cb) (SSL *ssl, int is_forward_secure); CRYPTO_RWLOCK *lock; /* * Callback for logging key material for use with debugging tools like * Wireshark. The callback should log `line` followed by a newline. */ SSL_CTX_keylog_cb_func keylog_callback; /* The maximum number of bytes that can be sent as early data */ uint32_t max_early_data; /* TLS1.3 padding callback */ size_t (*record_padding_cb)(SSL *s, int type, size_t len, void *arg); void *record_padding_arg; size_t block_padding; }; struct ssl_st { /* * protocol version (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, * DTLS1_VERSION) */ int version; /* SSLv3 */ const SSL_METHOD *method; /* * There are 2 BIO

s a boolean member "init" that is switched as soon * as SSL_set_{accept/connect}_state is called for the first time, so * that "state" and "handshake_func" are properly initialized. But as * handshake_func is == 0 until then, we use this test instead of an * "init" member. */ /* are we the server side? */ int server; /* * Generate a new session or reuse an old one. * NB: For servers, the

session may actually be a previously * cached session or even the previous session unless * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */ int new_session; /* don

copied

t care about verify failure. * 1 fail if verify fails */ uint32_t verify_mode; /* fail if callback returns 0 */ int (*verify_callback) (int ok, X509_STORE_CTX *ctx); /* optional informational callback */ void (*info_callback) (const SSL *ssl, int type, int val); /* error bytes to be written */ int error; /* actual code */ int error_code; # ifndef OPENSSL_NO_PSK SSL_psk_client_cb_func psk_client_callback; SSL_psk_server_cb_func psk_server_callback; # endif SSL_psk_find_session_cb_func psk_find_session_cb; SSL_psk_use_session_cb_func psk_use_session_cb; SSL_CTX *ctx; /* Verified chain of peer */ STACK_OF(X509) *verified_chain; long verify_result; /* extra application data */ CRYPTO_EX_DATA ex_data; /* for server side, keep the list of CA_dn we can use */ STACK_OF(X509_NAME) *ca_names; CRYPTO_REF_COUNT references; /* protocol behaviour */ uint32_t options; /* API behaviour */ uint32_t mode; int min_proto_version; int max_proto_version; size_t max_cert_list; int first_packet; /* * What was passed in ClientHello.legacy_version. Used for RSA pre-master * secret and SSLv3/TLS (<=1.2) rollback check */ int client_version; /* * If we

s selected_protocol from * NextProtocol and is set when handling the NextProtocol message, before * the Finished message. */ unsigned char *npn; size_t npn_len; /* The available PSK key exchange modes */ int psk_kex_mode; /* Set to one if we have negotiated ETM */ int use_etm; /* Are we expecting to receive early data? */ int early_data; /* Is the session suitable for early data? */ int early_data_ok; /* May be sent by a server in HRR. Must be echoed back in ClientHello */ unsigned char *tls13_cookie; size_t tls13_cookie_len; } ext; /* Parsed form of the ClientHello, kept around across early_cb calls. */ CLIENTHELLO_MSG *clienthello; /*- * no further mod of servername * 0 : call the servername extension callback. * 1 : prepare 2, allow last ack just after in server callback. * 2 : don

ll do */ STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles; /* What

s Finished message is received. * Unexpected ChangeCipherSpec messages trigger a fatal alert. */ int change_cipher_spec; int warn_alert; int fatal_alert; /* * we allow one fatal and one warning alert to be outstanding, send close * alert via the warning alert */ int alert_dispatch; unsigned char send_alert[2]; /* * This flag is set when we should renegotiate ASAP, basically when there * is no more data in the read or write buffers */ int renegotiate; int total_renegotiations; int num_renegotiations; int in_read_app_data; struct { /* actually only need to be 16+20 for SSLv3 and 12 for TLS */ unsigned char finish_md[EVP_MAX_MD_SIZE * 2]; size_t finish_md_len; unsigned char peer_finish_md[EVP_MAX_MD_SIZE * 2]; size_t peer_finish_md_len; size_t message_size; int message_type; /* used to hold the new cipher we are going to use */ const SSL_CIPHER *new_cipher; # if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) EVP_PKEY *pkey; /* holds short lived DH/ECDH key */ # endif /* used for certificate requests */ int cert_req; /* Certificate types in certificate request message. */ uint8_t *ctype; size_t ctype_len; /* Certificate authorities list peer sent */ STACK_OF(X509_NAME) *peer_ca_names; size_t key_block_length; unsigned char *key_block; const EVP_CIPHER *new_sym_enc; const EVP_MD *new_hash; int new_mac_pkey_type; size_t new_mac_secret_size; # ifndef OPENSSL_NO_COMP const SSL_COMP *new_compression; # else char *new_compression; # endif int cert_request; /* Raw values of the cipher list from a client */ unsigned char *ciphers_raw; size_t ciphers_rawlen; /* Temporary storage for premaster secret */ unsigned char *pms; size_t pmslen; # ifndef OPENSSL_NO_PSK /* Temporary storage for PSK key */ unsigned char *psk; size_t psklen; # endif /* Signature algorithm we actually use */ const SIGALG_LOOKUP *sigalg; /* Pointer to certificate we use */ CERT_PKEY *cert; /* * signature algorithms peer reports: e.g. supported signature * algorithms extension for server or as part of a certificate * request for client. */ uint16_t *peer_sigalgs; /* Size of above array */ size_t peer_sigalgslen; /* Sigalg peer actualy uses */ const SIGALG_LOOKUP *peer_sigalg; /* * Set if corresponding CERT_PKEY can be used with current * SSL session: e.g. appropriate curve, signature algorithms etc. * If zero it can

s using * based on what it knows so far. */ int min_ver; int max_ver; } tmp; /* Connection binding to prevent renegotiation attacks */ unsigned char previous_client_finished[EVP_MAX_MD_SIZE]; size_t previous_client_finished_len; unsigned char previous_server_finished[EVP_MAX_MD_SIZE]; size_t previous_server_finished_len; int send_connection_binding; /* TODOEKR */ # ifndef OPENSSL_NO_NEXTPROTONEG /* * Set if we saw the Next Protocol Negotiation extension from our peer. */ int npn_seen; # endif /* * ALPN information (we are in the process of transitioning from NPN to * ALPN.) */ /* * In a server these point to the selected ALPN protocol after the * ClientHello has been processed. In a client these contain the protocol * that the server selected once the ServerHello has been processed. */ unsigned char *alpn_selected; size_t alpn_selected_len; /* used by the server to know what options were proposed */ unsigned char *alpn_proposed; size_t alpn_proposed_len; /* used by the client to know if it actually sent alpn */ int alpn_sent; # ifndef OPENSSL_NO_EC /* * This is set to true if we believe that this is a version of Safari * running on OS X 10.6 or newer. We wish to know this because Safari on * 10.8 .. 10.8.3 has broken ECDHE-ECDSA support. */ char is_probably_safari; # endif /* !OPENSSL_NO_EC */ /* For clients: peer temporary key */ # if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) /* The group_id for the DH/ECDH key */ unsigned int group_id; EVP_PKEY *peer_tmp; # endif } SSL3_STATE; /* DTLS structures */ # ifndef OPENSSL_NO_SCTP # define DTLS1_SCTP_AUTH_LABEL "EXPORTER_DTLS_OVER_SCTP" # endif /* Max MTU overhead we know about so far is 40 for IPv6 + 8 for UDP */ # define DTLS1_MAX_MTU_OVERHEAD 48 /* * Flag used in message reuse to indicate the buffer contains the record * header as well as the the handshake message header. */ # define DTLS1_SKIP_RECORD_HEADER 2 struct dtls1_retransmit_state { EVP_CIPHER_CTX *enc_write_ctx; /* cryptographic state */ EVP_MD_CTX *write_hash; /* used for mac generation */ COMP_CTX *compress; /* compression */ SSL_SESSION *session; unsigned short epoch; }; struct hm_header_st { unsigned char type; size_t msg_len; unsigned short seq; size_t frag_off; size_t frag_len; unsigned int is_ccs; struct dtls1_retransmit_state saved_retransmit_state; }; struct dtls1_timeout_st { /* Number of read timeouts so far */ unsigned int read_timeouts; /* Number of write timeouts so far */ unsigned int write_timeouts; /* Number of alerts received so far */ unsigned int num_alerts; }; typedef struct hm_fragment_st { struct hm_header_st msg_header; unsigned char *fragment; unsigned char *reassembly; } hm_fragment; typedef struct pqueue_st pqueue; typedef struct pitem_st pitem; struct pitem_st { unsigned char priority[8]; /* 64-bit value in big-endian encoding */ void *data; pitem *next; }; typedef struct pitem_st *piterator; pitem *pitem_new(unsigned char *prio64be, void *data); void pitem_free(pitem *item); pqueue *pqueue_new(void); void pqueue_free(pqueue *pq); pitem *pqueue_insert(pqueue *pq, pitem *item); pitem *pqueue_peek(pqueue *pq); pitem *pqueue_pop(pqueue *pq); pitem *pqueue_find(pqueue *pq, unsigned char *prio64be); pitem *pqueue_iterator(pqueue *pq); pitem *pqueue_next(piterator *iter); size_t pqueue_size(pqueue *pq); typedef struct dtls1_state_st { unsigned char cookie[DTLS1_COOKIE_LENGTH]; size_t cookie_len; unsigned int cookie_verified; /* handshake message numbers */ unsigned short handshake_write_seq; unsigned short next_handshake_write_seq; unsigned short handshake_read_seq; /* Buffered handshake messages */ pqueue *buffered_messages; /* Buffered (sent) handshake records */ pqueue *sent_messages; size_t link_mtu; /* max on-the-wire DTLS packet size */ size_t mtu; /* max DTLS packet size */ struct hm_header_st w_msg_hdr; struct hm_header_st r_msg_hdr; struct dtls1_timeout_st timeout; /* * Indicates when the last handshake msg sent will timeout */ struct timeval next_timeout; /* Timeout duration */ unsigned short timeout_duration; unsigned int retransmitting; # ifndef OPENSSL_NO_SCTP int shutdown_received; # endif } DTLS1_STATE; # ifndef OPENSSL_NO_EC /* * From ECC-TLS draft, used in encoding the curve type in ECParameters */ # define EXPLICIT_PRIME_CURVE_TYPE 1 # define EXPLICIT_CHAR2_CURVE_TYPE 2 # define NAMED_CURVE_TYPE 3 # endif /* OPENSSL_NO_EC */ struct cert_pkey_st { X509 *x509; EVP_PKEY *privatekey; /* Chain for this certificate */ STACK_OF(X509) *chain; /*- * serverinfo data for this certificate. The data is in TLS Extension * wire format, specifically it

idx

CLIENT_RANDOM

CLIENT_EARLY_TRAFFIC_SECRET

CLIENT_HANDSHAKE_TRAFFIC_SECRET

SERVER_HANDSHAKE_TRAFFIC_SECRET

CLIENT_TRAFFIC_SECRET_0

SERVER_TRAFFIC_SECRET_0

0xff),

0xff),

0xff),

0xff))

0xff),

0xff),

0xff),

0xff))

0xff),

0xff),

0xff),

0xff),

0xff),

0xff))

0xff),

0xff),

0xff),

0xff),

0xff),

0xff),

0xff),

0xff))

0xff);

0xff);

0xff);

0xff);

0xff);

0xff);

0xff);

0xff);

0xff),

0xff)),(c)+=2)

0xff),

0xff),

0xff)),(c)+=3)

0xff00

0x00000001U

0x00000002U

0x00000004U

0x00000008U

0x00000010U

0x00000020U

0x00000040U

0x00000080U

0x00000100U

0x00000000U

0x00000001U

0x00000002U

0x00000004U

0x00000008U

0x00000010U

0x00000020U

0x00000040U

0x00000080U

0x00000000U

0x00000001U

0x00000002U

0x00000004U

0x00000008U

0x00000010U

0x00000020U

0x00000040U

0x00000080U

0x00000100U

0x00000200U

0x00000400U

0x00000800U

0x00001000U

0x00002000U

0x00004000U

0x00008000U

0x00010000U

0x00020000U

0x00040000U

0x00080000U

0x00100000U

0x00200000U

0x00000001U

0x00000002U

0x00000004U

0x00000008U

0x00000010U

0x00000020U

0x00000040U

0x00000080U

0x00000100U

0x00000200U

0xFF

0x10000

0x0000001FU

0X00000020U

0x00000001U

0x00000002U

0x00000004U

0x00000008U

0x00000010U

0x00000020U

0x03000000

0x1

0x01

0x02

0x1

0x2

0x1

0x2

0x4

0x8

0x10

0x0403

0x0503

0x0603

0x0303

0x0203

0x0804

0x0805

0x0806

0x0401

0x0501

0x0601

0x0301

0x0201

0x0402

0x0502

0x0602

0x0302

0x0202

0xeeee

0xefef

0xeded

0x0807

0x00

0x01

0x0101

0x3

0x0

0x1

0x2

