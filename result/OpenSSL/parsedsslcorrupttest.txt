Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

corrupt last bit of application data

We don't support this - not needed anyway

We don't support this - not needed anyway

Note: Not thread safe!

The test is supposed to be executed with RSA key, customarily with apps/server.pem used even in other tests. For this reason |cipher_list| is initialized with RSA ciphers' names. This naturally means that if test is to be re-purposed for other type of key, then NID_auth_ filter below would need adjustment.

The |cipher_list| will be filled only with names of RSA ciphers, so that some of the allocated space will be wasted, but the loss is deemed acceptable...

If we haven't got a TLSv1.3 cipher, then we mustn't attempt to use TLSv1.3. Version negotiation happens before cipher selection, so we will get a "no shared cipher" error.

BIO is freed by create_ssl_connection on error

www.openssl.org/source/license.html

License

ssltestlib.h

testutil.h

t support this - not needed anyway */ return -1; } static int tls_corrupt_puts(BIO *bio, const char *str) { /* We don

TLS corrupt filter

names. This * naturally means that if test is to be re-purposed for other * type of key, then NID_auth_* filter below would need adjustment. */ static const char **cipher_list = NULL; static int setup_cipher_list() { SSL_CTX *ctx = NULL; SSL *ssl = NULL; STACK_OF(SSL_CIPHER) *sk_ciphers = NULL; int i, j, numciphers = 0; if (!TEST_ptr(ctx = SSL_CTX_new(TLS_server_method())) || !TEST_ptr(ssl = SSL_new(ctx)) || !TEST_ptr(sk_ciphers = SSL_get1_supported_ciphers(ssl))) goto err; /* * The |cipher_list| will be filled only with names of RSA ciphers, * so that some of the allocated space will be wasted, but the loss * is deemed acceptable... */ cipher_list = OPENSSL_malloc(sk_SSL_CIPHER_num(sk_ciphers) * sizeof(cipher_list[0])); if (!TEST_ptr(cipher_list)) goto err; for (j = 0, i = 0; i < sk_SSL_CIPHER_num(sk_ciphers); i++) { const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(sk_ciphers, i); if (SSL_CIPHER_get_auth_nid(cipher) == NID_auth_rsa) cipher_list[j++] = SSL_CIPHER_get_name(cipher); } if (TEST_int_ne(j, 0)) numciphers = j; err: sk_SSL_CIPHER_free(sk_ciphers); SSL_free(ssl); SSL_CTX_free(ctx); return numciphers; } static char *cert = NULL; static char *privkey = NULL; static int test_ssl_corrupt(int testidx) { static unsigned char junk[16000] = { 0 }; SSL_CTX *sctx = NULL, *cctx = NULL; SSL *server = NULL, *client = NULL; BIO *c_to_s_fbio; int testresult = 0; STACK_OF(SSL_CIPHER) *ciphers; const SSL_CIPHER *currcipher; docorrupt = 0; TEST_info("Starting #%d, %s", testidx, cipher_list[testidx]); if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx, &cctx, cert, privkey))) return 0; if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipher_list[testidx]))) goto end; if (!TEST_ptr(ciphers = SSL_CTX_get_ciphers(cctx)) || !TEST_int_eq(sk_SSL_CIPHER_num(ciphers), 1) || !TEST_ptr(currcipher = sk_SSL_CIPHER_value(ciphers, 0))) goto end; /* * If we haven

no shared cipher

TLSv1.3

Usage error: require cert and private key files

0x80

