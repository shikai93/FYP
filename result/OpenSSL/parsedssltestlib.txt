Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Choose a sufficiently large type likely to be unused for this custom BIO

Note: Not thread safe!

Now look at message

We don't support this - not needed anyway

Record Header values

Probably run out of data

Overwrite the record sequence number. We strictly number them in the order received. Since we are actually a reliable transport we know that there won't be any re-ordering. We overwrite to deal with any packets that have been injected

We only allow injection before we've started writing any data

Check if we found the right place to insert this packet

If we're doing up front injection then we're done

We need to do some accounting on lastpkt. We increment it first, but it might now equal the value of injected packets, so we need to skip over those

We injected two packets with the same packet number!

We didn't find any packets with a packet number equal to or greater than this one, so we just add it onto the end

We don't support this - not needed anyway

NOTE: Transfers control of the BIOs - this function will free them on error

Set Non-blocking IO behaviour

Up ref these as we are passing them to two SSL objects

We attempt to read some data on the client side which we expect to fail. This will ensure we have received the NewSessionTicket in TLSv1.3 where appropriate.

www.openssl.org/source/license.html

License

internal/nelem.h

ssltestlib.h

testutil.h

TLS dump filter

---- START OF PACKET ----\n

*\n

*---- START OF RECORD ----\n

*---- RECORD TRUNCATED ----\n

** Record Content-type: %d\n

** Record Version: %02x%02x\n

** Record Epoch: %d\n

** Record Sequence:

%02x

\n** Record Length: %d\n

**---- START OF HANDSHAKE MESSAGE FRAGMENT ----\n

**---- HANDSHAKE MESSAGE FRAGMENT ENCRYPTED ----\n

**---- HANDSHAKE MESSAGE FRAGMENT TRUNCATED ----\n

*** Message Type: %d\n

*** Message Length: %d\n

*** Message sequence: %d\n

*** Message Fragment offset: %d\n

*** Message Fragment len: %d\n

***---- HANDSHAKE MESSAGE FRAGMENT INVALID ----\n

**---- HANDSHAKE MESSAGE FRAGMENT TRUNCATED ----\n

**---- END OF HANDSHAKE MESSAGE FRAGMENT ----\n

*---- RECORD TRUNCATED ----\n

*---- END OF RECORD ----\n

---- END OF PACKET ----\n\n

t support this - not needed anyway */ return -1; } static int tls_dump_puts(BIO *bio, const char *str) { return tls_dump_write(bio, str, strlen(str)); } struct mempacket_st { unsigned char *data; int len; unsigned int num; unsigned int type; }; static void mempacket_free(MEMPACKET *pkt) { if (pkt->data != NULL) OPENSSL_free(pkt->data); OPENSSL_free(pkt); } typedef struct mempacket_test_ctx_st { STACK_OF(MEMPACKET) *pkts; unsigned int epoch; unsigned int currrec; unsigned int currpkt; unsigned int lastpkt; unsigned int noinject; } MEMPACKET_TEST_CTX; static int mempacket_test_new(BIO *bi); static int mempacket_test_free(BIO *a); static int mempacket_test_read(BIO *b, char *out, int outl); static int mempacket_test_write(BIO *b, const char *in, int inl); static long mempacket_test_ctrl(BIO *b, int cmd, long num, void *ptr); static int mempacket_test_gets(BIO *bp, char *buf, int size); static int mempacket_test_puts(BIO *bp, const char *str); const BIO_METHOD *bio_s_mempacket_test(void) { if (meth_mem == NULL) { if (!TEST_ptr(meth_mem = BIO_meth_new(BIO_TYPE_MEMPACKET_TEST, "Mem Packet Test")) || !TEST_true(BIO_meth_set_write(meth_mem, mempacket_test_write)) || !TEST_true(BIO_meth_set_read(meth_mem, mempacket_test_read)) || !TEST_true(BIO_meth_set_puts(meth_mem, mempacket_test_puts)) || !TEST_true(BIO_meth_set_gets(meth_mem, mempacket_test_gets)) || !TEST_true(BIO_meth_set_ctrl(meth_mem, mempacket_test_ctrl)) || !TEST_true(BIO_meth_set_create(meth_mem, mempacket_test_new)) || !TEST_true(BIO_meth_set_destroy(meth_mem, mempacket_test_free))) return NULL; } return meth_mem; } void bio_s_mempacket_test_free(void) { BIO_meth_free(meth_mem); } static int mempacket_test_new(BIO *bio) { MEMPACKET_TEST_CTX *ctx; if (!TEST_ptr(ctx = OPENSSL_zalloc(sizeof(*ctx)))) return 0; if (!TEST_ptr(ctx->pkts = sk_MEMPACKET_new_null())) { OPENSSL_free(ctx); return 0; } BIO_set_init(bio, 1); BIO_set_data(bio, ctx); return 1; } static int mempacket_test_free(BIO *bio) { MEMPACKET_TEST_CTX *ctx = BIO_get_data(bio); sk_MEMPACKET_pop_free(ctx->pkts, mempacket_free); OPENSSL_free(ctx); BIO_set_data(bio, NULL); BIO_set_init(bio, 0); return 1; } /* Record Header values */ #define EPOCH_HI 4 #define EPOCH_LO 5 #define RECORD_SEQUENCE 10 #define RECORD_LEN_HI 11 #define RECORD_LEN_LO 12 #define STANDARD_PACKET 0 static int mempacket_test_read(BIO *bio, char *out, int outl) { MEMPACKET_TEST_CTX *ctx = BIO_get_data(bio); MEMPACKET *thispkt; unsigned char *rec; int rem; unsigned int seq, offset, len, epoch; BIO_clear_retry_flags(bio); thispkt = sk_MEMPACKET_value(ctx->pkts, 0); if (thispkt == NULL || thispkt->num != ctx->currpkt) { /* Probably run out of data */ BIO_set_retry_read(bio); return -1; } (void)sk_MEMPACKET_shift(ctx->pkts); ctx->currpkt++; if (outl > thispkt->len) outl = thispkt->len; if (thispkt->type != INJECT_PACKET_IGNORE_REC_SEQ) { /* * Overwrite the record sequence number. We strictly number them in * the order received. Since we are actually a reliable transport * we know that there won

ve started writing any data */ if (pktnum >= 0) { if (ctx->noinject) return -1; } else { ctx->noinject = 1; } if (!TEST_ptr(thispkt = OPENSSL_malloc(sizeof(*thispkt)))) return -1; if (!TEST_ptr(thispkt->data = OPENSSL_malloc(inl))) { mempacket_free(thispkt); return -1; } memcpy(thispkt->data, in, inl); thispkt->len = inl; thispkt->num = (pktnum >= 0) ? (unsigned int)pktnum : ctx->lastpkt; thispkt->type = type; for(i = 0; (looppkt = sk_MEMPACKET_value(ctx->pkts, i)) != NULL; i++) { /* Check if we found the right place to insert this packet */ if (looppkt->num > thispkt->num) { if (sk_MEMPACKET_insert(ctx->pkts, thispkt, i) == 0) { mempacket_free(thispkt); return -1; } /* If we

re done */ if (pktnum >= 0) return inl; /* * We need to do some accounting on lastpkt. We increment it first, * but it might now equal the value of injected packets, so we need * to skip over those */ ctx->lastpkt++; do { i++; nextpkt = sk_MEMPACKET_value(ctx->pkts, i); if (nextpkt != NULL && nextpkt->num == ctx->lastpkt) ctx->lastpkt++; else return inl; } while(1); } else if (looppkt->num == thispkt->num) { if (!ctx->noinject) { /* We injected two packets with the same packet number! */ return -1; } ctx->lastpkt++; thispkt->num++; } } /* * We didn

SSL_connect() failed %d, %d

SSL_accept() failed %d, %d

No progress made

0x80

0x81

0xFF;

Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Note: Not thread safe!

Packet types - value 0 is reserved

HEADER_SSLTESTLIB_H

www.openssl.org/source/license.html

License

