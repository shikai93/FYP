Copyright 2017 The OpenSSL Project Authors. All Rights Reserved. Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

The macros below generate unused functions which error out one of the clang builds. We disable this check here.

Check push and num

check the values

find unsorted -- the pointers are compared

find_ex unsorted

sorting

find sorted -- the value is matched so we don't need to locate it

find_ex sorted

shift

unshift and num

dup

pop

free -- we rely on the debug malloc to detect leakage here

dup again

zero

insert

delete

set

allocate and push

deepcopy

pop_free - we rely on the malloc debug to catch the leak

delete_ptr

allocate and push

check the pointers are correct

www.openssl.org/source/license.html

License

internal/nelem.h

testutil.h

-Wunused-function

int stack size %d

int value %d

int unsorted find %d

int unsorted find_ex %d

t need to locate it */ for (i = 0; i < n_finds; i++) if (!TEST_int_eq(sk_sint_find(s, &finds[i].value), finds[i].sorted)) { TEST_info("int sorted find %d", i); goto end; } /* find_ex sorted */ for (i = 0; i < n_finds; i++) if (!TEST_int_eq(sk_sint_find_ex(s, &finds[i].value), finds[i].ex)) { TEST_info("int sorted find_ex present %d", i); goto end; } for (i = 0; i < n_exfinds; i++) if (!TEST_int_eq(sk_sint_find_ex(s, &exfinds[i].value), exfinds[i].ex)){ TEST_info("int sorted find_ex absent %d", i); goto end; } /* shift */ if (!TEST_ptr_eq(sk_sint_shift(s), v + 6)) goto end; testresult = 1; end: sk_sint_free(s); return testresult; } static int uchar_compare(const unsigned char *const *a, const unsigned char *const *b) { return **a - (signed int)**b; } static int test_uchar_stack(void) { static const unsigned char v[] = { 1, 3, 7, 5, 255, 0 }; const int n = OSSL_NELEM(v); STACK_OF(uchar) *s = sk_uchar_new(&uchar_compare), *r = NULL; int i; int testresult = 0; /* unshift and num */ for (i = 0; i < n; i++) { if (!TEST_int_eq(sk_uchar_num(s), i)) { TEST_info("uchar stack size %d", i); goto end; } sk_uchar_unshift(s, v + i); } if (!TEST_int_eq(sk_uchar_num(s), n)) goto end; /* dup */ r = sk_uchar_dup(s); if (!TEST_int_eq(sk_uchar_num(r), n)) goto end; sk_uchar_sort(r); /* pop */ for (i = 0; i < n; i++) if (!TEST_ptr_eq(sk_uchar_pop(s), v + i)) { TEST_info("uchar pop %d", i); goto end; } /* free -- we rely on the debug malloc to detect leakage here */ sk_uchar_free(s); s = NULL; /* dup again */ if (!TEST_int_eq(sk_uchar_num(r), n)) goto end; /* zero */ sk_uchar_zero(r); if (!TEST_int_eq(sk_uchar_num(r), 0)) goto end; /* insert */ sk_uchar_insert(r, v, 0); sk_uchar_insert(r, v + 2, -1); sk_uchar_insert(r, v + 1, 1); for (i = 0; i < 3; i++) if (!TEST_ptr_eq(sk_uchar_value(r, i), v + i)) { TEST_info("uchar insert %d", i); goto end; } /* delete */ if (!TEST_ptr_null(sk_uchar_delete(r, 12))) goto end; if (!TEST_ptr_eq(sk_uchar_delete(r, 1), v + 1)) goto end; /* set */ sk_uchar_set(r, 1, v + 1); for (i = 0; i < 2; i++) if (!TEST_ptr_eq(sk_uchar_value(r, i), v + i)) { TEST_info("uchar set %d", i); goto end; } testresult = 1; end: sk_uchar_free(r); sk_uchar_free(s); return testresult; } static SS *SS_copy(const SS *p) { SS *q = OPENSSL_malloc(sizeof(*q)); if (q != NULL) memcpy(q, p, sizeof(*q)); return q; } static void SS_free(SS *p) { OPENSSL_free(p); } static int test_SS_stack(void) { STACK_OF(SS) *s = sk_SS_new_null(); STACK_OF(SS) *r = NULL; SS *v[10], *p; const int n = OSSL_NELEM(v); int i; int testresult = 0; /* allocate and push */ for (i = 0; i < n; i++) { v[i] = OPENSSL_malloc(sizeof(*v[i])); if (!TEST_ptr(v[i])) goto end; v[i]->n = i; v[i]->c =

+ i; if (!TEST_int_eq(sk_SS_num(s), i)) { TEST_info("SS stack size %d", i); goto end; } sk_SS_push(s, v[i]); } if (!TEST_int_eq(sk_SS_num(s), n)) goto end; /* deepcopy */ r = sk_SS_deep_copy(s, &SS_copy, &SS_free); if (!TEST_ptr(r)) goto end; for (i = 0; i < n; i++) { p = sk_SS_value(r, i); if (!TEST_ptr_ne(p, v[i])) { TEST_info("SS deepcopy non-copy %d", i); goto end; } if (!TEST_int_eq(p->n, v[i]->n)) { TEST_info("test SS deepcopy int %d", i); goto end; } if (!TEST_char_eq(p->c, v[i]->c)) { TEST_info("SS deepcopy char %d", i); goto end; } } /* pop_free - we rely on the malloc debug to catch the leak */ sk_SS_pop_free(r, &SS_free); r = NULL; /* delete_ptr */ p = sk_SS_delete_ptr(s, v[3]); if (!TEST_ptr(p)) goto end; SS_free(p); if (!TEST_int_eq(sk_SS_num(s), n - 1)) goto end; for (i = 0; i < n-1; i++) if (!TEST_ptr_eq(sk_SS_value(s, i), v[i<3 ? i : 1+i])) { TEST_info("SS delete ptr item %d", i); goto end; } testresult = 1; end: sk_SS_pop_free(r, &SS_free); sk_SS_pop_free(s, &SS_free); return testresult; } static int test_SU_stack(void) { STACK_OF(SU) *s = sk_SU_new_null(); SU v[10]; const int n = OSSL_NELEM(v); int i; int testresult = 0; /* allocate and push */ for (i = 0; i < n; i++) { if ((i & 1) == 0) v[i].n = i; else v[i].c =

SU stack size %d

SU pointer check %d

