Copyright 2015-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

This file implements the SSL/TLS/DTLS state machines. There are two primary state machines: 1) Message flow state machine 2) Handshake state machine The Message flow state machine controls the reading and sending of messages including handling of non-blocking IO events, flushing of the underlying write BIO, handling unexpected messages, etc. It is itself broken into two separate sub-state machines which control reading and writing respectively. The Handshake state machine keeps track of the current SSL/TLS handshake state. Transitions of the handshake state are the result of events that occur within the Message flow state machine. Overall it looks like this: --------------------------------------------- ------------------- | | | | | Message flow state machine | | | | | | | | -------------------- -------------------- | Transition | Handshake state | | | MSG_FLOW_READING | | MSG_FLOW_WRITING | | Event | machine | | | sub-state | | sub-state | |----------->| | | | machine for | | machine for | | | | | | reading messages | | writing messages | | | | | -------------------- -------------------- | | | | | | | --------------------------------------------- -------------------

Sub state machine return values

Something bad happened or NBIO

Sub state finished go to the next sub state

Sub state finished and handshake was completed

Historically being "in before" meant before anything had happened. In the current code though we remain in the "before" state for a while after we have started the handshake process (e.g. as a server waiting for the first message to arrive). There "in before" is taken to mean "in before" and not started any handshake process yet.

Clear the state machine state and reset back to MSG_FLOW_UNINITED

Set the state machine up ready for a renegotiation handshake

Put the state machine into an error state. This is a permanent error for the current connection.

Discover whether the current connection is in the error state. Valid return values are: 1: Yes 0: No

Are we in a sensible state to skip over unreadable early data?

Called when we are in SSL_read(), SSL_write(), or SSL_accept() /SSL_connect()/SSL_do_handshake(). Used to test whether we are in an early data state and whether we should attempt to move the handshake on if so. |sending| is 1 if we are attempting to send data (SSL_write()), 0 if we are attempting to read data (SSL_read()), or -1 if we are in SSL_do_handshake() or similar.

SSL_connect() or SSL_do_handshake() has been called directly. We don't allow any more writing of early data.

SSL_write() has been called directly. We don't allow any more writing of early data.

This will get reset (briefly) back to TLS_ST_BEFORE when we enter state_machine() because |state| is MSG_FLOW_UNINITED, but until then any calls to SSL_in_before() will return false. Also calls to SSL_state_string() and SSL_state_string_long() will return something sensible.

The main message flow state machine. We start in the MSG_FLOW_UNINITED or MSG_FLOW_FINISHED state and finish in MSG_FLOW_FINISHED. Valid states and transitions are as follows: MSG_FLOW_UNINITED MSG_FLOW_FINISHED | | +-----------------------+ v MSG_FLOW_WRITING <---> MSG_FLOW_READING | V MSG_FLOW_FINISHED | V [SUCCESS] We may exit at any point due to an error or NBIO event. If an NBIO event occurs then we restart at the point we left off when we are recalled. MSG_FLOW_WRITING and MSG_FLOW_READING have sub-state machines associated with them. In addition to the above there is also the MSG_FLOW_ERROR state. We can move into that state at any point in the event that an irrecoverable error occurs. Valid return values are: 1: Success <=0: NBIO or error

Shouldn't have been called if we're already in the error state

Notify SCTP BIO socket to enter handshake mode and prevent stream identifier other than 0.

Initialise state machine

Should have been reset by tls_process_finished, too.

Ok, we now need to push on a buffering BIO ...but not with SCTP

NBIO or error

NBIO or error

Error

Notify SCTP BIO socket to leave handshake mode and allow stream identifier other than 0.

Initialise the MSG_FLOW_READING sub-state machine

This function implements the sub-state machine when the message flow is in MSG_FLOW_READING. The valid sub-states and transitions are: READ_STATE_HEADER <--+<-------------+ | | | v | | READ_STATE_BODY -----+-->READ_STATE_POST_PROCESS | | +----------------------------+ v [SUB_STATE_FINISHED] READ_STATE_HEADER has the responsibility for reading in the message header and transitioning the state of the handshake state machine. READ_STATE_BODY reads in the rest of the message and then subsequently processes it. READ_STATE_POST_PROCESS is an optional step that may occur if some post processing activity performed on the message may block. Any of the above states could result in an NBIO event occurring in which case control returns to the calling application. When this function is recalled we will resume in the same state where we left off.

Get the state the peer wants to move to

In DTLS we get the whole message in one go - header and body

Could be non-blocking IO

Notify callback of an impending state change

Validate that we are allowed to move to the new state and move to that state if so

dtls_get_message already did this

Fall through

We already got this above for DTLS

Could be non-blocking IO

Discard the packet data

Shouldn't happen

Send a previously constructed message to the peer.

Initialise the MSG_FLOW_WRITING sub-state machine

This function implements the sub-state machine when the message flow is in MSG_FLOW_WRITING. The valid sub-states and transitions are: +-> WRITE_STATE_TRANSITION ------> [SUB_STATE_FINISHED] | | | v | WRITE_STATE_PRE_WORK -----> [SUB_STATE_END_HANDSHAKE] | | | v | WRITE_STATE_SEND | | | v | WRITE_STATE_POST_WORK | | +-------------+ WRITE_STATE_TRANSITION transitions the state of the handshake state machine WRITE_STATE_PRE_WORK performs any work necessary to prepare the later sending of the message. This could result in an NBIO event occurring in which case control returns to the calling application. When this function is recalled we will resume in the same state where we left off. WRITE_STATE_SEND sends the message and performs any work to be done after sending. WRITE_STATE_POST_WORK performs any work necessary after the sending of the message has been completed. As for WRITE_STATE_PRE_WORK this could also result in an NBIO event.

Notify callback of an impending state change

Skip construction and sending. This isn't a "real" state

Fall through

Fall through

Flush the write BIO

Called by the record layer to determine whether application data is allowed to be received in the current handshake state or not. Return values are: 1: Yes (application data allowed) 0: No (application data not allowed)

If we're a server and we haven't got as far as writing our ServerHello yet then we allow app data

If we're a client and we haven't read the ServerHello yet then we allow app data

www.openssl.org/source/license.html

License

internal/cryptlib.h

../ssl_locl.h

statem_locl.h

in before

before

in before

in before

t allow any more writing of early data. */ s->early_data_state = SSL_EARLY_DATA_FINISHED_WRITING; } } } else if (!s->server) { if ((sending && (s->statem.hand_state == TLS_ST_PENDING_EARLY_DATA_END || s->statem.hand_state == TLS_ST_EARLY_DATA) && s->early_data_state != SSL_EARLY_DATA_WRITING) || (!sending && s->statem.hand_state == TLS_ST_EARLY_DATA)) { ossl_statem_set_in_init(s, 1); /* * SSL_write() has been called directly. We don

t have been called if we

t happen */ ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR); SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR); ossl_statem_set_error(s); return SUB_STATE_ERROR; } } } /* * Send a previously constructed message to the peer. */ static int statem_do_write(SSL *s) { OSSL_STATEM *st = &s->statem; if (st->hand_state == TLS_ST_CW_CHANGE || st->hand_state == TLS_ST_SW_CHANGE) { if (SSL_IS_DTLS(s)) return dtls1_do_write(s, SSL3_RT_CHANGE_CIPHER_SPEC); else return ssl3_do_write(s, SSL3_RT_CHANGE_CIPHER_SPEC); } else { return ssl_do_write(s); } } /* * Initialise the MSG_FLOW_WRITING sub-state machine */ static void init_write_state_machine(SSL *s) { OSSL_STATEM *st = &s->statem; st->write_state = WRITE_STATE_TRANSITION; } /* * This function implements the sub-state machine when the message flow is in * MSG_FLOW_WRITING. The valid sub-states and transitions are: * * +-> WRITE_STATE_TRANSITION ------> [SUB_STATE_FINISHED] * | | * | v * | WRITE_STATE_PRE_WORK -----> [SUB_STATE_END_HANDSHAKE] * | | * | v * | WRITE_STATE_SEND * | | * | v * | WRITE_STATE_POST_WORK * | | * +-------------+ * * WRITE_STATE_TRANSITION transitions the state of the handshake state machine * WRITE_STATE_PRE_WORK performs any work necessary to prepare the later * sending of the message. This could result in an NBIO event occurring in * which case control returns to the calling application. When this function * is recalled we will resume in the same state where we left off. * * WRITE_STATE_SEND sends the message and performs any work to be done after * sending. * * WRITE_STATE_POST_WORK performs any work necessary after the sending of the * message has been completed. As for WRITE_STATE_PRE_WORK this could also * result in an NBIO event. */ static SUB_STATE_RETURN write_state_machine(SSL *s) { OSSL_STATEM *st = &s->statem; int ret; WRITE_TRAN(*transition) (SSL *s); WORK_STATE(*pre_work) (SSL *s, WORK_STATE wst); WORK_STATE(*post_work) (SSL *s, WORK_STATE wst); int (*get_construct_message_f) (SSL *s, WPACKET *pkt, int (**confunc) (SSL *s, WPACKET *pkt), int *mt); void (*cb) (const SSL *ssl, int type, int val) = NULL; int (*confunc) (SSL *s, WPACKET *pkt); int mt; WPACKET pkt; cb = get_callback(s); if (s->server) { transition = ossl_statem_server_write_transition; pre_work = ossl_statem_server_pre_work; post_work = ossl_statem_server_post_work; get_construct_message_f = ossl_statem_server_construct_message; } else { transition = ossl_statem_client_write_transition; pre_work = ossl_statem_client_pre_work; post_work = ossl_statem_client_post_work; get_construct_message_f = ossl_statem_client_construct_message; } while (1) { switch (st->write_state) { case WRITE_STATE_TRANSITION: if (cb != NULL) { /* Notify callback of an impending state change */ if (s->server) cb(s, SSL_CB_ACCEPT_LOOP, 1); else cb(s, SSL_CB_CONNECT_LOOP, 1); } switch (transition(s)) { case WRITE_TRAN_CONTINUE: st->write_state = WRITE_STATE_PRE_WORK; st->write_state_work = WORK_MORE_A; break; case WRITE_TRAN_FINISHED: return SUB_STATE_FINISHED; break; case WRITE_TRAN_ERROR: return SUB_STATE_ERROR; } break; case WRITE_STATE_PRE_WORK: switch (st->write_state_work = pre_work(s, st->write_state_work)) { case WORK_ERROR: case WORK_MORE_A: case WORK_MORE_B: case WORK_MORE_C: return SUB_STATE_ERROR; case WORK_FINISHED_CONTINUE: st->write_state = WRITE_STATE_SEND; break; case WORK_FINISHED_STOP: return SUB_STATE_END_HANDSHAKE; } if (!get_construct_message_f(s, &pkt, &confunc, &mt)) { ossl_statem_set_error(s); return SUB_STATE_ERROR; } if (mt == SSL3_MT_DUMMY) { /* Skip construction and sending. This isn

real

re a server and we haven

re a client and we haven

0xff00)

0xff00)

0xff00)

0xff00)))

Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

These enums should be considered PRIVATE to the state machine. No non-state machine code should need to use these

Valid return codes used for functions performing work prior to or after sending or receiving a message

Something went wrong

We're done working and there shouldn't be anything else to do after

We're done working move onto the next thing

We're working on phase A

We're working on phase B

We're working on phase C

Write transition return codes

Something went wrong

A transition was successfully completed and we should continue

There is no more write work to be done

Message flow states

No handshake in progress

A permanent error with this connection

We are reading messages

We are writing messages

Handshake has finished

Read states

Write states

This structure should be considered "opaque" to anything outside of the state machine. No non-state machine code should be accessing the members of this structure.

The handshake state requested by an API call (e.g. HelloRequest)

true when we are actually in SSL_accept() or SSL_connect()

True when are processing a "real" handshake that needs cleaning up (not just a HelloRequest or similar).

Should we skip the CertificateVerify message?

The following macros/functions represent the libssl internal API to the state machine. Any libssl code may call these functions/macros

www.openssl.org/source/license.html

License

re done working and there shouldn

re done working move onto the next thing */ WORK_FINISHED_CONTINUE, /* We

re working on phase B */ WORK_MORE_B, /* We

opaque

real

