Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

zero length fragment gets zero frag->fragment

Initialize reassembly bitmask if necessary

send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC)

should have something reasonable now

s->init_num shouldn't ever be < 0...but just in case

We must be writing a fragment other than the first one

This is the first attempt at writing out this fragment

Each fragment that was already sent must at least have contained the message header plus one other byte. Therefore |init_off| must have progressed by at least |DTLS1_HM_HEADER_LENGTH + 1| bytes. If not something went wrong.

Adjust |init_off| and |init_num| to allow room for a new message header for this fragment.

We must have been called again after a retry so use the fragment offset from our last attempt. We do not need to adjust |init_off| and |init_num| as above, because that should already have been done before the retry.

grr.. we could get an error if MTU picked was wrong

Shouldn't happen

We just checked that s->init_num > 0 so this cast should be safe

XDTLS: this function is too long. split out the CCS part

len is so small that we really can't do anything sensible so fail

might need to update MTU here, but we don't know which previous packet caused the failure -- so can't really retransmit anything. continue as if everything is fine and wait for an alert to handle the retransmit

Have one more go

bad if this assert fails, only part of the handshake message got sent. but why would this happen?

should not be done for 'Hello Request's, but in that case we'll ignore the result anyway

reconstruct message header is if it is being sent in single fragment

done writing this message

We save the fragment offset for the next fragment so we have it available in case of an IO retry. We don't know the length of the next fragment yet so just set that to 0 for now. It will be updated again later.

bad fragment received

This isn't a real handshake message so skip the processing below.

reconstruct message header

dtls1_max_handshake_message_len returns the maximum number of bytes permitted in a DTLS handshake message for |s|. The minimum is 16KB, but may be greater if the maximum certificate list size requires it.

sanity checking

first fragment

msg_len is limited to 2^24, but is effectively checked against dtls_max_handshake_message_len(s) above

They must be playing with us! BTW, failure to enforce upper limit would open possibility for buffer overrun.

no error

(0) check whether the desired fragment is available if so: (1) copy over the fragment to s->init_buf->data[] (2) update s->init_num

This is a stale message that has been buffered so clear it

Don't return if reassembly still in progress

no alert

Try to find item in queue

If message is already reassembled, this must be a retransmit and can be dropped. In this case item != NULL and so frag does not need to be freed.

read the body of the fragment (header has already been read

pqueue_insert fails iff a duplicate item is inserted. However, |item| cannot be a duplicate. If it were, |pqueue_find|, above, would have returned it and control would never have reached this branch.

Try to find item in queue, to prevent duplicate entries

If we already have an entry and this one is a fragment, don't discard it and rather try to reassemble it.

Discard the message if sequence number was already there, is too far in the future, already in the queue or if we received a FINISHED before the SERVER_HELLO, which then must be a stale retransmit.

read the body of the fragment (header has already been read

pqueue_insert fails iff a duplicate item is inserted. However, |item| cannot be a duplicate. If it were, |pqueue_find|, above, would have returned it. Then, either |frag_len| != |msg_hdr->msg_len| in which case |item| is set to NULL and it will have been processed with |dtls1_reassemble_fragment|, above, or the record will have been discarded.

see if we have the required fragment already

read handshake message header

nbio, or an error

Handshake fails if message header is incomplete

parse the message fragment header

We must have at least frag_len bytes left in the record to be read. Fragments must not span records.

if this is a future (or stale) message it gets buffered (or dropped)--no further processing at this time While listening, we accept seq 1 (ClientHello with cookie) although we're still expecting seq 0 (ClientHello)

The server may always send 'Hello Request' messages -- we are doing a handshake anyway now, so ignore them if their format is correct. Does not count for 'Finished' MAC.

Incorrectly formatted Hello request

This shouldn't ever fail due to NBIO because we already checked that we have enough data in the record

XDTLS: an incorrectly formatted fragment should cause the handshake to fail

Note that s->init_num is not used as current offset in s->init_buf->data, but as a counter summing up fragments' lengths: as soon as they sum up to handshake packet length, we assume we have got all the fragments.

for these 2 messages, we need to ssl->enc_read_ctx re-init ssl->rlayer.read_sequence zero ssl->s3->read_mac_secret re-init ssl->session->read_sym_enc assign ssl->session->read_compression assign ssl->session->read_hash assign

read app data until dry event

not a timeout, none of our business, let higher layers handle this. in fact it's probably an error

done, no need to send a retransmit

The index of the retransmission queue actually is the message sequence number, since the queue only contains messages of a single handshake. However, the ChangeCipherSpec has no message sequence number and so using only the sequence will result in the CCS and Finished having the same index. To prevent this, the sequence number is multiplied by 2. In case of a CCS 1 is subtracted. This does not only differ CSS and Finished, it also maintains the order of the index (important for priority queues) and fits in the unsigned short variable.

this function is called immediately after a message has been serialized

For DTLS1_BAD_VER the header length is non-standard

save current state

XDTLS: for now assuming that read/writes are blocking

XDTLS: the requested message ought to be found, otherwise error

save current state

restore state in which the message was originally sent

restore current state

don't actually do the writing, wait till the MTU has been retrieved

We allocate space at the start for the message header. This gets filled in later

Buffer the message to handle re-xmits

www.openssl.org/source/license.html

License

../ssl_locl.h

statem_locl.h

internal/cryptlib.h

type

t ever be < 0...but just in case */ while (s->init_num > 0) { if (type == SSL3_RT_HANDSHAKE && s->init_off != 0) { /* We must be writing a fragment other than the first one */ if (frag_off > 0) { /* This is the first attempt at writing out this fragment */ if (s->init_off <= DTLS1_HM_HEADER_LENGTH) { /* * Each fragment that was already sent must at least have * contained the message header plus one other byte. * Therefore |init_off| must have progressed by at least * |DTLS1_HM_HEADER_LENGTH + 1| bytes. If not something went * wrong. */ return -1; } /* * Adjust |init_off| and |init_num| to allow room for a new * message header for this fragment. */ s->init_off -= DTLS1_HM_HEADER_LENGTH; s->init_num += DTLS1_HM_HEADER_LENGTH; } else { /* * We must have been called again after a retry so use the * fragment offset from our last attempt. We do not need * to adjust |init_off| and |init_num| as above, because * that should already have been done before the retry. */ frag_off = s->d1->w_msg_hdr.frag_off; } } used_len = BIO_wpending(s->wbio) + DTLS1_RT_HEADER_LENGTH + mac_size + blocksize; if (s->d1->mtu > used_len) curr_mtu = s->d1->mtu - used_len; else curr_mtu = 0; if (curr_mtu <= DTLS1_HM_HEADER_LENGTH) { /* * grr.. we could get an error if MTU picked was wrong */ ret = BIO_flush(s->wbio); if (ret <= 0) { s->rwstate = SSL_WRITING; return ret; } used_len = DTLS1_RT_HEADER_LENGTH + mac_size + blocksize; if (s->d1->mtu > used_len + DTLS1_HM_HEADER_LENGTH) { curr_mtu = s->d1->mtu - used_len; } else { /* Shouldn

t do anything sensible * so fail */ return -1; } dtls1_fix_message_header(s, frag_off, len - DTLS1_HM_HEADER_LENGTH); dtls1_write_message_header(s, (unsigned char *)&s->init_buf-> data[s->init_off]); } ret = dtls1_write_bytes(s, type, &s->init_buf->data[s->init_off], len, &written); if (ret < 0) { /* * might need to update MTU here, but we don

t really * retransmit anything. continue as if everything is fine and * wait for an alert to handle the retransmit */ if (retry && BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0) { if (!(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) { if (!dtls1_query_mtu(s)) return -1; /* Have one more go */ retry = 0; } else return -1; } else { return -1; } } else { /* * bad if this assert fails, only part of the handshake message * got sent. but why would this happen? */ if (!ossl_assert(len == written)) return -1; if (type == SSL3_RT_HANDSHAKE && !s->d1->retransmitting) { /* * should not be done for

s, but in that case * we

t know the length of the * next fragment yet so just set that to 0 for now. It will be * updated again later. */ dtls1_fix_message_header(s, frag_off, 0); } } return 0; } int dtls_get_message(SSL *s, int *mt, size_t *len) { struct hm_header_st *msg_hdr; unsigned char *p; size_t msg_len; size_t tmplen; int errtype; msg_hdr = &s->d1->r_msg_hdr; memset(msg_hdr, 0, sizeof(*msg_hdr)); again: if (!dtls_get_reassembled_message(s, &errtype, &tmplen)) { if (errtype == DTLS1_HM_BAD_FRAGMENT || errtype == DTLS1_HM_FRAGMENT_RETRY) { /* bad fragment received */ goto again; } return 0; } *mt = s->s3->tmp.message_type; p = (unsigned char *)s->init_buf->data; *len = s->init_num; if (*mt == SSL3_MT_CHANGE_CIPHER_SPEC) { if (s->msg_callback) { s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, p, 1, s, s->msg_callback_arg); } /* * This isn

t return if reassembly still in progress */ if (frag->reassembly != NULL) return 0; if (s->d1->handshake_read_seq == frag->msg_header.seq) { size_t frag_len = frag->msg_header.frag_len; pqueue_pop(s->d1->buffered_messages); al = dtls1_preprocess_fragment(s, &frag->msg_header); if (al == 0) { /* no alert */ unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH; memcpy(&p[frag->msg_header.frag_off], frag->fragment, frag->msg_header.frag_len); } dtls1_hm_fragment_free(frag); pitem_free(item); if (al == 0) { *len = frag_len; return 1; } ssl3_send_alert(s, SSL3_AL_FATAL, al); s->init_num = 0; return 0; } else { return 0; } } static int dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr) { hm_fragment *frag = NULL; pitem *item = NULL; int i = -1, is_complete; unsigned char seq64be[8]; size_t frag_len = msg_hdr->frag_len; size_t readbytes; if ((msg_hdr->frag_off + frag_len) > msg_hdr->msg_len || msg_hdr->msg_len > dtls1_max_handshake_message_len(s)) goto err; if (frag_len == 0) { return DTLS1_HM_FRAGMENT_RETRY; } /* Try to find item in queue */ memset(seq64be, 0, sizeof(seq64be)); seq64be[6] = (unsigned char)(msg_hdr->seq >> 8); seq64be[7] = (unsigned char)msg_hdr->seq; item = pqueue_find(s->d1->buffered_messages, seq64be); if (item == NULL) { frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1); if (frag == NULL) goto err; memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr)); frag->msg_header.frag_len = frag->msg_header.msg_len; frag->msg_header.frag_off = 0; } else { frag = (hm_fragment *)item->data; if (frag->msg_header.msg_len != msg_hdr->msg_len) { item = NULL; frag = NULL; goto err; } } /* * If message is already reassembled, this must be a retransmit and can * be dropped. In this case item != NULL and so frag does not need to be * freed. */ if (frag->reassembly == NULL) { unsigned char devnull[256]; while (frag_len) { i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, devnull, frag_len > sizeof(devnull) ? sizeof(devnull) : frag_len, 0, &readbytes); if (i <= 0) goto err; frag_len -= readbytes; } return DTLS1_HM_FRAGMENT_RETRY; } /* read the body of the fragment (header has already been read */ i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, frag->fragment + msg_hdr->frag_off, frag_len, 0, &readbytes); if (i <= 0 || readbytes != frag_len) i = -1; if (i <= 0) goto err; RSMBLY_BITMASK_MARK(frag->reassembly, (long)msg_hdr->frag_off, (long)(msg_hdr->frag_off + frag_len)); if (!ossl_assert(msg_hdr->msg_len > 0)) goto err; RSMBLY_BITMASK_IS_COMPLETE(frag->reassembly, (long)msg_hdr->msg_len, is_complete); if (is_complete) { OPENSSL_free(frag->reassembly); frag->reassembly = NULL; } if (item == NULL) { item = pitem_new(seq64be, frag); if (item == NULL) { i = -1; goto err; } item = pqueue_insert(s->d1->buffered_messages, item); /* * pqueue_insert fails iff a duplicate item is inserted. However, * |item| cannot be a duplicate. If it were, |pqueue_find|, above, * would have returned it and control would never have reached this * branch. */ if (!ossl_assert(item != NULL)) goto err; } return DTLS1_HM_FRAGMENT_RETRY; err: if (item == NULL) dtls1_hm_fragment_free(frag); return -1; } static int dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr) { int i = -1; hm_fragment *frag = NULL; pitem *item = NULL; unsigned char seq64be[8]; size_t frag_len = msg_hdr->frag_len; size_t readbytes; if ((msg_hdr->frag_off + frag_len) > msg_hdr->msg_len) goto err; /* Try to find item in queue, to prevent duplicate entries */ memset(seq64be, 0, sizeof(seq64be)); seq64be[6] = (unsigned char)(msg_hdr->seq >> 8); seq64be[7] = (unsigned char)msg_hdr->seq; item = pqueue_find(s->d1->buffered_messages, seq64be); /* * If we already have an entry and this one is a fragment, don

re still expecting seq 0 (ClientHello) */ if (msg_hdr.seq != s->d1->handshake_read_seq) { *errtype = dtls1_process_out_of_seq_message(s, &msg_hdr); return 0; } if (frag_len && frag_len < mlen) { *errtype = dtls1_reassemble_fragment(s, &msg_hdr); return 0; } if (!s->server && s->d1->r_msg_hdr.frag_off == 0 && s->statem.hand_state != TLS_ST_OK && wire[0] == SSL3_MT_HELLO_REQUEST) { /* * The server may always send

messages -- we are * doing a handshake anyway now, so ignore them if their format is * correct. Does not count for

MAC. */ if (wire[1] == 0 && wire[2] == 0 && wire[3] == 0) { if (s->msg_callback) s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, wire, DTLS1_HM_HEADER_LENGTH, s, s->msg_callback_arg); s->init_num = 0; goto redo; } else { /* Incorrectly formatted Hello request */ al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_DTLS_GET_REASSEMBLED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE); goto f_err; } } if ((al = dtls1_preprocess_fragment(s, &msg_hdr))) goto f_err; if (frag_len > 0) { unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH; i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, &p[frag_off], frag_len, 0, &readbytes); /* * This shouldn

lengths: as * soon as they sum up to handshake packet length, we assume we have got * all the fragments. */ *len = s->init_num = frag_len; return 1; f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); s->init_num = 0; *len = 0; return 0; } /*- * for these 2 messages, we need to * ssl->enc_read_ctx re-init * ssl->rlayer.read_sequence zero * ssl->s3->read_mac_secret re-init * ssl->session->read_sym_enc assign * ssl->session->read_compression assign * ssl->session->read_hash assign */ int dtls_construct_change_cipher_spec(SSL *s, WPACKET *pkt) { if (s->version == DTLS1_BAD_VER) { s->d1->next_handshake_write_seq++; if (!WPACKET_put_bytes_u16(pkt, s->d1->handshake_write_seq)) { SSLerr(SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR); ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR); } } return 1; } #ifndef OPENSSL_NO_SCTP WORK_STATE dtls_wait_for_dry(SSL *s) { int ret; /* read app data until dry event */ ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s)); if (ret < 0) return WORK_ERROR; if (ret == 0) { s->s3->in_read_app_data = 2; s->rwstate = SSL_READING; BIO_clear_retry_flags(SSL_get_rbio(s)); BIO_set_retry_read(SSL_get_rbio(s)); return WORK_MORE_A; } return WORK_FINISHED_CONTINUE; } #endif int dtls1_read_failed(SSL *s, int code) { if (code > 0) { SSLerr(SSL_F_DTLS1_READ_FAILED, ERR_R_INTERNAL_ERROR); return 1; } if (!dtls1_is_timer_expired(s)) { /* * not a timeout, none of our business, let higher layers handle * this. in fact it

0xff;

0xff)

0xff,

0xfe,

0xfc,

0xf8,

0xf0,

0xe0,

0xc0,

0x80

0xff,

0x01,

0x03,

0x07,

0x0f,

0x1f,

0x3f,

0x7f

