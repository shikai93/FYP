Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Functions for manipulating OSSL_STORE_LOADERs

We usually don't check NULL arguments. For loaders, though, the scheme is crucial and must never be NULL, or the user will get mysterious errors when trying to register the created loader later on.

Functions for registering OSSL_STORE_LOADERs

Check that the given scheme conforms to correct scheme syntax as per RFC 3986: scheme = ALPHA ( ALPHA / DIGIT / "+" / "-" / "." )

Check that functions we absolutely require are present

Functions to list OSSL_STORE loaders

www.openssl.org/source/license.html

License

internal/ctype.h

store_locl.h

t check NULL arguments. For loaders, though, the * scheme is crucial and must never be NULL, or the user will get * mysterious errors when trying to register the created loader * later on. */ if (scheme == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, OSSL_STORE_R_INVALID_SCHEME); return NULL; } if ((res = OPENSSL_zalloc(sizeof(*res))) == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE); return NULL; } res->engine = e; res->scheme = scheme; return res; } const ENGINE *OSSL_STORE_LOADER_get0_engine(const OSSL_STORE_LOADER *loader) { return loader->engine; } const char *OSSL_STORE_LOADER_get0_scheme(const OSSL_STORE_LOADER *loader) { return loader->scheme; } int OSSL_STORE_LOADER_set_open(OSSL_STORE_LOADER *loader, OSSL_STORE_open_fn open_function) { loader->open = open_function; return 1; } int OSSL_STORE_LOADER_set_ctrl(OSSL_STORE_LOADER *loader, OSSL_STORE_ctrl_fn ctrl_function) { loader->ctrl = ctrl_function; return 1; } int OSSL_STORE_LOADER_set_load(OSSL_STORE_LOADER *loader, OSSL_STORE_load_fn load_function) { loader->load = load_function; return 1; } int OSSL_STORE_LOADER_set_eof(OSSL_STORE_LOADER *loader, OSSL_STORE_eof_fn eof_function) { loader->eof = eof_function; return 1; } int OSSL_STORE_LOADER_set_error(OSSL_STORE_LOADER *loader, OSSL_STORE_error_fn error_function) { loader->error = error_function; return 1; } int OSSL_STORE_LOADER_set_close(OSSL_STORE_LOADER *loader, OSSL_STORE_close_fn close_function) { loader->close = close_function; return 1; } void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *loader) { OPENSSL_free(loader); } /* * Functions for registering OSSL_STORE_LOADERs */ static unsigned long store_loader_hash(const OSSL_STORE_LOADER *v) { return OPENSSL_LH_strhash(v->scheme); } static int store_loader_cmp(const OSSL_STORE_LOADER *a, const OSSL_STORE_LOADER *b) { assert(a->scheme != NULL && b->scheme != NULL); return strcmp(a->scheme, b->scheme); } static LHASH_OF(OSSL_STORE_LOADER) *loader_register = NULL; int ossl_store_register_loader_int(OSSL_STORE_LOADER *loader) { const char *scheme = loader->scheme; int ok = 0; /* * Check that the given scheme conforms to correct scheme syntax as per * RFC 3986: * * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */ if (ossl_isalpha(*scheme)) while (*scheme !=

&& (ossl_isalpha(*scheme) || ossl_isdigit(*scheme) || strchr("+-.", *scheme) != NULL)) scheme++; if (*scheme !=

scheme=

scheme=

scheme=

