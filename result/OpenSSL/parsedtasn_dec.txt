Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Table to convert tags to bit values, used for MSTRING type

tags 0 - 3

tags 4- 7

tags 8-11

tags 12-15

tags 16-19

tags 20-22

tags 23-24

tags 25-27

tags 28-31

Macro to initialize and invalidate the cache

Version to avoid compiler warning about 'c' always non-NULL

Decode an ASN1 item, this currently behaves just like a standard 'd2i' function. 'in' points to a buffer to read the data from, in future we will have more advanced versions that can input data a piece at a time and this will simply be a special case.

Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and tag mismatch return -1 to handle OPTIONAL

tagging or OPTIONAL is currently illegal on an item template because the flags can't get passed down. In practice this isn't a problem: we include the relevant flags from the item template in the template itself.

Just read in tag and class

Must be UNIVERSAL class

If OPTIONAL, assume this is OK

Check tag matches bit map

If OPTIONAL, assume this is OK

Use new style d2i

Free up and zero CHOICE value if initialised

CHOICE type, try each possibility in turn

We mark field as OPTIONAL so its absence can be recognised.

If field not present, try the next one

If positive return, read OK, break loop

Must be an ASN1 parsing error. Free up any partial choice value

Did we fall off the end without reading anything?

If OPTIONAL, this is OK

Free and zero it

If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL

Get SEQUENCE length and update len, p

If indefinite we don't do a length check

Free up and zero any ADB found

Get each field entry

Have we ran out of data?

This determines the OPTIONAL flag value. The field cannot be omitted if it is the last of a SEQUENCE and there is still data to be read. This isn't strictly necessary but it increases efficiency in some cases.

attempt to read in field, allowing each to be OPTIONAL

OPTIONAL component absent. Free and zero the field.

Update length

Check for EOC if expecting one

Check all data read

If we get here we've got no more data in the SEQUENCE, however we may not have read all fields so check all remaining are OPTIONAL and clear any that are.

Save encoding

Templates are handled with two separate functions. One handles any EXPLICIT tag and the other handles the rest.

Check if EXPLICIT tag expected

Need to work out amount of data available to the inner content and where it starts: so read in EXPLICIT header to get the info.

We've found the field so it can't be OPTIONAL now

We read the field in OK so update length

If NDEF we must have an EOC here

Otherwise we must hit the EXPLICIT tag end or its an error

If field is embedded then val needs fixing so it is a pointer to a pointer to a field.

SET OF, SEQUENCE OF

First work out expected inner tag value

Get the tag

We've got a valid STACK: free up any items present

Read as many items as we can

See if EOC found

|skfield| may be partially allocated despite failure.

IMPLICIT tagging

Nothing special

Should never happen

If type is ANY need to figure out type from tag

Check header

SEQUENCE, SET and "OTHER" are left in encoded form

Clear context cache for type OTHER because the auto clear when we have a exact match won't work

SEQUENCE and SET must be constructed

If indefinite length constructed find the real end

Free any returned 'buf' content

Should really check the internal tags are correct but some things may get this wrong. The relevant specs say that constructed string types should be OCTET STRINGs internally irrespective of the type. So instead just check for UNIVERSAL class and ignore the tag.

Append a final null to string

We now have content length and type: translate into a structure

asn1_ex_c2i may reuse allocated buffer, and so sets free_cont to 0

Translate ASN1 content octets into a structure

If ANY type clear type and set pointer to internal value

Fixup type to match the expected form

All based on ASN1_STRING and handled the same

If we've already allocated a buffer use it

UGLY CAST! RL

If ASN1_ANY and NULL type fix up value

This function finds the end of an ASN1 structure when passed its maximum length, whether it is indefinite length and a pointer to the content. This is more efficient than calling asn1_collect because it does not recurse on each indefinite length header.

If not indefinite length constructed just add length

Indefinite length constructed form. Find the end when enough EOCs are found. If more indefinite length constructed headers are encountered increment the expected eoc count otherwise just skip to the end of the data.

Just read in a header: only care about the length

This function collects the asn1 data from a constructed string type into a buffer. The values of 'in' and 'len' should refer to the contents of the constructed type and 'inf' should be set if it is indefinite length.

This determines how many levels of recursion are permitted in ASN1 string types. If it is not limited stack overflows can occur. If set to zero no recursion is allowed at all. Although zero should be adequate examples exist that require a value of 1. So 5 should be more than enough.

If no buffer and not indefinite length constructed just pass over the encoded data

Check for EOC

EOC is illegal outside indefinite length constructed form

If indefinite length constructed update max length

Check for ASN1 EOC and swallow it if found

Check an ASN1 tag and length: a bit like ASN1_get_object but it sets the length for indefinite length constructed form, we don't know the exact length but we can set an upper bound to the amount of data available minus the header length just read.

If definite length, and no error, length + header can't exceed total amount of data available.

If type is OPTIONAL, not an error: indicate missing type.

We have a tag and class match: assume we are going to do something with it

www.openssl.org/source/license.html

License

internal/numbers.h

asn1_locl.h

c

d2i

in

opt

t get passed down. In practice this * isn

t do a length check */ else seq_nolen = seq_eoc; if (!cst) { ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED); goto err; } if (!*pval && !ASN1_item_ex_new(pval, it)) { ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR); goto err; } if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) goto auxerr; /* Free up and zero any ADB found */ for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) { if (tt->flags & ASN1_TFLG_ADB_MASK) { const ASN1_TEMPLATE *seqtt; ASN1_VALUE **pseqval; seqtt = asn1_do_adb(pval, tt, 0); if (seqtt == NULL) continue; pseqval = asn1_get_field_ptr(pval, seqtt); asn1_template_free(pseqval, seqtt); } } /* Get each field entry */ for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) { const ASN1_TEMPLATE *seqtt; ASN1_VALUE **pseqval; seqtt = asn1_do_adb(pval, tt, 1); if (seqtt == NULL) goto err; pseqval = asn1_get_field_ptr(pval, seqtt); /* Have we ran out of data? */ if (!len) break; q = p; if (asn1_check_eoc(&p, len)) { if (!seq_eoc) { ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_UNEXPECTED_EOC); goto err; } len -= p - q; seq_eoc = 0; q = p; break; } /* * This determines the OPTIONAL flag value. The field cannot be * omitted if it is the last of a SEQUENCE and there is still * data to be read. This isn

ve got no more data in the SEQUENCE, however we * may not have read all fields so check all remaining are OPTIONAL * and clear any that are. */ for (; i < it->tcount; tt++, i++) { const ASN1_TEMPLATE *seqtt; seqtt = asn1_do_adb(pval, tt, 1); if (seqtt == NULL) goto err; if (seqtt->flags & ASN1_TFLG_OPTIONAL) { ASN1_VALUE **pseqval; pseqval = asn1_get_field_ptr(pval, seqtt); asn1_template_free(pseqval, seqtt); } else { errtt = seqtt; ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_FIELD_MISSING); goto err; } } /* Save encoding */ if (!asn1_enc_save(pval, *in, p - *in, it)) goto auxerr; if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) goto auxerr; *in = p; return 1; default: return 0; } auxerr: ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_AUX_ERROR); err: if (errtt) ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname); else ERR_add_error_data(2, "Type=", it->sname); return 0; } /* * Templates are handled with two separate functions. One handles any * EXPLICIT tag and the other handles the rest. */ static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long inlen, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx) { int flags, aclass; int ret; long len; const unsigned char *p, *q; char exp_eoc; if (!val) return 0; flags = tt->flags; aclass = flags & ASN1_TFLG_TAG_CLASS; p = *in; /* Check if EXPLICIT tag expected */ if (flags & ASN1_TFLG_EXPTAG) { char cst; /* * Need to work out amount of data available to the inner content and * where it starts: so read in EXPLICIT header to get the info. */ ret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst, &p, inlen, tt->tag, aclass, opt, ctx); q = p; if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR); return 0; } else if (ret == -1) return -1; if (!cst) { ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED); return 0; } /* We

t be OPTIONAL now */ ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx); if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR); return 0; } /* We read the field in OK so update length */ len -= p - q; if (exp_eoc) { /* If NDEF we must have an EOC here */ if (!asn1_check_eoc(&p, len)) { ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_MISSING_EOC); goto err; } } else { /* * Otherwise we must hit the EXPLICIT tag end or its an error */ if (len) { ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_EXPLICIT_LENGTH_MISMATCH); goto err; } } } else return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx); *in = p; return 1; err: return 0; } static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx) { int flags, aclass; int ret; ASN1_VALUE *tval; const unsigned char *p, *q; if (!val) return 0; flags = tt->flags; aclass = flags & ASN1_TFLG_TAG_CLASS; p = *in; q = p; /* * If field is embedded then val needs fixing so it is a pointer to * a pointer to a field. */ if (tt->flags & ASN1_TFLG_EMBED) { tval = (ASN1_VALUE *)val; val = &tval; } if (flags & ASN1_TFLG_SK_MASK) { /* SET OF, SEQUENCE OF */ int sktag, skaclass; char sk_eoc; /* First work out expected inner tag value */ if (flags & ASN1_TFLG_IMPTAG) { sktag = tt->tag; skaclass = aclass; } else { skaclass = V_ASN1_UNIVERSAL; if (flags & ASN1_TFLG_SET_OF) sktag = V_ASN1_SET; else sktag = V_ASN1_SEQUENCE; } /* Get the tag */ ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL, &p, len, sktag, skaclass, opt, ctx); if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR); return 0; } else if (ret == -1) return -1; if (!*val) *val = (ASN1_VALUE *)OPENSSL_sk_new_null(); else { /* * We

OTHER

t work */ if (utype == V_ASN1_OTHER) { asn1_tlc_clear(ctx); } /* SEQUENCE and SET must be constructed */ else if (!cst) { ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_CONSTRUCTED); return 0; } cont = *in; /* If indefinite length constructed find the real end */ if (inf) { if (!asn1_find_end(&p, plen, inf)) goto err; len = p - cont; } else { len = p - cont + plen; p += plen; } } else if (cst) { if (utype == V_ASN1_NULL || utype == V_ASN1_BOOLEAN || utype == V_ASN1_OBJECT || utype == V_ASN1_INTEGER || utype == V_ASN1_ENUMERATED) { ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_PRIMITIVE); return 0; } /* Free any returned

content */ free_cont = 1; /* * Should really check the internal tags are correct but some things * may get this wrong. The relevant specs say that constructed string * types should be OCTET STRINGs internally irrespective of the type. * So instead just check for UNIVERSAL class and ignore the tag. */ if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0)) { goto err; } len = buf.length; /* Append a final null to string */ if (!BUF_MEM_grow_clean(&buf, len + 1)) { ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE); goto err; } buf.data[len] = 0; cont = (const unsigned char *)buf.data; } else { cont = p; len = plen; p += plen; } /* We now have content length and type: translate into a structure */ /* asn1_ex_c2i may reuse allocated buffer, and so sets free_cont to 0 */ if (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it)) goto err; *in = p; ret = 1; err: if (free_cont) OPENSSL_free(buf.data); return ret; } /* Translate ASN1 content octets into a structure */ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it) { ASN1_VALUE **opval = NULL; ASN1_STRING *stmp; ASN1_TYPE *typ = NULL; int ret = 0; const ASN1_PRIMITIVE_FUNCS *pf; ASN1_INTEGER **tint; pf = it->funcs; if (pf && pf->prim_c2i) return pf->prim_c2i(pval, cont, len, utype, free_cont, it); /* If ANY type clear type and set pointer to internal value */ if (it->utype == V_ASN1_ANY) { if (!*pval) { typ = ASN1_TYPE_new(); if (typ == NULL) goto err; *pval = (ASN1_VALUE *)typ; } else typ = (ASN1_TYPE *)*pval; if (utype != typ->type) ASN1_TYPE_set(typ, utype, NULL); opval = pval; pval = &typ->value.asn1_value; } switch (utype) { case V_ASN1_OBJECT: if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) goto err; break; case V_ASN1_NULL: if (len) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH); goto err; } *pval = (ASN1_VALUE *)1; break; case V_ASN1_BOOLEAN: if (len != 1) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH); goto err; } else { ASN1_BOOLEAN *tbool; tbool = (ASN1_BOOLEAN *)pval; *tbool = *cont; } break; case V_ASN1_BIT_STRING: if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) goto err; break; case V_ASN1_INTEGER: case V_ASN1_ENUMERATED: tint = (ASN1_INTEGER **)pval; if (!c2i_ASN1_INTEGER(tint, &cont, len)) goto err; /* Fixup type to match the expected form */ (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG); break; case V_ASN1_OCTET_STRING: case V_ASN1_NUMERICSTRING: case V_ASN1_PRINTABLESTRING: case V_ASN1_T61STRING: case V_ASN1_VIDEOTEXSTRING: case V_ASN1_IA5STRING: case V_ASN1_UTCTIME: case V_ASN1_GENERALIZEDTIME: case V_ASN1_GRAPHICSTRING: case V_ASN1_VISIBLESTRING: case V_ASN1_GENERALSTRING: case V_ASN1_UNIVERSALSTRING: case V_ASN1_BMPSTRING: case V_ASN1_UTF8STRING: case V_ASN1_OTHER: case V_ASN1_SET: case V_ASN1_SEQUENCE: default: if (utype == V_ASN1_BMPSTRING && (len & 1)) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH); goto err; } if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH); goto err; } /* All based on ASN1_STRING and handled the same */ if (!*pval) { stmp = ASN1_STRING_type_new(utype); if (stmp == NULL) { ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE); goto err; } *pval = (ASN1_VALUE *)stmp; } else { stmp = (ASN1_STRING *)*pval; stmp->type = utype; } /* If we

in

len

inf

t know the exact * length but we can set an upper bound to the amount of data available minus * the header length just read. */ static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass, char *inf, char *cst, const unsigned char **in, long len, int exptag, int expclass, char opt, ASN1_TLC *ctx) { int i; int ptag, pclass; long plen; const unsigned char *p, *q; p = *in; q = p; if (ctx && ctx->valid) { i = ctx->ret; plen = ctx->plen; pclass = ctx->pclass; ptag = ctx->ptag; p += ctx->hdrlen; } else { i = ASN1_get_object(&p, &plen, &ptag, &pclass, len); if (ctx) { ctx->ret = i; ctx->plen = plen; ctx->pclass = pclass; ctx->ptag = ptag; ctx->hdrlen = p - q; ctx->valid = 1; /* * If definite length, and no error, length + header can

0x81)

0x80)

