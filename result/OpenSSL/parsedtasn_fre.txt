Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Free up an ASN1 structure

if error or ref-counter > 0

If we free up as normal we will invalidate any ANY DEFINED BY field and we won't be able to determine the type of the field it defines. So free up in reverse order.

Special case: if 'it' is a primitive with a free_func, use that.

Special case: if 'it' is NULL, free contents of ASN1_TYPE

www.openssl.org/source/license.html

License

asn1_locl.h

t be able to determine the type of the field it * defines. So free up in reverse order. */ tt = it->templates + it->tcount; for (i = 0; i < it->tcount; i++) { ASN1_VALUE **pseqval; tt--; seqtt = asn1_do_adb(pval, tt, 0); if (!seqtt) continue; pseqval = asn1_get_field_ptr(pval, seqtt); asn1_template_free(pseqval, seqtt); } if (asn1_cb) asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL); if (embed == 0) { OPENSSL_free(*pval); *pval = NULL; } break; } } void asn1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) { int embed = tt->flags & ASN1_TFLG_EMBED; ASN1_VALUE *tval; if (embed) { tval = (ASN1_VALUE *)pval; pval = &tval; } if (tt->flags & ASN1_TFLG_SK_MASK) { STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval; int i; for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) { ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i); asn1_item_embed_free(&vtmp, ASN1_ITEM_ptr(tt->item), embed); } sk_ASN1_VALUE_free(sk); *pval = NULL; } else { asn1_item_embed_free(pval, ASN1_ITEM_ptr(tt->item), embed); } } void asn1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed) { int utype; /* Special case: if

is a primitive with a free_func, use that. */ if (it) { const ASN1_PRIMITIVE_FUNCS *pf = it->funcs; if (embed) { if (pf && pf->prim_clear) { pf->prim_clear(pval, it); return; } } else if (pf && pf->prim_free) { pf->prim_free(pval, it); return; } } /* Special case: if

