Copyright 2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Always filled with zeros

Given a |secret|; a |label| of length |labellen|; and |data| of length |datalen| (e.g. typically a hash of the handshake messages), derive a new secret |outlen| bytes long and store it in the location pointed to be |out|. The |data| value may be zero length. Returns 1 on success 0 on failure.

2 bytes for length of whole HkdfLabel + 1 byte for length of combined prefix and label + bytes for the label itself + bytes for the hash

Given a |secret| generate a |key| of length |keylen| bytes. Returns 1 on success 0 on failure.

Given a |secret| generate an |iv| of length |ivlen| bytes. Returns 1 on success 0 on failure.

Given the previous secret |prevsecret| and a new input secret |insecret| of length |insecretlen|, generate a new secret and store it in the location pointed to by |outsecret|. Returns 1 on success 0 on failure.

The pre-extract derive step uses a hash of no messages

Generate the pre-extract secret

Given an input secret |insecret| of length |insecretlen| generate the handshake secret. This requires the early secret to already have been generated. Returns 1 on success 0 on failure.

Given the handshake secret |prev| of length |prevlen| generate the master secret and store its length in |secret_size|. Returns 1 on success 0 on failure.

Generates the mac for the Finished message. Returns the length of the MAC or 0 on error.

There isn't really a key block in TLSv1.3, but we still need this function for initialising the cipher and hash. Returns 1 on success or 0 on failure.

TODO(size_t): convert me

We've not selected a cipher yet - we must be doing early data

We need to calculate the handshake digest using the digest from the session. We haven't yet selected our ciphersuite so we can't use ssl_handshake_md().

The handshake hash used for the server read/client write handshake traffic secret is the same as the hash for the server write/client read handshake traffic secret. However, if we processed early data then we delay changing the server read/client write cipher state until later, and the handshake hashes have moved on. Therefore we use the value saved earlier when we did the server write/client read change cipher state.

For this we only use the handshake hashes up until the server Finished hash. We do not include the client's Finished, which is what ssl_handshake_hash() would give us. Instead we use the previously saved value.

Early data never applies to client-read/server-write

Save the hash of handshakes up to now for use when we calculate the client application traffic secret

We also create the resumption master secret, but this time use the hash for the whole handshake including the Client Finished

Now we create the exporter master secret

www.openssl.org/source/license.html

License

ssl_locl.h

tls13

key

iv

finished

derived

t really a key block in TLSv1.3, but we still need this function * for initialising the cipher and hash. Returns 1 on success or 0 on failure. */ int tls13_setup_key_block(SSL *s) { const EVP_CIPHER *c; const EVP_MD *hash; int mac_type = NID_undef; s->session->cipher = s->s3->tmp.new_cipher; if (!ssl_cipher_get_evp (s->session, &c, &hash, &mac_type, NULL, NULL, 0)) { SSLerr(SSL_F_TLS13_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE); return 0; } s->s3->tmp.new_sym_enc = c; s->s3->tmp.new_hash = hash; return 1; } static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md, const EVP_CIPHER *ciph, const unsigned char *insecret, const unsigned char *hash, const unsigned char *label, size_t labellen, unsigned char *secret, unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx) { unsigned char key[EVP_MAX_KEY_LENGTH]; size_t ivlen, keylen, taglen; size_t hashlen = EVP_MD_size(md); if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen, secret, hashlen)) { SSLerr(SSL_F_DERIVE_SECRET_KEY_AND_IV, ERR_R_INTERNAL_ERROR); goto err; } /* TODO(size_t): convert me */ keylen = EVP_CIPHER_key_length(ciph); if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) { uint32_t algenc; ivlen = EVP_CCM_TLS_IV_LEN; if (s->s3->tmp.new_cipher == NULL) { /* We

c e traffic

c hs traffic

c ap traffic

s hs traffic

s ap traffic

exp master

res master

t yet selected our ciphersuite so we can

traffic upd

exporter

