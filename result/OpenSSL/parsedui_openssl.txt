Copyright 2001-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

need for #define _POSIX_C_SOURCE arises whenever you pass -ansi to gcc [maybe others?], because it masks interfaces not discussed in standard, sigaction and fileno included. -pedantic would be more appropriate for the intended purposes, but we can't prevent users from adding -ansi.

If unistd.h defines _POSIX_VERSION, we conclude that we are on a POSIX system and have sigaction and termios.

06-Apr-92 Luke Brennan Support for VMS

prototypes for sys$whatever

There are 6 types of terminal interface supported, TERMIO, TERMIOS, VMS, MSDOS, WIN32 Console and SGTTY. If someone defines one of the macros TERMIO, TERMIOS or SGTTY, it will remain respected. Otherwise, we default to TERMIOS except for a few systems that require something different. Note: we do not use SGTTY unless it's defined by the configuration. We may eventually opt to remove it's use entirely.

We know that VMS, MSDOS, VXWORKS, use entirely other mechanisms.

Define globals. They are protected by a lock

XXX Is there any guarantee that this will always suffice for the actual structures?

Declare static functions

The following function makes sure that info and error strings are printed before any prompt.

Internal functions to read a string without echoing

FIXME: noecho_fgets doesn't return errors

Internal functions to open, handle and close a channel to the console.

Ariel Glenn ariel@columbia.edu reports that solaris can return EINVAL instead. This should be ok

MacOS X returns ENODEV (Operation not supported by device), which seems appropriate.

if there isn't a TT device, something is very wrong

If IO$_SENSEMODE doesn't work, this is not a terminal device

Internal functions to handle signals and act on them

We can't make any action on that.

Internal functions specific for Windows

Win95 has several evil console bugs: one of these is that the last character read using getch() is passed to the next read: this is usually a CR so this can be trouble. No STDIO fix seems to work but flushing the console appears to do the trick.

No flusher is needed for command lines

The method with all the built-in console thingies

www.openssl.org/source/license.html

License

e_os.h

t prevent users from adding -ansi. */ # if defined(OPENSSL_SYS_VXWORKS) # include <sys/types.h> # endif # if !defined(_POSIX_C_SOURCE) && defined(OPENSSL_SYS_VMS) # ifndef _POSIX_C_SOURCE # define _POSIX_C_SOURCE 2 # endif # endif # include <signal.h> # include <stdio.h> # include <string.h> # include <errno.h> # if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) # ifdef OPENSSL_UNISTD # include OPENSSL_UNISTD # else # include <unistd.h> # endif /* * If unistd.h defines _POSIX_VERSION, we conclude that we are on a POSIX * system and have sigaction and termios. */ # if defined(_POSIX_VERSION) # define SIGACTION # if !defined(TERMIOS) && !defined(TERMIO) && !defined(SGTTY) # define TERMIOS # endif # endif # endif /* 06-Apr-92 Luke Brennan Support for VMS */ # include "ui_locl.h" # include "internal/cryptlib.h" # ifdef OPENSSL_SYS_VMS /* prototypes for sys$whatever */ # include <starlet.h> # ifdef __DECC # pragma message disable DOLLARID # endif # endif # ifdef WIN_CONSOLE_BUG # include <windows.h> # ifndef OPENSSL_SYS_WINCE # include <wincon.h> # endif # endif /* * There are 6 types of terminal interface supported, TERMIO, TERMIOS, VMS, * MSDOS, WIN32 Console and SGTTY. * * If someone defines one of the macros TERMIO, TERMIOS or SGTTY, it will * remain respected. Otherwise, we default to TERMIOS except for a few * systems that require something different. * * Note: we do not use SGTTY unless it

s use entirely. */ # if !defined(TERMIOS) && !defined(TERMIO) && !defined(SGTTY) # if defined(_LIBC) # undef TERMIOS # define TERMIO # undef SGTTY /* * We know that VMS, MSDOS, VXWORKS, use entirely other mechanisms. */ # elif !defined(OPENSSL_SYS_VMS) \ && !defined(OPENSSL_SYS_MSDOS) \ && !defined(OPENSSL_SYS_VXWORKS) # define TERMIOS # undef TERMIO # undef SGTTY # endif # endif # ifdef TERMIOS # include <termios.h> # define TTY_STRUCT struct termios # define TTY_FLAGS c_lflag # define TTY_get(tty,data) tcgetattr(tty,data) # define TTY_set(tty,data) tcsetattr(tty,TCSANOW,data) # endif # ifdef TERMIO # include <termio.h> # define TTY_STRUCT struct termio # define TTY_FLAGS c_lflag # define TTY_get(tty,data) ioctl(tty,TCGETA,data) # define TTY_set(tty,data) ioctl(tty,TCSETA,data) # endif # ifdef SGTTY # include <sgtty.h> # define TTY_STRUCT struct sgttyb # define TTY_FLAGS sg_flags # define TTY_get(tty,data) ioctl(tty,TIOCGETP,data) # define TTY_set(tty,data) ioctl(tty,TIOCSETP,data) # endif # if !defined(_LIBC) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) # include <sys/ioctl.h> # endif # ifdef OPENSSL_SYS_MSDOS # include <conio.h> # endif # ifdef OPENSSL_SYS_VMS # include <ssdef.h> # include <iodef.h> # include <ttdef.h> # include <descrip.h> struct IOSB { short iosb$w_value; short iosb$w_count; long iosb$l_info; }; # endif # ifndef NX509_SIG # define NX509_SIG 32 # endif /* Define globals. They are protected by a lock */ # ifdef SIGACTION static struct sigaction savsig[NX509_SIG]; # else static void (*savsig[NX509_SIG]) (int); # endif # ifdef OPENSSL_SYS_VMS static struct IOSB iosb; static $DESCRIPTOR(terminal, "TT"); static long tty_orig[3], tty_new[3]; /* XXX Is there any guarantee that this * will always suffice for the actual * structures? */ static long status; static unsigned short channel = 0; # elif defined(_WIN32) && !defined(_WIN32_WCE) static DWORD tty_orig, tty_new; # else # if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__) static TTY_STRUCT tty_orig, tty_new; # endif # endif static FILE *tty_in, *tty_out; static int is_a_tty; /* Declare static functions */ # if !defined(OPENSSL_SYS_WINCE) static int read_till_nl(FILE *); static void recsig(int); static void pushsig(void); static void popsig(void); # endif # if defined(OPENSSL_SYS_MSDOS) && !defined(_WIN32) static int noecho_fgets(char *buf, int size, FILE *tty); # endif static int read_string_inner(UI *ui, UI_STRING *uis, int echo, int strip_nl); static int read_string(UI *ui, UI_STRING *uis); static int write_string(UI *ui, UI_STRING *uis); static int open_console(UI *ui); static int echo_console(UI *ui); static int noecho_console(UI *ui); static int close_console(UI *ui); /* * The following function makes sure that info and error strings are printed * before any prompt. */ static int write_string(UI *ui, UI_STRING *uis) { switch (UI_get_string_type(uis)) { case UIT_ERROR: case UIT_INFO: fputs(UI_get0_output_string(uis), tty_out); fflush(tty_out); break; case UIT_NONE: case UIT_PROMPT: case UIT_VERIFY: case UIT_BOOLEAN: break; } return 1; } static int read_string(UI *ui, UI_STRING *uis) { int ok = 0; switch (UI_get_string_type(uis)) { case UIT_BOOLEAN: fputs(UI_get0_output_string(uis), tty_out); fputs(UI_get0_action_string(uis), tty_out); fflush(tty_out); return read_string_inner(ui, uis, UI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 0); case UIT_PROMPT: fputs(UI_get0_output_string(uis), tty_out); fflush(tty_out); return read_string_inner(ui, uis, UI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 1); case UIT_VERIFY: fprintf(tty_out, "Verifying - %s", UI_get0_output_string(uis)); fflush(tty_out); if ((ok = read_string_inner(ui, uis, UI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 1)) <= 0) return ok; if (strcmp(UI_get0_result_string(uis), UI_get0_test_string(uis)) != 0) { fprintf(tty_out, "Verify failure\n"); fflush(tty_out); return 0; } break; case UIT_NONE: case UIT_INFO: case UIT_ERROR: break; } return 1; } # if !defined(OPENSSL_SYS_WINCE) /* Internal functions to read a string without echoing */ static int read_till_nl(FILE *in) { # define SIZE 4 char buf[SIZE + 1]; do { if (!fgets(buf, SIZE, in)) return 0; } while (strchr(buf,

) == NULL); return 1; } static volatile sig_atomic_t intr_signal; # endif static int read_string_inner(UI *ui, UI_STRING *uis, int echo, int strip_nl) { static int ps; int ok; char result[BUFSIZ]; int maxsize = BUFSIZ - 1; # if !defined(OPENSSL_SYS_WINCE) char *p = NULL; int echo_eol = !echo; intr_signal = 0; ok = 0; ps = 0; pushsig(); ps = 1; if (!echo && !noecho_console(ui)) goto error; ps = 2; result[0] =

; # if defined(_WIN32) if (is_a_tty) { DWORD numread; # if defined(CP_UTF8) if (GetEnvironmentVariableW(L"OPENSSL_WIN32_UTF8", NULL, 0) != 0) { WCHAR wresult[BUFSIZ]; if (ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), wresult, maxsize, &numread, NULL)) { if (numread >= 2 && wresult[numread-2] == L

&& wresult[numread-1] == L

) { wresult[numread-2] = L

; numread--; } wresult[numread] =

; if (WideCharToMultiByte(CP_UTF8, 0, wresult, -1, result, sizeof(result), NULL, 0) > 0) p = result; OPENSSL_cleanse(wresult, sizeof(wresult)); } } else # endif if (ReadConsoleA(GetStdHandle(STD_INPUT_HANDLE), result, maxsize, &numread, NULL)) { if (numread >= 2 && result[numread-2] ==

&& result[numread-1] ==

) { result[numread-2] =

; numread--; } result[numread] =

; p = result; } } else # elif defined(OPENSSL_SYS_MSDOS) if (!echo) { noecho_fgets(result, maxsize, tty_in); p = result; /* FIXME: noecho_fgets doesn

\n

\0

\n

conout$

w

conin$

r

con

/dev/tty

r

w

%d

errno=

t a TT device, something is very wrong */ if (status != SS$_NORMAL) { char tmp_num[12]; BIO_snprintf(tmp_num, sizeof(tmp_num) - 1, "%%X%08X", status); UIerr(UI_F_OPEN_CONSOLE, UI_R_SYSASSIGN_ERROR); ERR_add_error_data(2, "status=", tmp_num); return 0; } status = sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12, 0, 0, 0, 0); /* If IO$_SENSEMODE doesn

%%X%08X

%%X%08X

status=

,

iosb.iosb$w_value=

%%X%08X

%%X%08X

status=

,

iosb.iosb$w_value=

%%X%08X

status=

t make any action on that. */ continue; # endif # ifdef SIGACTION sigaction(i, &sa, &savsig[i]); # else savsig[i] = signal(i, recsig); # endif } # endif # ifdef SIGWINCH signal(SIGWINCH, SIG_DFL); # endif } static void popsig(void) { # ifdef OPENSSL_SYS_WIN32 signal(SIGABRT, savsig[SIGABRT]); signal(SIGFPE, savsig[SIGFPE]); signal(SIGILL, savsig[SIGILL]); signal(SIGINT, savsig[SIGINT]); signal(SIGSEGV, savsig[SIGSEGV]); signal(SIGTERM, savsig[SIGTERM]); # else int i; for (i = 1; i < NX509_SIG; i++) { # ifdef SIGUSR1 if (i == SIGUSR1) continue; # endif # ifdef SIGUSR2 if (i == SIGUSR2) continue; # endif # ifdef SIGACTION sigaction(i, &savsig[i], NULL); # else signal(i, savsig[i]); # endif } # endif } static void recsig(int i) { intr_signal = i; } # endif /* Internal functions specific for Windows */ # if defined(OPENSSL_SYS_MSDOS) && !defined(_WIN32) static int noecho_fgets(char *buf, int size, FILE *tty) { int i; char *p; p = buf; for (;;) { if (size == 0) { *p =

; break; } size--; # if defined(_WIN32) i = _getch(); # else i = getch(); # endif if (i ==

) i =

; *(p++) = i; if (i ==

) { *p =

OpenSSL default user interface

