Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Implementation of RFC 3779 section 2.2.

OpenSSL ASN.1 template translation of RFC 3779 2.2.3.

How much buffer space do we need for a raw address?

What's the address length associated with this AFI?

Extract the AFI from an IPAddressFamily.

Expand the bitstring form of an address into a raw byte array. At the moment this is coded for simplicity, not speed.

Extract the prefix length from a bitstring.

i2r handler for one address bitstring.

i2r handler for a sequence of addresses and ranges.

i2r handler for an IPAddrBlocks extension.

Sort comparison function for a sequence of IPAddressOrRange elements. There's no sane answer we can give if addr_expand() fails, and an assertion failure on externally supplied data is seriously uncool, so we just arbitrarily declare that if given invalid inputs this function returns -1. If this messes up your preferred sort order for garbage input, tough noogies.

IPv4-specific closure over IPAddressOrRange_cmp, since sk_sort() comparison routines are only allowed two arguments.

IPv6-specific closure over IPAddressOrRange_cmp, since sk_sort() comparison routines are only allowed two arguments.

Calculate whether a range collapses to a prefix. See last paragraph of RFC 3779 2.2.3.7.

Construct a prefix.

Construct a range. If it can be expressed as a prefix, return a prefix instead. Doing this here simplifies the rest of the code considerably.

Construct a new address family or find an existing one.

Add an inheritance element.

Construct an IPAddressOrRange sequence, or return an existing one.

Add a prefix.

Add a range.

Extract min and max values from an IPAddressOrRange.

Public wrapper for extract_min_max().

Sort comparison function for a sequence of IPAddressFamily. The last paragraph of RFC 3779 2.2.3.3 is slightly ambiguous about the ordering: I can read it as meaning that IPv6 without a SAFI comes before IPv4 with a SAFI, which seems pretty weird. The examples in appendix B suggest that the author intended the null-SAFI rule to apply only within a single AFI, which is what I would have expected and is what the following code implements.

Check whether an IPAddrBLocks is in canonical form.

Empty extension is canonical.

Check whether the top-level list is in order.

Top level's ok, now check each address family.

Inheritance is canonical. Anything other than inheritance or a SEQUENCE OF IPAddressOrRange is an ASN.1 error or something.

It's an IPAddressOrRanges sequence, check it.

Punt misordered list, overlapping start, or inverted range.

Punt if adjacent or overlapping. Check for adjacency by subtracting one from b_min first.

Check for range that should be expressed as a prefix.

Check range to see if it's inverted or should be a prefix.

If we made it through all that, we're happy.

Whack an IPAddressOrRanges into canonical form.

Sort the IPAddressOrRanges sequence.

Clean up representation issues, punt on duplicates or overlaps.

Punt inverted ranges.

Punt overlaps.

Merge if a and b are adjacent. We check for adjacency by subtracting one from b_min first.

Check for inverted final range.

Whack an IPAddrBlocks extension into canonical form.

v2i handler for the IPAddrBlocks extension.

Handle SAFI, if any, and OPENSSL_strdup() so we can null-terminate the other input values.

Check for inheritance. Not worth additional complexity to optimize this (seldom-used) case.

Canonize the result, then we're done.

OpenSSL dispatch

nid

flags

template

old functions, ignored

i2s

s2i

i2v

v2i

i2r

r2i

extension-specific data

Figure out whether extension sues inheritance.

Figure out whether parent contains child.

Test whether a is a subset of b.

Validation error handling via callback.

Core code for RFC 3779 2.3 path validation. Returns 1 for success, 0 on error. When returning 0, ctx->error MUST be set to an appropriate value other than X509_V_OK.

Figure out where to start. If we don't have an extension to check, we're done. Otherwise, check canonical form and set up for walking up the chain.

Now walk up the chain. No cert may list resources that its parent doesn't list.

Trust anchor can't inherit.

RFC 3779 2.3 path validation -- called from X509_verify_cert().

RFC 3779 2.3 path validation of an extension. Test whether chain covers extension.

OPENSSL_NO_RFC3779

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/x509_int.h

ext_dat.h

s the address length associated with this AFI? */ static int length_from_afi(const unsigned afi) { switch (afi) { case IANA_AFI_IPV4: return 4; case IANA_AFI_IPV6: return 16; default: return 0; } } /* * Extract the AFI from an IPAddressFamily. */ unsigned int X509v3_addr_get_afi(const IPAddressFamily *f) { if (f == NULL || f->addressFamily == NULL || f->addressFamily->data == NULL || f->addressFamily->length < 2) return 0; return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1]; } /* * Expand the bitstring form of an address into a raw byte array. * At the moment this is coded for simplicity, not speed. */ static int addr_expand(unsigned char *addr, const ASN1_BIT_STRING *bs, const int length, const unsigned char fill) { if (bs->length < 0 || bs->length > length) return 0; if (bs->length > 0) { memcpy(addr, bs->data, bs->length); if ((bs->flags & 7) != 0) { unsigned char mask = 0xFF >> (8 - (bs->flags & 7)); if (fill == 0) addr[bs->length - 1] &= ~mask; else addr[bs->length - 1] |= mask; } } memset(addr + bs->length, fill, length - bs->length); return 1; } /* * Extract the prefix length from a bitstring. */ #define addr_prefixlen(bs) ((int) ((bs)->length * 8 - ((bs)->flags & 7))) /* * i2r handler for one address bitstring. */ static int i2r_address(BIO *out, const unsigned afi, const unsigned char fill, const ASN1_BIT_STRING *bs) { unsigned char addr[ADDR_RAW_BUF_LEN]; int i, n; if (bs->length < 0) return 0; switch (afi) { case IANA_AFI_IPV4: if (!addr_expand(addr, bs, 4, fill)) return 0; BIO_printf(out, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]); break; case IANA_AFI_IPV6: if (!addr_expand(addr, bs, 16, fill)) return 0; for (n = 16; n > 1 && addr[n - 1] == 0x00 && addr[n - 2] == 0x00; n -= 2) ; for (i = 0; i < n; i += 2) BIO_printf(out, "%x%s", (addr[i] << 8) | addr[i + 1], (i < 14 ? ":" : "")); if (i < 16) BIO_puts(out, ":"); if (i == 0) BIO_puts(out, ":"); break; default: for (i = 0; i < bs->length; i++) BIO_printf(out, "%s%02x", (i > 0 ? ":" : ""), bs->data[i]); BIO_printf(out, "[%d]", (int)(bs->flags & 7)); break; } return 1; } /* * i2r handler for a sequence of addresses and ranges. */ static int i2r_IPAddressOrRanges(BIO *out, const int indent, const IPAddressOrRanges *aors, const unsigned afi) { int i; for (i = 0; i < sk_IPAddressOrRange_num(aors); i++) { const IPAddressOrRange *aor = sk_IPAddressOrRange_value(aors, i); BIO_printf(out, "%*s", indent, ""); switch (aor->type) { case IPAddressOrRange_addressPrefix: if (!i2r_address(out, afi, 0x00, aor->u.addressPrefix)) return 0; BIO_printf(out, "/%d\n", addr_prefixlen(aor->u.addressPrefix)); continue; case IPAddressOrRange_addressRange: if (!i2r_address(out, afi, 0x00, aor->u.addressRange->min)) return 0; BIO_puts(out, "-"); if (!i2r_address(out, afi, 0xFF, aor->u.addressRange->max)) return 0; BIO_puts(out, "\n"); continue; } } return 1; } /* * i2r handler for an IPAddrBlocks extension. */ static int i2r_IPAddrBlocks(const X509V3_EXT_METHOD *method, void *ext, BIO *out, int indent) { const IPAddrBlocks *addr = ext; int i; for (i = 0; i < sk_IPAddressFamily_num(addr); i++) { IPAddressFamily *f = sk_IPAddressFamily_value(addr, i); const unsigned int afi = X509v3_addr_get_afi(f); switch (afi) { case IANA_AFI_IPV4: BIO_printf(out, "%*sIPv4", indent, ""); break; case IANA_AFI_IPV6: BIO_printf(out, "%*sIPv6", indent, ""); break; default: BIO_printf(out, "%*sUnknown AFI %u", indent, "", afi); break; } if (f->addressFamily->length > 2) { switch (f->addressFamily->data[2]) { case 1: BIO_puts(out, " (Unicast)"); break; case 2: BIO_puts(out, " (Multicast)"); break; case 3: BIO_puts(out, " (Unicast/Multicast)"); break; case 4: BIO_puts(out, " (MPLS)"); break; case 64: BIO_puts(out, " (Tunnel)"); break; case 65: BIO_puts(out, " (VPLS)"); break; case 66: BIO_puts(out, " (BGP MDT)"); break; case 128: BIO_puts(out, " (MPLS-labeled VPN)"); break; default: BIO_printf(out, " (Unknown SAFI %u)", (unsigned)f->addressFamily->data[2]); break; } } switch (f->ipAddressChoice->type) { case IPAddressChoice_inherit: BIO_puts(out, ": inherit\n"); break; case IPAddressChoice_addressesOrRanges: BIO_puts(out, ":\n"); if (!i2r_IPAddressOrRanges(out, indent + 2, f->ipAddressChoice-> u.addressesOrRanges, afi)) return 0; break; } } return 1; } /* * Sort comparison function for a sequence of IPAddressOrRange * elements. * * There

s ok, now check each address family. */ for (i = 0; i < sk_IPAddressFamily_num(addr); i++) { IPAddressFamily *f = sk_IPAddressFamily_value(addr, i); int length = length_from_afi(X509v3_addr_get_afi(f)); /* * Inheritance is canonical. Anything other than inheritance or * a SEQUENCE OF IPAddressOrRange is an ASN.1 error or something. */ if (f == NULL || f->ipAddressChoice == NULL) return 0; switch (f->ipAddressChoice->type) { case IPAddressChoice_inherit: continue; case IPAddressChoice_addressesOrRanges: break; default: return 0; } /* * It

s inverted or should be a * prefix. */ j = sk_IPAddressOrRange_num(aors) - 1; { IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j); if (a != NULL && a->type == IPAddressOrRange_addressRange) { if (!extract_min_max(a, a_min, a_max, length)) return 0; if (memcmp(a_min, a_max, length) > 0 || range_should_be_prefix(a_min, a_max, length) >= 0) return 0; } } } /* * If we made it through all that, we

0123456789.

0123456789.:abcdefABCDEF

IPv4

IPv6

IPv4-SAFI

IPv6-SAFI

\t

:

\t

inherit

\t

\0

/

\0

-

\t

\0

\0

re done. */ if (!X509v3_addr_canonize(addr)) goto err; return addr; err: OPENSSL_free(s); sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free); return NULL; } /* * OpenSSL dispatch */ const X509V3_EXT_METHOD v3_addr = { NID_sbgp_ipAddrBlock, /* nid */ 0, /* flags */ ASN1_ITEM_ref(IPAddrBlocks), /* template */ 0, 0, 0, 0, /* old functions, ignored */ 0, /* i2s */ 0, /* s2i */ 0, /* i2v */ v2i_IPAddrBlocks, /* v2i */ i2r_IPAddrBlocks, /* i2r */ 0, /* r2i */ NULL /* extension-specific data */ }; /* * Figure out whether extension sues inheritance. */ int X509v3_addr_inherits(IPAddrBlocks *addr) { int i; if (addr == NULL) return 0; for (i = 0; i < sk_IPAddressFamily_num(addr); i++) { IPAddressFamily *f = sk_IPAddressFamily_value(addr, i); if (f->ipAddressChoice->type == IPAddressChoice_inherit) return 1; } return 0; } /* * Figure out whether parent contains child. */ static int addr_contains(IPAddressOrRanges *parent, IPAddressOrRanges *child, int length) { unsigned char p_min[ADDR_RAW_BUF_LEN], p_max[ADDR_RAW_BUF_LEN]; unsigned char c_min[ADDR_RAW_BUF_LEN], c_max[ADDR_RAW_BUF_LEN]; int p, c; if (child == NULL || parent == child) return 1; if (parent == NULL) return 0; p = 0; for (c = 0; c < sk_IPAddressOrRange_num(child); c++) { if (!extract_min_max(sk_IPAddressOrRange_value(child, c), c_min, c_max, length)) return -1; for (;; p++) { if (p >= sk_IPAddressOrRange_num(parent)) return 0; if (!extract_min_max(sk_IPAddressOrRange_value(parent, p), p_min, p_max, length)) return 0; if (memcmp(p_max, c_max, length) < 0) continue; if (memcmp(p_min, c_min, length) > 0) return 0; break; } } return 1; } /* * Test whether a is a subset of b. */ int X509v3_addr_subset(IPAddrBlocks *a, IPAddrBlocks *b) { int i; if (a == NULL || a == b) return 1; if (b == NULL || X509v3_addr_inherits(a) || X509v3_addr_inherits(b)) return 0; (void)sk_IPAddressFamily_set_cmp_func(b, IPAddressFamily_cmp); for (i = 0; i < sk_IPAddressFamily_num(a); i++) { IPAddressFamily *fa = sk_IPAddressFamily_value(a, i); int j = sk_IPAddressFamily_find(b, fa); IPAddressFamily *fb; fb = sk_IPAddressFamily_value(b, j); if (fb == NULL) return 0; if (!addr_contains(fb->ipAddressChoice->u.addressesOrRanges, fa->ipAddressChoice->u.addressesOrRanges, length_from_afi(X509v3_addr_get_afi(fb)))) return 0; } return 1; } /* * Validation error handling via callback. */ #define validation_err(_err_) \ do { \ if (ctx != NULL) { \ ctx->error = _err_; \ ctx->error_depth = i; \ ctx->current_cert = x; \ ret = ctx->verify_cb(0, ctx); \ } else { \ ret = 0; \ } \ if (!ret) \ goto done; \ } while (0) /* * Core code for RFC 3779 2.3 path validation. * * Returns 1 for success, 0 on error. * * When returning 0, ctx->error MUST be set to an appropriate value other than * X509_V_OK. */ static int addr_validate_path_internal(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, IPAddrBlocks *ext) { IPAddrBlocks *child = NULL; int i, j, ret = 1; X509 *x; if (!ossl_assert(chain != NULL && sk_X509_num(chain) > 0) || !ossl_assert(ctx != NULL || ext != NULL) || !ossl_assert(ctx == NULL || ctx->verify_cb != NULL)) { if (ctx != NULL) ctx->error = X509_V_ERR_UNSPECIFIED; return 0; } /* * Figure out where to start. If we don

re done. Otherwise, check canonical form and * set up for walking up the chain. */ if (ext != NULL) { i = -1; x = NULL; } else { i = 0; x = sk_X509_value(chain, i); if ((ext = x->rfc3779_addr) == NULL) goto done; } if (!X509v3_addr_is_canonical(ext)) validation_err(X509_V_ERR_INVALID_EXTENSION); (void)sk_IPAddressFamily_set_cmp_func(ext, IPAddressFamily_cmp); if ((child = sk_IPAddressFamily_dup(ext)) == NULL) { X509V3err(X509V3_F_ADDR_VALIDATE_PATH_INTERNAL, ERR_R_MALLOC_FAILURE); if (ctx != NULL) ctx->error = X509_V_ERR_OUT_OF_MEM; ret = 0; goto done; } /* * Now walk up the chain. No cert may list resources that its * parent doesn

0xFF

0x00

0x00;

0x00,

0x00,

0xFF,

0x00))

0x00))

0x00))

0x00))

0x00

0xFF;

0x01:

0x03:

0x07:

0x0F:

0x1F:

0x3F:

0x7F:

0xFF

0x00;

0xFFU

0xFF;

0xFFU

0xFFU

0xFF;

0xFF;

0xFF;

0x00)

0xFF));

0x00)

0xFF));

0x00;

0x00;

0xFF

