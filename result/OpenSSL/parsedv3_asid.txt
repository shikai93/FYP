Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Implementation of RFC 3779 section 3.2.

OpenSSL ASN.1 template translation of RFC 3779 3.2.3.

i2r method for an ASIdentifierChoice.

i2r method for an ASIdentifier extension.

Sort comparison function for a sequence of ASIdOrRange elements.

Add an inherit element.

Add an ID or range to an ASIdentifierChoice.

Extract min and max values from an ASIdOrRange.

Check whether an ASIdentifierChoice is in canonical form.

Empty element or inheritance is canonical.

If not a list, or if empty list, it's broken.

It's a list, check it.

Punt misordered list, overlapping start, or inverted range.

Calculate a_max + 1 to check for adjacency.

Punt if adjacent or overlapping.

Check for inverted range.

Check whether an ASIdentifier extension is in canonical form.

Whack an ASIdentifierChoice into canonical form.

Nothing to do for empty element or inheritance.

If not a list, or if empty list, it's broken.

We have a non-empty list. Sort it.

Now check for errors and suboptimal encoding, rejecting the former and fixing the latter.

Make sure we're properly sorted (paranoia).

Punt inverted ranges.

Check for overlaps.

Calculate a_max + 1 to check for adjacency.

If a and b are adjacent, merge them.

Check for final inverted range.

Paranoia

Whack an ASIdentifier extension into canonical form.

v2i method for an ASIdentifier extension.

Figure out whether this is an AS or an RDI.

Handle inheritance.

Number, range, or mistake, pick it apart and figure out which.

Syntax is ok, read and add it.

Canonize the result, then we're done.

OpenSSL dispatch.

nid

flags

template

old functions, ignored

i2s

s2i

i2v

v2i

i2r

r2i

extension-specific data

Figure out whether extension uses inheritance.

Figure out whether parent contains child.

Test whether a is a subset of b.

Validation error handling via callback.

Core code for RFC 3779 3.3 path validation.

Figure out where to start. If we don't have an extension to check, we're done. Otherwise, check canonical form and set up for walking up the chain.

Now walk up the chain. Extensions must be in canonical form, no cert may list resources that its parent doesn't list.

Trust anchor can't inherit.

RFC 3779 3.3 path validation -- called from X509_verify_cert().

RFC 3779 3.3 path validation of an extension. Test whether chain covers extension.

OPENSSL_NO_RFC3779

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/x509_int.h

ext_dat.h

%*s%s:\n



%*sinherit\n



%*s%s\n



%*s%s-



%s\n

Autonomous System Numbers

Routing Domain Identifiers

s broken. */ if (choice->type != ASIdentifierChoice_asIdsOrRanges || sk_ASIdOrRange_num(choice->u.asIdsOrRanges) == 0) return 0; /* * It

s broken. */ if (choice->type != ASIdentifierChoice_asIdsOrRanges || sk_ASIdOrRange_num(choice->u.asIdsOrRanges) == 0) { X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE, X509V3_R_EXTENSION_VALUE_ERROR); return 0; } /* * We have a non-empty list. Sort it. */ sk_ASIdOrRange_sort(choice->u.asIdsOrRanges); /* * Now check for errors and suboptimal encoding, rejecting the * former and fixing the latter. */ for (i = 0; i < sk_ASIdOrRange_num(choice->u.asIdsOrRanges) - 1; i++) { ASIdOrRange *a = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i); ASIdOrRange *b = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i + 1); ASN1_INTEGER *a_min = NULL, *a_max = NULL, *b_min = NULL, *b_max = NULL; if (!extract_min_max(a, &a_min, &a_max) || !extract_min_max(b, &b_min, &b_max)) goto done; /* * Make sure we

AS

RDI

inherit

0123456789

\0

\t

-

\t

0123456789

\0

\0

re done. */ if (!X509v3_asid_canonize(asid)) goto err; return asid; err: ASIdentifiers_free(asid); ASN1_INTEGER_free(min); ASN1_INTEGER_free(max); return NULL; } /* * OpenSSL dispatch. */ const X509V3_EXT_METHOD v3_asid = { NID_sbgp_autonomousSysNum, /* nid */ 0, /* flags */ ASN1_ITEM_ref(ASIdentifiers), /* template */ 0, 0, 0, 0, /* old functions, ignored */ 0, /* i2s */ 0, /* s2i */ 0, /* i2v */ v2i_ASIdentifiers, /* v2i */ i2r_ASIdentifiers, /* i2r */ 0, /* r2i */ NULL /* extension-specific data */ }; /* * Figure out whether extension uses inheritance. */ int X509v3_asid_inherits(ASIdentifiers *asid) { return (asid != NULL && ((asid->asnum != NULL && asid->asnum->type == ASIdentifierChoice_inherit) || (asid->rdi != NULL && asid->rdi->type == ASIdentifierChoice_inherit))); } /* * Figure out whether parent contains child. */ static int asid_contains(ASIdOrRanges *parent, ASIdOrRanges *child) { ASN1_INTEGER *p_min = NULL, *p_max = NULL, *c_min = NULL, *c_max = NULL; int p, c; if (child == NULL || parent == child) return 1; if (parent == NULL) return 0; p = 0; for (c = 0; c < sk_ASIdOrRange_num(child); c++) { if (!extract_min_max(sk_ASIdOrRange_value(child, c), &c_min, &c_max)) return 0; for (;; p++) { if (p >= sk_ASIdOrRange_num(parent)) return 0; extract_min_max(sk_ASIdOrRange_value(parent, p), &p_min, &p_max); if (ASN1_INTEGER_cmp(p_max, c_max) < 0) continue; if (ASN1_INTEGER_cmp(p_min, c_min) > 0) return 0; break; } } return 1; } /* * Test whether a is a subset of b. */ int X509v3_asid_subset(ASIdentifiers *a, ASIdentifiers *b) { return (a == NULL || a == b || (b != NULL && !X509v3_asid_inherits(a) && !X509v3_asid_inherits(b) && asid_contains(b->asnum->u.asIdsOrRanges, a->asnum->u.asIdsOrRanges) && asid_contains(b->rdi->u.asIdsOrRanges, a->rdi->u.asIdsOrRanges))); } /* * Validation error handling via callback. */ #define validation_err(_err_) \ do { \ if (ctx != NULL) { \ ctx->error = _err_; \ ctx->error_depth = i; \ ctx->current_cert = x; \ ret = ctx->verify_cb(0, ctx); \ } else { \ ret = 0; \ } \ if (!ret) \ goto done; \ } while (0) /* * Core code for RFC 3779 3.3 path validation. */ static int asid_validate_path_internal(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, ASIdentifiers *ext) { ASIdOrRanges *child_as = NULL, *child_rdi = NULL; int i, ret = 1, inherit_as = 0, inherit_rdi = 0; X509 *x; if (!ossl_assert(chain != NULL && sk_X509_num(chain) > 0) || !ossl_assert(ctx != NULL || ext != NULL) || !ossl_assert(ctx == NULL || ctx->verify_cb != NULL)) { if (ctx != NULL) ctx->error = X509_V_ERR_UNSPECIFIED; return 0; } /* * Figure out where to start. If we don

re done. Otherwise, check canonical form and * set up for walking up the chain. */ if (ext != NULL) { i = -1; x = NULL; } else { i = 0; x = sk_X509_value(chain, i); if ((ext = x->rfc3779_asid) == NULL) goto done; } if (!X509v3_asid_is_canonical(ext)) validation_err(X509_V_ERR_INVALID_EXTENSION); if (ext->asnum != NULL) { switch (ext->asnum->type) { case ASIdentifierChoice_inherit: inherit_as = 1; break; case ASIdentifierChoice_asIdsOrRanges: child_as = ext->asnum->u.asIdsOrRanges; break; } } if (ext->rdi != NULL) { switch (ext->rdi->type) { case ASIdentifierChoice_inherit: inherit_rdi = 1; break; case ASIdentifierChoice_asIdsOrRanges: child_rdi = ext->rdi->u.asIdsOrRanges; break; } } /* * Now walk up the chain. Extensions must be in canonical form, no * cert may list resources that its parent doesn

