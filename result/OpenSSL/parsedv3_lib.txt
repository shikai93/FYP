Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

X509 v3 extension utilities

Legacy function: we don't need to add standard extensions any more because they are now kept in ext_dat.h.

Return an extension internal structure

Get critical flag and decoded version of extension from a NID. The "idx" variable returns the last found extension and can be used to retrieve multiple extensions of the same NID. However multiple extensions with the same NID is usually due to a badly encoded certificate so if idx is NULL we choke if multiple extensions exist. The "crit" variable is set to the critical value. The return value is the decoded extension or NULL on error. The actual error can have several different causes, the value of crit reflects the cause: >= 0, extension found but not decoded (reflects critical value). -1 extension not found. -2 extension occurs more than once.

Found more than one

Found it

Extension not found

This function is a general extension append, replace and delete utility. The precise operation is governed by the 'flags' value. The 'crit' and 'value' arguments (if relevant) are the extensions internal structure.

If appending we don't care if it exists, otherwise look for existing extension.

See if extension exists

If keep existing, nothing to do

If default then its an error

If delete, just delete it

If replace existing or delete, error since extension must exist

If we get this far then we have to create an extension: could have some flags for alternative encoding schemes...

If extension exists replace it..

www.openssl.org/source/license.html

License

internal/cryptlib.h

ext_dat.h

standard_exts.h

t need to add standard extensions any more because * they are now kept in ext_dat.h. */ int X509V3_add_standard_extensions(void) { return 1; } /* Return an extension internal structure */ void *X509V3_EXT_d2i(X509_EXTENSION *ext) { const X509V3_EXT_METHOD *method; const unsigned char *p; ASN1_STRING *extvalue; int extlen; if ((method = X509V3_EXT_get(ext)) == NULL) return NULL; extvalue = X509_EXTENSION_get_data(ext); p = ASN1_STRING_get0_data(extvalue); extlen = ASN1_STRING_length(extvalue); if (method->it) return ASN1_item_d2i(NULL, &p, extlen, ASN1_ITEM_ptr(method->it)); return method->d2i(NULL, &p, extlen); } /*- * Get critical flag and decoded version of extension from a NID. * The "idx" variable returns the last found extension and can * be used to retrieve multiple extensions of the same NID. * However multiple extensions with the same NID is usually * due to a badly encoded certificate so if idx is NULL we * choke if multiple extensions exist. * The "crit" variable is set to the critical value. * The return value is the decoded extension or NULL on * error. The actual error can have several different causes, * the value of *crit reflects the cause: * >= 0, extension found but not decoded (reflects critical value). * -1 extension not found. * -2 extension occurs more than once. */ void *X509V3_get_d2i(const STACK_OF(X509_EXTENSION) *x, int nid, int *crit, int *idx) { int lastpos, i; X509_EXTENSION *ex, *found_ex = NULL; if (!x) { if (idx) *idx = -1; if (crit) *crit = -1; return NULL; } if (idx) lastpos = *idx + 1; else lastpos = 0; if (lastpos < 0) lastpos = 0; for (i = lastpos; i < sk_X509_EXTENSION_num(x); i++) { ex = sk_X509_EXTENSION_value(x, i); if (OBJ_obj2nid(X509_EXTENSION_get_object(ex)) == nid) { if (idx) { *idx = i; found_ex = ex; break; } else if (found_ex) { /* Found more than one */ if (crit) *crit = -2; return NULL; } found_ex = ex; } } if (found_ex) { /* Found it */ if (crit) *crit = X509_EXTENSION_get_critical(found_ex); return X509V3_EXT_d2i(found_ex); } /* Extension not found */ if (idx) *idx = -1; if (crit) *crit = -1; return NULL; } /* * This function is a general extension append, replace and delete utility. * The precise operation is governed by the

value. The

and *

arguments (if relevant) are the extensions internal structure. */ int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value, int crit, unsigned long flags) { int extidx = -1; int errcode; X509_EXTENSION *ext, *extmp; unsigned long ext_op = flags & X509V3_ADD_OP_MASK; /* * If appending we don

