Copyright 2003-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

for strncasecmp

Check a certificate conforms to a specified set of constraints. Return values: X509_V_OK: All constraints obeyed. X509_V_ERR_PERMITTED_VIOLATION: Permitted subtree violation. X509_V_ERR_EXCLUDED_VIOLATION: Excluded subtree violation. X509_V_ERR_SUBTREE_MINMAX: Min or max values present and matching type. X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: Unsupported constraint type. X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: bad unsupported constraint syntax. X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: bad or unsupported syntax of name

Process any email address attributes in subject name

Process any commonName attributes in subject name

Only process attributes that look like host names

Permitted subtrees: if any subtrees exist of matching the type at least one subtree must match.

If we already have a match don't bother trying any more

Excluded subtrees: must not match any of these

directoryName name constraint matching. The canonical encoding of X509_NAME makes this comparison easy. It is matched if the subtree is a subset of the name.

Ensure canonical encodings are up to date.

Empty matches everything

Otherwise can add zero or more components on the left so compare RHS and if dns is longer and expect '.' as preceding character.

Special case: initial '.' is RHS match

If we have anything before '@' match local part

Case sensitive match of local part

Position base after '@'

Just have hostname left to match: case insensitive

Check for foo:// and skip past it

Determine length of hostname part of URI

Look for a port indicator as end of hostname first

Otherwise look for trailing slash

Special case: initial '.' is RHS match

Invalid if not IPv4 or IPv6

Do not match IPv4 with IPv6

Considering possible not aligned base ipAddress

Not checking for wrong mask definition: i.e.: 255.0.255.0

www.openssl.org/source/license.html

and skip past it */

License

e_os.h

internal/cryptlib.h

internal/asn1_int.h

internal/x509_int.h

ext_dat.h

permitted

excluded

Permitted

Excluded

%*s%s:\n



%*s



\n

IP:

%d.%d.%d.%d/%d.%d.%d.%d

%X

/

:

IP Address:<invalid>

t bother trying any more */ if (match == 2) continue; if (match == 0) match = 1; r = nc_match_single(gen, sub->base); if (r == X509_V_OK) match = 2; else if (r != X509_V_ERR_PERMITTED_VIOLATION) return r; } if (match == 1) return X509_V_ERR_PERMITTED_VIOLATION; /* Excluded subtrees: must not match any of these */ for (i = 0; i < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) { sub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees, i); if (gen->type != sub->base->type) continue; if (sub->minimum || sub->maximum) return X509_V_ERR_SUBTREE_MINMAX; r = nc_match_single(gen, sub->base); if (r == X509_V_OK) return X509_V_ERR_EXCLUDED_VIOLATION; else if (r != X509_V_ERR_PERMITTED_VIOLATION) return r; } return X509_V_OK; } static int nc_match_single(GENERAL_NAME *gen, GENERAL_NAME *base) { switch (base->type) { case GEN_DIRNAME: return nc_dn(gen->d.directoryName, base->d.directoryName); case GEN_DNS: return nc_dns(gen->d.dNSName, base->d.dNSName); case GEN_EMAIL: return nc_email(gen->d.rfc822Name, base->d.rfc822Name); case GEN_URI: return nc_uri(gen->d.uniformResourceIdentifier, base->d.uniformResourceIdentifier); case GEN_IPADD: return nc_ip(gen->d.iPAddress, base->d.iPAddress); default: return X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE; } } /* * directoryName name constraint matching. The canonical encoding of * X509_NAME makes this comparison easy. It is matched if the subtree is a * subset of the name. */ static int nc_dn(X509_NAME *nm, X509_NAME *base) { /* Ensure canonical encodings are up to date. */ if (nm->modified && i2d_X509_NAME(nm, NULL) < 0) return X509_V_ERR_OUT_OF_MEM; if (base->modified && i2d_X509_NAME(base, NULL) < 0) return X509_V_ERR_OUT_OF_MEM; if (base->canon_enclen > nm->canon_enclen) return X509_V_ERR_PERMITTED_VIOLATION; if (memcmp(base->canon_enc, nm->canon_enc, base->canon_enclen)) return X509_V_ERR_PERMITTED_VIOLATION; return X509_V_OK; } static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base) { char *baseptr = (char *)base->data; char *dnsptr = (char *)dns->data; /* Empty matches everything */ if (!*baseptr) return X509_V_OK; /* * Otherwise can add zero or more components on the left so compare RHS * and if dns is longer and expect

as preceding character. */ if (dns->length > base->length) { dnsptr += dns->length - base->length; if (*baseptr !=

&& dnsptr[-1] !=

) return X509_V_ERR_PERMITTED_VIOLATION; } if (strcasecmp(baseptr, dnsptr)) return X509_V_ERR_PERMITTED_VIOLATION; return X509_V_OK; } static int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base) { const char *baseptr = (char *)base->data; const char *emlptr = (char *)eml->data; const char *baseat = strchr(baseptr,

); const char *emlat = strchr(emlptr,

); if (!emlat) return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX; /* Special case: initial

is RHS match */ if (!baseat && (*baseptr ==

)) { if (eml->length > base->length) { emlptr += eml->length - base->length; if (strcasecmp(baseptr, emlptr) == 0) return X509_V_OK; } return X509_V_ERR_PERMITTED_VIOLATION; } /* If we have anything before

match local part */ if (baseat) { if (baseat != baseptr) { if ((baseat - baseptr) != (emlat - emlptr)) return X509_V_ERR_PERMITTED_VIOLATION; /* Case sensitive match of local part */ if (strncmp(baseptr, emlptr, emlat - emlptr)) return X509_V_ERR_PERMITTED_VIOLATION; } /* Position base after

*/ baseptr = baseat + 1; } emlptr = emlat + 1; /* Just have hostname left to match: case insensitive */ if (strcasecmp(baseptr, emlptr)) return X509_V_ERR_PERMITTED_VIOLATION; return X509_V_OK; } static int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING *base) { const char *baseptr = (char *)base->data; const char *hostptr = (char *)uri->data; const char *p = strchr(hostptr,

); int hostlen; /* Check for foo:// and skip past it */ if (!p || (p[1] !=

) || (p[2] !=

)) return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX; hostptr = p + 3; /* Determine length of hostname part of URI */ /* Look for a port indicator as end of hostname first */ p = strchr(hostptr,

); /* Otherwise look for trailing slash */ if (!p) p = strchr(hostptr,

); if (!p) hostlen = strlen(hostptr); else hostlen = p - hostptr; if (hostlen == 0) return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX; /* Special case: initial

is RHS match */ if (*baseptr ==

