Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

As much as I'd like to make X509_check_purpose use a "const" X509 I really can't because it does recalculate hashes and do other non-const things.

Return if side-effect only call

This is set according to what we change: application can't set it

This will always be set for application modified trust entries

Get existing entry if any

Need a new entry

OPENSSL_free existing name if dynamic

dup supplied name

Keep the dynamic flag of existing entry

Set all other flags

If its a new entry manage the dynamic table

This table is a list of the NIDs of supported extensions: that is those which are used by the verify process. If an extension is critical and doesn't appear in this list then the verify process will normally reject the certificate. The list must be kept in numerical order because it will be searched using bsearch.

71

83

85

87

89

103

126

290

291

401

663

666

747

748

V1 should mean no extensions ...

Handle basic constraints

Handle proxy certificates

Handle key usage

Does subject name match issuer ?

If SKID matches AKID also indicate self signed

CA checks common to all purposes return codes: 0 not a CA 1 is a CA 2 basicConstraints absent so "maybe" a CA 3 basicConstraints absent but self signed V1. 4 basicConstraints absent but keyUsage present and keyCertSign asserted.

keyUsage if present should allow cert signing

If basicConstraints says not a CA then say so

we support V1 roots for... uh, I don't really know why.

If key usage present it must have certSign so tolerate it

Older certificates could have Netscape-specific CA types

can this still be regarded a CA certificate? I doubt it

Check SSL CA: common checks for SSL client and server

check nsCertType if present

We need to do digital signatures or key agreement

nsCertType if present should allow SSL client use

Key usage needed for TLS/SSL server: digital signature, encipherment or key agreement. The ssl code can check this more thoroughly for individual key types.

We need to encipher or Netscape complains

common S/MIME checks

check nsCertType if present

Workaround for some buggy certificates

OCSP helper: this is not a full OCSP check. It just checks that each CA is valid. Additional checks must be made on the chain.

Must be a valid CA. Should we really support the "I don't know" value (2)?

leaf certificate is checked in OCSP_verify()

If ca is true we must return if this is a valid CA certificate.

Check the optional key usage field: if Key Usage is present, it must be one of digitalSignature and/or nonRepudiation (other values are not consistent and shall be rejected).

Only time stamp key usage is permitted and it's required.

Extended Key Usage MUST be critical

Various checks to see if one certificate issued the second. This can be used to prune a set of possible issuer certificates which have been looked up using some simple method such as by subject name. These are: 1. Check issuer_name(subject) == subject_name(issuer) 2. If akid(subject) exists check it matches issuer 3. If key_usage(issuer) exists check it supports certificate signing returns 0 for OK, positive for reason for mismatch, reasons match codes for X509_verify_cert()

Check key ids (if present)

Check serial number

Check issuer name

Ugh, for some peculiar reason AKID includes SEQUENCE OF GeneralName. So look for a DirName. There may be more than one but we only take any notice of the first.

Call for side-effect of computing hash and caching extensions

Call for side-effect of computing hash and caching extensions

Call for side-effect of computing hash and caching extensions

Call for side-effect of computing hash and caching extensions

Called for side effect of caching extensions

Called for side effect of caching extensions

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/numbers.h

internal/x509_int.h

SSL client

sslclient

SSL server

sslserver

Netscape SSL server

nssslserver

S/MIME signing

smimesign

S/MIME encryption

smimeencrypt

CRL signing

crlsign

Any Purpose

any

OCSP helper

ocsphelper

Time Stamp signing

timestampsign

d like to make X509_check_purpose use a "const" X509* I * really can

t set it */ flags &= ~X509_PURPOSE_DYNAMIC; /* This will always be set for application modified trust entries */ flags |= X509_PURPOSE_DYNAMIC_NAME; /* Get existing entry if any */ idx = X509_PURPOSE_get_by_id(id); /* Need a new entry */ if (idx == -1) { if ((ptmp = OPENSSL_malloc(sizeof(*ptmp))) == NULL) { X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE); return 0; } ptmp->flags = X509_PURPOSE_DYNAMIC; } else ptmp = X509_PURPOSE_get0(idx); /* OPENSSL_free existing name if dynamic */ if (ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) { OPENSSL_free(ptmp->name); OPENSSL_free(ptmp->sname); } /* dup supplied name */ ptmp->name = OPENSSL_strdup(name); ptmp->sname = OPENSSL_strdup(sname); if (!ptmp->name || !ptmp->sname) { X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE); goto err; } /* Keep the dynamic flag of existing entry */ ptmp->flags &= X509_PURPOSE_DYNAMIC; /* Set all other flags */ ptmp->flags |= flags; ptmp->purpose = id; ptmp->trust = trust; ptmp->check_purpose = ck; ptmp->usr_data = arg; /* If its a new entry manage the dynamic table */ if (idx == -1) { if (xptable == NULL && (xptable = sk_X509_PURPOSE_new(xp_cmp)) == NULL) { X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE); goto err; } if (!sk_X509_PURPOSE_push(xptable, ptmp)) { X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE); goto err; } } return 1; err: if (idx == -1) { OPENSSL_free(ptmp->name); OPENSSL_free(ptmp->sname); OPENSSL_free(ptmp); } return 0; } static void xptable_free(X509_PURPOSE *p) { if (!p) return; if (p->flags & X509_PURPOSE_DYNAMIC) { if (p->flags & X509_PURPOSE_DYNAMIC_NAME) { OPENSSL_free(p->name); OPENSSL_free(p->sname); } OPENSSL_free(p); } } void X509_PURPOSE_cleanup(void) { sk_X509_PURPOSE_pop_free(xptable, xptable_free); xptable = NULL; } int X509_PURPOSE_get_id(const X509_PURPOSE *xp) { return xp->purpose; } char *X509_PURPOSE_get0_name(const X509_PURPOSE *xp) { return xp->name; } char *X509_PURPOSE_get0_sname(const X509_PURPOSE *xp) { return xp->sname; } int X509_PURPOSE_get_trust(const X509_PURPOSE *xp) { return xp->trust; } static int nid_cmp(const int *a, const int *b) { return *a - *b; } DECLARE_OBJ_BSEARCH_CMP_FN(int, int, nid); IMPLEMENT_OBJ_BSEARCH_CMP_FN(int, int, nid); int X509_supported_extension(X509_EXTENSION *ex) { /* * This table is a list of the NIDs of supported extensions: that is * those which are used by the verify process. If an extension is * critical and doesn

maybe

t really know why. */ if ((x->ex_flags & V1_ROOT) == V1_ROOT) return 3; /* * If key usage present it must have certSign so tolerate it */ else if (x->ex_flags & EXFLAG_KUSAGE) return 4; /* Older certificates could have Netscape-specific CA types */ else if (x->ex_flags & EXFLAG_NSCERT && x->ex_nscert & NS_ANY_CA) return 5; /* can this still be regarded a CA certificate? I doubt it */ return 0; } } void X509_set_proxy_flag(X509 *x) { x->ex_flags |= EXFLAG_PROXY; } void X509_set_proxy_pathlen(X509 *x, long l) { x->ex_pcpathlen = l; } int X509_check_ca(X509 *x) { if (!(x->ex_flags & EXFLAG_SET)) { CRYPTO_THREAD_write_lock(x->lock); x509v3_cache_extensions(x); CRYPTO_THREAD_unlock(x->lock); } return check_ca(x); } /* Check SSL CA: common checks for SSL client and server */ static int check_ssl_ca(const X509 *x) { int ca_ret; ca_ret = check_ca(x); if (!ca_ret) return 0; /* check nsCertType if present */ if (ca_ret != 5 || x->ex_nscert & NS_SSL_CA) return ca_ret; else return 0; } static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca) { if (xku_reject(x, XKU_SSL_CLIENT)) return 0; if (ca) return check_ssl_ca(x); /* We need to do digital signatures or key agreement */ if (ku_reject(x, KU_DIGITAL_SIGNATURE | KU_KEY_AGREEMENT)) return 0; /* nsCertType if present should allow SSL client use */ if (ns_reject(x, NS_SSL_CLIENT)) return 0; return 1; } /* * Key usage needed for TLS/SSL server: digital signature, encipherment or * key agreement. The ssl code can check this more thoroughly for individual * key types. */ #define KU_TLS \ KU_DIGITAL_SIGNATURE|KU_KEY_ENCIPHERMENT|KU_KEY_AGREEMENT static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca) { if (xku_reject(x, XKU_SSL_SERVER | XKU_SGC)) return 0; if (ca) return check_ssl_ca(x); if (ns_reject(x, NS_SSL_SERVER)) return 0; if (ku_reject(x, KU_TLS)) return 0; return 1; } static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca) { int ret; ret = check_purpose_ssl_server(xp, x, ca); if (!ret || ca) return ret; /* We need to encipher or Netscape complains */ if (ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0; return ret; } /* common S/MIME checks */ static int purpose_smime(const X509 *x, int ca) { if (xku_reject(x, XKU_SMIME)) return 0; if (ca) { int ca_ret; ca_ret = check_ca(x); if (!ca_ret) return 0; /* check nsCertType if present */ if (ca_ret != 5 || x->ex_nscert & NS_SMIME_CA) return ca_ret; else return 0; } if (x->ex_flags & EXFLAG_NSCERT) { if (x->ex_nscert & NS_SMIME) return 1; /* Workaround for some buggy certificates */ if (x->ex_nscert & NS_SSL_CLIENT) return 2; return 0; } return 1; } static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca) { int ret; ret = purpose_smime(x, ca); if (!ret || ca) return ret; if (ku_reject(x, KU_DIGITAL_SIGNATURE | KU_NON_REPUDIATION)) return 0; return ret; } static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca) { int ret; ret = purpose_smime(x, ca); if (!ret || ca) return ret; if (ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0; return ret; } static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca) { if (ca) { int ca_ret; if ((ca_ret = check_ca(x)) != 2) return ca_ret; else return 0; } if (ku_reject(x, KU_CRL_SIGN)) return 0; return 1; } /* * OCSP helper: this is *not* a full OCSP check. It just checks that each CA * is valid. Additional checks must be made on the chain. */ static int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca) { /* * Must be a valid CA. Should we really support the "I don

