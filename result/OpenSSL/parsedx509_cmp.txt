Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

Compare two certificates: they must be identical for this to work. NB: Although "cmp" operations are generally prototyped to take "const" arguments (eg. for use in STACKs), the way X509 handling is - these operations may involve ensuring the hashes are up-to-date and ensuring certain cert information is cached. So this is the point where the "depth-first" constification tree has to halt with an evil cast.

ensure hash is valid

Check for match against stored encoding too

Ensure canonical encoding is present and up to date

Make sure X509_NAME structure contains valid cached encoding

I now DER encode the name and hash it. Since I cache the DER encoding, this is reasonably efficient.

Make sure X509_NAME structure contains valid cached encoding

Search a stack of X509 for a match

Check a suite B algorithm is permitted: pass in a public key and the NID of its signature (or 0 if no signature). The pflags is a pointer to a flags field which must contain the suite B verification flags.

Check curve is consistent with LOS

P-384

Check signature algorithm is consistent with curve.

If we encounter P-384 we cannot use P-256 later

P-256

If no EE certificate passed in must be first in chain

With DANE-EE(3) success, or DANE-EE(3)/PKIX-EE(1) failure we don't build a chain all, just report trust success or failure, but must also report Suite-B errors if applicable. This is indicated via a NULL chain pointer. All we need to do is check the leaf key algorithm.

Correct error depth

Check EE key only

Correct error depth

Final check: root CA signature

Invalid signature or LOS errors are for previous cert

If we have LOS error and flags changed then we are signing P-384 with P-256. Use more meaningful error.

Not strictly speaking an "up_ref" as a STACK doesn't have a reference count but it has the same effect by duping the STACK and upping the ref of each X509 structure.

www.openssl.org/source/license.html

License

internal/cryptlib.h

internal/x509_int.h

cmp

const

depth-first

t build * a chain all, just report trust success or failure, but must also report * Suite-B errors if applicable. This is indicated via a NULL chain * pointer. All we need to do is check the leaf key algorithm. */ if (chain == NULL) return check_suite_b(pk, -1, &tflags); if (X509_get_version(x) != 2) { rv = X509_V_ERR_SUITE_B_INVALID_VERSION; /* Correct error depth */ i = 0; goto end; } /* Check EE key only */ rv = check_suite_b(pk, -1, &tflags); if (rv != X509_V_OK) { /* Correct error depth */ i = 0; goto end; } for (; i < sk_X509_num(chain); i++) { sign_nid = X509_get_signature_nid(x); x = sk_X509_value(chain, i); if (X509_get_version(x) != 2) { rv = X509_V_ERR_SUITE_B_INVALID_VERSION; goto end; } pk = X509_get0_pubkey(x); rv = check_suite_b(pk, sign_nid, &tflags); if (rv != X509_V_OK) goto end; } /* Final check: root CA signature */ rv = check_suite_b(pk, X509_get_signature_nid(x), &tflags); end: if (rv != X509_V_OK) { /* Invalid signature or LOS errors are for previous cert */ if ((rv == X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM || rv == X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED) && i) i--; /* * If we have LOS error and flags changed then we are signing P-384 * with P-256. Use more meaningful error. */ if (rv == X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED && flags != tflags) rv = X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256; if (perror_depth) *perror_depth = i; } return rv; } int X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags) { int sign_nid; if (!(flags & X509_V_FLAG_SUITEB_128_LOS)) return X509_V_OK; sign_nid = OBJ_obj2nid(crl->crl.sig_alg.algorithm); return check_suite_b(pk, sign_nid, &flags); } #else int X509_chain_check_suiteb(int *perror_depth, X509 *x, STACK_OF(X509) *chain, unsigned long flags) { return 0; } int X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags) { return 0; } #endif /* * Not strictly speaking an "up_ref" as a STACK doesn

0xffffffffL;

0xffffffffL;

0xffffffffL;

