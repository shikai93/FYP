Copyright 2002-2016 The OpenSSL Project Authors. All Rights Reserved. Licensed under the OpenSSL license (the "License"). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at https://www.openssl.org/source/license.html

kind of dirty hack for Sun Studio

x86_64 BIGNUM accelerator version 0.1, December 2002. Implemented by Andy Polyakov <appro@fy.chalmers.se> for the OpenSSL project. Rights for redistribution and usage in source and binary forms are granted according to the OpenSSL license. Warranty of any kind is disclaimed. Q. Version 0.1? It doesn't sound like Andy, he used to assign real versions, like 1.0... A. Well, that's because this code is basically a quick-n-dirty proof-of-concept hack. As you can see it's implemented with inline assembler, which means that you're bound to GCC and that there might be enough room for further improvement. Q. Why inline assembler? A. x86_64 features own ABI which I'm not familiar with. This is why I decided to let the compiler take care of subroutine prologue/epilogue as well as register allocation. For reference. Win64 implements different ABI for AMD64, different from Linux. Q. How much faster does it get? A. 'apps/openssl speed rsa dsa' output with no-asm: sign verify sign/s verify/s rsa 512 bits 0.0006s 0.0001s 1683.8 18456.2 rsa 1024 bits 0.0028s 0.0002s 356.0 6407.0 rsa 2048 bits 0.0172s 0.0005s 58.0 1957.8 rsa 4096 bits 0.1155s 0.0018s 8.7 555.6 sign verify sign/s verify/s dsa 512 bits 0.0005s 0.0006s 2100.8 1768.3 dsa 1024 bits 0.0014s 0.0018s 692.3 559.2 dsa 2048 bits 0.0049s 0.0061s 204.7 165.0 'apps/openssl speed rsa dsa' output with this module: sign verify sign/s verify/s rsa 512 bits 0.0004s 0.0000s 2767.1 33297.9 rsa 1024 bits 0.0012s 0.0001s 867.4 14674.7 rsa 2048 bits 0.0061s 0.0002s 164.0 5270.0 rsa 4096 bits 0.0384s 0.0006s 26.1 1650.8 sign verify sign/s verify/s dsa 512 bits 0.0002s 0.0003s 4442.2 3786.3 dsa 1024 bits 0.0005s 0.0007s 1835.1 1497.4 dsa 2048 bits 0.0016s 0.0020s 620.4 504.6 For the reference. IA-32 assembler implementation performs very much like 64-bit code compiled with no-asm on the same machine.

"m"(a), "+m"(r) is the way to favor DirectPath Âµ-code; "g"(0) let the compiler to decide where does it want to keep the value of zero;

clear carry

clear borrow

Simics 1.4<7 has buggy sbbq:-(

mul_add_c(a,b,c0,c1,c2) -- c+=ab for three word number c=(c2,c1,c0)

mul_add_c2(a,b,c0,c1,c2) -- c+=2ab for three word number c=(c2,c1,c0)

sqr_add_c(a,i,c0,c1,c2) -- c+=a[i]^2 for three word number c=(c2,c1,c0)

sqr_add_c2(a,i,c0,c1,c2) -- c+=2a[i]a[j] for three word number c=(c2,c1,c0)

Keep in mind that carrying into high part of multiplication result can not overflow, because it cannot be all-ones.

original macros are kept for reference purposes

www.openssl.org/source/license.html

License

../bn_lcl.h

../bn_asm.c

t sound like Andy, he used to assign real * versions, like 1.0... * A. Well, that

s implemented with * inline assembler, which means that you

m not familiar with. This is * why I decided to let the compiler take care of subroutine * prologue/epilogue as well as register allocation. For reference. * Win64 implements different ABI for AMD64, different from Linux. * * Q. How much faster does it get? * A.

output with no-asm: * * sign verify sign/s verify/s * rsa 512 bits 0.0006s 0.0001s 1683.8 18456.2 * rsa 1024 bits 0.0028s 0.0002s 356.0 6407.0 * rsa 2048 bits 0.0172s 0.0005s 58.0 1957.8 * rsa 4096 bits 0.1155s 0.0018s 8.7 555.6 * sign verify sign/s verify/s * dsa 512 bits 0.0005s 0.0006s 2100.8 1768.3 * dsa 1024 bits 0.0014s 0.0018s 692.3 559.2 * dsa 2048 bits 0.0049s 0.0061s 204.7 165.0 * *

m

+m

g

mulq %3

=a

=d

a

m

cc

addq %2,%0; adcq %3,%1

+r

+d

a

g

cc

addq %2,%0; adcq %3,%1

+m

+d

r

g

cc

mulq %3

=a

=d

a

g

cc

addq %2,%0; adcq %3,%1

+r

+d

a

g

cc

mulq %2

=a

=d

a

cc

divq %4

=a

=d

a

d

r

cc

subq %0,%0 \n

jmp 1f \n

.p2align 4 \n

1: movq (%4,%2,8),%0 \n

adcq (%5,%2,8),%0 \n

movq %0,(%3,%2,8) \n

lea 1(%2),%2 \n

loop 1b \n

sbbq %0,%0 \n

=&r

+c

+r

r

r

r

cc

memory

subq %0,%0 \n

jmp 1f \n

.p2align 4 \n

1: movq (%4,%2,8),%0 \n

sbbq (%5,%2,8),%0 \n

movq %0,(%3,%2,8) \n

lea 1(%2),%2 \n

loop 1b \n

sbbq %0,%0 \n

=&r

+c

+r

r

r

r

cc

memory

mulq %3

=a

=d

a

m

cc

addq %3,%0; adcq %4,%1; adcq %5,%2

+r

+r

+r

r

r

g

cc

mulq %2

=a

=d

a

cc

addq %3,%0; adcq %4,%1; adcq %5,%2

+r

+r

+r

r

r

g

cc

mulq %3

=a

=d

a

m

cc

addq %3,%0; adcq %4,%1; adcq %5,%2

+r

+r

+r

r

r

g

cc

addq %3,%0; adcq %4,%1; adcq %5,%2

+r

+r

+r

r

r

g

cc

0xffffffffffffffffL

